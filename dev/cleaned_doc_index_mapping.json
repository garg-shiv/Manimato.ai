[{"name": "_AnimationBuilder", "code": "class _AnimationBuilder:\n    def __init__(self, mobject: OpenGLMobject):\n        self.mobject = mobject\n        self.mobject.generate_target()\n\n        self.overridden_animation = None\n        self.is_chaining = False\n        self.methods = []\n\n        # Whether animation args can be passed\n        self.cannot_pass_args = False\n        self.anim_args = {}\n\n    def __call__(self, **kwargs) -> Self:\n        if self.cannot_pass_args:\n            raise ValueError(\n                \"Animation arguments must be passed before accessing methods and can only be passed once\",\n            )\n\n        self.anim_args = kwargs\n        self.cannot_pass_args = True\n\n        return self\n\n    def __getattr__(self, method_name: str) -> Callable[..., Self]:\n        method = getattr(self.mobject.target, method_name)\n        has_overridden_animation = hasattr(method, \"_override_animate\")\n\n        if (self.is_chaining and has_overridden_animation) or self.overridden_animation:\n            raise NotImplementedError(\n                \"Method chaining is currently not supported for overridden animations\",\n            )\n\n        def update_target(*method_args, **method_kwargs):\n            if has_overridden_animation:\n                self.overridden_animation = method._override_animate(\n                    self.mobject,\n                    *method_args,\n                    anim_args=self.anim_args,\n                    **method_kwargs,\n                )\n            else:\n                self.methods.append([method, method_args, method_kwargs])\n                method(*method_args, **method_kwargs)\n            return self\n\n        self.is_chaining = True\n        self.cannot_pass_args = True\n\n        return update_target\n\n    def build(self) -> _MethodAnimation:\n        from manim.animation.transform import _MethodAnimation\n\n        if self.overridden_animation:\n            anim = self.overridden_animation\n        else:\n            anim = _MethodAnimation(self.mobject, self.methods)\n\n        for attr, value in self.anim_args.items():\n            setattr(anim, attr, value)\n\n        return anim"}, {"name": "_BooleanOps", "code": "class _BooleanOps(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"This class contains some helper functions which\n    helps to convert to and from skia objects and manim\n    objects (:class:`~.VMobject`).\n    \"\"\"\n\n    def _convert_2d_to_3d_array(\n        self,\n        points: Point2DLike_Array | Point3DLike_Array,\n        z_dim: float = 0.0,\n    ) -> Point3D_Array:\n        \"\"\"Converts an iterable with coordinates in 2D to 3D by adding\n        :attr:`z_dim` as the Z coordinate.\n\n        Parameters\n        ----------\n        points\n            An iterable of points.\n        z_dim\n            Default value for the Z coordinate.\n\n        Returns\n        -------\n        Point3D_Array\n            A list of the points converted to 3D.\n\n        Example\n        -------\n        >>> a = _BooleanOps()\n        >>> p = [(1, 2), (3, 4)]\n        >>> a._convert_2d_to_3d_array(p)\n        array([[1., 2., 0.],\n               [3., 4., 0.]])\n        \"\"\"\n        list_of_points = list(points)\n        for i, point in enumerate(list_of_points):\n            if len(point) == 2:\n                list_of_points[i] = np.array(list(point) + [z_dim])\n        return np.asarray(list_of_points)\n\n    def _convert_vmobject_to_skia_path(self, vmobject: VMobject) -> SkiaPath:\n        \"\"\"Converts a :class:`~.VMobject` to SkiaPath. This method only works for\n        cairo renderer because it treats the points as Cubic beizer curves.\n\n        Parameters\n        ----------\n        vmobject:\n            The :class:`~.VMobject` to convert from.\n\n        Returns\n        -------\n        SkiaPath\n            The converted path.\n        \"\"\"\n        path = SkiaPath()\n\n        if not np.all(np.isfinite(vmobject.points)):\n            points = np.zeros((1, 3))  # point invalid?\n        else:\n            points = vmobject.points\n\n        if len(points) == 0:  # what? No points so return empty path\n            return path\n\n        # In OpenGL it's quadratic beizer curves while on Cairo it's cubic...\n        if config.renderer == RendererType.OPENGL:\n            subpaths = vmobject.get_subpaths_from_points(points)\n            for subpath in subpaths:\n                quads = vmobject.get_bezier_tuples_from_points(subpath)\n                start = subpath[0]\n                path.moveTo(*start[:2])\n                for _p0, p1, p2 in quads:\n                    path.quadTo(*p1[:2], *p2[:2])\n                if vmobject.consider_points_equals(subpath[0], subpath[-1]):\n                    path.close()\n        elif config.renderer == RendererType.CAIRO:\n            subpaths = vmobject.gen_subpaths_from_points_2d(points)  # type: ignore[assignment]\n            for subpath in subpaths:\n                quads = vmobject.gen_cubic_bezier_tuples_from_points(subpath)\n                start = subpath[0]\n                path.moveTo(*start[:2])\n                for _p0, p1, p2, p3 in quads:\n                    path.cubicTo(*p1[:2], *p2[:2], *p3[:2])\n\n                if vmobject.consider_points_equals_2d(subpath[0], subpath[-1]):\n                    path.close()\n\n        return path\n\n    def _convert_skia_path_to_vmobject(self, path: SkiaPath) -> VMobject:\n        \"\"\"Converts SkiaPath back to VMobject.\n        Parameters\n        ----------\n        path:\n            The SkiaPath to convert.\n\n        Returns\n        -------\n        VMobject:\n            The converted VMobject.\n        \"\"\"\n        vmobject = self\n        current_path_start = np.array([0, 0, 0])\n\n        for path_verb, points in path:\n            if path_verb == PathVerb.MOVE:\n                parts = self._convert_2d_to_3d_array(points)\n                for part in parts:\n                    current_path_start = part\n                    vmobject.start_new_path(part)\n                    # vmobject.move_to(*part)\n            elif path_verb == PathVerb.CUBIC:\n                n1, n2, n3 = self._convert_2d_to_3d_array(points)\n                vmobject.add_cubic_bezier_curve_to(n1, n2, n3)\n            elif path_verb == PathVerb.LINE:\n                parts = self._convert_2d_to_3d_array(points)\n                vmobject.add_line_to(parts[0])\n            elif path_verb == PathVerb.CLOSE:\n                vmobject.add_line_to(current_path_start)\n            elif path_verb == PathVerb.QUAD:\n                n1, n2 = self._convert_2d_to_3d_array(points)\n                vmobject.add_quadratic_bezier_curve_to(n1, n2)\n            else:\n                raise Exception(f\"Unsupported: {path_verb}\")\n        return vmobject"}, {"name": "_config_test", "code": "def _config_test(last_frame: bool) -> ManimConfig:\n    return ManimConfig().digest_file(\n        str(\n            Path(__file__).parent\n            / (\n                \"config_graphical_tests_monoframe.cfg\"\n                if last_frame\n                else \"config_graphical_tests_multiframes.cfg\"\n            ),\n        ),\n    )"}, {"name": "_control_data_path", "code": "def _control_data_path(\n    test_file_path: str | None, module_name: str, test_name: str, setting_test: bool\n) -> Path:\n    if test_file_path is None:\n        # For some reason, path to test file containing @frames_comparison could not\n        # be determined. Use local directory instead.\n        test_file_path = __file__\n\n    path = Path(test_file_path).absolute().parent / \"control_data\" / module_name\n\n    if setting_test:\n        # Create the directory if not existing.\n        path.mkdir(exist_ok=True)\n    if not setting_test and not path.exists():\n        raise Exception(f\"The control frames directory can't be found  in {path}\")\n    path = (path / test_name).with_suffix(\".npz\")\n    if not setting_test and not path.is_file():\n        raise Exception(\n            f\"The control frame for the test {test_name} cannot be found in {path.parent}. \"\n            \"Make sure you generated the control frames first.\",\n        )\n    return path"}, {"name": "_ControlDataWriter", "code": "class _ControlDataWriter(_FramesTester):\n    def __init__(self, file_path: Path, size_frame: tuple) -> None:\n        self.file_path = file_path\n        self.frames = np.empty((0, *size_frame, 4))\n        self._number_frames_written: int = 0\n\n    # Actually write a frame.\n    def check_frame(self, index: int, frame: PixelArray) -> None:\n        frame = frame[np.newaxis, ...]\n        self.frames = np.concatenate((self.frames, frame))\n        self._number_frames_written += 1\n\n    @contextlib.contextmanager\n    def testing(self) -> Generator[None, None, None]:\n        yield\n        self.save_contol_data()\n\n    def save_contol_data(self) -> None:\n        self.frames = self.frames.astype(\"uint8\")\n        np.savez_compressed(self.file_path, frame_data=self.frames)\n        logger.info(\n            f\"{self._number_frames_written} control frames saved in {self.file_path}\",\n        )"}, {"name": "_convert_point_to_3d", "code": "def _convert_point_to_3d(x: float, y: float) -> np.ndarray:\n    return np.array([x, y, 0.0])"}, {"name": "_CustomEncoder", "code": "class _CustomEncoder(json.JSONEncoder):\n    def default(self, obj: Any):\n        \"\"\"\n        This method is used to serialize objects to JSON format.\n\n        If obj is a function, then it will return a dict with two keys : 'code', for\n        the code source, and 'nonlocals' for all nonlocalsvalues. (including nonlocals\n        functions, that will be serialized as this is recursive.)\n        if obj is a np.darray, it converts it into a list.\n        if obj is an object with __dict__ attribute, it returns its __dict__.\n        Else, will let the JSONEncoder do the stuff, and throw an error if the type is\n        not suitable for JSONEncoder.\n\n        Parameters\n        ----------\n        obj\n            Arbitrary object to convert\n\n        Returns\n        -------\n        Any\n            Python object that JSON encoder will recognize\n\n        \"\"\"\n        if not (isinstance(obj, ModuleType)) and isinstance(\n            obj,\n            (MethodType, FunctionType),\n        ):\n            cvars = inspect.getclosurevars(obj)\n            cvardict = {**copy.copy(cvars.globals), **copy.copy(cvars.nonlocals)}\n            for i in list(cvardict):\n                # NOTE : All module types objects are removed, because otherwise it\n                # throws ValueError: Circular reference detected if not. TODO\n                if isinstance(cvardict[i], ModuleType):\n                    del cvardict[i]\n            try:\n                code = inspect.getsource(obj)\n            except (OSError, TypeError):\n                # This happens when rendering videos included in the documentation\n                # within doctests and should be replaced by a solution avoiding\n                # hash collision (due to the same, empty, code strings) at some point.\n                # See https://github.com/ManimCommunity/manim/pull/402.\n                code = \"\"\n            return self._cleaned_iterable({\"code\": code, \"nonlocals\": cvardict})\n        elif isinstance(obj, np.ndarray):\n            if obj.size > 1000:\n                obj = np.resize(obj, (100, 100))\n                return f\"TRUNCATED ARRAY: {repr(obj)}\"\n            # We return the repr and not a list to avoid the JsonEncoder to iterate over it.\n            return repr(obj)\n        elif hasattr(obj, \"__dict__\"):\n            temp = obj.__dict__\n            # MappingProxy is scene-caching nightmare. It contains all of the object methods and attributes. We skip it as the mechanism will at some point process the object, but instantiated.\n            # Indeed, there is certainly no case where scene-caching will receive only a non instancied object, as this is never used in the library or encouraged to be used user-side.\n            if isinstance(temp, MappingProxyType):\n                return \"MappingProxy\"\n            return self._cleaned_iterable(temp)\n        elif isinstance(obj, np.uint8):\n            return int(obj)\n        # Serialize it with only the type of the object. You can change this to whatever string when debugging the serialization process.\n        return str(type(obj))\n\n    def _cleaned_iterable(self, iterable: typing.Iterable[Any]):\n        \"\"\"Check for circular reference at each iterable that will go through the JSONEncoder, as well as key of the wrong format.\n\n        If a key with a bad format is found (i.e not a int, string, or float), it gets replaced byt its hash using the same process implemented here.\n        If a circular reference is found within the iterable, it will be replaced by the string \"already processed\".\n\n        Parameters\n        ----------\n        iterable\n            The iterable to check.\n        \"\"\"\n\n        def _key_to_hash(key):\n            return zlib.crc32(json.dumps(key, cls=_CustomEncoder).encode())\n\n        def _iter_check_list(lst):\n            processed_list = [None] * len(lst)\n            for i, el in enumerate(lst):\n                el = _Memoizer.check_already_processed(el)\n                if isinstance(el, (list, tuple)):\n                    new_value = _iter_check_list(el)\n                elif isinstance(el, dict):\n                    new_value = _iter_check_dict(el)\n                else:\n                    new_value = el\n                processed_list[i] = new_value\n            return processed_list\n\n        def _iter_check_dict(dct):\n            processed_dict = {}\n            for k, v in dct.items():\n                v = _Memoizer.check_already_processed(v)\n                if k in KEYS_TO_FILTER_OUT:\n                    continue\n                # We check if the k is of the right format (supporter by Json)\n                if not isinstance(k, (str, int, float, bool)) and k is not None:\n                    k_new = _key_to_hash(k)\n                else:\n                    k_new = k\n                if isinstance(v, dict):\n                    new_value = _iter_check_dict(v)\n                elif isinstance(v, (list, tuple)):\n                    new_value = _iter_check_list(v)\n                else:\n                    new_value = v\n                processed_dict[k_new] = new_value\n            return processed_dict\n\n        if isinstance(iterable, (list, tuple)):\n            return _iter_check_list(iterable)\n        elif isinstance(iterable, dict):\n            return _iter_check_dict(iterable)\n\n    def encode(self, obj: Any):\n        \"\"\"Overriding of :meth:`JSONEncoder.encode`, to make our own process.\n\n        Parameters\n        ----------\n        obj\n            The object to encode in JSON.\n\n        Returns\n        -------\n        :class:`str`\n           The object encoder with the standard json process.\n        \"\"\"\n        _Memoizer.mark_as_processed(obj)\n        if isinstance(obj, (dict, list, tuple)):\n            return super().encode(self._cleaned_iterable(obj))\n        return super().encode(obj)"}, {"name": "_Data", "code": "class _Data:\n    \"\"\"Descriptor that allows _Data variables to be grouped and accessed from self.data[\"attr\"] via self.attr.\n    self.data attributes must be arrays.\n    \"\"\"\n\n    def __set_name__(self, obj: Any, name: str) -> None:\n        self.name = name\n\n    def __get__(self, obj: Any, owner: Any) -> npt.NDArray[Any]:\n        value: npt.NDArray[Any] = obj.data[self.name]\n        return value\n\n    def __set__(self, obj: Any, array: npt.NDArray[Any]) -> None:\n        obj.data[self.name] = array"}, {"name": "_delete_rendering_times", "code": "def _delete_rendering_times(*args: tuple[Any]) -> None:\n    if rendering_times_file_path.exists():\n        rendering_times_file_path.unlink()"}, {"name": "_deprecation_text_component", "code": "def _deprecation_text_component(\n    since: str | None = None,\n    until: str | None = None,\n    message: str | None = None,\n) -> str:\n    \"\"\"Generates a text component used in deprecation messages.\n\n    Parameters\n    ----------\n    since\n        The version or date since deprecation\n    until\n        The version or date until removal of the deprecated callable\n    message\n        The reason for why the callable has been deprecated\n\n    Returns\n    -------\n    str\n        The deprecation message text component.\n    \"\"\"\n    since = f\"since {since} \" if since else \"\"\n    until = (\n        f\"is expected to be removed after {until}\"\n        if until\n        else \"may be removed in a later version\"\n    )\n    msg = \" \" + message if message else \"\"\n    return f\"deprecated {since}and {until}.{msg}\""}, {"name": "_determine_graph_layout", "code": "def _determine_graph_layout(\n    nx_graph: nx.classes.graph.Graph | nx.classes.digraph.DiGraph,\n    layout: LayoutName | dict[Hashable, Point3DLike] | LayoutFunction = \"spring\",\n    layout_scale: float | tuple[float, float, float] = 2,\n    layout_config: dict[str, Any] | None = None,\n) -> dict[Hashable, Point3DLike]:\n    if layout_config is None:\n        layout_config = {}\n\n    if isinstance(layout, dict):\n        return layout\n    elif layout in _layouts:\n        auto_layout = _layouts[layout](nx_graph, scale=layout_scale, **layout_config)\n        # NetworkX returns a dictionary of 3D points if the dimension\n        # is specified to be 3. Otherwise, it returns a dictionary of\n        # 2D points, so adjusting is required.\n        if (\n            layout_config.get(\"dim\") == 3\n            or auto_layout[next(auto_layout.__iter__())].shape[0] == 3\n        ):\n            return auto_layout\n        else:\n            return {k: np.append(v, [0]) for k, v in auto_layout.items()}\n    else:\n        try:\n            return cast(LayoutFunction, layout)(\n                nx_graph, scale=layout_scale, **layout_config\n            )\n        except TypeError as e:\n            raise ValueError(\n                f\"The layout '{layout}' is neither a recognized layout, a layout function,\"\n                \"nor a vertex placement dictionary.\",\n            ) from e"}, {"name": "_determine_quality", "code": "def _determine_quality(qual: str) -> str:\n    for quality, values in constants.QUALITIES.items():\n        if values[\"flag\"] is not None and values[\"flag\"] == qual:\n            return quality\n\n    return qual"}, {"name": "_Fade", "code": "class _Fade(Transform):\n    \"\"\"Fade :class:`~.Mobject` s in or out.\n\n    Parameters\n    ----------\n    mobjects\n        The mobjects to be faded.\n    shift\n        The vector by which the mobject shifts while being faded.\n    target_position\n        The position to/from which the mobject moves while being faded in. In case\n        another mobject is given as target position, its center is used.\n    scale\n        The factor by which the mobject is scaled initially before being rescaling to\n        its original size while being faded in.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        *mobjects: Mobject,\n        shift: np.ndarray | None = None,\n        target_position: np.ndarray | Mobject | None = None,\n        scale: float = 1,\n        **kwargs,\n    ) -> None:\n        if not mobjects:\n            raise ValueError(\"At least one mobject must be passed.\")\n        mobject = mobjects[0] if len(mobjects) == 1 else Group(*mobjects)\n\n        self.point_target = False\n        if shift is None:\n            if target_position is not None:\n                if isinstance(target_position, (Mobject, OpenGLMobject)):\n                    target_position = target_position.get_center()\n                shift = target_position - mobject.get_center()\n                self.point_target = True\n            else:\n                shift = ORIGIN\n        self.shift_vector = shift\n        self.scale_factor = scale\n        super().__init__(mobject, **kwargs)\n\n    def _create_faded_mobject(self, fadeIn: bool) -> Mobject:\n        \"\"\"Create a faded, shifted and scaled copy of the mobject.\n\n        Parameters\n        ----------\n        fadeIn\n            Whether the faded mobject is used to fade in.\n\n        Returns\n        -------\n        Mobject\n            The faded, shifted and scaled copy of the mobject.\n        \"\"\"\n        faded_mobject = self.mobject.copy()\n        faded_mobject.fade(1)\n        direction_modifier = -1 if fadeIn and not self.point_target else 1\n        faded_mobject.shift(self.shift_vector * direction_modifier)\n        faded_mobject.scale(self.scale_factor)\n        return faded_mobject"}, {"name": "_FramesTester", "code": "class _FramesTester:\n    def __init__(self, file_path: Path, show_diff: bool = False) -> None:\n        self._file_path = file_path\n        self._show_diff = show_diff\n        self._frames: np.ndarray\n        self._number_frames: int = 0\n        self._frames_compared = 0\n\n    @contextlib.contextmanager\n    def testing(self) -> Generator[None, None, None]:\n        with np.load(self._file_path) as data:\n            self._frames = data[\"frame_data\"]\n            # For backward compatibility, when the control data contains only one frame (<= v0.8.0)\n            if len(self._frames.shape) != 4:\n                self._frames = np.expand_dims(self._frames, axis=0)\n            logger.debug(self._frames.shape)\n            self._number_frames = np.ma.size(self._frames, axis=0)\n            yield\n            assert self._frames_compared == self._number_frames, (\n                f\"The scene tested contained {self._frames_compared} frames, \"\n                f\"when there are {self._number_frames} control frames for this test.\"\n            )\n\n    def check_frame(self, frame_number: int, frame: PixelArray) -> None:\n        assert frame_number < self._number_frames, (\n            f\"The tested scene is at frame number {frame_number} \"\n            f\"when there are {self._number_frames} control frames.\"\n        )\n        try:\n            np.testing.assert_allclose(\n                frame,\n                self._frames[frame_number],\n                atol=FRAME_ABSOLUTE_TOLERANCE,\n                err_msg=f\"Frame no {frame_number}. You can use --show_diff to visually show the difference.\",\n                verbose=False,\n            )\n            self._frames_compared += 1\n        except AssertionError as e:\n            number_of_matches = np.isclose(\n                frame, self._frames[frame_number], atol=FRAME_ABSOLUTE_TOLERANCE\n            ).sum()\n            number_of_mismatches = frame.size - number_of_matches\n            if number_of_mismatches / frame.size < FRAME_MISMATCH_RATIO_TOLERANCE:\n                # we tolerate a small (< 0.001%) amount of pixel value errors\n                # in the tests, this accounts for minor OS dependent inconsistencies\n                self._frames_compared += 1\n                warnings.warn(\n                    f\"Mismatch of {number_of_mismatches} pixel values in frame {frame_number} \"\n                    f\"against control data in {self._file_path}. Below error threshold, \"\n                    \"continuing...\",\n                    stacklevel=1,\n                )\n                return\n\n            if self._show_diff:\n                show_diff_helper(\n                    frame_number,\n                    frame,\n                    self._frames[frame_number],\n                    self._file_path.name,\n                )\n            raise e"}, {"name": "_generate_file_name", "code": "def _generate_file_name() -> str:\n    val: str = (\n        config[\"scene_names\"][0] + \"@\" + datetime.now().strftime(\"%Y-%m-%d@%H-%M-%S\")\n    )\n    return val"}, {"name": "_get_callable_info", "code": "def _get_callable_info(callable_: Callable[..., Any], /) -> tuple[str, str]:\n    \"\"\"Returns type and name of a callable.\n\n    Parameters\n    ----------\n    callable\n        The callable\n\n    Returns\n    -------\n    Tuple[str, str]\n        The type and name of the callable. Type can can be one of \"class\", \"method\" (for\n        functions defined in classes) or \"function\"). For methods, name is Class.method.\n    \"\"\"\n    what = type(callable_).__name__\n    name = callable_.__qualname__\n    if what == \"function\" and \".\" in name:\n        what = \"method\"\n    elif what != \"function\":\n        what = \"class\"\n    return (what, name)"}, {"name": "_get_subdivision_matrix", "code": "def _get_subdivision_matrix(n_points: int, n_divisions: int) -> MatrixMN:\n    \"\"\"Gets the matrix which subdivides a B\u00e9zier curve of\n    ``n_points`` control points into ``n_divisions`` parts.\n\n    Auxiliary function for :func:`subdivide_bezier`. See its\n    docstrings for an explanation of the matrix build process.\n\n    Parameters\n    ----------\n    n_points\n        The number of control points of the B\u00e9zier curve to\n        subdivide. This function only handles up to 4 points.\n    n_divisions\n        The number of parts to subdivide the B\u00e9zier curve into.\n\n    Returns\n    -------\n    MatrixMN\n        The matrix which, upon multiplying the control points of the\n        B\u00e9zier curve, subdivides it into ``n_divisions`` parts.\n    \"\"\"\n    if n_points not in (1, 2, 3, 4):\n        raise NotImplementedError(\n            \"This function does not support subdividing B\u00e9zier \"\n            \"curves with 0 or more than 4 control points.\"\n        )\n\n    subdivision_matrix = SUBDIVISION_MATRICES[n_points - 1].get(n_divisions, None)\n    if subdivision_matrix is not None:\n        return subdivision_matrix\n\n    subdivision_matrix = np.empty((n_points * n_divisions, n_points))\n\n    # Cubic B\u00e9zier\n    if n_points == 4:\n        for i in range(n_divisions):\n            i2 = i * i\n            i3 = i2 * i\n            ip1 = i + 1\n            ip12 = ip1 * ip1\n            ip13 = ip12 * ip1\n            nmi = n_divisions - i\n            nmi2 = nmi * nmi\n            nmi3 = nmi2 * nmi\n            nmim1 = nmi - 1\n            nmim12 = nmim1 * nmim1\n            nmim13 = nmim12 * nmim1\n\n            subdivision_matrix[4 * i : 4 * (i + 1)] = np.array(\n                [\n                    [\n                        nmi3,\n                        3 * nmi2 * i,\n                        3 * nmi * i2,\n                        i3,\n                    ],\n                    [\n                        nmi2 * nmim1,\n                        2 * nmi * nmim1 * i + nmi2 * ip1,\n                        nmim1 * i2 + 2 * nmi * i * ip1,\n                        i2 * ip1,\n                    ],\n                    [\n                        nmi * nmim12,\n                        nmim12 * i + 2 * nmi * nmim1 * ip1,\n                        2 * nmim1 * i * ip1 + nmi * ip12,\n                        i * ip12,\n                    ],\n                    [\n                        nmim13,\n                        3 * nmim12 * ip1,\n                        3 * nmim1 * ip12,\n                        ip13,\n                    ],\n                ]\n            )\n        subdivision_matrix /= n_divisions * n_divisions * n_divisions\n\n    # Quadratic B\u00e9zier\n    elif n_points == 3:\n        for i in range(n_divisions):\n            ip1 = i + 1\n            nmi = n_divisions - i\n            nmim1 = nmi - 1\n            subdivision_matrix[3 * i : 3 * (i + 1)] = np.array(\n                [\n                    [nmi * nmi, 2 * i * nmi, i * i],\n                    [nmi * nmim1, i * nmim1 + ip1 * nmi, i * ip1],\n                    [nmim1 * nmim1, 2 * ip1 * nmim1, ip1 * ip1],\n                ]\n            )\n        subdivision_matrix /= n_divisions * n_divisions\n\n    # Linear B\u00e9zier (straight line)\n    elif n_points == 2:\n        aux_range = np.arange(n_divisions + 1)\n        subdivision_matrix[::2, 1] = aux_range[:-1]\n        subdivision_matrix[1::2, 1] = aux_range[1:]\n        subdivision_matrix[:, 0] = subdivision_matrix[::-1, 1]\n        subdivision_matrix /= n_divisions\n\n    # Zero-degree B\u00e9zier (single point)\n    elif n_points == 1:\n        subdivision_matrix[:] = 1\n\n    SUBDIVISION_MATRICES[n_points - 1][n_divisions] = subdivision_matrix\n    return subdivision_matrix"}, {"name": "_is_expected_datatype", "code": "def _is_expected_datatype(\n    value: str, expected: str, validate_style: bool = False\n) -> bool:\n    \"\"\"Check whether the literal from ``value`` is the same datatype as the\n    literal from ``expected``. If ``validate_style`` is ``True``, also check if\n    the style given by ``value`` is valid, according to ``rich``.\n\n    Parameters\n    ----------\n    value\n        The string of the value to check, obtained from reading the user input.\n    expected\n        The string of the literal datatype which must be matched by ``value``.\n        This is obtained from reading the ``cfg`` file.\n    validate_style\n        Whether or not to confirm if ``value`` is a valid style, according to\n        ``rich``. Default is ``False``.\n\n    Returns\n    -------\n    :class:`bool`\n        Whether or not the literal from ``value`` matches the datatype of the\n        literal from ``expected``.\n    \"\"\"\n    value_literal = value_from_string(value)\n    ExpectedLiteralType = type(value_from_string(expected))\n\n    return isinstance(value_literal, ExpectedLiteralType) and (\n        (isinstance(value_literal, str) and is_valid_style(value_literal))\n        if validate_style\n        else True\n    )"}, {"name": "_log_rendering_times", "code": "def _log_rendering_times(*args: tuple[Any]) -> None:\n    if rendering_times_file_path.exists():\n        with rendering_times_file_path.open() as file:\n            data = list(csv.reader(file))\n        if len(data) == 0:\n            sys.exit()\n\n        print(\"\\nRendering Summary\\n-----------------\\n\")\n\n        # filter out empty lists caused by csv reader\n        data = [row for row in data if row]\n\n        max_file_length = max(len(row[0]) for row in data)\n        for key, group_iter in it.groupby(data, key=lambda row: row[0]):\n            key = key.ljust(max_file_length + 1, \".\")\n            group = list(group_iter)\n            if len(group) == 1:\n                row = group[0]\n                print(f\"{key}{row[2].rjust(7, '.')}s {row[1]}\")\n                continue\n            time_sum = sum(float(row[2]) for row in group)\n            print(\n                f\"{key}{f'{time_sum:.3f}'.rjust(7, '.')}s  => {len(group)} EXAMPLES\",\n            )\n            for row in group:\n                print(f\"{' ' * max_file_length} {row[2].rjust(7)}s {row[1]}\")\n        print(\"\")"}, {"name": "_make_scene_file_writer_class", "code": "def _make_scene_file_writer_class(tester: _FramesTester) -> type[SceneFileWriter]:\n    class TestSceneFileWriter(DummySceneFileWriter):\n        def write_frame(\n            self, frame_or_renderer: PixelArray | OpenGLRenderer, num_frames: int = 1\n        ) -> None:\n            tester.check_frame(self.i, frame_or_renderer)\n            super().write_frame(frame_or_renderer, num_frames=num_frames)\n\n    return TestSceneFileWriter"}, {"name": "_make_test_comparing_frames", "code": "def _make_test_comparing_frames(\n    file_path: Path,\n    base_scene: type[Scene],\n    construct: Callable[[Scene], None],\n    renderer_class: type,  # Renderer type, there is no superclass renderer yet .....\n    is_set_test_data_test: bool,\n    last_frame: bool,\n    show_diff: bool,\n    size_frame: tuple,\n) -> Callable[[], None]:\n    \"\"\"Create the real pytest test that will fail if the frames mismatch.\n\n    Parameters\n    ----------\n    file_path\n        The path of the control frames.\n    base_scene\n        The base scene class.\n    construct\n        The construct method (= the test function)\n    renderer_class\n        The renderer base class.\n    show_diff\n        whether to visually show_diff (see --show_diff)\n\n    Returns\n    -------\n    Callable[[], None]\n        The pytest test.\n    \"\"\"\n    if is_set_test_data_test:\n        frames_tester: _FramesTester = _ControlDataWriter(\n            file_path, size_frame=size_frame\n        )\n    else:\n        frames_tester = _FramesTester(file_path, show_diff=show_diff)\n\n    file_writer_class = (\n        _make_scene_file_writer_class(frames_tester)\n        if not last_frame\n        else DummySceneFileWriter\n    )\n    testRenderer = _make_test_renderer_class(renderer_class)\n\n    def real_test() -> None:\n        with frames_tester.testing():\n            sceneTested = _make_test_scene_class(\n                base_scene=base_scene,\n                construct_test=construct,\n                # NOTE this is really ugly but it's due to the very bad design of the two renderers.\n                # If you pass a custom renderer to the Scene, the Camera class given as an argument in the Scene\n                # is not passed to the renderer. See __init__ of Scene.\n                # This potentially prevents OpenGL testing.\n                test_renderer=(\n                    testRenderer(file_writer_class=file_writer_class)\n                    if base_scene is not ThreeDScene\n                    else testRenderer(\n                        file_writer_class=file_writer_class,\n                        camera_class=ThreeDCamera,\n                    )\n                ),  # testRenderer(file_writer_class=file_writer_class),\n            )\n            scene_tested = sceneTested(skip_animations=True)\n            scene_tested.render()\n            if last_frame:\n                frames_tester.check_frame(-1, scene_tested.renderer.get_frame())\n\n    return real_test"}, {"name": "_make_test_renderer_class", "code": "def _make_test_renderer_class(from_renderer: type) -> Any:\n    # Just for inheritance.\n    class _TestRenderer(from_renderer):\n        pass\n\n    return _TestRenderer"}, {"name": "_make_test_scene_class", "code": "def _make_test_scene_class(\n    base_scene: type[Scene],\n    construct_test: Callable[[Scene], None],\n    test_renderer: CairoRenderer | OpenGLRenderer | None,\n) -> type[Scene]:\n    # TODO: Get the type annotation right for the base_scene argument.\n    class _TestedScene(base_scene):  # type: ignore[valid-type, misc]\n        def __init__(self, *args: Any, **kwargs: Any) -> None:\n            super().__init__(*args, renderer=test_renderer, **kwargs)\n\n        def construct(self) -> None:\n            construct_test(self)\n\n            # Manim hack to render the very last frame (normally the last frame is not the very end of the animation)\n            if self.animations is not None:\n                self.update_to_time(self.get_run_time(self.animations))\n                self.renderer.render(self, 1, self.moving_mobjects)\n\n    return _TestedScene"}, {"name": "_Memoizer", "code": "class _Memoizer:\n    \"\"\"Implements the memoization logic to optimize the hashing procedure and prevent\n    the circular references within iterable processed.\n\n    Keeps a record of all the processed objects, and handle the logic to return a place\n    holder instead of the original object if the object has already been processed\n    by the hashing logic (i.e, recursively checked, converted to JSON, etc..).\n\n    This class uses two signatures functions to keep a track of processed objects :\n    hash or id. Whenever possible, hash is used to ensure a broader object\n    content-equality detection.\n    \"\"\"\n\n    _already_processed = set()\n\n    # Can be changed to whatever string to help debugging the JSon generation.\n    ALREADY_PROCESSED_PLACEHOLDER = \"AP\"\n    THRESHOLD_WARNING = 170_000\n\n    @classmethod\n    def reset_already_processed(cls):\n        cls._already_processed.clear()\n\n    @classmethod\n    def check_already_processed_decorator(cls: _Memoizer, is_method: bool = False):\n        \"\"\"Decorator to handle the arguments that goes through the decorated function.\n        Returns _ALREADY_PROCESSED_PLACEHOLDER if the obj has been processed, or lets\n        the decorated function call go ahead.\n\n        Parameters\n        ----------\n        is_method\n            Whether the function passed is a method, by default False.\n        \"\"\"\n\n        def layer(func):\n            # NOTE : There is probably a better way to separate both case when func is\n            # a method or a function.\n            if is_method:\n                return lambda self, obj: cls._handle_already_processed(\n                    obj,\n                    default_function=lambda obj: func(self, obj),\n                )\n            return lambda obj: cls._handle_already_processed(obj, default_function=func)\n\n        return layer\n\n    @classmethod\n    def check_already_processed(cls, obj: Any) -> Any:\n        \"\"\"Checks if obj has been already processed. Returns itself if it has not been,\n        or the value of _ALREADY_PROCESSED_PLACEHOLDER if it has.\n        Marks the object as processed in the second case.\n\n        Parameters\n        ----------\n        obj\n            The object to check.\n\n        Returns\n        -------\n        Any\n            Either the object itself or the placeholder.\n        \"\"\"\n        # When the object is not memoized, we return the object itself.\n        return cls._handle_already_processed(obj, lambda x: x)\n\n    @classmethod\n    def mark_as_processed(cls, obj: Any) -> None:\n        \"\"\"Marks an object as processed.\n\n        Parameters\n        ----------\n        obj\n            The object to mark as processed.\n        \"\"\"\n        cls._handle_already_processed(obj, lambda x: x)\n        return cls._return(obj, id, lambda x: x, memoizing=False)\n\n    @classmethod\n    def _handle_already_processed(\n        cls,\n        obj,\n        default_function: typing.Callable[[Any], Any],\n    ):\n        if isinstance(\n            obj,\n            (\n                int,\n                float,\n                str,\n                complex,\n            ),\n        ) and obj not in [None, cls.ALREADY_PROCESSED_PLACEHOLDER]:\n            # It makes no sense (and it'd slower) to memoize objects of these primitive\n            # types.  Hence, we simply return the object.\n            return obj\n        if isinstance(obj, collections.abc.Hashable):\n            try:\n                return cls._return(obj, hash, default_function)\n            except TypeError:\n                # In case of an error with the hash (eg an object is marked as hashable\n                # but contains a non hashable within it)\n                # Fallback to use the built-in function id instead.\n                pass\n        return cls._return(obj, id, default_function)\n\n    @classmethod\n    def _return(\n        cls,\n        obj: typing.Any,\n        obj_to_membership_sign: typing.Callable[[Any], int],\n        default_func,\n        memoizing=True,\n    ) -> str | Any:\n        obj_membership_sign = obj_to_membership_sign(obj)\n        if obj_membership_sign in cls._already_processed:\n            return cls.ALREADY_PROCESSED_PLACEHOLDER\n        if memoizing:\n            if (\n                not config.disable_caching_warning\n                and len(cls._already_processed) == cls.THRESHOLD_WARNING\n            ):\n                logger.warning(\n                    \"It looks like the scene contains a lot of sub-mobjects. Caching \"\n                    \"is sometimes not suited to handle such large scenes, you might \"\n                    \"consider disabling caching with --disable_caching to potentially \"\n                    \"speed up the rendering process.\",\n                )\n                logger.warning(\n                    \"You can disable this warning by setting disable_caching_warning \"\n                    \"to True in your config file.\",\n                )\n\n            cls._already_processed.add(obj_membership_sign)\n        return default_func(obj)"}, {"name": "_MethodAnimation", "code": "class _MethodAnimation(MoveToTarget):\n    def __init__(self, mobject, methods):\n        self.methods = methods\n        super().__init__(mobject)\n\n    def finish(self) -> None:\n        for method, method_args, method_kwargs in self.methods:\n            method.__func__(self.mobject, *method_args, **method_kwargs)\n        super().finish()"}, {"name": "_new_ams_template", "code": "def _new_ams_template() -> TexTemplate:\n    \"\"\"Returns a simple Tex Template with only basic AMS packages\"\"\"\n    preamble = r\"\"\"\n\\usepackage[english]{babel}\n\\usepackage{amsmath}\n\\usepackage{amssymb}\n\"\"\"\n    return TexTemplate(preamble=preamble)"}, {"name": "_partite_layout", "code": "def _partite_layout(\n    nx_graph: NxGraph,\n    scale: float = 2,\n    partitions: Sequence[Sequence[Hashable]] | None = None,\n    **kwargs: Any,\n) -> dict[Hashable, Point3D]:\n    if partitions is None or len(partitions) == 0:\n        raise ValueError(\n            \"The partite layout requires partitions parameter to contain the partition of the vertices\",\n        )\n    partition_count = len(partitions)\n    for i in range(partition_count):\n        for v in partitions[i]:\n            if nx_graph.nodes[v] is None:\n                raise ValueError(\n                    \"The partition must contain arrays of vertices in the graph\",\n                )\n            nx_graph.nodes[v][\"subset\"] = i\n    # Add missing vertices to their own side\n    for v in nx_graph.nodes:\n        if \"subset\" not in nx_graph.nodes[v]:\n            nx_graph.nodes[v][\"subset\"] = partition_count\n\n    return nx.layout.multipartite_layout(nx_graph, scale=scale, **kwargs)"}, {"name": "_PixelUnits", "code": "class _PixelUnits:\n    def __mul__(self, val: float) -> float:\n        return val * config.frame_width / config.pixel_width\n\n    def __rmul__(self, val: float) -> float:\n        return val * config.frame_width / config.pixel_width"}, {"name": "_random_layout", "code": "def _random_layout(nx_graph: NxGraph, scale: float = 2, **kwargs: Any):\n    # the random layout places coordinates in [0, 1)\n    # we need to rescale manually afterwards...\n    auto_layout = nx.layout.random_layout(nx_graph, **kwargs)\n    for k, v in auto_layout.items():\n        auto_layout[k] = 2 * scale * (v - np.array([0.5, 0.5]))\n    return {k: np.append(v, [0]) for k, v in auto_layout.items()}"}, {"name": "_ScaleBase", "code": "class _ScaleBase:\n    \"\"\"Scale baseclass for graphing/functions.\n\n    Parameters\n    ----------\n    custom_labels\n        Whether to create custom labels when plotted on a :class:`~.NumberLine`.\n    \"\"\"\n\n    def __init__(self, custom_labels: bool = False):\n        self.custom_labels = custom_labels\n\n    def function(self, value: float) -> float:\n        \"\"\"The function that will be used to scale the values.\n\n        Parameters\n        ----------\n        value\n            The number/``np.ndarray`` to be scaled.\n\n        Returns\n        -------\n        float\n            The value after it has undergone the scaling.\n\n        Raises\n        ------\n        NotImplementedError\n            Must be subclassed.\n        \"\"\"\n        raise NotImplementedError\n\n    def inverse_function(self, value: float) -> float:\n        \"\"\"The inverse of ``function``. Used for plotting on a particular axis.\n\n        Raises\n        ------\n        NotImplementedError\n            Must be subclassed.\n        \"\"\"\n        raise NotImplementedError\n\n    def get_custom_labels(\n        self,\n        val_range: Iterable[float],\n    ) -> Iterable[Mobject]:\n        \"\"\"Custom instructions for generating labels along an axis.\n\n        Parameters\n        ----------\n        val_range\n            The position of labels. Also used for defining the content of the labels.\n\n        Returns\n        -------\n        Dict\n            A list consisting of the labels.\n            Can be passed to :meth:`~.NumberLine.add_labels() along with ``val_range``.\n\n        Raises\n        ------\n        NotImplementedError\n            Can be subclassed, optional.\n        \"\"\"\n        raise NotImplementedError"}, {"name": "_texcode_for_environment", "code": "def _texcode_for_environment(environment: str) -> tuple[str, str]:\n    r\"\"\"Processes the tex_environment string to return the correct ``\\begin{environment}[extra]{extra}`` and\n    ``\\end{environment}`` strings.\n\n    Parameters\n    ----------\n    environment\n        The tex_environment as a string. Acceptable formats include:\n        ``{align*}``, ``align*``, ``{tabular}[t]{cccl}``, ``tabular}{cccl``, ``\\begin{tabular}[t]{cccl}``.\n\n    Returns\n    -------\n    Tuple[:class:`str`, :class:`str`]\n        A pair of strings representing the opening and closing of the tex environment, e.g.\n        ``\\begin{tabular}{cccl}`` and ``\\end{tabular}``\n    \"\"\"\n    environment = environment.removeprefix(r\"\\begin\").removeprefix(\"{\")\n\n    # The \\begin command takes everything and closes with a brace\n    begin = r\"\\begin{\" + environment\n    # If it doesn't end on } or ], assume missing }\n    if not begin.endswith((\"}\", \"]\")):\n        begin += \"}\"\n\n    # While the \\end command terminates at the first closing brace\n    split_at_brace = re.split(\"}\", environment, maxsplit=1)\n    end = r\"\\end{\" + split_at_brace[0] + \"}\"\n\n    return begin, end"}, {"name": "_tree_layout", "code": "def _tree_layout(\n    T: NxGraph,\n    root_vertex: Hashable | None = None,\n    scale: float | tuple | None = 2,\n    vertex_spacing: tuple | None = None,\n    orientation: str = \"down\",\n):\n    if root_vertex is None:\n        raise ValueError(\"The tree layout requires the root_vertex parameter\")\n    if not nx.is_tree(T):\n        raise ValueError(\"The tree layout must be used with trees\")\n\n    children = {root_vertex: list(T.neighbors(root_vertex))}\n    # The following code is SageMath's tree layout implementation, taken from\n    # https://github.com/sagemath/sage/blob/cc60cfebc4576fed8b01f0fc487271bdee3cefed/src/sage/graphs/graph_plot.py#L1447\n\n    # Always make a copy of the children because they get eaten\n    stack = [list(children[root_vertex]).copy()]\n    stick = [root_vertex]\n    parent = dict.fromkeys(children[root_vertex], root_vertex)\n    pos = {}\n    obstruction = [0.0] * len(T)\n    o = -1 if orientation == \"down\" else 1\n\n    def slide(v, dx):\n        \"\"\"\n        Shift the vertex v and its descendants to the right by dx.\n        Precondition: v and its descendents have already had their\n        positions computed.\n        \"\"\"\n        level = [v]\n        while level:\n            nextlevel = []\n            for u in level:\n                x, y = pos[u]\n                x += dx\n                obstruction[y] = max(x + 1, obstruction[y])\n                pos[u] = x, y\n                nextlevel += children[u]\n            level = nextlevel\n\n    while stack:\n        C = stack[-1]\n        if not C:\n            p = stick.pop()\n            stack.pop()\n            cp = children[p]\n            y = o * len(stack)\n            if not cp:\n                x = obstruction[y]\n                pos[p] = x, y\n            else:\n                x = sum(pos[c][0] for c in cp) / float(len(cp))\n                pos[p] = x, y\n                ox = obstruction[y]\n                if x < ox:\n                    slide(p, ox - x)\n                    x = ox\n            obstruction[y] = x + 1\n            continue\n\n        t = C.pop()\n        pt = parent[t]\n\n        ct = [u for u in list(T.neighbors(t)) if u != pt]\n        for c in ct:\n            parent[c] = t\n        children[t] = copy(ct)\n\n        stack.append(ct)\n        stick.append(t)\n\n    # the resulting layout is then rescaled again to fit on Manim's canvas\n\n    x_min = min(pos.values(), key=lambda t: t[0])[0]\n    x_max = max(pos.values(), key=lambda t: t[0])[0]\n    y_min = min(pos.values(), key=lambda t: t[1])[1]\n    y_max = max(pos.values(), key=lambda t: t[1])[1]\n    center = np.array([x_min + x_max, y_min + y_max, 0]) / 2\n    height = y_max - y_min\n    width = x_max - x_min\n    if vertex_spacing is None:\n        if isinstance(scale, (float, int)) and (width > 0 or height > 0):\n            sf = 2 * scale / max(width, height)\n        elif isinstance(scale, tuple):\n            sw = 2 * scale[0] / width if scale[0] is not None and width > 0 else 1\n\n            sh = 2 * scale[1] / height if scale[1] is not None and height > 0 else 1\n\n            sf = np.array([sw, sh, 0])\n        else:\n            sf = 1\n    else:\n        sx, sy = vertex_spacing\n        sf = np.array([sx, sy, 0])\n    return {v: (np.array([x, y, 0]) - center) * sf for v, (x, y) in pos.items()}"}, {"name": "_Uniforms", "code": "class _Uniforms:\n    \"\"\"Descriptor that allows _Uniforms variables to be grouped from self.uniforms[\"attr\"] via self.attr.\n    self.uniforms attributes must be floats.\n    \"\"\"\n\n    def __set_name__(self, obj: Any, name: str) -> None:\n        self.name = name\n\n    def __get__(self, obj: Any, owner: Any) -> float:\n        val: float = obj.__dict__[\"uniforms\"][self.name]\n        return val\n\n    def __set__(self, obj: Any, num: float) -> None:\n        obj.__dict__[\"uniforms\"][self.name] = num"}, {"name": "_write_rendering_stats", "code": "def _write_rendering_stats(scene_name: str, run_time: float, file_name: str) -> None:\n    with rendering_times_file_path.open(\"a\") as file:\n        csv.writer(file).writerow(\n            [\n                re.sub(r\"^(reference\\/)|(manim\\.)\", \"\", file_name),\n                scene_name,\n                f\"{run_time:.3f}\",\n            ],\n        )"}, {"name": "AbstractImageMobject", "code": "class AbstractImageMobject(Mobject):\n    \"\"\"\n    Automatically filters out black pixels\n\n    Parameters\n    ----------\n    scale_to_resolution\n        At this resolution the image is placed pixel by pixel onto the screen, so it\n        will look the sharpest and best.\n        This is a custom parameter of ImageMobject so that rendering a scene with\n        e.g. the ``--quality low`` or ``--quality medium`` flag for faster rendering\n        won't effect the position of the image on the screen.\n    \"\"\"\n\n    def __init__(\n        self,\n        scale_to_resolution: int,\n        pixel_array_dtype: str = \"uint8\",\n        resampling_algorithm: Resampling = Resampling.BICUBIC,\n        **kwargs: Any,\n    ) -> None:\n        self.pixel_array_dtype = pixel_array_dtype\n        self.scale_to_resolution = scale_to_resolution\n        self.set_resampling_algorithm(resampling_algorithm)\n        super().__init__(**kwargs)\n\n    def get_pixel_array(self) -> None:\n        raise NotImplementedError()\n\n    def set_color(self, color, alpha=None, family=True):\n        # Likely to be implemented in subclasses, but no obligation\n        pass\n\n    def set_resampling_algorithm(self, resampling_algorithm: int) -> Self:\n        \"\"\"\n        Sets the interpolation method for upscaling the image. By default the image is\n        interpolated using bicubic algorithm. This method lets you change it.\n        Interpolation is done internally using Pillow, and the function besides the\n        string constants describing the algorithm accepts the Pillow integer constants.\n\n        Parameters\n        ----------\n        resampling_algorithm\n            An integer constant described in the Pillow library,\n            or one from the RESAMPLING_ALGORITHMS global dictionary,\n            under the following keys:\n\n            * 'bicubic' or 'cubic'\n            * 'nearest' or 'none'\n            * 'box'\n            * 'bilinear' or 'linear'\n            * 'hamming'\n            * 'lanczos' or 'antialias'\n        \"\"\"\n        if isinstance(resampling_algorithm, int):\n            self.resampling_algorithm = resampling_algorithm\n        else:\n            raise ValueError(\n                \"resampling_algorithm has to be an int, one of the values defined in \"\n                \"RESAMPLING_ALGORITHMS or a Pillow resampling filter constant. \"\n                \"Available algorithms: 'bicubic', 'nearest', 'box', 'bilinear', \"\n                \"'hamming', 'lanczos'.\",\n            )\n        return self\n\n    def reset_points(self) -> None:\n        \"\"\"Sets :attr:`points` to be the four image corners.\"\"\"\n        self.points = np.array(\n            [\n                UP + LEFT,\n                UP + RIGHT,\n                DOWN + LEFT,\n                DOWN + RIGHT,\n            ],\n        )\n        self.center()\n        h, w = self.get_pixel_array().shape[:2]\n        if self.scale_to_resolution:\n            height = h / self.scale_to_resolution * config[\"frame_height\"]\n        else:\n            height = 3  # this is the case for ImageMobjectFromCamera\n        self.stretch_to_fit_height(height)\n        self.stretch_to_fit_width(height * w / h)"}, {"name": "Add", "code": "class Add(Animation):\n    \"\"\"Add Mobjects to a scene, without animating them in any other way. This\n    is similar to the :meth:`.Scene.add` method, but :class:`Add` is an\n    animation which can be grouped into other animations.\n\n    Parameters\n    ----------\n    mobjects\n        One :class:`~.Mobject` or more to add to a scene.\n    run_time\n        The duration of the animation after adding the ``mobjects``. Defaults\n        to 0, which means this is an instant animation without extra wait time\n        after adding them.\n    **kwargs\n        Additional arguments to pass to the parent :class:`Animation` class.\n\n    Examples\n    --------\n\n    .. manim:: DefaultAddScene\n\n        class DefaultAddScene(Scene):\n            def construct(self):\n                text_1 = Text(\"I was added with Add!\")\n                text_2 = Text(\"Me too!\")\n                text_3 = Text(\"And me!\")\n                texts = VGroup(text_1, text_2, text_3).arrange(DOWN)\n                rect = SurroundingRectangle(texts, buff=0.5)\n\n                self.play(\n                    Create(rect, run_time=3.0),\n                    Succession(\n                        Wait(1.0),\n                        # You can Add a Mobject in the middle of an animation...\n                        Add(text_1),\n                        Wait(1.0),\n                        # ...or multiple Mobjects at once!\n                        Add(text_2, text_3),\n                    ),\n                )\n                self.wait()\n\n    .. manim:: AddWithRunTimeScene\n\n        class AddWithRunTimeScene(Scene):\n            def construct(self):\n                # A 5x5 grid of circles\n                circles = VGroup(\n                    *[Circle(radius=0.5) for _ in range(25)]\n                ).arrange_in_grid(5, 5)\n\n                self.play(\n                    Succession(\n                        # Add a run_time of 0.2 to wait for 0.2 seconds after\n                        # adding the circle, instead of using Wait(0.2) after Add!\n                        *[Add(circle, run_time=0.2) for circle in circles],\n                        rate_func=smooth,\n                    )\n                )\n                self.wait()\n    \"\"\"\n\n    def __init__(\n        self, *mobjects: Mobject, run_time: float = 0.0, **kwargs: Any\n    ) -> None:\n        mobject = mobjects[0] if len(mobjects) == 1 else Group(*mobjects)\n        super().__init__(mobject, run_time=run_time, introducer=True, **kwargs)\n\n    def begin(self) -> None:\n        pass\n\n    def finish(self) -> None:\n        pass\n\n    def clean_up_from_scene(self, scene: Scene) -> None:\n        pass\n\n    def update_mobjects(self, dt: float) -> None:\n        pass\n\n    def interpolate(self, alpha: float) -> None:\n        pass"}, {"name": "add_extension_if_not_present", "code": "def add_extension_if_not_present(file_name: Path, extension: str) -> Path:\n    if file_name.suffix != extension:\n        return file_name.with_suffix(file_name.suffix + extension)\n    else:\n        return file_name"}, {"name": "add_import_statement", "code": "def add_import_statement(file: Path) -> None:\n    \"\"\"Prepends an import statement in a file\n\n    Parameters\n    ----------\n        file\n    \"\"\"\n    with file.open(\"r+\") as f:\n        import_line = \"from manim import *\"\n        content = f.read()\n        f.seek(0)\n        f.write(import_line + \"\\n\" + content)"}, {"name": "add_version_before_extension", "code": "def add_version_before_extension(file_name: Path) -> Path:\n    return file_name.with_name(\n        f\"{file_name.stem}_ManimCE_v{__version__}{file_name.suffix}\"\n    )"}, {"name": "AddTextLetterByLetter", "code": "class AddTextLetterByLetter(ShowIncreasingSubsets):\n    \"\"\"Show a :class:`~.Text` letter by letter on the scene.\n\n    Parameters\n    ----------\n    time_per_char\n        Frequency of appearance of the letters.\n\n    .. tip::\n\n        This is currently only possible for class:`~.Text` and not for class:`~.MathTex`\n\n    \"\"\"\n\n    def __init__(\n        self,\n        text: Text,\n        suspend_mobject_updating: bool = False,\n        int_func: Callable[[np.ndarray], np.ndarray] = np.ceil,\n        rate_func: Callable[[float], float] = linear,\n        time_per_char: float = 0.1,\n        run_time: float | None = None,\n        reverse_rate_function=False,\n        introducer=True,\n        **kwargs,\n    ) -> None:\n        self.time_per_char = time_per_char\n        # Check for empty text using family_members_with_points()\n        if not text.family_members_with_points():\n            raise ValueError(\n                f\"The text mobject {text} does not seem to contain any characters.\"\n            )\n        if run_time is None:\n            # minimum time per character is 1/frame_rate, otherwise\n            # the animation does not finish.\n            run_time = np.max((1 / config.frame_rate, self.time_per_char)) * len(text)\n        super().__init__(\n            text,\n            suspend_mobject_updating=suspend_mobject_updating,\n            int_func=int_func,\n            rate_func=rate_func,\n            run_time=run_time,\n            reverse_rate_function=reverse_rate_function,\n            introducer=introducer,\n            **kwargs,\n        )"}, {"name": "AddTextWordByWord", "code": "class AddTextWordByWord(Succession):\n    \"\"\"Show a :class:`~.Text` word by word on the scene. Note: currently broken.\"\"\"\n\n    def __init__(\n        self,\n        text_mobject: Text,\n        run_time: float = None,\n        time_per_char: float = 0.06,\n        **kwargs,\n    ) -> None:\n        self.time_per_char = time_per_char\n        tpc = self.time_per_char\n        anims = it.chain(\n            *(\n                [\n                    ShowIncreasingSubsets(word, run_time=tpc * len(word)),\n                    Animation(word, run_time=0.005 * len(word) ** 1.5),\n                ]\n                for word in text_mobject\n            )\n        )\n        super().__init__(*anims, **kwargs)"}, {"name": "adjacent_n_tuples", "code": "def adjacent_n_tuples(objects: Sequence[T], n: int) -> zip[tuple[T, ...]]:\n    \"\"\"Returns the Sequence objects cyclically split into n length tuples.\n\n    See Also\n    --------\n    adjacent_pairs : alias with n=2\n\n    Examples\n    --------\n    .. code-block:: pycon\n\n        >>> list(adjacent_n_tuples([1, 2, 3, 4], 2))\n        [(1, 2), (2, 3), (3, 4), (4, 1)]\n        >>> list(adjacent_n_tuples([1, 2, 3, 4], 3))\n        [(1, 2, 3), (2, 3, 4), (3, 4, 1), (4, 1, 2)]\n    \"\"\"\n    return zip(*([*objects[k:], *objects[:k]] for k in range(n)))"}, {"name": "adjacent_pairs", "code": "def adjacent_pairs(objects: Sequence[T]) -> zip[tuple[T, ...]]:\n    \"\"\"Alias for ``adjacent_n_tuples(objects, 2)``.\n\n    See Also\n    --------\n    adjacent_n_tuples\n\n    Examples\n    --------\n    .. code-block:: pycon\n\n        >>> list(adjacent_pairs([1, 2, 3, 4]))\n        [(1, 2), (2, 3), (3, 4), (4, 1)]\n    \"\"\"\n    return adjacent_n_tuples(objects, 2)"}, {"name": "affects_shader_info_id", "code": "def affects_shader_info_id(\n    func: Callable[[OpenGLMobject], OpenGLMobject],\n) -> Callable[[OpenGLMobject], OpenGLMobject]:\n    @wraps(func)\n    def wrapper(self: OpenGLMobject) -> OpenGLMobject:\n        for mob in self.get_family():\n            func(mob)\n            mob.refresh_shader_wrapper_id()\n        return self\n\n    return wrapper"}, {"name": "AliasAttrDocumenter", "code": "class AliasAttrDocumenter(Directive):\n    \"\"\"Directive which replaces Sphinx's Autosummary for module-level\n    attributes: instead, it manually crafts a new \"Type Aliases\"\n    section, where all the module-level attributes which are explicitly\n    annotated as :class:`TypeAlias` are considered as such, for their\n    use all around the Manim docs.\n\n    These type aliases are separated from the \"regular\" module-level\n    attributes, which get their traditional \"Module Attributes\"\n    section autogenerated with Sphinx's Autosummary under \"Type\n    Aliases\".\n\n    See ``docs/source/_templates/autosummary/module.rst`` to watch\n    this directive in action.\n\n    See :func:`~.parse_module_attributes` for more information on how\n    the modules are parsed to obtain the :class:`TypeAlias` information\n    and separate it from the other attributes.\n    \"\"\"\n\n    objtype = \"autoaliasattr\"\n    required_arguments = 1\n    has_content = True\n\n    def run(self) -> list[nodes.Element]:\n        module_name = self.arguments[0]\n        # not present in the keys of the DICTs\n        module_name = module_name.removeprefix(\"manim.\")\n        module_alias_dict = ALIAS_DOCS_DICT.get(module_name, None)\n        module_attrs_list = DATA_DICT.get(module_name, None)\n        module_typevars = TYPEVAR_DICT.get(module_name, None)\n\n        content = nodes.container()\n\n        # Add \"Type Aliases\" section\n        if module_alias_dict is not None:\n            module_alias_section = nodes.section(ids=[f\"{module_name}.alias\"])\n            content += module_alias_section\n\n            # Use a rubric (title-like), just like in `module.rst`\n            module_alias_section += nodes.rubric(text=\"Type Aliases\")\n\n            # category_name: str\n            # category_dict: AliasCategoryDict = dict[str, AliasInfo]\n            for category_name, category_dict in module_alias_dict.items():\n                category_section = nodes.section(\n                    ids=[category_name.lower().replace(\" \", \"_\")]\n                )\n                module_alias_section += category_section\n                # category_name can be possibly \"\" for uncategorized aliases\n                if category_name:\n                    category_section += nodes.title(text=category_name)\n\n                category_alias_container = nodes.container()\n                category_section += category_alias_container\n\n                # alias_name: str\n                # alias_info: AliasInfo = dict[str, str]\n                #   Contains \"definition\": str\n                #   Can possibly contain \"doc\": str\n                for alias_name, alias_info in category_dict.items():\n                    # Replace all occurrences of type aliases in the\n                    # definition for automatic cross-referencing!\n                    alias_def = alias_info[\"definition\"]\n                    for A in ALIAS_LIST:\n                        alias_def = smart_replace(alias_def, A, f\":class:`~.{A}`\")\n\n                    # Using the `.. class::` directive is CRUCIAL, since\n                    # function/method parameters are always annotated via\n                    # classes - therefore Sphinx expects a class\n                    unparsed = ViewList(\n                        [\n                            f\".. class:: {alias_name}\",\n                            \"\",\n                            \"    .. parsed-literal::\",\n                            \"\",\n                            f\"        {alias_def}\",\n                            \"\",\n                        ]\n                    )\n\n                    if \"doc\" in alias_info:\n                        # Replace all occurrences of type aliases in\n                        # the docs for automatic cross-referencing!\n                        alias_doc = alias_info[\"doc\"]\n                        for A in ALIAS_LIST:\n                            alias_doc = alias_doc.replace(f\"`{A}`\", f\":class:`~.{A}`\")\n\n                        # also hyperlink the TypeVars from that module\n                        if module_typevars is not None:\n                            for T in module_typevars:\n                                alias_doc = alias_doc.replace(f\"`{T}`\", f\":class:`{T}`\")\n\n                        # Add all the lines with 4 spaces behind, to consider all the\n                        # documentation as a paragraph INSIDE the `.. class::` block\n                        doc_lines = alias_doc.split(\"\\n\")\n                        unparsed.extend(ViewList([f\"    {line}\" for line in doc_lines]))\n\n                    # Parse the reST text into a fresh container\n                    # https://www.sphinx-doc.org/en/master/extdev/markupapi.html#parsing-directive-content-as-rest\n                    alias_container = nodes.container()\n                    self.state.nested_parse(unparsed, 0, alias_container)\n                    category_alias_container += alias_container\n\n        # then add the module TypeVars section\n        if module_typevars is not None:\n            module_typevars_section = nodes.section(ids=[f\"{module_name}.typevars\"])\n            content += module_typevars_section\n\n            # Use a rubric (title-like), just like in `module.rst`\n            module_typevars_section += nodes.rubric(text=\"TypeVar's\")\n\n            # name: str\n            # definition: TypeVarDict = dict[str, str]\n            for name, definition in module_typevars.items():\n                # Using the `.. class::` directive is CRUCIAL, since\n                # function/method parameters are always annotated via\n                # classes - therefore Sphinx expects a class\n                unparsed = ViewList(\n                    [\n                        f\".. class:: {name}\",\n                        \"\",\n                        \"    .. parsed-literal::\",\n                        \"\",\n                        f\"        {definition}\",\n                        \"\",\n                    ]\n                )\n\n                # Parse the reST text into a fresh container\n                # https://www.sphinx-doc.org/en/master/extdev/markupapi.html#parsing-directive-content-as-rest\n                typevar_container = nodes.container()\n                self.state.nested_parse(unparsed, 0, typevar_container)\n                module_typevars_section += typevar_container\n\n        # Then, add the traditional \"Module Attributes\" section\n        if module_attrs_list is not None:\n            module_attrs_section = nodes.section(ids=[f\"{module_name}.data\"])\n            content += module_attrs_section\n\n            # Use the same rubric (title-like) as in `module.rst`\n            module_attrs_section += nodes.rubric(text=\"Module Attributes\")\n            # Let Sphinx Autosummary do its thing as always\n            # Add all the attribute names with 4 spaces behind, so that\n            # they're considered as INSIDE the `.. autosummary::` block\n            unparsed = ViewList(\n                [\n                    \".. autosummary::\",\n                    *(f\"    {attr}\" for attr in module_attrs_list),\n                ]\n            )\n\n            # Parse the reST text into a fresh container\n            # https://www.sphinx-doc.org/en/master/extdev/markupapi.html#parsing-directive-content-as-rest\n            data_container = nodes.container()\n            self.state.nested_parse(unparsed, 0, data_container)\n            module_attrs_section += data_container\n\n        return [content]"}, {"name": "all_elements_are_instances", "code": "def all_elements_are_instances(iterable: Iterable[object], Class: type[object]) -> bool:\n    \"\"\"Returns ``True`` if all elements of iterable are instances of Class.\n    False otherwise.\n    \"\"\"\n    return all(isinstance(e, Class) for e in iterable)"}, {"name": "always", "code": "def always(method: Callable, *args, **kwargs) -> Mobject:\n    assert_is_mobject_method(method)\n    mobject = method.__self__\n    func = method.__func__\n    mobject.add_updater(lambda m: func(m, *args, **kwargs))\n    return mobject"}, {"name": "always_redraw", "code": "def always_redraw(func: Callable[[], Mobject]) -> Mobject:\n    \"\"\"Redraw the mobject constructed by a function every frame.\n\n    This function returns a mobject with an attached updater that\n    continuously regenerates the mobject according to the\n    specified function.\n\n    Parameters\n    ----------\n    func\n        A function without (required) input arguments that returns\n        a mobject.\n\n    Examples\n    --------\n\n    .. manim:: TangentAnimation\n\n        class TangentAnimation(Scene):\n            def construct(self):\n                ax = Axes()\n                sine = ax.plot(np.sin, color=RED)\n                alpha = ValueTracker(0)\n                point = always_redraw(\n                    lambda: Dot(\n                        sine.point_from_proportion(alpha.get_value()),\n                        color=BLUE\n                    )\n                )\n                tangent = always_redraw(\n                    lambda: TangentLine(\n                        sine,\n                        alpha=alpha.get_value(),\n                        color=YELLOW,\n                        length=4\n                    )\n                )\n                self.add(ax, sine, point, tangent)\n                self.play(alpha.animate.set_value(1), rate_func=linear, run_time=2)\n    \"\"\"\n    mob = func()\n    mob.add_updater(lambda _: mob.become(func()))\n    return mob"}, {"name": "always_rotate", "code": "def always_rotate(mobject: Mobject, rate: float = 20 * DEGREES, **kwargs) -> Mobject:\n    \"\"\"A mobject which is continuously rotated at a certain rate.\n\n    Parameters\n    ----------\n    mobject\n        The mobject to be rotated.\n    rate\n        The angle which the mobject is rotated by\n        over one second.\n    kwags\n        Further arguments to be passed to :meth:`.Mobject.rotate`.\n\n    Examples\n    --------\n\n    .. manim:: SpinningTriangle\n\n        class SpinningTriangle(Scene):\n            def construct(self):\n                tri = Triangle().set_fill(opacity=1).set_z_index(2)\n                sq = Square().to_edge(LEFT)\n\n                # will keep spinning while there is an animation going on\n                always_rotate(tri, rate=2*PI, about_point=ORIGIN)\n\n                self.add(tri, sq)\n                self.play(sq.animate.to_edge(RIGHT), rate_func=linear, run_time=1)\n    \"\"\"\n    mobject.add_updater(lambda m, dt: m.rotate(dt * rate, **kwargs))\n    return mobject"}, {"name": "always_shift", "code": "def always_shift(\n    mobject: Mobject, direction: np.ndarray[np.float64] = RIGHT, rate: float = 0.1\n) -> Mobject:\n    \"\"\"A mobject which is continuously shifted along some direction\n    at a certain rate.\n\n    Parameters\n    ----------\n    mobject\n        The mobject to shift.\n    direction\n        The direction to shift. The vector is normalized, the specified magnitude\n        is not relevant.\n    rate\n        Length in Manim units which the mobject travels in one\n        second along the specified direction.\n\n    Examples\n    --------\n\n    .. manim:: ShiftingSquare\n\n        class ShiftingSquare(Scene):\n            def construct(self):\n                sq = Square().set_fill(opacity=1)\n                tri = Triangle()\n                VGroup(sq, tri).arrange(LEFT)\n\n                # construct a square which is continuously\n                # shifted to the right\n                always_shift(sq, RIGHT, rate=5)\n\n                self.add(sq)\n                self.play(tri.animate.set_fill(opacity=1))\n    \"\"\"\n    mobject.add_updater(lambda m, dt: m.shift(dt * rate * normalize(direction)))\n    return mobject"}, {"name": "Angle", "code": "class Angle(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A circular arc or elbow-type mobject representing an angle of two lines.\n\n    Parameters\n    ----------\n    line1 :\n        The first line.\n    line2 :\n        The second line.\n    radius :\n        The radius of the :class:`Arc`.\n    quadrant\n        A sequence of two :class:`int` numbers determining which of the 4 quadrants should be used.\n        The first value indicates whether to anchor the arc on the first line closer to the end point (1)\n        or start point (-1), and the second value functions similarly for the\n        end (1) or start (-1) of the second line.\n        Possibilities: (1,1), (-1,1), (1,-1), (-1,-1).\n    other_angle :\n        Toggles between the two possible angles defined by two points and an arc center. If set to\n        False (default), the arc will always go counterclockwise from the point on line1 until\n        the point on line2 is reached. If set to True, the angle will go clockwise from line1 to line2.\n    dot\n        Allows for a :class:`Dot` in the arc. Mainly used as an convention to indicate a right angle.\n        The dot can be customized in the next three parameters.\n    dot_radius\n        The radius of the :class:`Dot`. If not specified otherwise, this radius will be 1/10 of the arc radius.\n    dot_distance\n        Relative distance from the center to the arc: 0 puts the dot in the center and 1 on the arc itself.\n    dot_color\n        The color of the :class:`Dot`.\n    elbow\n        Produces an elbow-type mobject indicating a right angle, see :class:`RightAngle` for more information\n        and a shorthand.\n    **kwargs\n        Further keyword arguments that are passed to the constructor of :class:`Arc` or :class:`Elbow`.\n\n    Examples\n    --------\n    The first example shows some right angles with a dot in the middle while the second example shows\n    all 8 possible angles defined by two lines.\n\n    .. manim:: RightArcAngleExample\n        :save_last_frame:\n\n        class RightArcAngleExample(Scene):\n            def construct(self):\n                line1 = Line( LEFT, RIGHT )\n                line2 = Line( DOWN, UP )\n                rightarcangles = [\n                    Angle(line1, line2, dot=True),\n                    Angle(line1, line2, radius=0.4, quadrant=(1,-1), dot=True, other_angle=True),\n                    Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, dot=True, dot_color=YELLOW, dot_radius=0.04, other_angle=True),\n                    Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, dot=True, dot_color=GREEN, dot_radius=0.08),\n                ]\n                plots = VGroup()\n                for angle in rightarcangles:\n                    plot=VGroup(line1.copy(),line2.copy(), angle)\n                    plots.add(plot)\n                plots.arrange(buff=1.5)\n                self.add(plots)\n\n    .. manim:: AngleExample\n        :save_last_frame:\n\n        class AngleExample(Scene):\n            def construct(self):\n                line1 = Line( LEFT + (1/3) * UP, RIGHT + (1/3) * DOWN )\n                line2 = Line( DOWN + (1/3) * RIGHT, UP + (1/3) * LEFT )\n                angles = [\n                    Angle(line1, line2),\n                    Angle(line1, line2, radius=0.4, quadrant=(1,-1), other_angle=True),\n                    Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, other_angle=True),\n                    Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED),\n                    Angle(line1, line2, other_angle=True),\n                    Angle(line1, line2, radius=0.4, quadrant=(1,-1)),\n                    Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8),\n                    Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, other_angle=True),\n                ]\n                plots = VGroup()\n                for angle in angles:\n                    plot=VGroup(line1.copy(),line2.copy(), angle)\n                    plots.add(VGroup(plot,SurroundingRectangle(plot, buff=0.3)))\n                plots.arrange_in_grid(rows=2,buff=1)\n                self.add(plots)\n\n    .. manim:: FilledAngle\n        :save_last_frame:\n\n        class FilledAngle(Scene):\n            def construct(self):\n                l1 = Line(ORIGIN, 2 * UP + RIGHT).set_color(GREEN)\n                l2 = (\n                    Line(ORIGIN, 2 * UP + RIGHT)\n                    .set_color(GREEN)\n                    .rotate(-20 * DEGREES, about_point=ORIGIN)\n                )\n                norm = l1.get_length()\n                a1 = Angle(l1, l2, other_angle=True, radius=norm - 0.5).set_color(GREEN)\n                a2 = Angle(l1, l2, other_angle=True, radius=norm).set_color(GREEN)\n                q1 = a1.points #  save all coordinates of points of angle a1\n                q2 = a2.reverse_direction().points  #  save all coordinates of points of angle a1 (in reversed direction)\n                pnts = np.concatenate([q1, q2, q1[0].reshape(1, 3)])  # adds points and ensures that path starts and ends at same point\n                mfill = VMobject().set_color(ORANGE)\n                mfill.set_points_as_corners(pnts).set_fill(GREEN, opacity=1)\n                self.add(l1, l2)\n                self.add(mfill)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        line1: Line,\n        line2: Line,\n        radius: float | None = None,\n        quadrant: AngleQuadrant = (1, 1),\n        other_angle: bool = False,\n        dot: bool = False,\n        dot_radius: float | None = None,\n        dot_distance: float = 0.55,\n        dot_color: ParsableManimColor = WHITE,\n        elbow: bool = False,\n        **kwargs: Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.lines = (line1, line2)\n        self.quadrant = quadrant\n        self.dot_distance = dot_distance\n        self.elbow = elbow\n        inter = line_intersection(\n            [line1.get_start(), line1.get_end()],\n            [line2.get_start(), line2.get_end()],\n        )\n\n        if radius is None:\n            if quadrant[0] == 1:\n                dist_1 = np.linalg.norm(line1.get_end() - inter)\n            else:\n                dist_1 = np.linalg.norm(line1.get_start() - inter)\n            if quadrant[1] == 1:\n                dist_2 = np.linalg.norm(line2.get_end() - inter)\n            else:\n                dist_2 = np.linalg.norm(line2.get_start() - inter)\n            if np.minimum(dist_1, dist_2) < 0.6:\n                radius = (2 / 3) * np.minimum(dist_1, dist_2)\n            else:\n                radius = 0.4\n        else:\n            self.radius = radius\n\n        anchor_angle_1 = inter + quadrant[0] * radius * line1.get_unit_vector()\n        anchor_angle_2 = inter + quadrant[1] * radius * line2.get_unit_vector()\n\n        if elbow:\n            anchor_middle = (\n                inter\n                + quadrant[0] * radius * line1.get_unit_vector()\n                + quadrant[1] * radius * line2.get_unit_vector()\n            )\n            angle_mobject: VMobject = Elbow(**kwargs)\n            angle_mobject.set_points_as_corners(\n                np.array([anchor_angle_1, anchor_middle, anchor_angle_2]),\n            )\n        else:\n            angle_1 = angle_of_vector(anchor_angle_1 - inter)\n            angle_2 = angle_of_vector(anchor_angle_2 - inter)\n\n            if not other_angle:\n                start_angle = angle_1\n                if angle_2 > angle_1:\n                    angle_fin = angle_2 - angle_1\n                else:\n                    angle_fin = 2 * np.pi - (angle_1 - angle_2)\n            else:\n                start_angle = angle_1\n                if angle_2 < angle_1:\n                    angle_fin = -angle_1 + angle_2\n                else:\n                    angle_fin = -2 * np.pi + (angle_2 - angle_1)\n\n            self.angle_value = angle_fin\n\n            angle_mobject = Arc(\n                radius=radius,\n                angle=self.angle_value,\n                start_angle=start_angle,\n                arc_center=inter,\n                **kwargs,\n            )\n\n            if dot:\n                if dot_radius is None:\n                    dot_radius = radius / 10\n                else:\n                    self.dot_radius = dot_radius\n                right_dot = Dot(ORIGIN, radius=dot_radius, color=dot_color)\n                dot_anchor = (\n                    inter\n                    + (angle_mobject.get_center() - inter)\n                    / np.linalg.norm(angle_mobject.get_center() - inter)\n                    * radius\n                    * dot_distance\n                )\n                right_dot.move_to(dot_anchor)\n                self.add(right_dot)\n\n        self.set_points(angle_mobject.points)\n\n    def get_lines(self) -> VGroup:\n        \"\"\"Get the lines forming an angle of the :class:`Angle` class.\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            A :class:`~.VGroup` containing the lines that form the angle of the :class:`Angle` class.\n\n        Examples\n        --------\n        ::\n\n            >>> line_1, line_2 = Line(ORIGIN, RIGHT), Line(ORIGIN, UR)\n            >>> angle = Angle(line_1, line_2)\n            >>> angle.get_lines()\n            VGroup(Line, Line)\n        \"\"\"\n        return VGroup(*self.lines)\n\n    def get_value(self, degrees: bool = False) -> float:\n        r\"\"\"Get the value of an angle of the :class:`Angle` class.\n\n        Parameters\n        ----------\n        degrees\n            A boolean to decide the unit (deg/rad) in which the value of the angle is returned.\n\n        Returns\n        -------\n        :class:`float`\n            The value in degrees/radians of an angle of the :class:`Angle` class.\n\n        Examples\n        --------\n\n        .. manim:: GetValueExample\n            :save_last_frame:\n\n            class GetValueExample(Scene):\n                def construct(self):\n                    line1 = Line(LEFT+(1/3)*UP, RIGHT+(1/3)*DOWN)\n                    line2 = Line(DOWN+(1/3)*RIGHT, UP+(1/3)*LEFT)\n\n                    angle = Angle(line1, line2, radius=0.4)\n\n                    value = DecimalNumber(angle.get_value(degrees=True), unit=r\"^{\\circ}\")\n                    value.next_to(angle, UR)\n\n                    self.add(line1, line2, angle, value)\n        \"\"\"\n        return self.angle_value / DEGREES if degrees else self.angle_value\n\n    @staticmethod\n    def from_three_points(\n        A: Point3DLike, B: Point3DLike, C: Point3DLike, **kwargs: Any\n    ) -> Angle:\n        r\"\"\"The angle between the lines AB and BC.\n\n        This constructs the angle :math:`\\\\angle ABC`.\n\n        Parameters\n        ----------\n        A\n            The endpoint of the first angle leg\n        B\n            The vertex of the angle\n        C\n            The endpoint of the second angle leg\n\n        **kwargs\n            Further keyword arguments are passed to :class:`.Angle`\n\n        Returns\n        -------\n        The Angle calculated from the three points\n\n                    Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8),\n                    Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, other_angle=True),\n\n        Examples\n        --------\n        .. manim:: AngleFromThreePointsExample\n            :save_last_frame:\n\n            class AngleFromThreePointsExample(Scene):\n                def construct(self):\n                    sample_angle = Angle.from_three_points(UP, ORIGIN, LEFT)\n                    red_angle = Angle.from_three_points(LEFT + UP, ORIGIN, RIGHT, radius=.8, quadrant=(-1,-1), color=RED, stroke_width=8, other_angle=True)\n                    self.add(red_angle, sample_angle)\n        \"\"\"\n        return Angle(Line(B, A), Line(B, C), **kwargs)"}, {"name": "angle_axis_from_quaternion", "code": "def angle_axis_from_quaternion(quaternion: Sequence[float]) -> Sequence[float]:\n    \"\"\"Gets angle and axis from a quaternion.\n\n    Parameters\n    ----------\n    quaternion\n        The quaternion from which we get the angle and axis.\n\n    Returns\n    -------\n    Sequence[float]\n        Gives the angle and axis\n    \"\"\"\n    axis = normalize(quaternion[1:], fall_back=np.array([1, 0, 0]))\n    angle = 2 * np.arccos(quaternion[0])\n    if angle > TAU / 2:\n        angle = TAU - angle\n    return angle, axis"}, {"name": "angle_between_vectors", "code": "def angle_between_vectors(v1: np.ndarray, v2: np.ndarray) -> float:\n    \"\"\"Returns the angle between two vectors.\n    This angle will always be between 0 and pi\n\n    Parameters\n    ----------\n    v1\n        The first vector.\n    v2\n        The second vector.\n\n    Returns\n    -------\n    float\n        The angle between the vectors.\n    \"\"\"\n    val: float = 2 * np.arctan2(\n        np.linalg.norm(normalize(v1) - normalize(v2)),\n        np.linalg.norm(normalize(v1) + normalize(v2)),\n    )\n\n    return val"}, {"name": "angle_of_vector", "code": "def angle_of_vector(vector: Sequence[float] | np.ndarray) -> float:\n    \"\"\"Returns polar coordinate theta when vector is projected on xy plane.\n\n    Parameters\n    ----------\n    vector\n        The vector to find the angle for.\n\n    Returns\n    -------\n    float\n        The angle of the vector projected.\n    \"\"\"\n    if isinstance(vector, np.ndarray) and len(vector.shape) > 1:\n        if vector.shape[0] < 2:\n            raise ValueError(\"Vector must have the correct dimensions. (2, n)\")\n        c_vec = np.empty(vector.shape[1], dtype=np.complex128)\n        c_vec.real = vector[0]\n        c_vec.imag = vector[1]\n        val1: float = np.angle(c_vec)\n        return val1\n    val: float = np.angle(complex(*vector[:2]))\n    return val"}, {"name": "AnimatedBoundary", "code": "class AnimatedBoundary(VGroup):\n    \"\"\"Boundary of a :class:`.VMobject` with animated color change.\n\n    Examples\n    --------\n    .. manim:: AnimatedBoundaryExample\n\n        class AnimatedBoundaryExample(Scene):\n            def construct(self):\n                text = Text(\"So shiny!\")\n                boundary = AnimatedBoundary(text, colors=[RED, GREEN, BLUE],\n                                            cycle_rate=3)\n                self.add(text, boundary)\n                self.wait(2)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        vmobject,\n        colors=[BLUE_D, BLUE_B, BLUE_E, GREY_BROWN],\n        max_stroke_width=3,\n        cycle_rate=0.5,\n        back_and_forth=True,\n        draw_rate_func=smooth,\n        fade_rate_func=smooth,\n        **kwargs,\n    ):\n        super().__init__(**kwargs)\n        self.colors = colors\n        self.max_stroke_width = max_stroke_width\n        self.cycle_rate = cycle_rate\n        self.back_and_forth = back_and_forth\n        self.draw_rate_func = draw_rate_func\n        self.fade_rate_func = fade_rate_func\n        self.vmobject = vmobject\n        self.boundary_copies = [\n            vmobject.copy().set_style(stroke_width=0, fill_opacity=0) for x in range(2)\n        ]\n        self.add(*self.boundary_copies)\n        self.total_time = 0\n        self.add_updater(lambda m, dt: self.update_boundary_copies(dt))\n\n    def update_boundary_copies(self, dt):\n        # Not actual time, but something which passes at\n        # an altered rate to make the implementation below\n        # cleaner\n        time = self.total_time * self.cycle_rate\n        growing, fading = self.boundary_copies\n        colors = self.colors\n        msw = self.max_stroke_width\n        vmobject = self.vmobject\n\n        index = int(time % len(colors))\n        alpha = time % 1\n        draw_alpha = self.draw_rate_func(alpha)\n        fade_alpha = self.fade_rate_func(alpha)\n\n        if self.back_and_forth and int(time) % 2 == 1:\n            bounds = (1 - draw_alpha, 1)\n        else:\n            bounds = (0, draw_alpha)\n        self.full_family_become_partial(growing, vmobject, *bounds)\n        growing.set_stroke(colors[index], width=msw)\n\n        if time >= 1:\n            self.full_family_become_partial(fading, vmobject, 0, 1)\n            fading.set_stroke(color=colors[index - 1], width=(1 - fade_alpha) * msw)\n\n        self.total_time += dt\n\n    def full_family_become_partial(self, mob1, mob2, a, b):\n        family1 = mob1.family_members_with_points()\n        family2 = mob2.family_members_with_points()\n        for sm1, sm2 in zip(family1, family2):\n            sm1.pointwise_become_partial(sm2, a, b)\n        return self"}, {"name": "Animation", "code": "class Animation:\n    \"\"\"An animation.\n\n    Animations have a fixed time span.\n\n    Parameters\n    ----------\n    mobject\n        The mobject to be animated. This is not required for all types of animations.\n    lag_ratio\n        Defines the delay after which the animation is applied to submobjects. This lag\n        is relative to the duration of the animation.\n\n        This does not influence the total\n        runtime of the animation. Instead the runtime of individual animations is\n        adjusted so that the complete animation has the defined run time.\n\n    run_time\n        The duration of the animation in seconds.\n    rate_func\n        The function defining the animation progress based on the relative runtime (see  :mod:`~.rate_functions`) .\n\n        For example ``rate_func(0.5)`` is the proportion of the animation that is done\n        after half of the animations run time.\n\n    reverse_rate_function\n        Reverses the rate function of the animation. Setting ``reverse_rate_function``\n        does not have any effect on ``remover`` or ``introducer``. These need to be\n        set explicitly if an introducer-animation should be turned into a remover one\n        and vice versa.\n    name\n        The name of the animation. This gets displayed while rendering the animation.\n        Defaults to <class-name>(<Mobject-name>).\n    remover\n        Whether the given mobject should be removed from the scene after this animation.\n    suspend_mobject_updating\n        Whether updaters of the mobject should be suspended during the animation.\n\n\n    .. NOTE::\n\n        In the current implementation of this class, the specified rate function is applied\n        within :meth:`.Animation.interpolate_mobject` call as part of the call to\n        :meth:`.Animation.interpolate_submobject`. For subclasses of :class:`.Animation`\n        that are implemented by overriding :meth:`interpolate_mobject`, the rate function\n        has to be applied manually (e.g., by passing ``self.rate_func(alpha)`` instead\n        of just ``alpha``).\n\n\n    Examples\n    --------\n\n    .. manim:: LagRatios\n\n        class LagRatios(Scene):\n            def construct(self):\n                ratios = [0, 0.1, 0.5, 1, 2]  # demonstrated lag_ratios\n\n                # Create dot groups\n                group = VGroup(*[Dot() for _ in range(4)]).arrange_submobjects()\n                groups = VGroup(*[group.copy() for _ in ratios]).arrange_submobjects(buff=1)\n                self.add(groups)\n\n                # Label groups\n                self.add(Text(\"lag_ratio = \", font_size=36).next_to(groups, UP, buff=1.5))\n                for group, ratio in zip(groups, ratios):\n                    self.add(Text(str(ratio), font_size=36).next_to(group, UP))\n\n                #Animate groups with different lag_ratios\n                self.play(AnimationGroup(*[\n                    group.animate(lag_ratio=ratio, run_time=1.5).shift(DOWN * 2)\n                    for group, ratio in zip(groups, ratios)\n                ]))\n\n                # lag_ratio also works recursively on nested submobjects:\n                self.play(groups.animate(run_time=1, lag_ratio=0.1).shift(UP * 2))\n\n    \"\"\"\n\n    def __new__(\n        cls,\n        mobject=None,\n        *args,\n        use_override=True,\n        **kwargs,\n    ) -> Self:\n        if isinstance(mobject, Mobject) and use_override:\n            func = mobject.animation_override_for(cls)\n            if func is not None:\n                anim = func(mobject, *args, **kwargs)\n                logger.debug(\n                    f\"The {cls.__name__} animation has been overridden for \"\n                    f\"{type(mobject).__name__} mobjects. use_override = False can \"\n                    f\" be used as keyword argument to prevent animation overriding.\",\n                )\n                return anim\n        return super().__new__(cls)\n\n    def __init__(\n        self,\n        mobject: Mobject | None,\n        lag_ratio: float = DEFAULT_ANIMATION_LAG_RATIO,\n        run_time: float = DEFAULT_ANIMATION_RUN_TIME,\n        rate_func: Callable[[float], float] = smooth,\n        reverse_rate_function: bool = False,\n        name: str = None,\n        remover: bool = False,  # remove a mobject from the screen?\n        suspend_mobject_updating: bool = True,\n        introducer: bool = False,\n        *,\n        _on_finish: Callable[[], None] = lambda _: None,\n        use_override: bool = True,  # included here to avoid TypeError if passed from a subclass' constructor\n    ) -> None:\n        self._typecheck_input(mobject)\n        self.run_time: float = run_time\n        self.rate_func: Callable[[float], float] = rate_func\n        self.reverse_rate_function: bool = reverse_rate_function\n        self.name: str | None = name\n        self.remover: bool = remover\n        self.introducer: bool = introducer\n        self.suspend_mobject_updating: bool = suspend_mobject_updating\n        self.lag_ratio: float = lag_ratio\n        self._on_finish: Callable[[Scene], None] = _on_finish\n        if config[\"renderer\"] == RendererType.OPENGL:\n            self.starting_mobject: OpenGLMobject = OpenGLMobject()\n            self.mobject: OpenGLMobject = (\n                mobject if mobject is not None else OpenGLMobject()\n            )\n        else:\n            self.starting_mobject: Mobject = Mobject()\n            self.mobject: Mobject = mobject if mobject is not None else Mobject()\n\n        if hasattr(self, \"CONFIG\"):\n            logger.error(\n                (\n                    \"CONFIG has been removed from ManimCommunity.\",\n                    \"Please use keyword arguments instead.\",\n                ),\n            )\n\n    @property\n    def run_time(self) -> float:\n        return self._run_time\n\n    @run_time.setter\n    def run_time(self, value: float) -> None:\n        if value < 0:\n            raise ValueError(\n                f\"The run_time of {self.__class__.__name__} cannot be \"\n                f\"negative. The given value was {value}.\"\n            )\n        self._run_time = value\n\n    def _typecheck_input(self, mobject: Mobject | None) -> None:\n        if mobject is None:\n            logger.debug(\"Animation with empty mobject\")\n        elif not isinstance(mobject, (Mobject, OpenGLMobject)):\n            raise TypeError(\"Animation only works on Mobjects\")\n\n    def __str__(self) -> str:\n        if self.name:\n            return self.name\n        return f\"{self.__class__.__name__}({str(self.mobject)})\"\n\n    def __repr__(self) -> str:\n        return str(self)\n\n    def begin(self) -> None:\n        \"\"\"Begin the animation.\n\n        This method is called right as an animation is being played. As much\n        initialization as possible, especially any mobject copying, should live in this\n        method.\n\n        \"\"\"\n        self.starting_mobject = self.create_starting_mobject()\n        if self.suspend_mobject_updating:\n            # All calls to self.mobject's internal updaters\n            # during the animation, either from this Animation\n            # or from the surrounding scene, should do nothing.\n            # It is, however, okay and desirable to call\n            # the internal updaters of self.starting_mobject,\n            # or any others among self.get_all_mobjects()\n            self.mobject.suspend_updating()\n        self.interpolate(0)\n\n    def finish(self) -> None:\n        # TODO: begin and finish should require a scene as parameter.\n        # That way Animation.clean_up_from_screen and Scene.add_mobjects_from_animations\n        # could be removed as they fulfill basically the same purpose.\n        \"\"\"Finish the animation.\n\n        This method gets called when the animation is over.\n\n        \"\"\"\n        self.interpolate(1)\n        if self.suspend_mobject_updating and self.mobject is not None:\n            self.mobject.resume_updating()\n\n    def clean_up_from_scene(self, scene: Scene) -> None:\n        \"\"\"Clean up the :class:`~.Scene` after finishing the animation.\n\n        This includes to :meth:`~.Scene.remove` the Animation's\n        :class:`~.Mobject` if the animation is a remover.\n\n        Parameters\n        ----------\n        scene\n            The scene the animation should be cleaned up from.\n        \"\"\"\n        self._on_finish(scene)\n        if self.is_remover():\n            scene.remove(self.mobject)\n\n    def _setup_scene(self, scene: Scene) -> None:\n        \"\"\"Setup up the :class:`~.Scene` before starting the animation.\n\n        This includes to :meth:`~.Scene.add` the Animation's\n        :class:`~.Mobject` if the animation is an introducer.\n\n        Parameters\n        ----------\n        scene\n            The scene the animation should be cleaned up from.\n        \"\"\"\n        if scene is None:\n            return\n        if (\n            self.is_introducer()\n            and self.mobject not in scene.get_mobject_family_members()\n        ):\n            scene.add(self.mobject)\n\n    def create_starting_mobject(self) -> Mobject:\n        # Keep track of where the mobject starts\n        return self.mobject.copy()\n\n    def get_all_mobjects(self) -> Sequence[Mobject]:\n        \"\"\"Get all mobjects involved in the animation.\n\n        Ordering must match the ordering of arguments to interpolate_submobject\n\n        Returns\n        -------\n        Sequence[Mobject]\n            The sequence of mobjects.\n        \"\"\"\n        return self.mobject, self.starting_mobject\n\n    def get_all_families_zipped(self) -> Iterable[tuple]:\n        if config[\"renderer\"] == RendererType.OPENGL:\n            return zip(*(mob.get_family() for mob in self.get_all_mobjects()))\n        return zip(\n            *(mob.family_members_with_points() for mob in self.get_all_mobjects())\n        )\n\n    def update_mobjects(self, dt: float) -> None:\n        \"\"\"\n        Updates things like starting_mobject, and (for\n        Transforms) target_mobject.  Note, since typically\n        (always?) self.mobject will have its updating\n        suspended during the animation, this will do\n        nothing to self.mobject.\n        \"\"\"\n        for mob in self.get_all_mobjects_to_update():\n            mob.update(dt)\n\n    def get_all_mobjects_to_update(self) -> list[Mobject]:\n        \"\"\"Get all mobjects to be updated during the animation.\n\n        Returns\n        -------\n        List[Mobject]\n            The list of mobjects to be updated during the animation.\n        \"\"\"\n        # The surrounding scene typically handles\n        # updating of self.mobject.  Besides, in\n        # most cases its updating is suspended anyway\n        return list(filter(lambda m: m is not self.mobject, self.get_all_mobjects()))\n\n    def copy(self) -> Animation:\n        \"\"\"Create a copy of the animation.\n\n        Returns\n        -------\n        Animation\n            A copy of ``self``\n        \"\"\"\n        return deepcopy(self)\n\n    # Methods for interpolation, the mean of an Animation\n\n    # TODO: stop using alpha as parameter name in different meanings.\n    def interpolate(self, alpha: float) -> None:\n        \"\"\"Set the animation progress.\n\n        This method gets called for every frame during an animation.\n\n        Parameters\n        ----------\n        alpha\n            The relative time to set the animation to, 0 meaning the start, 1 meaning\n            the end.\n        \"\"\"\n        self.interpolate_mobject(alpha)\n\n    def interpolate_mobject(self, alpha: float) -> None:\n        \"\"\"Interpolates the mobject of the :class:`Animation` based on alpha value.\n\n        Parameters\n        ----------\n        alpha\n            A float between 0 and 1 expressing the ratio to which the animation\n            is completed. For example, alpha-values of 0, 0.5, and 1 correspond\n            to the animation being completed 0%, 50%, and 100%, respectively.\n        \"\"\"\n        families = list(self.get_all_families_zipped())\n        for i, mobs in enumerate(families):\n            sub_alpha = self.get_sub_alpha(alpha, i, len(families))\n            self.interpolate_submobject(*mobs, sub_alpha)\n\n    def interpolate_submobject(\n        self,\n        submobject: Mobject,\n        starting_submobject: Mobject,\n        # target_copy: Mobject, #Todo: fix - signature of interpolate_submobject differs in Transform().\n        alpha: float,\n    ) -> Animation:\n        # Typically implemented by subclass\n        pass\n\n    def get_sub_alpha(self, alpha: float, index: int, num_submobjects: int) -> float:\n        \"\"\"Get the animation progress of any submobjects subanimation.\n\n        Parameters\n        ----------\n        alpha\n            The overall animation progress\n        index\n            The index of the subanimation.\n        num_submobjects\n            The total count of subanimations.\n\n        Returns\n        -------\n        float\n            The progress of the subanimation.\n        \"\"\"\n        # TODO, make this more understandable, and/or combine\n        # its functionality with AnimationGroup's method\n        # build_animations_with_timings\n        lag_ratio = self.lag_ratio\n        full_length = (num_submobjects - 1) * lag_ratio + 1\n        value = alpha * full_length\n        lower = index * lag_ratio\n        if self.reverse_rate_function:\n            return self.rate_func(1 - (value - lower))\n        else:\n            return self.rate_func(value - lower)\n\n    # Getters and setters\n    def set_run_time(self, run_time: float) -> Animation:\n        \"\"\"Set the run time of the animation.\n\n        Parameters\n        ----------\n        run_time\n            The new time the animation should take in seconds.\n\n        .. note::\n\n            The run_time of an animation should not be changed while it is already\n            running.\n\n        Returns\n        -------\n        Animation\n            ``self``\n        \"\"\"\n        self.run_time = run_time\n        return self\n\n    # TODO: is this getter even necessary?\n    def get_run_time(self) -> float:\n        \"\"\"Get the run time of the animation.\n\n        Returns\n        -------\n        float\n            The time the animation takes in seconds.\n        \"\"\"\n        return self.run_time\n\n    def set_rate_func(\n        self,\n        rate_func: Callable[[float], float],\n    ) -> Animation:\n        \"\"\"Set the rate function of the animation.\n\n        Parameters\n        ----------\n        rate_func\n            The new function defining the animation progress based on the\n            relative runtime (see :mod:`~.rate_functions`).\n\n        Returns\n        -------\n        Animation\n            ``self``\n        \"\"\"\n        self.rate_func = rate_func\n        return self\n\n    def get_rate_func(\n        self,\n    ) -> Callable[[float], float]:\n        \"\"\"Get the rate function of the animation.\n\n        Returns\n        -------\n        Callable[[float], float]\n            The rate function of the animation.\n        \"\"\"\n        return self.rate_func\n\n    def set_name(self, name: str) -> Animation:\n        \"\"\"Set the name of the animation.\n\n        Parameters\n        ----------\n        name\n            The new name of the animation.\n\n        Returns\n        -------\n        Animation\n            ``self``\n        \"\"\"\n        self.name = name\n        return self\n\n    def is_remover(self) -> bool:\n        \"\"\"Test if the animation is a remover.\n\n        Returns\n        -------\n        bool\n            ``True`` if the animation is a remover, ``False`` otherwise.\n        \"\"\"\n        return self.remover\n\n    def is_introducer(self) -> bool:\n        \"\"\"Test if the animation is an introducer.\n\n        Returns\n        -------\n        bool\n            ``True`` if the animation is an introducer, ``False`` otherwise.\n        \"\"\"\n        return self.introducer\n\n    @classmethod\n    def __init_subclass__(cls, **kwargs) -> None:\n        super().__init_subclass__(**kwargs)\n\n        cls._original__init__ = cls.__init__\n\n    _original__init__ = __init__  # needed if set_default() is called with no kwargs directly from Animation\n\n    @classmethod\n    def set_default(cls, **kwargs) -> None:\n        \"\"\"Sets the default values of keyword arguments.\n\n        If this method is called without any additional keyword\n        arguments, the original default values of the initialization\n        method of this class are restored.\n\n        Parameters\n        ----------\n\n        kwargs\n            Passing any keyword argument will update the default\n            values of the keyword arguments of the initialization\n            function of this class.\n\n        Examples\n        --------\n\n        .. manim:: ChangeDefaultAnimation\n\n            class ChangeDefaultAnimation(Scene):\n                def construct(self):\n                    Rotate.set_default(run_time=2, rate_func=rate_functions.linear)\n                    Indicate.set_default(color=None)\n\n                    S = Square(color=BLUE, fill_color=BLUE, fill_opacity=0.25)\n                    self.add(S)\n                    self.play(Rotate(S, PI))\n                    self.play(Indicate(S))\n\n                    Rotate.set_default()\n                    Indicate.set_default()\n\n        \"\"\"\n        if kwargs:\n            cls.__init__ = partialmethod(cls.__init__, **kwargs)\n        else:\n            cls.__init__ = cls._original__init__"}, {"name": "AnimationGroup", "code": "class AnimationGroup(Animation):\n    \"\"\"Plays a group or series of :class:`~.Animation`.\n\n    Parameters\n    ----------\n    animations\n        Sequence of :class:`~.Animation` objects to be played.\n    group\n        A group of multiple :class:`~.Mobject`.\n    run_time\n        The duration of the animation in seconds.\n    rate_func\n        The function defining the animation progress based on the relative\n        runtime (see :mod:`~.rate_functions`) .\n    lag_ratio\n        Defines the delay after which the animation is applied to submobjects. A lag_ratio of\n        ``n.nn`` means the next animation will play when ``nnn%`` of the current animation has played.\n        Defaults to 0.0, meaning that all animations will be played together.\n\n        This does not influence the total runtime of the animation. Instead the runtime\n        of individual animations is adjusted so that the complete animation has the defined\n        run time.\n    \"\"\"\n\n    def __init__(\n        self,\n        *animations: Animation | Iterable[Animation] | types.GeneratorType[Animation],\n        group: Group | VGroup | OpenGLGroup | OpenGLVGroup = None,\n        run_time: float | None = None,\n        rate_func: Callable[[float], float] = linear,\n        lag_ratio: float = 0,\n        **kwargs,\n    ) -> None:\n        arg_anim = flatten_iterable_parameters(animations)\n        self.animations = [prepare_animation(anim) for anim in arg_anim]\n        self.rate_func = rate_func\n        self.group = group\n        if self.group is None:\n            mobjects = remove_list_redundancies(\n                [anim.mobject for anim in self.animations if not anim.is_introducer()],\n            )\n            if config[\"renderer\"] == RendererType.OPENGL:\n                self.group = OpenGLGroup(*mobjects)\n            else:\n                self.group = Group(*mobjects)\n        super().__init__(\n            self.group, rate_func=self.rate_func, lag_ratio=lag_ratio, **kwargs\n        )\n        self.run_time: float = self.init_run_time(run_time)\n\n    def get_all_mobjects(self) -> Sequence[Mobject]:\n        return list(self.group)\n\n    def begin(self) -> None:\n        if not self.animations:\n            raise ValueError(\n                f\"Trying to play {self} without animations, this is not supported. \"\n                \"Please add at least one subanimation.\"\n            )\n        self.anim_group_time = 0.0\n        if self.suspend_mobject_updating:\n            self.group.suspend_updating()\n        for anim in self.animations:\n            anim.begin()\n\n    def _setup_scene(self, scene) -> None:\n        for anim in self.animations:\n            anim._setup_scene(scene)\n\n    def finish(self) -> None:\n        for anim in self.animations:\n            anim.finish()\n        self.anims_begun[:] = True\n        self.anims_finished[:] = True\n        if self.suspend_mobject_updating:\n            self.group.resume_updating()\n\n    def clean_up_from_scene(self, scene: Scene) -> None:\n        self._on_finish(scene)\n        for anim in self.animations:\n            if self.remover:\n                anim.remover = self.remover\n            anim.clean_up_from_scene(scene)\n\n    def update_mobjects(self, dt: float) -> None:\n        for anim in self.anims_with_timings[\"anim\"][\n            self.anims_begun & ~self.anims_finished\n        ]:\n            anim.update_mobjects(dt)\n\n    def init_run_time(self, run_time) -> float:\n        \"\"\"Calculates the run time of the animation, if different from ``run_time``.\n\n        Parameters\n        ----------\n        run_time\n            The duration of the animation in seconds.\n\n        Returns\n        -------\n        run_time\n            The duration of the animation in seconds.\n        \"\"\"\n        self.build_animations_with_timings()\n        # Note: if lag_ratio < 1, then not necessarily the final animation's\n        # end time will be the max end time! Therefore we must calculate the\n        # maximum over all the end times, and not just take the last one.\n        # Example: if you want to play 2 animations of 10s and 1s with a\n        # lag_ratio of 0.1, the 1st one will end at t=10 and the 2nd one will\n        # end at t=2, so the AnimationGroup will end at t=10.\n        self.max_end_time = max(self.anims_with_timings[\"end\"], default=0)\n        return self.max_end_time if run_time is None else run_time\n\n    def build_animations_with_timings(self) -> None:\n        \"\"\"Creates a list of triplets of the form (anim, start_time, end_time).\"\"\"\n        run_times = np.array([anim.run_time for anim in self.animations])\n        num_animations = run_times.shape[0]\n        dtype = [(\"anim\", \"O\"), (\"start\", \"f8\"), (\"end\", \"f8\")]\n        self.anims_with_timings = np.zeros(num_animations, dtype=dtype)\n        self.anims_begun = np.zeros(num_animations, dtype=bool)\n        self.anims_finished = np.zeros(num_animations, dtype=bool)\n        if num_animations == 0:\n            return\n\n        lags = run_times[:-1] * self.lag_ratio\n        self.anims_with_timings[\"anim\"] = self.animations\n        self.anims_with_timings[\"start\"][1:] = np.add.accumulate(lags)\n        self.anims_with_timings[\"end\"] = self.anims_with_timings[\"start\"] + run_times\n\n    def interpolate(self, alpha: float) -> None:\n        # Note, if the run_time of AnimationGroup has been\n        # set to something other than its default, these\n        # times might not correspond to actual times,\n        # e.g. of the surrounding scene.  Instead they'd\n        # be a rescaled version.  But that's okay!\n        anim_group_time = self.rate_func(alpha) * self.max_end_time\n        time_goes_back = anim_group_time < self.anim_group_time\n\n        # Only update ongoing animations\n        awt = self.anims_with_timings\n        new_begun = anim_group_time >= awt[\"start\"]\n        new_finished = anim_group_time > awt[\"end\"]\n        to_update = awt[\n            (self.anims_begun | new_begun) & (~self.anims_finished | ~new_finished)\n        ]\n\n        run_times = to_update[\"end\"] - to_update[\"start\"]\n        with_zero_run_time = run_times == 0\n        run_times[with_zero_run_time] = 1\n        sub_alphas = (anim_group_time - to_update[\"start\"]) / run_times\n        if time_goes_back:\n            sub_alphas[(sub_alphas < 0) | with_zero_run_time] = 0\n        else:\n            sub_alphas[(sub_alphas > 1) | with_zero_run_time] = 1\n\n        for anim_to_update, sub_alpha in zip(to_update[\"anim\"], sub_alphas):\n            anim_to_update.interpolate(sub_alpha)\n\n        self.anim_group_time = anim_group_time\n        self.anims_begun = new_begun\n        self.anims_finished = new_finished"}, {"name": "AnnotationDot", "code": "class AnnotationDot(Dot):\n    \"\"\"A dot with bigger radius and bold stroke to annotate scenes.\"\"\"\n\n    def __init__(\n        self,\n        radius: float = DEFAULT_DOT_RADIUS * 1.3,\n        stroke_width: float = 5,\n        stroke_color: ParsableManimColor = WHITE,\n        fill_color: ParsableManimColor = BLUE,\n        **kwargs: Any,\n    ) -> None:\n        super().__init__(\n            radius=radius,\n            stroke_width=stroke_width,\n            stroke_color=stroke_color,\n            fill_color=fill_color,\n            **kwargs,\n        )"}, {"name": "AnnularSector", "code": "class AnnularSector(Arc):\n    \"\"\"A sector of an annulus.\n\n\n    Parameters\n    ----------\n    inner_radius\n       The inside radius of the Annular Sector.\n    outer_radius\n       The outside radius of the Annular Sector.\n    angle\n       The clockwise angle of the Annular Sector.\n    start_angle\n       The starting clockwise angle of the Annular Sector.\n    fill_opacity\n       The opacity of the color filled in the Annular Sector.\n    stroke_width\n       The stroke width of the Annular Sector.\n    color\n       The color filled into the Annular Sector.\n\n    Examples\n    --------\n    .. manim:: AnnularSectorExample\n        :save_last_frame:\n\n        class AnnularSectorExample(Scene):\n            def construct(self):\n                # Changes background color to clearly visualize changes in fill_opacity.\n                self.camera.background_color = WHITE\n\n                # The default parameter start_angle is 0, so the AnnularSector starts from the +x-axis.\n                s1 = AnnularSector(color=YELLOW).move_to(2 * UL)\n\n                # Different inner_radius and outer_radius than the default.\n                s2 = AnnularSector(inner_radius=1.5, outer_radius=2, angle=45 * DEGREES, color=RED).move_to(2 * UR)\n\n                # fill_opacity is typically a number > 0 and <= 1. If fill_opacity=0, the AnnularSector is transparent.\n                s3 = AnnularSector(inner_radius=1, outer_radius=1.5, angle=PI, fill_opacity=0.25, color=BLUE).move_to(2 * DL)\n\n                # With a negative value for the angle, the AnnularSector is drawn clockwise from the start value.\n                s4 = AnnularSector(inner_radius=1, outer_radius=1.5, angle=-3 * PI / 2, color=GREEN).move_to(2 * DR)\n\n                self.add(s1, s2, s3, s4)\n    \"\"\"\n\n    def __init__(\n        self,\n        inner_radius: float = 1,\n        outer_radius: float = 2,\n        angle: float = TAU / 4,\n        start_angle: float = 0,\n        fill_opacity: float = 1,\n        stroke_width: float = 0,\n        color: ParsableManimColor = WHITE,\n        **kwargs: Any,\n    ) -> None:\n        self.inner_radius = inner_radius\n        self.outer_radius = outer_radius\n        super().__init__(\n            start_angle=start_angle,\n            angle=angle,\n            fill_opacity=fill_opacity,\n            stroke_width=stroke_width,\n            color=color,\n            **kwargs,\n        )\n\n    def generate_points(self) -> None:\n        inner_arc, outer_arc = (\n            Arc(\n                start_angle=self.start_angle,\n                angle=self.angle,\n                radius=radius,\n                arc_center=self.arc_center,\n            )\n            for radius in (self.inner_radius, self.outer_radius)\n        )\n        outer_arc.reverse_points()\n        self.append_points(inner_arc.points)\n        self.add_line_to(outer_arc.points[0])\n        self.append_points(outer_arc.points)\n        self.add_line_to(inner_arc.points[0])\n\n    init_points = generate_points"}, {"name": "Annulus", "code": "class Annulus(Circle):\n    \"\"\"Region between two concentric :class:`Circles <.Circle>`.\n\n    Parameters\n    ----------\n    inner_radius\n        The radius of the inner :class:`Circle`.\n    outer_radius\n        The radius of the outer :class:`Circle`.\n    kwargs\n        Additional arguments to be passed to :class:`Annulus`\n\n    Examples\n    --------\n    .. manim:: AnnulusExample\n        :save_last_frame:\n\n        class AnnulusExample(Scene):\n            def construct(self):\n                annulus_1 = Annulus(inner_radius=0.5, outer_radius=1).shift(UP)\n                annulus_2 = Annulus(inner_radius=0.3, outer_radius=0.6, color=RED).next_to(annulus_1, DOWN)\n                self.add(annulus_1, annulus_2)\n    \"\"\"\n\n    def __init__(\n        self,\n        inner_radius: float = 1,\n        outer_radius: float = 2,\n        fill_opacity: float = 1,\n        stroke_width: float = 0,\n        color: ParsableManimColor = WHITE,\n        mark_paths_closed: bool = False,\n        **kwargs: Any,\n    ) -> None:\n        self.mark_paths_closed = mark_paths_closed  # is this even used?\n        self.inner_radius = inner_radius\n        self.outer_radius = outer_radius\n        super().__init__(\n            fill_opacity=fill_opacity, stroke_width=stroke_width, color=color, **kwargs\n        )\n\n    def generate_points(self) -> None:\n        self.radius = self.outer_radius\n        outer_circle = Circle(radius=self.outer_radius)\n        inner_circle = Circle(radius=self.inner_radius)\n        inner_circle.reverse_points()\n        self.append_points(outer_circle.points)\n        self.append_points(inner_circle.points)\n        self.shift(self.arc_center)\n\n    init_points = generate_points"}, {"name": "ApplyComplexFunction", "code": "class ApplyComplexFunction(ApplyMethod):\n    def __init__(self, function: types.MethodType, mobject: Mobject, **kwargs) -> None:\n        self.function = function\n        method = mobject.apply_complex_function\n        super().__init__(method, function, **kwargs)\n\n    def _init_path_func(self) -> None:\n        func1 = self.function(complex(1))\n        self.path_arc = np.log(func1).imag\n        super()._init_path_func()"}, {"name": "ApplyFunction", "code": "class ApplyFunction(Transform):\n    def __init__(self, function: types.MethodType, mobject: Mobject, **kwargs) -> None:\n        self.function = function\n        super().__init__(mobject, **kwargs)\n\n    def create_target(self) -> Any:\n        target = self.function(self.mobject.copy())\n        if not isinstance(target, (Mobject, OpenGLMobject)):\n            raise TypeError(\n                \"Functions passed to ApplyFunction must return object of type Mobject\",\n            )\n        return target"}, {"name": "ApplyMatrix", "code": "class ApplyMatrix(ApplyPointwiseFunction):\n    \"\"\"Applies a matrix transform to an mobject.\n\n    Parameters\n    ----------\n    matrix\n        The transformation matrix.\n    mobject\n        The :class:`~.Mobject`.\n    about_point\n        The origin point for the transform. Defaults to ``ORIGIN``.\n    kwargs\n        Further keyword arguments that are passed to :class:`ApplyPointwiseFunction`.\n\n    Examples\n    --------\n\n    .. manim:: ApplyMatrixExample\n\n        class ApplyMatrixExample(Scene):\n            def construct(self):\n                matrix = [[1, 1], [0, 2/3]]\n                self.play(ApplyMatrix(matrix, Text(\"Hello World!\")), ApplyMatrix(matrix, NumberPlane()))\n\n    \"\"\"\n\n    def __init__(\n        self,\n        matrix: np.ndarray,\n        mobject: Mobject,\n        about_point: np.ndarray = ORIGIN,\n        **kwargs,\n    ) -> None:\n        matrix = self.initialize_matrix(matrix)\n\n        def func(p):\n            return np.dot(p - about_point, matrix.T) + about_point\n\n        super().__init__(func, mobject, **kwargs)\n\n    def initialize_matrix(self, matrix: np.ndarray) -> np.ndarray:\n        matrix = np.array(matrix)\n        if matrix.shape == (2, 2):\n            new_matrix = np.identity(3)\n            new_matrix[:2, :2] = matrix\n            matrix = new_matrix\n        elif matrix.shape != (3, 3):\n            raise ValueError(\"Matrix has bad dimensions\")\n        return matrix"}, {"name": "ApplyMethod", "code": "class ApplyMethod(Transform):\n    \"\"\"Animates a mobject by applying a method.\n\n    Note that only the method needs to be passed to this animation,\n    it is not required to pass the corresponding mobject. Furthermore,\n    this animation class only works if the method returns the modified\n    mobject.\n\n    Parameters\n    ----------\n    method\n        The method that will be applied in the animation.\n    args\n        Any positional arguments to be passed when applying the method.\n    kwargs\n        Any keyword arguments passed to :class:`~.Transform`.\n\n    \"\"\"\n\n    def __init__(\n        self, method: Callable, *args, **kwargs\n    ) -> None:  # method typing (we want to specify Mobject method)? for args?\n        self.check_validity_of_input(method)\n        self.method = method\n        self.method_args = args\n        super().__init__(method.__self__, **kwargs)\n\n    def check_validity_of_input(self, method: Callable) -> None:\n        if not inspect.ismethod(method):\n            raise ValueError(\n                \"Whoops, looks like you accidentally invoked \"\n                \"the method you want to animate\",\n            )\n        assert isinstance(method.__self__, (Mobject, OpenGLMobject))\n\n    def create_target(self) -> Mobject:\n        method = self.method\n        # Make sure it's a list so that args.pop() works\n        args = list(self.method_args)\n\n        if len(args) > 0 and isinstance(args[-1], dict):\n            method_kwargs = args.pop()\n        else:\n            method_kwargs = {}\n        target = method.__self__.copy()\n        method.__func__(target, *args, **method_kwargs)\n        return target"}, {"name": "ApplyPointwiseFunction", "code": "class ApplyPointwiseFunction(ApplyMethod):\n    \"\"\"Animation that applies a pointwise function to a mobject.\n\n    Examples\n    --------\n\n    .. manim:: WarpSquare\n        :quality: low\n\n        class WarpSquare(Scene):\n            def construct(self):\n                square = Square()\n                self.play(\n                    ApplyPointwiseFunction(\n                        lambda point: complex_to_R3(np.exp(R3_to_complex(point))), square\n                    )\n                )\n                self.wait()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        function: types.MethodType,\n        mobject: Mobject,\n        run_time: float = DEFAULT_POINTWISE_FUNCTION_RUN_TIME,\n        **kwargs,\n    ) -> None:\n        super().__init__(mobject.apply_function, function, run_time=run_time, **kwargs)"}, {"name": "ApplyPointwiseFunctionToCenter", "code": "class ApplyPointwiseFunctionToCenter(ApplyPointwiseFunction):\n    def __init__(self, function: types.MethodType, mobject: Mobject, **kwargs) -> None:\n        self.function = function\n        super().__init__(mobject.move_to, **kwargs)\n\n    def begin(self) -> None:\n        self.method_args = [self.function(self.mobject.get_center())]\n        super().begin()"}, {"name": "ApplyWave", "code": "class ApplyWave(Homotopy):\n    \"\"\"Send a wave through the Mobject distorting it temporarily.\n\n    Parameters\n    ----------\n    mobject\n        The mobject to be distorted.\n    direction\n        The direction in which the wave nudges points of the shape\n    amplitude\n        The distance points of the shape get shifted\n    wave_func\n        The function defining the shape of one wave flank.\n    time_width\n        The length of the wave relative to the width of the mobject.\n    ripples\n        The number of ripples of the wave\n    run_time\n        The duration of the animation.\n\n    Examples\n    --------\n\n    .. manim:: ApplyingWaves\n\n        class ApplyingWaves(Scene):\n            def construct(self):\n                tex = Tex(\"WaveWaveWaveWaveWave\").scale(2)\n                self.play(ApplyWave(tex))\n                self.play(ApplyWave(\n                    tex,\n                    direction=RIGHT,\n                    time_width=0.5,\n                    amplitude=0.3\n                ))\n                self.play(ApplyWave(\n                    tex,\n                    rate_func=linear,\n                    ripples=4\n                ))\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        direction: np.ndarray = UP,\n        amplitude: float = 0.2,\n        wave_func: Callable[[float], float] = smooth,\n        time_width: float = 1,\n        ripples: int = 1,\n        run_time: float = 2,\n        **kwargs,\n    ) -> None:\n        x_min = mobject.get_left()[0]\n        x_max = mobject.get_right()[0]\n        vect = amplitude * normalize(direction)\n\n        def wave(t):\n            # Creates a wave with n ripples from a simple rate_func\n            # This wave is build up as follows:\n            # The time is split into 2*ripples phases. In every phase the amplitude\n            # either rises to one or goes down to zero. Consecutive ripples will have\n            # their amplitudes in opposing directions (first ripple from 0 to 1 to 0,\n            # second from 0 to -1 to 0 and so on). This is how two ripples would be\n            # divided into phases:\n\n            #         ####|####        |            |\n            #       ##    |    ##      |            |\n            #     ##      |      ##    |            |\n            # ####        |        ####|####        |        ####\n            #             |            |    ##      |      ##\n            #             |            |      ##    |    ##\n            #             |            |        ####|####\n\n            # However, this looks weird in the middle between two ripples. Therefore the\n            # middle phases do actually use only one appropriately scaled version of the\n            # rate like this:\n\n            # 1 / 4 Time  | 2 / 4 Time            | 1 / 4 Time\n            #         ####|######                 |\n            #       ##    |      ###              |\n            #     ##      |         ##            |\n            # ####        |           #           |        ####\n            #             |            ##         |      ##\n            #             |              ###      |    ##\n            #             |                 ######|####\n\n            # Mirrored looks better in the way the wave is used.\n            t = 1 - t\n\n            # Clamp input\n            if t >= 1 or t <= 0:\n                return 0\n\n            phases = ripples * 2\n            phase = int(t * phases)\n            if phase == 0:\n                # First rising ripple\n                return wave_func(t * phases)\n            elif phase == phases - 1:\n                # last ripple. Rising or falling depending on the number of ripples\n                # The (ripples % 2)-term is used to make this distinction.\n                t -= phase / phases  # Time relative to the phase\n                return (1 - wave_func(t * phases)) * (2 * (ripples % 2) - 1)\n            else:\n                # Longer phases:\n                phase = int((phase - 1) / 2)\n                t -= (2 * phase + 1) / phases\n\n                # Similar to last ripple:\n                return (1 - 2 * wave_func(t * ripples)) * (1 - 2 * ((phase) % 2))\n\n        def homotopy(\n            x: float,\n            y: float,\n            z: float,\n            t: float,\n        ) -> tuple[float, float, float]:\n            upper = interpolate(0, 1 + time_width, t)\n            lower = upper - time_width\n            relative_x = inverse_interpolate(x_min, x_max, x)\n            wave_phase = inverse_interpolate(lower, upper, relative_x)\n            nudge = wave(wave_phase) * vect\n            return np.array([x, y, z]) + nudge\n\n        super().__init__(homotopy, mobject, run_time=run_time, **kwargs)"}, {"name": "Arc", "code": "class Arc(TipableVMobject):\n    \"\"\"A circular arc.\n\n    Examples\n    --------\n    A simple arc of angle Pi.\n\n    .. manim:: ArcExample\n        :save_last_frame:\n\n        class ArcExample(Scene):\n            def construct(self):\n                self.add(Arc(angle=PI))\n    \"\"\"\n\n    def __init__(\n        self,\n        radius: float | None = 1.0,\n        start_angle: float = 0,\n        angle: float = TAU / 4,\n        num_components: int = 9,\n        arc_center: Point3DLike = ORIGIN,\n        **kwargs: Any,\n    ):\n        if radius is None:  # apparently None is passed by ArcBetweenPoints\n            radius = 1.0\n        self.radius = radius\n        self.num_components = num_components\n        self.arc_center: Point3D = np.asarray(arc_center)\n        self.start_angle = start_angle\n        self.angle = angle\n        self._failed_to_get_center: bool = False\n        super().__init__(**kwargs)\n\n    def generate_points(self) -> None:\n        self._set_pre_positioned_points()\n        self.scale(self.radius, about_point=ORIGIN)\n        self.shift(self.arc_center)\n\n    # Points are set a bit differently when rendering via OpenGL.\n    # TODO: refactor Arc so that only one strategy for setting points\n    # has to be used.\n    def init_points(self) -> None:\n        self.set_points(\n            Arc._create_quadratic_bezier_points(\n                angle=self.angle,\n                start_angle=self.start_angle,\n                n_components=self.num_components,\n            ),\n        )\n        self.scale(self.radius, about_point=ORIGIN)\n        self.shift(self.arc_center)\n\n    @staticmethod\n    def _create_quadratic_bezier_points(\n        angle: float, start_angle: float = 0, n_components: int = 8\n    ) -> QuadraticSpline:\n        samples = np.array(\n            [\n                [np.cos(a), np.sin(a), 0]\n                for a in np.linspace(\n                    start_angle,\n                    start_angle + angle,\n                    2 * n_components + 1,\n                )\n            ],\n        )\n        theta = angle / n_components\n        samples[1::2] /= np.cos(theta / 2)\n\n        points = np.zeros((3 * n_components, 3))\n        points[0::3] = samples[0:-1:2]\n        points[1::3] = samples[1::2]\n        points[2::3] = samples[2::2]\n        return points\n\n    def _set_pre_positioned_points(self) -> None:\n        anchors = np.array(\n            [\n                np.cos(a) * RIGHT + np.sin(a) * UP\n                for a in np.linspace(\n                    self.start_angle,\n                    self.start_angle + self.angle,\n                    self.num_components,\n                )\n            ],\n        )\n        # Figure out which control points will give the\n        # Appropriate tangent lines to the circle\n        d_theta = self.angle / (self.num_components - 1.0)\n        tangent_vectors = np.zeros(anchors.shape)\n        # Rotate all 90 degrees, via (x, y) -> (-y, x)\n        tangent_vectors[:, 1] = anchors[:, 0]\n        tangent_vectors[:, 0] = -anchors[:, 1]\n        # Use tangent vectors to deduce anchors\n        factor = 4 / 3 * np.tan(d_theta / 4)\n        handles1 = anchors[:-1] + factor * tangent_vectors[:-1]\n        handles2 = anchors[1:] - factor * tangent_vectors[1:]\n        self.set_anchors_and_handles(anchors[:-1], handles1, handles2, anchors[1:])\n\n    def get_arc_center(self, warning: bool = True) -> Point3D:\n        \"\"\"Looks at the normals to the first two\n        anchors, and finds their intersection points\n        \"\"\"\n        # First two anchors and handles\n        a1, h1, h2, a2 = self.points[:4]\n\n        if np.all(a1 == a2):\n            # For a1 and a2 to lie at the same point arc radius\n            # must be zero. Thus arc_center will also lie at\n            # that point.\n            return np.copy(a1)\n        # Tangent vectors\n        t1 = h1 - a1\n        t2 = h2 - a2\n        # Normals\n        n1 = rotate_vector(t1, TAU / 4)\n        n2 = rotate_vector(t2, TAU / 4)\n        try:\n            return line_intersection(line1=(a1, a1 + n1), line2=(a2, a2 + n2))\n        except Exception:\n            if warning:\n                warnings.warn(\n                    \"Can't find Arc center, using ORIGIN instead\", stacklevel=1\n                )\n            self._failed_to_get_center = True\n            return np.array(ORIGIN)\n\n    def move_arc_center_to(self, point: Point3DLike) -> Self:\n        self.shift(point - self.get_arc_center())\n        return self\n\n    def stop_angle(self) -> float:\n        return cast(\n            float,\n            angle_of_vector(self.points[-1] - self.get_arc_center()) % TAU,\n        )"}, {"name": "ArcBetweenPoints", "code": "class ArcBetweenPoints(Arc):\n    \"\"\"Inherits from Arc and additionally takes 2 points between which the arc is spanned.\n\n    Example\n    -------\n    .. manim:: ArcBetweenPointsExample\n\n      class ArcBetweenPointsExample(Scene):\n          def construct(self):\n              circle = Circle(radius=2, stroke_color=GREY)\n              dot_1 = Dot(color=GREEN).move_to([2, 0, 0]).scale(0.5)\n              dot_1_text = Tex(\"(2,0)\").scale(0.5).next_to(dot_1, RIGHT).set_color(BLUE)\n              dot_2 = Dot(color=GREEN).move_to([0, 2, 0]).scale(0.5)\n              dot_2_text = Tex(\"(0,2)\").scale(0.5).next_to(dot_2, UP).set_color(BLUE)\n              arc= ArcBetweenPoints(start=2 * RIGHT, end=2 * UP, stroke_color=YELLOW)\n              self.add(circle, dot_1, dot_2, dot_1_text, dot_2_text)\n              self.play(Create(arc))\n    \"\"\"\n\n    def __init__(\n        self,\n        start: Point3DLike,\n        end: Point3DLike,\n        angle: float = TAU / 4,\n        radius: float | None = None,\n        **kwargs: Any,\n    ) -> None:\n        if radius is not None:\n            self.radius = radius\n            if radius < 0:\n                sign = -2\n                radius *= -1\n            else:\n                sign = 2\n            halfdist = np.linalg.norm(np.array(start) - np.array(end)) / 2\n            if radius < halfdist:\n                raise ValueError(\n                    \"\"\"ArcBetweenPoints called with a radius that is\n                            smaller than half the distance between the points.\"\"\",\n                )\n            arc_height = radius - np.sqrt(radius**2 - halfdist**2)\n            angle = np.arccos((radius - arc_height) / radius) * sign\n\n        super().__init__(radius=radius, angle=angle, **kwargs)\n        if angle == 0:\n            self.set_points_as_corners(np.array([LEFT, RIGHT]))\n        self.put_start_and_end_on(start, end)\n\n        if radius is None:\n            center = self.get_arc_center(warning=False)\n            if not self._failed_to_get_center:\n                # np.linalg.norm returns floating[Any] which is not compatible with float\n                self.radius = cast(\n                    float, np.linalg.norm(np.array(start) - np.array(center))\n                )\n            else:\n                self.radius = np.inf"}, {"name": "ArcBrace", "code": "class ArcBrace(Brace):\n    \"\"\"Creates a :class:`~Brace` that wraps around an :class:`~.Arc`.\n\n    The direction parameter allows the brace to be applied\n    from outside or inside the arc.\n\n    .. warning::\n        The :class:`ArcBrace` is smaller for arcs with smaller radii.\n\n    .. note::\n        The :class:`ArcBrace` is initially a vertical :class:`Brace` defined by the\n        length of the :class:`~.Arc`, but is scaled down to match the start and end\n        angles. An exponential function is then applied after it is shifted based on\n        the radius of the arc.\n\n        The scaling effect is not applied for arcs with radii smaller than 1 to prevent\n        over-scaling.\n\n    Parameters\n    ----------\n    arc\n        The :class:`~.Arc` that wraps around the :class:`Brace` mobject.\n    direction\n        The direction from which the brace faces the arc.\n        ``LEFT`` for inside the arc, and ``RIGHT`` for the outside.\n\n    Example\n    -------\n        .. manim:: ArcBraceExample\n            :save_last_frame:\n            :ref_classes: Arc\n\n            class ArcBraceExample(Scene):\n                def construct(self):\n                    arc_1 = Arc(radius=1.5,start_angle=0,angle=2*PI/3).set_color(RED)\n                    brace_1 = ArcBrace(arc_1,LEFT)\n                    group_1 = VGroup(arc_1,brace_1)\n\n                    arc_2 = Arc(radius=3,start_angle=0,angle=5*PI/6).set_color(YELLOW)\n                    brace_2 = ArcBrace(arc_2)\n                    group_2 = VGroup(arc_2,brace_2)\n\n                    arc_3 = Arc(radius=0.5,start_angle=-0,angle=PI).set_color(BLUE)\n                    brace_3 = ArcBrace(arc_3)\n                    group_3 = VGroup(arc_3,brace_3)\n\n                    arc_4 = Arc(radius=0.2,start_angle=0,angle=3*PI/2).set_color(GREEN)\n                    brace_4 = ArcBrace(arc_4)\n                    group_4 = VGroup(arc_4,brace_4)\n\n                    arc_group = VGroup(group_1, group_2, group_3, group_4).arrange_in_grid(buff=1.5)\n                    self.add(arc_group.center())\n\n    \"\"\"\n\n    def __init__(\n        self,\n        arc: Arc | None = None,\n        direction: Sequence[float] = RIGHT,\n        **kwargs,\n    ):\n        if arc is None:\n            arc = Arc(start_angle=-1, angle=2, radius=1)\n        arc_end_angle = arc.start_angle + arc.angle\n        line = Line(UP * arc.start_angle, UP * arc_end_angle)\n        scale_shift = RIGHT * np.log(arc.radius)\n\n        if arc.radius >= 1:\n            line.scale(arc.radius, about_point=ORIGIN)\n            super().__init__(line, direction=direction, **kwargs)\n            self.scale(1 / (arc.radius), about_point=ORIGIN)\n        else:\n            super().__init__(line, direction=direction, **kwargs)\n\n        if arc.radius >= 0.3:\n            self.shift(scale_shift)\n        else:\n            self.shift(RIGHT * np.log(0.3))\n\n        self.apply_complex_function(np.exp)\n        self.shift(arc.get_arc_center())"}, {"name": "ArcPolygon", "code": "class ArcPolygon(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A generalized polygon allowing for points to be connected with arcs.\n\n    This version tries to stick close to the way :class:`Polygon` is used. Points\n    can be passed to it directly which are used to generate the according arcs\n    (using :class:`ArcBetweenPoints`). An angle or radius can be passed to it to\n    use across all arcs, but to configure arcs individually an ``arc_config`` list\n    has to be passed with the syntax explained below.\n\n    Parameters\n    ----------\n    vertices\n        A list of vertices, start and end points for the arc segments.\n    angle\n        The angle used for constructing the arcs. If no other parameters\n        are set, this angle is used to construct all arcs.\n    radius\n        The circle radius used to construct the arcs. If specified,\n        overrides the specified ``angle``.\n    arc_config\n        When passing a ``dict``, its content will be passed as keyword\n        arguments to :class:`~.ArcBetweenPoints`. Otherwise, a list\n        of dictionaries containing values that are passed as keyword\n        arguments for every individual arc can be passed.\n    kwargs\n        Further keyword arguments that are passed to the constructor of\n        :class:`~.VMobject`.\n\n    Attributes\n    ----------\n    arcs : :class:`list`\n        The arcs created from the input parameters::\n\n            >>> from manim import ArcPolygon\n            >>> ap = ArcPolygon([0, 0, 0], [2, 0, 0], [0, 2, 0])\n            >>> ap.arcs\n            [ArcBetweenPoints, ArcBetweenPoints, ArcBetweenPoints]\n\n\n    .. tip::\n\n        Two instances of :class:`ArcPolygon` can be transformed properly into one\n        another as well. Be advised that any arc initialized with ``angle=0``\n        will actually be a straight line, so if a straight section should seamlessly\n        transform into an arced section or vice versa, initialize the straight section\n        with a negligible angle instead (such as ``angle=0.0001``).\n\n    .. note::\n        There is an alternative version (:class:`ArcPolygonFromArcs`) that is instantiated\n        with pre-defined arcs.\n\n    See Also\n    --------\n    :class:`ArcPolygonFromArcs`\n\n\n    Examples\n    --------\n    .. manim:: SeveralArcPolygons\n\n        class SeveralArcPolygons(Scene):\n            def construct(self):\n                a = [0, 0, 0]\n                b = [2, 0, 0]\n                c = [0, 2, 0]\n                ap1 = ArcPolygon(a, b, c, radius=2)\n                ap2 = ArcPolygon(a, b, c, angle=45*DEGREES)\n                ap3 = ArcPolygon(a, b, c, arc_config={'radius': 1.7, 'color': RED})\n                ap4 = ArcPolygon(a, b, c, color=RED, fill_opacity=1,\n                                            arc_config=[{'radius': 1.7, 'color': RED},\n                                            {'angle': 20*DEGREES, 'color': BLUE},\n                                            {'radius': 1}])\n                ap_group = VGroup(ap1, ap2, ap3, ap4).arrange()\n                self.play(*[Create(ap) for ap in [ap1, ap2, ap3, ap4]])\n                self.wait()\n\n    For further examples see :class:`ArcPolygonFromArcs`.\n    \"\"\"\n\n    def __init__(\n        self,\n        *vertices: Point3DLike,\n        angle: float = PI / 4,\n        radius: float | None = None,\n        arc_config: list[dict] | None = None,\n        **kwargs: Any,\n    ) -> None:\n        n = len(vertices)\n        point_pairs = [(vertices[k], vertices[(k + 1) % n]) for k in range(n)]\n\n        if not arc_config:\n            if radius:\n                all_arc_configs: Iterable[dict] = itertools.repeat(\n                    {\"radius\": radius}, len(point_pairs)\n                )\n            else:\n                all_arc_configs = itertools.repeat({\"angle\": angle}, len(point_pairs))\n        elif isinstance(arc_config, dict):\n            all_arc_configs = itertools.repeat(arc_config, len(point_pairs))\n        else:\n            assert len(arc_config) == n\n            all_arc_configs = arc_config\n\n        arcs = [\n            ArcBetweenPoints(*pair, **conf)\n            for (pair, conf) in zip(point_pairs, all_arc_configs)\n        ]\n\n        super().__init__(**kwargs)\n        # Adding the arcs like this makes ArcPolygon double as a VGroup.\n        # Also makes changes to the ArcPolygon, such as scaling, affect\n        # the arcs, so that their new values are usable.\n        self.add(*arcs)\n        for arc in arcs:\n            self.append_points(arc.points)\n\n        # This enables the use of ArcPolygon.arcs as a convenience\n        # because ArcPolygon[0] returns itself, not the first Arc.\n        self.arcs = arcs"}, {"name": "ArcPolygonFromArcs", "code": "class ArcPolygonFromArcs(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A generalized polygon allowing for points to be connected with arcs.\n\n    This version takes in pre-defined arcs to generate the arcpolygon and introduces\n    little new syntax. However unlike :class:`Polygon` it can't be created with points\n    directly.\n\n    For proper appearance the passed arcs should connect seamlessly:\n    ``[a,b][b,c][c,a]``\n\n    If there are any gaps between the arcs, those will be filled in\n    with straight lines, which can be used deliberately for any straight\n    sections. Arcs can also be passed as straight lines such as an arc\n    initialized with ``angle=0``.\n\n    Parameters\n    ----------\n    arcs\n        These are the arcs from which the arcpolygon is assembled.\n    kwargs\n        Keyword arguments that are passed to the constructor of\n        :class:`~.VMobject`. Affects how the ArcPolygon itself is drawn,\n        but doesn't affect passed arcs.\n\n    Attributes\n    ----------\n    arcs\n        The arcs used to initialize the ArcPolygonFromArcs::\n\n            >>> from manim import ArcPolygonFromArcs, Arc, ArcBetweenPoints\n            >>> ap = ArcPolygonFromArcs(Arc(), ArcBetweenPoints([1,0,0], [0,1,0]), Arc())\n            >>> ap.arcs\n            [Arc, ArcBetweenPoints, Arc]\n\n\n    .. tip::\n\n        Two instances of :class:`ArcPolygon` can be transformed properly into\n        one another as well. Be advised that any arc initialized with ``angle=0``\n        will actually be a straight line, so if a straight section should seamlessly\n        transform into an arced section or vice versa, initialize the straight\n        section with a negligible angle instead (such as ``angle=0.0001``).\n\n    .. note::\n        There is an alternative version (:class:`ArcPolygon`) that can be instantiated\n        with points.\n\n    .. seealso::\n        :class:`ArcPolygon`\n\n    Examples\n    --------\n    One example of an arcpolygon is the Reuleaux triangle.\n    Instead of 3 straight lines connecting the outer points,\n    a Reuleaux triangle has 3 arcs connecting those points,\n    making a shape with constant width.\n\n    Passed arcs are stored as submobjects in the arcpolygon.\n    This means that the arcs are changed along with the arcpolygon,\n    for example when it's shifted, and these arcs can be manipulated\n    after the arcpolygon has been initialized.\n\n    Also both the arcs contained in an :class:`~.ArcPolygonFromArcs`, as well as the\n    arcpolygon itself are drawn, which affects draw time in :class:`~.Create`\n    for example. In most cases the arcs themselves don't\n    need to be drawn, in which case they can be passed as invisible.\n\n    .. manim:: ArcPolygonExample\n\n        class ArcPolygonExample(Scene):\n            def construct(self):\n                arc_conf = {\"stroke_width\": 0}\n                poly_conf = {\"stroke_width\": 10, \"stroke_color\": BLUE,\n                      \"fill_opacity\": 1, \"color\": PURPLE}\n                a = [-1, 0, 0]\n                b = [1, 0, 0]\n                c = [0, np.sqrt(3), 0]\n                arc0 = ArcBetweenPoints(a, b, radius=2, **arc_conf)\n                arc1 = ArcBetweenPoints(b, c, radius=2, **arc_conf)\n                arc2 = ArcBetweenPoints(c, a, radius=2, **arc_conf)\n                reuleaux_tri = ArcPolygonFromArcs(arc0, arc1, arc2, **poly_conf)\n                self.play(FadeIn(reuleaux_tri))\n                self.wait(2)\n\n    The arcpolygon itself can also be hidden so that instead only the contained\n    arcs are drawn. This can be used to easily debug arcs or to highlight them.\n\n    .. manim:: ArcPolygonExample2\n\n        class ArcPolygonExample2(Scene):\n            def construct(self):\n                arc_conf = {\"stroke_width\": 3, \"stroke_color\": BLUE,\n                    \"fill_opacity\": 0.5, \"color\": GREEN}\n                poly_conf = {\"color\": None}\n                a = [-1, 0, 0]\n                b = [1, 0, 0]\n                c = [0, np.sqrt(3), 0]\n                arc0 = ArcBetweenPoints(a, b, radius=2, **arc_conf)\n                arc1 = ArcBetweenPoints(b, c, radius=2, **arc_conf)\n                arc2 = ArcBetweenPoints(c, a, radius=2, stroke_color=RED)\n                reuleaux_tri = ArcPolygonFromArcs(arc0, arc1, arc2, **poly_conf)\n                self.play(FadeIn(reuleaux_tri))\n                self.wait(2)\n    \"\"\"\n\n    def __init__(self, *arcs: Arc | ArcBetweenPoints, **kwargs: Any) -> None:\n        if not all(isinstance(m, (Arc, ArcBetweenPoints)) for m in arcs):\n            raise ValueError(\n                \"All ArcPolygon submobjects must be of type Arc/ArcBetweenPoints\",\n            )\n        super().__init__(**kwargs)\n        # Adding the arcs like this makes ArcPolygonFromArcs double as a VGroup.\n        # Also makes changes to the ArcPolygonFromArcs, such as scaling, affect\n        # the arcs, so that their new values are usable.\n        self.add(*arcs)\n        # This enables the use of ArcPolygonFromArcs.arcs as a convenience\n        # because ArcPolygonFromArcs[0] returns itself, not the first Arc.\n        self.arcs = [*arcs]\n        from .line import Line\n\n        for arc1, arc2 in adjacent_pairs(arcs):\n            self.append_points(arc1.points)\n            line = Line(arc1.get_end(), arc2.get_start())\n            len_ratio = line.get_length() / arc1.get_arc_length()\n            if np.isnan(len_ratio) or np.isinf(len_ratio):\n                continue\n            line.insert_n_curves(int(arc1.get_num_curves() * len_ratio))\n            self.append_points(line.points)"}, {"name": "Arrow", "code": "class Arrow(Line):\n    \"\"\"An arrow.\n\n    Parameters\n    ----------\n    args\n        Arguments to be passed to :class:`Line`.\n    stroke_width\n        The thickness of the arrow. Influenced by :attr:`max_stroke_width_to_length_ratio`.\n    buff\n        The distance of the arrow from its start and end points.\n    max_tip_length_to_length_ratio\n        :attr:`tip_length` scales with the length of the arrow. Increasing this ratio raises the max value of :attr:`tip_length`.\n    max_stroke_width_to_length_ratio\n        :attr:`stroke_width` scales with the length of the arrow. Increasing this ratio ratios the max value of :attr:`stroke_width`.\n    kwargs\n        Additional arguments to be passed to :class:`Line`.\n\n\n    .. seealso::\n        :class:`ArrowTip`\n        :class:`CurvedArrow`\n\n    Examples\n    --------\n    .. manim:: ArrowExample\n        :save_last_frame:\n\n        from manim.mobject.geometry.tips import ArrowSquareTip\n        class ArrowExample(Scene):\n            def construct(self):\n                arrow_1 = Arrow(start=RIGHT, end=LEFT, color=GOLD)\n                arrow_2 = Arrow(start=RIGHT, end=LEFT, color=GOLD, tip_shape=ArrowSquareTip).shift(DOWN)\n                g1 = Group(arrow_1, arrow_2)\n\n                # the effect of buff\n                square = Square(color=MAROON_A)\n                arrow_3 = Arrow(start=LEFT, end=RIGHT)\n                arrow_4 = Arrow(start=LEFT, end=RIGHT, buff=0).next_to(arrow_1, UP)\n                g2 = Group(arrow_3, arrow_4, square)\n\n                # a shorter arrow has a shorter tip and smaller stroke width\n                arrow_5 = Arrow(start=ORIGIN, end=config.top).shift(LEFT * 4)\n                arrow_6 = Arrow(start=config.top + DOWN, end=config.top).shift(LEFT * 3)\n                g3 = Group(arrow_5, arrow_6)\n\n                self.add(Group(g1, g2, g3).arrange(buff=2))\n\n\n    .. manim:: ArrowExample\n        :save_last_frame:\n\n        class ArrowExample(Scene):\n            def construct(self):\n                left_group = VGroup()\n                # As buff increases, the size of the arrow decreases.\n                for buff in np.arange(0, 2.2, 0.45):\n                    left_group += Arrow(buff=buff, start=2 * LEFT, end=2 * RIGHT)\n                # Required to arrange arrows.\n                left_group.arrange(DOWN)\n                left_group.move_to(4 * LEFT)\n\n                middle_group = VGroup()\n                # As max_stroke_width_to_length_ratio gets bigger,\n                # the width of stroke increases.\n                for i in np.arange(0, 5, 0.5):\n                    middle_group += Arrow(max_stroke_width_to_length_ratio=i)\n                middle_group.arrange(DOWN)\n\n                UR_group = VGroup()\n                # As max_tip_length_to_length_ratio increases,\n                # the length of the tip increases.\n                for i in np.arange(0, 0.3, 0.1):\n                    UR_group += Arrow(max_tip_length_to_length_ratio=i)\n                UR_group.arrange(DOWN)\n                UR_group.move_to(4 * RIGHT + 2 * UP)\n\n                DR_group = VGroup()\n                DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareTip)\n                DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareFilledTip)\n                DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleTip)\n                DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleFilledTip)\n                DR_group.arrange(DOWN)\n                DR_group.move_to(4 * RIGHT + 2 * DOWN)\n\n                self.add(left_group, middle_group, UR_group, DR_group)\n    \"\"\"\n\n    def __init__(\n        self,\n        *args: Any,\n        stroke_width: float = 6,\n        buff: float = MED_SMALL_BUFF,\n        max_tip_length_to_length_ratio: float = 0.25,\n        max_stroke_width_to_length_ratio: float = 5,\n        **kwargs: Any,\n    ) -> None:\n        self.max_tip_length_to_length_ratio = max_tip_length_to_length_ratio\n        self.max_stroke_width_to_length_ratio = max_stroke_width_to_length_ratio\n        tip_shape = kwargs.pop(\"tip_shape\", ArrowTriangleFilledTip)\n        super().__init__(*args, buff=buff, stroke_width=stroke_width, **kwargs)  # type: ignore[misc]\n        # TODO, should this be affected when\n        # Arrow.set_stroke is called?\n        self.initial_stroke_width = self.stroke_width\n        self.add_tip(tip_shape=tip_shape)\n        self._set_stroke_width_from_length()\n\n    def scale(self, factor: float, scale_tips: bool = False, **kwargs: Any) -> Self:  # type: ignore[override]\n        r\"\"\"Scale an arrow, but keep stroke width and arrow tip size fixed.\n\n\n        .. seealso::\n            :meth:`~.Mobject.scale`\n\n        Examples\n        --------\n        ::\n\n            >>> arrow = Arrow(np.array([-1, -1, 0]), np.array([1, 1, 0]), buff=0)\n            >>> scaled_arrow = arrow.scale(2)\n            >>> np.round(scaled_arrow.get_start_and_end(), 8) + 0\n            array([[-2., -2.,  0.],\n                   [ 2.,  2.,  0.]])\n            >>> arrow.tip.length == scaled_arrow.tip.length\n            True\n\n        Manually scaling the object using the default method\n        :meth:`~.Mobject.scale` does not have the same properties::\n\n            >>> new_arrow = Arrow(np.array([-1, -1, 0]), np.array([1, 1, 0]), buff=0)\n            >>> another_scaled_arrow = VMobject.scale(new_arrow, 2)\n            >>> another_scaled_arrow.tip.length == arrow.tip.length\n            False\n\n        \"\"\"\n        if self.get_length() == 0:\n            return self\n\n        if scale_tips:\n            super().scale(factor, **kwargs)\n            self._set_stroke_width_from_length()\n            return self\n\n        has_tip = self.has_tip()\n        has_start_tip = self.has_start_tip()\n        if has_tip or has_start_tip:\n            old_tips = self.pop_tips()\n\n        super().scale(factor, **kwargs)\n        self._set_stroke_width_from_length()\n\n        if has_tip:\n            self.add_tip(tip=old_tips[0])\n        if has_start_tip:\n            self.add_tip(tip=old_tips[1], at_start=True)\n        return self\n\n    def get_normal_vector(self) -> Vector3D:\n        \"\"\"Returns the normal of a vector.\n\n        Examples\n        --------\n        ::\n\n            >>> np.round(Arrow().get_normal_vector()) + 0. # add 0. to avoid negative 0 in output\n            array([ 0.,  0., -1.])\n        \"\"\"\n        p0, p1, p2 = self.tip.get_start_anchors()[:3]\n        return normalize(np.cross(p2 - p1, p1 - p0))\n\n    def reset_normal_vector(self) -> Self:\n        \"\"\"Resets the normal of a vector\"\"\"\n        self.normal_vector = self.get_normal_vector()\n        return self\n\n    def get_default_tip_length(self) -> float:\n        \"\"\"Returns the default tip_length of the arrow.\n\n        Examples\n        --------\n\n        ::\n\n            >>> Arrow().get_default_tip_length()\n            0.35\n        \"\"\"\n        max_ratio = self.max_tip_length_to_length_ratio\n        return min(self.tip_length, max_ratio * self.get_length())\n\n    def _set_stroke_width_from_length(self) -> Self:\n        \"\"\"Sets stroke width based on length.\"\"\"\n        max_ratio = self.max_stroke_width_to_length_ratio\n        if config.renderer == RendererType.OPENGL:\n            # Mypy does not recognize that the self object in this case\n            # is a OpenGLVMobject and that the set_stroke method is\n            # defined here:\n            # mobject/opengl/opengl_vectorized_mobject.py#L248\n            self.set_stroke(  # type: ignore[call-arg]\n                width=min(self.initial_stroke_width, max_ratio * self.get_length()),\n                recurse=False,\n            )\n        else:\n            self.set_stroke(\n                width=min(self.initial_stroke_width, max_ratio * self.get_length()),\n                family=False,\n            )\n        return self"}, {"name": "Arrow3D", "code": "class Arrow3D(Line3D):\n    \"\"\"An arrow made out of a cylindrical line and a conical tip.\n\n    Parameters\n    ----------\n    start\n        The start position of the arrow.\n    end\n        The end position of the arrow.\n    thickness\n        The thickness of the arrow.\n    height\n        The height of the conical tip.\n    base_radius\n        The base radius of the conical tip.\n    color\n        The color of the arrow.\n    resolution\n        The resolution of the arrow line.\n\n    Examples\n    --------\n    .. manim:: ExampleArrow3D\n        :save_last_frame:\n\n        class ExampleArrow3D(ThreeDScene):\n            def construct(self):\n                axes = ThreeDAxes()\n                arrow = Arrow3D(\n                    start=np.array([0, 0, 0]),\n                    end=np.array([2, 2, 2]),\n                    resolution=8\n                )\n                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n                self.add(axes, arrow)\n    \"\"\"\n\n    def __init__(\n        self,\n        start: np.ndarray = LEFT,\n        end: np.ndarray = RIGHT,\n        thickness: float = 0.02,\n        height: float = 0.3,\n        base_radius: float = 0.08,\n        color: ParsableManimColor = WHITE,\n        resolution: int | Sequence[int] = 24,\n        **kwargs,\n    ) -> None:\n        super().__init__(\n            start=start,\n            end=end,\n            thickness=thickness,\n            color=color,\n            resolution=resolution,\n            **kwargs,\n        )\n\n        self.length = np.linalg.norm(self.vect)\n        self.set_start_and_end_attrs(\n            self.start,\n            self.end - height * self.direction,\n            **kwargs,\n        )\n        self.cone = Cone(\n            direction=self.direction,\n            base_radius=base_radius,\n            height=height,\n            **kwargs,\n        )\n        self.cone.shift(end)\n        self.end_point = VectorizedPoint(end)\n        self.add(self.end_point, self.cone)\n        self.set_color(color)\n\n    def get_end(self) -> np.ndarray:\n        return self.end_point.get_center()"}, {"name": "ArrowCircleFilledTip", "code": "class ArrowCircleFilledTip(ArrowCircleTip):\n    r\"\"\"Circular arrow tip with filled tip.\"\"\"\n\n    def __init__(\n        self, fill_opacity: float = 1, stroke_width: float = 0, **kwargs: Any\n    ) -> None:\n        super().__init__(fill_opacity=fill_opacity, stroke_width=stroke_width, **kwargs)"}, {"name": "ArrowCircleTip", "code": "class ArrowCircleTip(ArrowTip, Circle):\n    r\"\"\"Circular arrow tip.\"\"\"\n\n    def __init__(\n        self,\n        fill_opacity: float = 0,\n        stroke_width: float = 3,\n        length: float = DEFAULT_ARROW_TIP_LENGTH,\n        start_angle: float = PI,\n        **kwargs: Any,\n    ) -> None:\n        self.start_angle = start_angle\n        Circle.__init__(\n            self, fill_opacity=fill_opacity, stroke_width=stroke_width, **kwargs\n        )\n        self.width = length\n        self.stretch_to_fit_height(length)"}, {"name": "ArrowSquareFilledTip", "code": "class ArrowSquareFilledTip(ArrowSquareTip):\n    r\"\"\"Square arrow tip with filled tip.\"\"\"\n\n    def __init__(\n        self, fill_opacity: float = 1, stroke_width: float = 0, **kwargs: Any\n    ) -> None:\n        super().__init__(fill_opacity=fill_opacity, stroke_width=stroke_width, **kwargs)"}, {"name": "ArrowSquareTip", "code": "class ArrowSquareTip(ArrowTip, Square):\n    r\"\"\"Square arrow tip.\"\"\"\n\n    def __init__(\n        self,\n        fill_opacity: float = 0,\n        stroke_width: float = 3,\n        length: float = DEFAULT_ARROW_TIP_LENGTH,\n        start_angle: float = PI,\n        **kwargs: Any,\n    ) -> None:\n        self.start_angle = start_angle\n        Square.__init__(\n            self,\n            fill_opacity=fill_opacity,\n            stroke_width=stroke_width,\n            side_length=length,\n            **kwargs,\n        )\n        self.width = length\n        self.stretch_to_fit_height(length)"}, {"name": "ArrowTip", "code": "class ArrowTip(VMobject, metaclass=ConvertToOpenGL):\n    r\"\"\"Base class for arrow tips.\n\n    .. seealso::\n        :class:`ArrowTriangleTip`\n        :class:`ArrowTriangleFilledTip`\n        :class:`ArrowCircleTip`\n        :class:`ArrowCircleFilledTip`\n        :class:`ArrowSquareTip`\n        :class:`ArrowSquareFilledTip`\n        :class:`StealthTip`\n\n    Examples\n    --------\n    Cannot be used directly, only intended for inheritance::\n\n        >>> tip = ArrowTip()\n        Traceback (most recent call last):\n        ...\n        NotImplementedError: Has to be implemented in inheriting subclasses.\n\n    Instead, use one of the pre-defined ones, or make\n    a custom one like this:\n\n    .. manim:: CustomTipExample\n\n        >>> from manim import RegularPolygon, Arrow\n        >>> class MyCustomArrowTip(ArrowTip, RegularPolygon):\n        ...     def __init__(self, length=0.35, **kwargs):\n        ...         RegularPolygon.__init__(self, n=5, **kwargs)\n        ...         self.width = length\n        ...         self.stretch_to_fit_height(length)\n        >>> arr = Arrow(\n        ...     np.array([-2, -2, 0]), np.array([2, 2, 0]), tip_shape=MyCustomArrowTip\n        ... )\n        >>> isinstance(arr.tip, RegularPolygon)\n        True\n        >>> from manim import Scene, Create\n        >>> class CustomTipExample(Scene):\n        ...     def construct(self):\n        ...         self.play(Create(arr))\n\n    Using a class inherited from :class:`ArrowTip` to get a non-filled\n    tip is a shorthand to manually specifying the arrow tip style as follows::\n\n        >>> arrow = Arrow(np.array([0, 0, 0]), np.array([1, 1, 0]),\n        ...               tip_style={'fill_opacity': 0, 'stroke_width': 3})\n\n    The following example illustrates the usage of all of the predefined\n    arrow tips.\n\n    .. manim:: ArrowTipsShowcase\n        :save_last_frame:\n\n        class ArrowTipsShowcase(Scene):\n            def construct(self):\n                tip_names = [\n                    'Default (YELLOW)', 'ArrowTriangleTip', 'Default', 'ArrowSquareTip',\n                    'ArrowSquareFilledTip', 'ArrowCircleTip', 'ArrowCircleFilledTip', 'StealthTip'\n                ]\n\n                big_arrows = [\n                    Arrow(start=[-4, 3.5, 0], end=[2, 3.5, 0], color=YELLOW),\n                    Arrow(start=[-4, 2.5, 0], end=[2, 2.5, 0], tip_shape=ArrowTriangleTip),\n                    Arrow(start=[-4, 1.5, 0], end=[2, 1.5, 0]),\n                    Arrow(start=[-4, 0.5, 0], end=[2, 0.5, 0], tip_shape=ArrowSquareTip),\n\n                    Arrow([-4, -0.5, 0], [2, -0.5, 0], tip_shape=ArrowSquareFilledTip),\n                    Arrow([-4, -1.5, 0], [2, -1.5, 0], tip_shape=ArrowCircleTip),\n                    Arrow([-4, -2.5, 0], [2, -2.5, 0], tip_shape=ArrowCircleFilledTip),\n                    Arrow([-4, -3.5, 0], [2, -3.5, 0], tip_shape=StealthTip)\n                ]\n\n                small_arrows = (\n                    arrow.copy().scale(0.5, scale_tips=True).next_to(arrow, RIGHT) for arrow in big_arrows\n                )\n\n                labels = (\n                    Text(tip_names[i], font='monospace', font_size=20, color=BLUE).next_to(big_arrows[i], LEFT) for i in range(len(big_arrows))\n                )\n\n                self.add(*big_arrows, *small_arrows, *labels)\n    \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        raise NotImplementedError(\"Has to be implemented in inheriting subclasses.\")\n\n    @property\n    def base(self) -> Point3D:\n        r\"\"\"The base point of the arrow tip.\n\n        This is the point connecting to the arrow line.\n\n        Examples\n        --------\n        ::\n\n            >>> from manim import Arrow\n            >>> arrow = Arrow(np.array([0, 0, 0]), np.array([2, 0, 0]), buff=0)\n            >>> arrow.tip.base.round(2) + 0.  # add 0. to avoid negative 0 in output\n            array([1.65, 0.  , 0.  ])\n\n        \"\"\"\n        return self.point_from_proportion(0.5)\n\n    @property\n    def tip_point(self) -> Point3D:\n        r\"\"\"The tip point of the arrow tip.\n\n        Examples\n        --------\n        ::\n\n            >>> from manim import Arrow\n            >>> arrow = Arrow(np.array([0, 0, 0]), np.array([2, 0, 0]), buff=0)\n            >>> arrow.tip.tip_point.round(2) + 0.\n            array([2., 0., 0.])\n\n        \"\"\"\n        # Type inference of extracting an element from a list, is not\n        # supported by numpy, see this numpy issue\n        # https://github.com/numpy/numpy/issues/16544\n        tip_point: Point3D = self.points[0]\n        return tip_point\n\n    @property\n    def vector(self) -> Vector3D:\n        r\"\"\"The vector pointing from the base point to the tip point.\n\n        Examples\n        --------\n        ::\n\n            >>> from manim import Arrow\n            >>> arrow = Arrow(np.array([0, 0, 0]), np.array([2, 2, 0]), buff=0)\n            >>> arrow.tip.vector.round(2) + 0.\n            array([0.25, 0.25, 0.  ])\n\n        \"\"\"\n        return self.tip_point - self.base\n\n    @property\n    def tip_angle(self) -> float:\n        r\"\"\"The angle of the arrow tip.\n\n        Examples\n        --------\n        ::\n\n            >>> from manim import Arrow\n            >>> arrow = Arrow(np.array([0, 0, 0]), np.array([1, 1, 0]), buff=0)\n            >>> bool(round(arrow.tip.tip_angle, 5) == round(PI/4, 5))\n            True\n\n        \"\"\"\n        return angle_of_vector(self.vector)\n\n    @property\n    def length(self) -> float:\n        r\"\"\"The length of the arrow tip.\n\n        Examples\n        --------\n        ::\n\n            >>> from manim import Arrow\n            >>> arrow = Arrow(np.array([0, 0, 0]), np.array([1, 2, 0]))\n            >>> round(arrow.tip.length, 3)\n            0.35\n\n        \"\"\"\n        return float(np.linalg.norm(self.vector))"}, {"name": "ArrowTriangleFilledTip", "code": "class ArrowTriangleFilledTip(ArrowTriangleTip):\n    r\"\"\"Triangular arrow tip with filled tip.\n\n    This is the default arrow tip shape.\n    \"\"\"\n\n    def __init__(\n        self, fill_opacity: float = 1, stroke_width: float = 0, **kwargs: Any\n    ) -> None:\n        super().__init__(fill_opacity=fill_opacity, stroke_width=stroke_width, **kwargs)"}, {"name": "ArrowTriangleTip", "code": "class ArrowTriangleTip(ArrowTip, Triangle):\n    r\"\"\"Triangular arrow tip.\"\"\"\n\n    def __init__(\n        self,\n        fill_opacity: float = 0,\n        stroke_width: float = 3,\n        length: float = DEFAULT_ARROW_TIP_LENGTH,\n        width: float = DEFAULT_ARROW_TIP_LENGTH,\n        start_angle: float = PI,\n        **kwargs: Any,\n    ) -> None:\n        Triangle.__init__(\n            self,\n            fill_opacity=fill_opacity,\n            stroke_width=stroke_width,\n            start_angle=start_angle,\n            **kwargs,\n        )\n        self.width = width\n\n        self.stretch_to_fit_width(length)\n        self.stretch_to_fit_height(width)"}, {"name": "ArrowVectorField", "code": "class ArrowVectorField(VectorField):\n    \"\"\"A :class:`VectorField` represented by a set of change vectors.\n\n    Vector fields are always based on a function defining the :class:`~.Vector` at every position.\n    The values of this functions is displayed as a grid of vectors.\n    By default the color of each vector is determined by it's magnitude.\n    Other color schemes can be used however.\n\n    Parameters\n    ----------\n    func\n        The function defining the rate of change at every position of the vector field.\n    color\n        The color of the vector field. If set, position-specific coloring is disabled.\n    color_scheme\n        A function mapping a vector to a single value. This value gives the position in the color gradient defined using `min_color_scheme_value`, `max_color_scheme_value` and `colors`.\n    min_color_scheme_value\n        The value of the color_scheme function to be mapped to the first color in `colors`. Lower values also result in the first color of the gradient.\n    max_color_scheme_value\n        The value of the color_scheme function to be mapped to the last color in `colors`. Higher values also result in the last color of the gradient.\n    colors\n        The colors defining the color gradient of the vector field.\n    x_range\n        A sequence of x_min, x_max, delta_x\n    y_range\n        A sequence of y_min, y_max, delta_y\n    z_range\n        A sequence of z_min, z_max, delta_z\n    three_dimensions\n        Enables three_dimensions. Default set to False, automatically turns True if\n        z_range is not None.\n    length_func\n        The function determining the displayed size of the vectors. The actual size\n        of the vector is passed, the returned value will be used as display size for the\n        vector. By default this is used to cap the displayed size of vectors to reduce the clutter.\n    opacity\n        The opacity of the arrows.\n    vector_config\n        Additional arguments to be passed to the :class:`~.Vector` constructor\n    kwargs\n        Additional arguments to be passed to the :class:`~.VGroup` constructor\n\n    Examples\n    --------\n\n    .. manim:: BasicUsage\n        :save_last_frame:\n\n        class BasicUsage(Scene):\n            def construct(self):\n                func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3\n                self.add(ArrowVectorField(func))\n\n    .. manim:: SizingAndSpacing\n\n        class SizingAndSpacing(Scene):\n            def construct(self):\n                func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT\n                vf = ArrowVectorField(func, x_range=[-7, 7, 1])\n                self.add(vf)\n                self.wait()\n\n                length_func = lambda x: x / 3\n                vf2 = ArrowVectorField(func, x_range=[-7, 7, 1], length_func=length_func)\n                self.play(vf.animate.become(vf2))\n                self.wait()\n\n    .. manim:: Coloring\n        :save_last_frame:\n\n        class Coloring(Scene):\n            def construct(self):\n                func = lambda pos: pos - LEFT * 5\n                colors = [RED, YELLOW, BLUE, DARK_GRAY]\n                min_radius = Circle(radius=2, color=colors[0]).shift(LEFT * 5)\n                max_radius = Circle(radius=10, color=colors[-1]).shift(LEFT * 5)\n                vf = ArrowVectorField(\n                    func, min_color_scheme_value=2, max_color_scheme_value=10, colors=colors\n                )\n                self.add(vf, min_radius, max_radius)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        func: Callable[[np.ndarray], np.ndarray],\n        color: ParsableManimColor | None = None,\n        color_scheme: Callable[[np.ndarray], float] | None = None,\n        min_color_scheme_value: float = 0,\n        max_color_scheme_value: float = 2,\n        colors: Sequence[ParsableManimColor] = DEFAULT_SCALAR_FIELD_COLORS,\n        # Determining Vector positions:\n        x_range: Sequence[float] = None,\n        y_range: Sequence[float] = None,\n        z_range: Sequence[float] = None,\n        three_dimensions: bool = False,  # Automatically True if z_range is set\n        # Takes in actual norm, spits out displayed norm\n        length_func: Callable[[float], float] = lambda norm: 0.45 * sigmoid(norm),\n        opacity: float = 1.0,\n        vector_config: dict | None = None,\n        **kwargs,\n    ):\n        self.x_range = x_range or [\n            floor(-config[\"frame_width\"] / 2),\n            ceil(config[\"frame_width\"] / 2),\n        ]\n        self.y_range = y_range or [\n            floor(-config[\"frame_height\"] / 2),\n            ceil(config[\"frame_height\"] / 2),\n        ]\n        self.ranges = [self.x_range, self.y_range]\n\n        if three_dimensions or z_range:\n            self.z_range = z_range or self.y_range.copy()\n            self.ranges += [self.z_range]\n        else:\n            self.ranges += [[0, 0]]\n\n        for i in range(len(self.ranges)):\n            if len(self.ranges[i]) == 2:\n                self.ranges[i] += [0.5]\n            self.ranges[i][1] += self.ranges[i][2]\n\n        self.x_range, self.y_range, self.z_range = self.ranges\n\n        super().__init__(\n            func,\n            color,\n            color_scheme,\n            min_color_scheme_value,\n            max_color_scheme_value,\n            colors,\n            **kwargs,\n        )\n\n        self.length_func = length_func\n        self.opacity = opacity\n        if vector_config is None:\n            vector_config = {}\n        self.vector_config = vector_config\n        self.func = func\n\n        x_range = np.arange(*self.x_range)\n        y_range = np.arange(*self.y_range)\n        z_range = np.arange(*self.z_range)\n        self.add(\n            *[\n                self.get_vector(x * RIGHT + y * UP + z * OUT)\n                for x, y, z in it.product(x_range, y_range, z_range)\n            ]\n        )\n        self.set_opacity(self.opacity)\n\n    def get_vector(self, point: np.ndarray):\n        \"\"\"Creates a vector in the vector field.\n\n        The created vector is based on the function of the vector field and is\n        rooted in the given point. Color and length fit the specifications of\n        this vector field.\n\n        Parameters\n        ----------\n        point\n            The root point of the vector.\n\n        \"\"\"\n        output = np.array(self.func(point))\n        norm = np.linalg.norm(output)\n        if norm != 0:\n            output *= self.length_func(norm) / norm\n        vect = Vector(output, **self.vector_config)\n        vect.shift(point)\n        if self.single_color:\n            vect.set_color(self.color)\n        else:\n            vect.set_color(self.pos_to_color(point))\n        return vect"}, {"name": "assert_is_mobject_method", "code": "def assert_is_mobject_method(method: Callable) -> None:\n    assert inspect.ismethod(method)\n    mobject = method.__self__\n    assert isinstance(mobject, (Mobject, OpenGLMobject))"}, {"name": "average_color", "code": "def average_color(*colors: ParsableManimColor) -> ManimColor:\n    \"\"\"Determine the average color between the given parameters.\n\n    .. note::\n        This operation does not consider the alphas (opacities) of the colors. The\n        generated color has an alpha or opacity of 1.0.\n\n    Returns\n    -------\n    ManimColor\n        The average color of the input.\n    \"\"\"\n    rgbs = np.array([color_to_rgb(color) for color in colors])\n    mean_rgb = np.apply_along_axis(np.mean, 0, rgbs)\n    return rgb_to_color(mean_rgb)"}, {"name": "Axes", "code": "class Axes(VGroup, CoordinateSystem, metaclass=ConvertToOpenGL):\n    \"\"\"Creates a set of axes.\n\n    Parameters\n    ----------\n    x_range\n        The ``(x_min, x_max, x_step)`` values of the x-axis.\n    y_range\n        The ``(y_min, y_max, y_step)`` values of the y-axis.\n    x_length\n        The length of the x-axis.\n    y_length\n        The length of the y-axis.\n    axis_config\n        Arguments to be passed to :class:`~.NumberLine` that influences both axes.\n    x_axis_config\n        Arguments to be passed to :class:`~.NumberLine` that influence the x-axis.\n    y_axis_config\n        Arguments to be passed to :class:`~.NumberLine` that influence the y-axis.\n    tips\n        Whether or not to include the tips on both axes.\n    kwargs\n        Additional arguments to be passed to :class:`CoordinateSystem` and :class:`~.VGroup`.\n\n    Examples\n    --------\n    .. manim:: LogScalingExample\n        :save_last_frame:\n\n        class LogScalingExample(Scene):\n            def construct(self):\n                ax = Axes(\n                    x_range=[0, 10, 1],\n                    y_range=[-2, 6, 1],\n                    tips=False,\n                    axis_config={\"include_numbers\": True},\n                    y_axis_config={\"scaling\": LogBase(custom_labels=True)},\n                )\n\n                # x_min must be > 0 because log is undefined at 0.\n                graph = ax.plot(lambda x: x ** 2, x_range=[0.001, 10], use_smoothing=False)\n                self.add(ax, graph)\n\n    Styling arguments can be passed to the underlying :class:`.NumberLine`\n    mobjects that represent the axes:\n\n    .. manim:: AxesWithDifferentTips\n        :save_last_frame:\n\n        class AxesWithDifferentTips(Scene):\n            def construct(self):\n                ax = Axes(axis_config={'tip_shape': StealthTip})\n                self.add(ax)\n    \"\"\"\n\n    def __init__(\n        self,\n        x_range: Sequence[float] | None = None,\n        y_range: Sequence[float] | None = None,\n        x_length: float | None = round(config.frame_width) - 2,\n        y_length: float | None = round(config.frame_height) - 2,\n        axis_config: dict | None = None,\n        x_axis_config: dict | None = None,\n        y_axis_config: dict | None = None,\n        tips: bool = True,\n        **kwargs: Any,\n    ) -> None:\n        VGroup.__init__(self, **kwargs)\n        CoordinateSystem.__init__(self, x_range, y_range, x_length, y_length)\n\n        self.axis_config = {\n            \"include_tip\": tips,\n            \"numbers_to_exclude\": [0],\n        }\n        self.x_axis_config = {}\n        self.y_axis_config = {\"rotation\": 90 * DEGREES, \"label_direction\": LEFT}\n\n        self._update_default_configs(\n            (self.axis_config, self.x_axis_config, self.y_axis_config),\n            (axis_config, x_axis_config, y_axis_config),\n        )\n\n        self.x_axis_config = merge_dicts_recursively(\n            self.axis_config,\n            self.x_axis_config,\n        )\n        self.y_axis_config = merge_dicts_recursively(\n            self.axis_config,\n            self.y_axis_config,\n        )\n\n        # excluding the origin tick removes a tick at the 0-point of the axis\n        # This is desired for LinearBase because the 0 point is always the x-axis\n        # For non-LinearBase, the \"0-point\" does not have this quality, so it must be included.\n\n        # i.e. with LogBase range [-2, 4]:\n        # it would remove the \"0\" tick, which is actually 10^0,\n        # not the lowest tick on the graph (which is 10^-2).\n\n        if self.x_axis_config.get(\"scaling\") is None or isinstance(\n            self.x_axis_config.get(\"scaling\"), LinearBase\n        ):\n            self.x_axis_config[\"exclude_origin_tick\"] = True\n        else:\n            self.x_axis_config[\"exclude_origin_tick\"] = False\n\n        if self.y_axis_config.get(\"scaling\") is None or isinstance(\n            self.y_axis_config.get(\"scaling\"), LinearBase\n        ):\n            self.y_axis_config[\"exclude_origin_tick\"] = True\n        else:\n            self.y_axis_config[\"exclude_origin_tick\"] = False\n\n        self.x_axis = self._create_axis(self.x_range, self.x_axis_config, self.x_length)\n        self.y_axis = self._create_axis(self.y_range, self.y_axis_config, self.y_length)\n\n        # Add as a separate group in case various other\n        # mobjects are added to self, as for example in\n        # NumberPlane below\n        self.axes = VGroup(self.x_axis, self.y_axis)\n        self.add(*self.axes)\n\n        # finds the middle-point on each axis\n        lines_center_point = [\n            axis.scaling.function((axis.x_range[1] + axis.x_range[0]) / 2)\n            for axis in self.axes\n        ]\n\n        self.shift(-self.coords_to_point(*lines_center_point))\n\n    @staticmethod\n    def _update_default_configs(\n        default_configs: tuple[dict[Any, Any]], passed_configs: tuple[dict[Any, Any]]\n    ) -> None:\n        \"\"\"Takes in two tuples of dicts and return modifies the first such that values from\n        ``passed_configs`` overwrite values in ``default_configs``. If a key does not exist\n        in default_configs, it is added to the dict.\n\n        This method is useful for having defaults in a class and being able to overwrite\n        them with user-defined input.\n\n        Parameters\n        ----------\n        default_configs\n            The dict that will be updated.\n        passed_configs\n            The dict that will be used to update.\n\n        Examples\n        --------\n        To create a tuple with one dictionary, add a comma after the element:\n\n        .. code-block:: python\n\n            self._update_default_configs(\n                (dict_1,)(\n                    dict_2,\n                )\n            )\n        \"\"\"\n        for default_config, passed_config in zip(default_configs, passed_configs):\n            if passed_config is not None:\n                update_dict_recursively(default_config, passed_config)\n\n    def _create_axis(\n        self,\n        range_terms: Sequence[float],\n        axis_config: dict[str, Any],\n        length: float,\n    ) -> NumberLine:\n        \"\"\"Creates an axis and dynamically adjusts its position depending on where 0 is located on the line.\n\n        Parameters\n        ----------\n        range_terms\n            The range of the the axis : ``(x_min, x_max, x_step)``.\n        axis_config\n            Additional parameters that are passed to :class:`~.NumberLine`.\n        length\n            The length of the axis.\n\n        Returns\n        -------\n        :class:`NumberLine`\n            Returns a number line based on ``range_terms``.\n        \"\"\"\n        axis_config[\"length\"] = length\n        axis = NumberLine(range_terms, **axis_config)\n\n        # without the call to _origin_shift, graph does not exist when min > 0 or max < 0\n        # shifts the axis so that 0 is centered\n        axis.shift(-axis.number_to_point(self._origin_shift([axis.x_min, axis.x_max])))\n        return axis\n\n    def coords_to_point(\n        self, *coords: float | Sequence[float] | Sequence[Sequence[float]] | np.ndarray\n    ) -> np.ndarray:\n        \"\"\"Accepts coordinates from the axes and returns a point with respect to the scene.\n        Equivalent to `ax @ (coord1)`\n\n        Parameters\n        ----------\n        coords\n            The coordinates. Each coord is passed as a separate argument: ``ax.coords_to_point(1, 2, 3)``.\n\n            Also accepts a list of coordinates\n\n            ``ax.coords_to_point( [x_0, x_1, ...], [y_0, y_1, ...], ... )``\n\n            ``ax.coords_to_point( [[x_0, y_0, z_0], [x_1, y_1, z_1]] )``\n\n        Returns\n        -------\n        np.ndarray\n            A point with respect to the scene's coordinate system.\n            The shape of the array will be similar to the shape of the input.\n\n        Examples\n        --------\n\n        .. code-block:: pycon\n\n            >>> from manim import Axes\n            >>> import numpy as np\n            >>> ax = Axes()\n            >>> np.around(ax.coords_to_point(1, 0, 0), 2)\n            array([0.86, 0.  , 0.  ])\n            >>> np.around(ax @ (1, 0, 0), 2)\n            array([0.86, 0.  , 0.  ])\n            >>> np.around(ax.coords_to_point([[0, 1], [1, 1], [1, 0]]), 2)\n            array([[0.  , 0.75, 0.  ],\n                   [0.86, 0.75, 0.  ],\n                   [0.86, 0.  , 0.  ]])\n            >>> np.around(\n            ...     ax.coords_to_point([0, 1, 1], [1, 1, 0]), 2\n            ... )  # Transposed version of the above\n            array([[0.  , 0.86, 0.86],\n                   [0.75, 0.75, 0.  ],\n                   [0.  , 0.  , 0.  ]])\n\n        .. manim:: CoordsToPointExample\n            :save_last_frame:\n\n            class CoordsToPointExample(Scene):\n                def construct(self):\n                    ax = Axes().add_coordinates()\n\n                    # a dot with respect to the axes\n                    dot_axes = Dot(ax.coords_to_point(2, 2), color=GREEN)\n                    lines = ax.get_lines_to_point(ax.c2p(2,2))\n\n                    # a dot with respect to the scene\n                    # the default plane corresponds to the coordinates of the scene.\n                    plane = NumberPlane()\n                    dot_scene = Dot((2,2,0), color=RED)\n\n                    self.add(plane, dot_scene, ax, dot_axes, lines)\n        \"\"\"\n        coords = np.asarray(coords)\n        origin = self.x_axis.number_to_point(\n            self._origin_shift([self.x_axis.x_min, self.x_axis.x_max]),\n        )\n\n        # Is coords in the format ([[x1 y1 z1] [x2 y2 z2] ...])? (True)\n        # Or is coords in the format (x, y, z) or ([x1 x2 ...], [y1 y2 ...], [z1 z2 ...])? (False)\n        # The latter is preferred.\n        are_coordinates_transposed = False\n\n        # If coords is in the format ([[x1 y1 z1] [x2 y2 z2] ...]):\n        if coords.ndim == 3:\n            # Extract from original tuple: now coords looks like [[x y z]] or [[x1 y1 z1] [x2 y2 z2] ...].\n            coords = coords[0]\n            # If there's a single coord (coords = [[x y z]]), extract it so that\n            # coords = [x y z] and coords_to_point returns a single point.\n            if coords.shape[0] == 1:\n                coords = coords[0]\n            # Else, if coords looks more like [[x1 y1 z1] [x2 y2 z2] ...], transform them (by\n            # transposing) into the format [[x1 x2 ...] [y1 y2 ...] [z1 z2 ...]] for later processing.\n            else:\n                coords = coords.T\n                are_coordinates_transposed = True\n        # Otherwise, coords already looked like (x, y, z) or ([x1 x2 ...], [y1 y2 ...], [z1 z2 ...]),\n        # so no further processing is needed.\n\n        # Now coords should either look like [x y z] or [[x1 x2 ...] [y1 y2 ...] [z1 z2 ...]],\n        # so it can be iterated directly. Each element is either a float representing a single\n        # coordinate, or a float ndarray of coordinates corresponding to a single axis.\n        # Although \"points\" and \"nums\" are in plural, there might be a single point or number.\n        points = self.x_axis.number_to_point(coords[0])\n        other_axes = self.axes.submobjects[1:]\n        for axis, nums in zip(other_axes, coords[1:]):\n            points += axis.number_to_point(nums) - origin\n\n        # Return points as is, except if coords originally looked like\n        # ([x1 x2 ...], [y1 y2 ...], [z1 z2 ...]), which is determined by the conditions below. In\n        # that case, the current implementation requires that the results have to be transposed.\n        if are_coordinates_transposed or points.ndim == 1:\n            return points\n        return points.T\n\n    def point_to_coords(self, point: Sequence[float]) -> np.ndarray:\n        \"\"\"Accepts a point from the scene and returns its coordinates with respect to the axes.\n\n        Parameters\n        ----------\n        point\n            The point, i.e. ``RIGHT`` or ``[0, 1, 0]``.\n            Also accepts a list of points as ``[RIGHT, [0, 1, 0]]``.\n\n        Returns\n        -------\n        np.ndarray[float]\n            The coordinates on the axes, i.e. ``[4.0, 7.0]``.\n            Or a list of coordinates if `point` is a list of points.\n\n        Examples\n        --------\n\n        .. code-block:: pycon\n\n            >>> from manim import Axes, RIGHT\n            >>> import numpy as np\n            >>> ax = Axes(x_range=[0, 10, 2])\n            >>> np.around(ax.point_to_coords(RIGHT), 2)\n            array([5.83, 0.  ])\n            >>> np.around(ax.point_to_coords([[0, 0, 1], [1, 0, 0]]), 2)\n            array([[5.  , 0.  ],\n                   [5.83, 0.  ]])\n\n\n        .. manim:: PointToCoordsExample\n            :save_last_frame:\n\n            class PointToCoordsExample(Scene):\n                def construct(self):\n                    ax = Axes(x_range=[0, 10, 2]).add_coordinates()\n                    circ = Circle(radius=0.5).shift(UR * 2)\n\n                    # get the coordinates of the circle with respect to the axes\n                    coords = np.around(ax.point_to_coords(circ.get_right()), decimals=2)\n\n                    label = (\n                        Matrix([[coords[0]], [coords[1]]]).scale(0.75).next_to(circ, RIGHT)\n                    )\n\n                    self.add(ax, circ, label, Dot(circ.get_right()))\n        \"\"\"\n        point = np.asarray(point)\n        result = np.asarray([axis.point_to_number(point) for axis in self.get_axes()])\n        if point.ndim == 2:\n            return result.T\n        return result\n\n    def get_axes(self) -> VGroup:\n        \"\"\"Gets the axes.\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            A pair of axes.\n        \"\"\"\n        return self.axes\n\n    def get_axis_labels(\n        self,\n        x_label: float | str | Mobject = \"x\",\n        y_label: float | str | Mobject = \"y\",\n    ) -> VGroup:\n        \"\"\"Defines labels for the x-axis and y-axis of the graph.\n\n        For increased control over the position of the labels,\n        use :meth:`~.CoordinateSystem.get_x_axis_label` and\n        :meth:`~.CoordinateSystem.get_y_axis_label`.\n\n        Parameters\n        ----------\n        x_label\n            The label for the x_axis. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n        y_label\n            The label for the y_axis. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            A :class:`~.VGroup` of the labels for the x_axis and y_axis.\n\n\n        .. seealso::\n            :meth:`~.CoordinateSystem.get_x_axis_label`\n            :meth:`~.CoordinateSystem.get_y_axis_label`\n\n        Examples\n        --------\n        .. manim:: GetAxisLabelsExample\n            :save_last_frame:\n\n            class GetAxisLabelsExample(Scene):\n                def construct(self):\n                    ax = Axes()\n                    labels = ax.get_axis_labels(\n                        Tex(\"x-axis\").scale(0.7), Text(\"y-axis\").scale(0.45)\n                    )\n                    self.add(ax, labels)\n        \"\"\"\n        self.axis_labels = VGroup(\n            self.get_x_axis_label(x_label),\n            self.get_y_axis_label(y_label),\n        )\n        return self.axis_labels\n\n    def plot_line_graph(\n        self,\n        x_values: Iterable[float],\n        y_values: Iterable[float],\n        z_values: Iterable[float] | None = None,\n        line_color: ParsableManimColor = YELLOW,\n        add_vertex_dots: bool = True,\n        vertex_dot_radius: float = DEFAULT_DOT_RADIUS,\n        vertex_dot_style: dict[str, Any] | None = None,\n        **kwargs: Any,\n    ) -> VDict:\n        \"\"\"Draws a line graph.\n\n        The graph connects the vertices formed from zipping\n        ``x_values``, ``y_values`` and ``z_values``. Also adds :class:`Dots <.Dot>` at the\n        vertices if ``add_vertex_dots`` is set to ``True``.\n\n        Parameters\n        ----------\n        x_values\n            Iterable of values along the x-axis.\n        y_values\n            Iterable of values along the y-axis.\n        z_values\n            Iterable of values (zeros if z_values is None) along the z-axis.\n        line_color\n            Color for the line graph.\n        add_vertex_dots\n            Whether or not to add :class:`~.Dot` at each vertex.\n        vertex_dot_radius\n            Radius for the :class:`~.Dot` at each vertex.\n        vertex_dot_style\n            Style arguments to be passed into :class:`~.Dot` at each vertex.\n        kwargs\n            Additional arguments to be passed into :class:`~.VMobject`.\n\n        Returns\n        -------\n        :class:`~.VDict`\n            A VDict containing both the line and dots (if specified). The line can be accessed with: ``line_graph[\"line_graph\"]``.\n            The dots can be accessed with: ``line_graph[\"vertex_dots\"]``.\n\n        Examples\n        --------\n        .. manim:: LineGraphExample\n            :save_last_frame:\n\n            class LineGraphExample(Scene):\n                def construct(self):\n                    plane = NumberPlane(\n                        x_range = (0, 7),\n                        y_range = (0, 5),\n                        x_length = 7,\n                        axis_config={\"include_numbers\": True},\n                    )\n                    plane.center()\n                    line_graph = plane.plot_line_graph(\n                        x_values = [0, 1.5, 2, 2.8, 4, 6.25],\n                        y_values = [1, 3, 2.25, 4, 2.5, 1.75],\n                        line_color=GOLD_E,\n                        vertex_dot_style=dict(stroke_width=3,  fill_color=PURPLE),\n                        stroke_width = 4,\n                    )\n                    self.add(plane, line_graph)\n        \"\"\"\n        x_values, y_values = map(np.array, (x_values, y_values))\n        if z_values is None:\n            z_values = np.zeros(x_values.shape)\n\n        line_graph = VDict()\n        graph = VGroup(color=line_color, **kwargs)\n\n        vertices = [\n            self.coords_to_point(x, y, z)\n            for x, y, z in zip(x_values, y_values, z_values)\n        ]\n        graph.set_points_as_corners(vertices)\n        line_graph[\"line_graph\"] = graph\n\n        if add_vertex_dots:\n            vertex_dot_style = vertex_dot_style or {}\n            vertex_dots = VGroup(\n                *(\n                    Dot(point=vertex, radius=vertex_dot_radius, **vertex_dot_style)\n                    for vertex in vertices\n                )\n            )\n            line_graph[\"vertex_dots\"] = vertex_dots\n\n        return line_graph\n\n    @staticmethod\n    def _origin_shift(axis_range: Sequence[float]) -> float:\n        \"\"\"Determines how to shift graph mobjects to compensate when 0 is not on the axis.\n\n        Parameters\n        ----------\n        axis_range\n            The range of the axis : ``(x_min, x_max, x_step)``.\n        \"\"\"\n        if axis_range[0] > 0:\n            # min greater than 0\n            return axis_range[0]\n        if axis_range[1] < 0:\n            # max less than 0\n            return axis_range[1]\n        else:\n            return 0"}, {"name": "BackgroundColoredVMobjectDisplayer", "code": "class BackgroundColoredVMobjectDisplayer:\n    \"\"\"Auxiliary class that handles displaying vectorized mobjects with\n    a set background image.\n\n    Parameters\n    ----------\n    camera\n        Camera object to use.\n    \"\"\"\n\n    def __init__(self, camera: Camera):\n        self.camera = camera\n        self.file_name_to_pixel_array_map = {}\n        self.pixel_array = np.array(camera.pixel_array)\n        self.reset_pixel_array()\n\n    def reset_pixel_array(self):\n        self.pixel_array[:, :] = 0\n\n    def resize_background_array(\n        self,\n        background_array: np.ndarray,\n        new_width: float,\n        new_height: float,\n        mode: str = \"RGBA\",\n    ):\n        \"\"\"Resizes the pixel array representing the background.\n\n        Parameters\n        ----------\n        background_array\n            The pixel\n        new_width\n            The new width of the background\n        new_height\n            The new height of the background\n        mode\n            The PIL image mode, by default \"RGBA\"\n\n        Returns\n        -------\n        np.array\n            The numpy pixel array of the resized background.\n        \"\"\"\n        image = Image.fromarray(background_array)\n        image = image.convert(mode)\n        resized_image = image.resize((new_width, new_height))\n        return np.array(resized_image)\n\n    def resize_background_array_to_match(\n        self, background_array: np.ndarray, pixel_array: np.ndarray\n    ):\n        \"\"\"Resizes the background array to match the passed pixel array.\n\n        Parameters\n        ----------\n        background_array\n            The prospective pixel array.\n        pixel_array\n            The pixel array whose width and height should be matched.\n\n        Returns\n        -------\n        np.array\n            The resized background array.\n        \"\"\"\n        height, width = pixel_array.shape[:2]\n        mode = \"RGBA\" if pixel_array.shape[2] == 4 else \"RGB\"\n        return self.resize_background_array(background_array, width, height, mode)\n\n    def get_background_array(self, image: Image.Image | pathlib.Path | str):\n        \"\"\"Gets the background array that has the passed file_name.\n\n        Parameters\n        ----------\n        image\n            The background image or its file name.\n\n        Returns\n        -------\n        np.ndarray\n            The pixel array of the image.\n        \"\"\"\n        image_key = str(image)\n\n        if image_key in self.file_name_to_pixel_array_map:\n            return self.file_name_to_pixel_array_map[image_key]\n        if isinstance(image, str):\n            full_path = get_full_raster_image_path(image)\n            image = Image.open(full_path)\n        back_array = np.array(image)\n\n        pixel_array = self.pixel_array\n        if not np.all(pixel_array.shape == back_array.shape):\n            back_array = self.resize_background_array_to_match(back_array, pixel_array)\n\n        self.file_name_to_pixel_array_map[image_key] = back_array\n        return back_array\n\n    def display(self, *cvmobjects: VMobject):\n        \"\"\"Displays the colored VMobjects.\n\n        Parameters\n        ----------\n        *cvmobjects\n            The VMobjects\n\n        Returns\n        -------\n        np.array\n            The pixel array with the `cvmobjects` displayed.\n        \"\"\"\n        batch_image_pairs = it.groupby(cvmobjects, lambda cv: cv.get_background_image())\n        curr_array = None\n        for image, batch in batch_image_pairs:\n            background_array = self.get_background_array(image)\n            pixel_array = self.pixel_array\n            self.camera.display_multiple_non_background_colored_vmobjects(\n                batch,\n                pixel_array,\n            )\n            new_array = np.array(\n                (background_array * pixel_array.astype(\"float\") / 255),\n                dtype=self.camera.pixel_array_dtype,\n            )\n            if curr_array is None:\n                curr_array = new_array\n            else:\n                curr_array = np.maximum(curr_array, new_array)\n            self.reset_pixel_array()\n        return curr_array"}, {"name": "BackgroundRectangle", "code": "class BackgroundRectangle(SurroundingRectangle):\n    \"\"\"A background rectangle. Its default color is the background color\n    of the scene.\n\n    Examples\n    --------\n    .. manim:: ExampleBackgroundRectangle\n        :save_last_frame:\n\n        class ExampleBackgroundRectangle(Scene):\n            def construct(self):\n                circle = Circle().shift(LEFT)\n                circle.set_stroke(color=GREEN, width=20)\n                triangle = Triangle().shift(2 * RIGHT)\n                triangle.set_fill(PINK, opacity=0.5)\n                backgroundRectangle1 = BackgroundRectangle(circle, color=WHITE, fill_opacity=0.15)\n                backgroundRectangle2 = BackgroundRectangle(triangle, color=WHITE, fill_opacity=0.15)\n                self.add(backgroundRectangle1)\n                self.add(backgroundRectangle2)\n                self.add(circle)\n                self.add(triangle)\n                self.play(Rotate(backgroundRectangle1, PI / 4))\n                self.play(Rotate(backgroundRectangle2, PI / 2))\n    \"\"\"\n\n    def __init__(\n        self,\n        *mobjects: Mobject,\n        color: ParsableManimColor | None = None,\n        stroke_width: float = 0,\n        stroke_opacity: float = 0,\n        fill_opacity: float = 0.75,\n        buff: float = 0,\n        **kwargs: Any,\n    ) -> None:\n        if color is None:\n            color = config.background_color\n\n        super().__init__(\n            *mobjects,\n            color=color,\n            stroke_width=stroke_width,\n            stroke_opacity=stroke_opacity,\n            fill_opacity=fill_opacity,\n            buff=buff,\n            **kwargs,\n        )\n        self.original_fill_opacity: float = self.fill_opacity\n\n    def pointwise_become_partial(self, mobject: Mobject, a: Any, b: float) -> Self:\n        self.set_fill(opacity=b * self.original_fill_opacity)\n        return self\n\n    def set_style(self, fill_opacity: float, **kwargs: Any) -> Self:  # type: ignore[override]\n        # Unchangeable style, except for fill_opacity\n        # All other style arguments are ignored\n        super().set_style(\n            stroke_color=BLACK,\n            stroke_width=0,\n            fill_color=BLACK,\n            fill_opacity=fill_opacity,\n        )\n        if len(kwargs) > 0:\n            logger.info(\n                \"Argument %s is ignored in BackgroundRectangle.set_style.\",\n                kwargs,\n            )\n        return self\n\n    def get_fill_color(self) -> ManimColor:\n        # The type of the color property is set to Any using the property decorator\n        # vectorized_mobject.py#L571\n        temp_color: ManimColor = self.color\n        return temp_color"}, {"name": "BarChart", "code": "class BarChart(Axes):\n    \"\"\"Creates a bar chart. Inherits from :class:`~.Axes`, so it shares its methods\n    and attributes. Each axis inherits from :class:`~.NumberLine`, so pass in ``x_axis_config``/``y_axis_config``\n    to control their attributes.\n\n    Parameters\n    ----------\n    values\n        A sequence of values that determines the height of each bar. Accepts negative values.\n    bar_names\n        A sequence of names for each bar. Does not have to match the length of ``values``.\n    y_range\n        The y_axis range of values. If ``None``, the range will be calculated based on the\n        min/max of ``values`` and the step will be calculated based on ``y_length``.\n    x_length\n        The length of the x-axis. If ``None``, it is automatically calculated based on\n        the number of values and the width of the screen.\n    y_length\n        The length of the y-axis.\n    bar_colors\n        The color for the bars. Accepts a sequence of colors (can contain just one item).\n        If the length of``bar_colors`` does not match that of ``values``,\n        intermediate colors will be automatically determined.\n    bar_width\n        The length of a bar. Must be between 0 and 1.\n    bar_fill_opacity\n        The fill opacity of the bars.\n    bar_stroke_width\n        The stroke width of the bars.\n\n    Examples\n    --------\n    .. manim:: BarChartExample\n        :save_last_frame:\n\n        class BarChartExample(Scene):\n            def construct(self):\n                chart = BarChart(\n                    values=[-5, 40, -10, 20, -3],\n                    bar_names=[\"one\", \"two\", \"three\", \"four\", \"five\"],\n                    y_range=[-20, 50, 10],\n                    y_length=6,\n                    x_length=10,\n                    x_axis_config={\"font_size\": 36},\n                )\n\n                c_bar_lbls = chart.get_bar_labels(font_size=48)\n\n                self.add(chart, c_bar_lbls)\n    \"\"\"\n\n    def __init__(\n        self,\n        values: MutableSequence[float],\n        bar_names: Sequence[str] | None = None,\n        y_range: Sequence[float] | None = None,\n        x_length: float | None = None,\n        y_length: float | None = None,\n        bar_colors: Iterable[str] = [\n            \"#003f5c\",\n            \"#58508d\",\n            \"#bc5090\",\n            \"#ff6361\",\n            \"#ffa600\",\n        ],\n        bar_width: float = 0.6,\n        bar_fill_opacity: float = 0.7,\n        bar_stroke_width: float = 3,\n        **kwargs,\n    ):\n        if isinstance(bar_colors, str):\n            logger.warning(\n                \"Passing a string to `bar_colors` has been deprecated since v0.15.2 and will be removed after v0.17.0, the parameter must be a list.  \"\n            )\n            bar_colors = list(bar_colors)\n\n        y_length = y_length if y_length is not None else config.frame_height - 4\n\n        self.values = values\n        self.bar_names = bar_names\n        self.bar_colors = bar_colors\n        self.bar_width = bar_width\n        self.bar_fill_opacity = bar_fill_opacity\n        self.bar_stroke_width = bar_stroke_width\n\n        x_range = [0, len(self.values), 1]\n\n        if y_range is None:\n            y_range = [\n                min(0, min(self.values)),\n                max(0, max(self.values)),\n                round(max(self.values) / y_length, 2),\n            ]\n\n        elif len(y_range) == 2:\n            y_range = [*y_range, round(max(self.values) / y_length, 2)]\n\n        if x_length is None:\n            x_length = min(len(self.values), config.frame_width - 2)\n\n        x_axis_config = {\"font_size\": 24, \"label_constructor\": Tex}\n        self._update_default_configs(\n            (x_axis_config,), (kwargs.pop(\"x_axis_config\", None),)\n        )\n\n        self.bars: VGroup = VGroup()\n        self.x_labels: VGroup | None = None\n        self.bar_labels: VGroup | None = None\n\n        super().__init__(\n            x_range=x_range,\n            y_range=y_range,\n            x_length=x_length,\n            y_length=y_length,\n            x_axis_config=x_axis_config,\n            tips=kwargs.pop(\"tips\", False),\n            **kwargs,\n        )\n\n        self._add_bars()\n\n        if self.bar_names is not None:\n            self._add_x_axis_labels()\n\n        self.y_axis.add_numbers()\n\n    def _update_colors(self):\n        \"\"\"Initialize the colors of the bars of the chart.\n\n        Sets the color of ``self.bars`` via ``self.bar_colors``.\n\n        Primarily used when the bars are initialized with ``self._add_bars``\n        or updated via ``self.change_bar_values``.\n        \"\"\"\n        self.bars.set_color_by_gradient(*self.bar_colors)\n\n    def _add_x_axis_labels(self):\n        \"\"\"Essentially :meth`:~.NumberLine.add_labels`, but differs in that\n        the direction of the label with respect to the x_axis changes to UP or DOWN\n        depending on the value.\n\n        UP for negative values and DOWN for positive values.\n        \"\"\"\n        val_range = np.arange(\n            0.5, len(self.bar_names), 1\n        )  # 0.5 shifted so that labels are centered, not on ticks\n\n        labels = VGroup()\n\n        for i, (value, bar_name) in enumerate(zip(val_range, self.bar_names)):\n            # to accommodate negative bars, the label may need to be\n            # below or above the x_axis depending on the value of the bar\n            direction = UP if self.values[i] < 0 else DOWN\n            bar_name_label = self.x_axis.label_constructor(bar_name)\n\n            bar_name_label.font_size = self.x_axis.font_size\n            bar_name_label.next_to(\n                self.x_axis.number_to_point(value),\n                direction=direction,\n                buff=self.x_axis.line_to_number_buff,\n            )\n\n            labels.add(bar_name_label)\n\n        self.x_axis.labels = labels\n        self.x_axis.add(labels)\n\n    def _create_bar(self, bar_number: int, value: float) -> Rectangle:\n        \"\"\"Creates a positioned bar on the chart.\n\n        Parameters\n        ----------\n        bar_number\n            Determines the x-position of the bar.\n        value\n            The value that determines the height of the bar.\n\n        Returns\n        -------\n        Rectangle\n            A positioned rectangle representing a bar on the chart.\n        \"\"\"\n        # bar measurements relative to the axis\n\n        # distance from between the y-axis and the top of the bar\n        bar_h = abs(self.c2p(0, value)[1] - self.c2p(0, 0)[1])\n        # width of the bar\n        bar_w = self.c2p(self.bar_width, 0)[0] - self.c2p(0, 0)[0]\n\n        bar = Rectangle(\n            height=bar_h,\n            width=bar_w,\n            stroke_width=self.bar_stroke_width,\n            fill_opacity=self.bar_fill_opacity,\n        )\n\n        pos = UP if (value >= 0) else DOWN\n        bar.next_to(self.c2p(bar_number + 0.5, 0), pos, buff=0)\n        return bar\n\n    def _add_bars(self) -> None:\n        for i, value in enumerate(self.values):\n            tmp_bar = self._create_bar(bar_number=i, value=value)\n            self.bars.add(tmp_bar)\n\n        self._update_colors()\n        self.add_to_back(self.bars)\n\n    def get_bar_labels(\n        self,\n        color: ParsableManimColor | None = None,\n        font_size: float = 24,\n        buff: float = MED_SMALL_BUFF,\n        label_constructor: type[VMobject] = Tex,\n    ):\n        \"\"\"Annotates each bar with its corresponding value. Use ``self.bar_labels`` to access the\n        labels after creation.\n\n        Parameters\n        ----------\n        color\n            The color of each label. By default ``None`` and is based on the parent's bar color.\n        font_size\n            The font size of each label.\n        buff\n            The distance from each label to its bar. By default 0.4.\n        label_constructor\n            The Mobject class to construct the labels, by default :class:`~.Tex`.\n\n        Examples\n        --------\n        .. manim:: GetBarLabelsExample\n            :save_last_frame:\n\n            class GetBarLabelsExample(Scene):\n                def construct(self):\n                    chart = BarChart(values=[10, 9, 8, 7, 6, 5, 4, 3, 2, 1], y_range=[0, 10, 1])\n\n                    c_bar_lbls = chart.get_bar_labels(\n                        color=WHITE, label_constructor=MathTex, font_size=36\n                    )\n\n                    self.add(chart, c_bar_lbls)\n        \"\"\"\n        bar_labels = VGroup()\n        for bar, value in zip(self.bars, self.values):\n            bar_lbl = label_constructor(str(value))\n\n            if color is None:\n                bar_lbl.set_color(bar.get_fill_color())\n            else:\n                bar_lbl.set_color(color)\n\n            bar_lbl.font_size = font_size\n\n            pos = UP if (value >= 0) else DOWN\n            bar_lbl.next_to(bar, pos, buff=buff)\n            bar_labels.add(bar_lbl)\n\n        return bar_labels\n\n    def change_bar_values(self, values: Iterable[float], update_colors: bool = True):\n        \"\"\"Updates the height of the bars of the chart.\n\n        Parameters\n        ----------\n        values\n            The values that will be used to update the height of the bars.\n            Does not have to match the number of bars.\n        update_colors\n            Whether to re-initalize the colors of the bars based on ``self.bar_colors``.\n\n        Examples\n        --------\n        .. manim:: ChangeBarValuesExample\n            :save_last_frame:\n\n            class ChangeBarValuesExample(Scene):\n                def construct(self):\n                    values=[-10, -8, -6, -4, -2, 0, 2, 4, 6, 8, 10]\n\n                    chart = BarChart(\n                        values,\n                        y_range=[-10, 10, 2],\n                        y_axis_config={\"font_size\": 24},\n                    )\n                    self.add(chart)\n\n                    chart.change_bar_values(list(reversed(values)))\n                    self.add(chart.get_bar_labels(font_size=24))\n        \"\"\"\n        for i, (bar, value) in enumerate(zip(self.bars, values)):\n            chart_val = self.values[i]\n\n            if chart_val > 0:\n                bar_lim = bar.get_bottom()\n                aligned_edge = DOWN\n            else:\n                bar_lim = bar.get_top()\n                aligned_edge = UP\n\n            # check if the bar has height\n            if chart_val != 0:\n                quotient = value / chart_val\n                if quotient < 0:\n                    aligned_edge = UP if chart_val > 0 else DOWN\n\n                    # if the bar is already positive, then we now want to move it\n                    # so that it is negative. So, we move the top edge of the bar\n                    # to the location of the previous bottom\n\n                    # if already negative, then we move the bottom edge of the bar\n                    # to the location of the previous top\n\n                bar.stretch_to_fit_height(abs(quotient) * bar.height)\n\n            else:\n                # create a new bar since the current one has a height of zero (doesn't exist)\n                temp_bar = self._create_bar(i, value)\n                self.bars.remove(bar)\n                self.bars.insert(i, temp_bar)\n\n            bar.move_to(bar_lim, aligned_edge)\n\n        if update_colors:\n            self._update_colors()\n\n        self.values[: len(values)] = values"}, {"name": "batch_by_property", "code": "def batch_by_property(\n    items: Iterable[T], property_func: Callable[[T], U]\n) -> list[tuple[list[T], U | None]]:\n    \"\"\"Takes in a Sequence, and returns a list of tuples, (batch, prop)\n    such that all items in a batch have the same output when\n    put into the Callable property_func, and such that chaining all these\n    batches together would give the original Sequence (i.e. order is\n    preserved).\n\n    Examples\n    --------\n    .. code-block:: pycon\n\n        >>> batch_by_property([(1, 2), (3, 4), (5, 6, 7), (8, 9)], len)\n        [([(1, 2), (3, 4)], 2), ([(5, 6, 7)], 3), ([(8, 9)], 2)]\n    \"\"\"\n    batch_prop_pairs: list[tuple[list[T], U | None]] = []\n    curr_batch: list[T] = []\n    curr_prop = None\n    for item in items:\n        prop = property_func(item)\n        if prop != curr_prop:\n            # Add current batch\n            if len(curr_batch) > 0:\n                batch_prop_pairs.append((curr_batch, curr_prop))\n            # Redefine curr\n            curr_prop = prop\n            curr_batch = [item]\n        else:\n            curr_batch.append(item)\n    if len(curr_batch) > 0:\n        batch_prop_pairs.append((curr_batch, curr_prop))\n    return batch_prop_pairs"}, {"name": "bezier", "code": "def bezier(\n    points: Point3D_Array | Sequence[Point3D_Array],\n) -> Callable[[float | ColVector], Point3D_Array]:\n    \"\"\"Classic implementation of a B\u00e9zier curve.\n\n    Parameters\n    ----------\n    points\n        :math:`(d+1, 3)`-shaped array of :math:`d+1` control points defining a single B\u00e9zier\n        curve of degree :math:`d`. Alternatively, for vectorization purposes, ``points`` can\n        also be a :math:`(d+1, M, 3)`-shaped sequence of :math:`d+1` arrays of :math:`M`\n        control points each, which define `M` B\u00e9zier curves instead.\n\n    Returns\n    -------\n    bezier_func : :class:`typing.Callable` [[:class:`float` | :class:`~.ColVector`], :class:`~.Point3D` | :class:`~.Point3D_Array`]\n        Function describing the B\u00e9zier curve. The behaviour of this function depends on\n        the shape of ``points``:\n\n            *   If ``points`` was a :math:`(d+1, 3)` array representing a single B\u00e9zier curve,\n                then ``bezier_func`` can receive either:\n\n                *   a :class:`float` ``t``, in which case it returns a\n                    single :math:`(1, 3)`-shaped :class:`~.Point3D` representing the evaluation\n                    of the B\u00e9zier at ``t``, or\n                *   an :math:`(n, 1)`-shaped :class:`~.ColVector`\n                    containing :math:`n` values to evaluate the B\u00e9zier curve at, returning instead\n                    an :math:`(n, 3)`-shaped :class:`~.Point3D_Array` containing the points\n                    resulting from evaluating the B\u00e9zier at each of the :math:`n` values.\n                .. warning::\n                    If passing a vector of :math:`t`-values to ``bezier_func``, it **must**\n                    be a column vector/matrix of shape :math:`(n, 1)`. Passing an 1D array of\n                    shape :math:`(n,)` is not supported and **will result in undefined behaviour**.\n\n            *   If ``points`` was a :math:`(d+1, M, 3)` array describing :math:`M` B\u00e9zier curves,\n                then ``bezier_func`` can receive either:\n\n                *   a :class:`float` ``t``, in which case it returns an\n                    :math:`(M, 3)`-shaped :class:`~.Point3D_Array` representing the evaluation\n                    of the :math:`M` B\u00e9zier curves at the same value ``t``, or\n                *   an :math:`(M, 1)`-shaped\n                    :class:`~.ColVector` containing :math:`M` values, such that the :math:`i`-th\n                    B\u00e9zier curve defined by ``points`` is evaluated at the corresponding :math:`i`-th\n                    value in ``t``, returning again an :math:`(M, 3)`-shaped :class:`~.Point3D_Array`\n                    containing those :math:`M` evaluations.\n                .. warning::\n                    Unlike the previous case, if you pass a :class:`~.ColVector` to ``bezier_func``,\n                    it **must** contain exactly :math:`M` values, each value for each of the :math:`M`\n                    B\u00e9zier curves defined by ``points``. Any array of shape other than :math:`(M, 1)`\n                    **will result in undefined behaviour**.\n    \"\"\"\n    P = np.asarray(points)\n    degree = P.shape[0] - 1\n\n    if degree == 0:\n\n        def zero_bezier(t: float | ColVector) -> Point3D | Point3D_Array:\n            return np.ones_like(t) * P[0]\n\n        return zero_bezier\n\n    if degree == 1:\n\n        def linear_bezier(t: float | ColVector) -> Point3D | Point3D_Array:\n            return P[0] + t * (P[1] - P[0])\n\n        return linear_bezier\n\n    if degree == 2:\n\n        def quadratic_bezier(t: float | ColVector) -> Point3D | Point3D_Array:\n            t2 = t * t\n            mt = 1 - t\n            mt2 = mt * mt\n            return mt2 * P[0] + 2 * t * mt * P[1] + t2 * P[2]\n\n        return quadratic_bezier\n\n    if degree == 3:\n\n        def cubic_bezier(t: float | ColVector) -> Point3D | Point3D_Array:\n            t2 = t * t\n            t3 = t2 * t\n            mt = 1 - t\n            mt2 = mt * mt\n            mt3 = mt2 * mt\n            return mt3 * P[0] + 3 * t * mt2 * P[1] + 3 * t2 * mt * P[2] + t3 * P[3]\n\n        return cubic_bezier\n\n    def nth_grade_bezier(t: float | ColVector) -> Point3D | Point3D_Array:\n        is_scalar = not isinstance(t, np.ndarray)\n        if is_scalar:\n            B = np.empty((1, *P.shape))\n        else:\n            assert isinstance(t, np.ndarray)\n            t = t.reshape(-1, *[1 for dim in P.shape])\n            B = np.empty((t.shape[0], *P.shape))\n        B[:] = P\n\n        for i in range(degree):\n            # After the i-th iteration (i in [0, ..., d-1]) there are evaluations at t\n            # of (d-i) Bezier curves of grade (i+1), stored in the first d-i slots of B\n            B[:, : degree - i] += t * (B[:, 1 : degree - i + 1] - B[:, : degree - i])\n\n        # In the end, there shall be the evaluation at t of a single Bezier curve of\n        # grade d, stored in the first slot of B\n        if is_scalar:\n            val: Point3D = B[0, 0]\n            return val\n        return B[:, 0]\n\n    return nth_grade_bezier"}, {"name": "bezier_remap", "code": "def bezier_remap(\n    bezier_tuples: BezierPointsLike_Array,\n    new_number_of_curves: int,\n) -> BezierPoints_Array:\n    \"\"\"Subdivides each curve in ``bezier_tuples`` into as many parts as necessary, until the final number of\n    curves reaches a desired amount, ``new_number_of_curves``.\n\n    Parameters\n    ----------\n    bezier_tuples\n        An array of multiple B\u00e9zier curves of degree :math:`d` to be remapped. The shape of this array\n        must be ``(current_number_of_curves, nppc, dim)``, where:\n\n        *   ``current_number_of_curves`` is the current amount of curves in the array ``bezier_tuples``,\n        *   ``nppc`` is the amount of points per curve, such that their degree is ``nppc-1``, and\n        *   ``dim`` is the dimension of the points, usually :math:`3`.\n\n    new_number_of_curves\n        The number of curves that the output will contain. This needs to be higher than the current number.\n\n    Returns\n    -------\n    :class:`~.BezierPoints_Array`\n        The new array of shape ``(new_number_of_curves, nppc, dim)``,\n        containing the new B\u00e9zier curves after the remap.\n    \"\"\"\n    bezier_tuples = np.asarray(bezier_tuples)\n    current_number_of_curves, nppc, dim = bezier_tuples.shape\n    # This is an array with values ranging from 0\n    # up to curr_num_curves,  with repeats such that\n    # its total length is target_num_curves.  For example,\n    # with curr_num_curves = 10, target_num_curves = 15, this\n    # would be [0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9].\n    repeat_indices = (\n        np.arange(new_number_of_curves, dtype=\"i\") * current_number_of_curves\n    ) // new_number_of_curves\n\n    # If the nth term of this list is k, it means\n    # that the nth curve of our path should be split\n    # into k pieces.\n    # In the above example our array had the following elements\n    # [0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9]\n    # We have two 0s, one 1, two 2s and so on.\n    # The split factors array would hence be:\n    # [2, 1, 2, 1, 2, 1, 2, 1, 2, 1]\n    split_factors = np.zeros(current_number_of_curves, dtype=\"i\")\n    np.add.at(split_factors, repeat_indices, 1)\n\n    new_tuples = np.empty((new_number_of_curves, nppc, dim))\n    index = 0\n    for curve, sf in zip(bezier_tuples, split_factors):\n        new_tuples[index : index + sf] = subdivide_bezier(curve, sf).reshape(\n            sf, nppc, dim\n        )\n        index += sf\n\n    return new_tuples"}, {"name": "binary_search", "code": "def binary_search(\n    function: Callable[[float], float],\n    target: float,\n    lower_bound: float,\n    upper_bound: float,\n    tolerance: float = 1e-4,\n) -> float | None:\n    \"\"\"Searches for a value in a range by repeatedly dividing the range in half.\n\n    To be more precise, performs numerical binary search to determine the\n    input to ``function``, between the bounds given, that outputs ``target``\n    to within ``tolerance`` (default of 0.0001).\n    Returns ``None`` if no input can be found within the bounds.\n\n    Examples\n    --------\n\n    Consider the polynomial :math:`x^2 + 3x + 1` where we search for\n    a target value of :math:`11`. An exact solution is :math:`x = 2`.\n\n    ::\n\n        >>> solution = binary_search(lambda x: x**2 + 3*x + 1, 11, 0, 5)\n        >>> bool(abs(solution - 2) < 1e-4)\n        True\n        >>> solution = binary_search(lambda x: x**2 + 3*x + 1, 11, 0, 5, tolerance=0.01)\n        >>> bool(abs(solution - 2) < 0.01)\n        True\n\n    Searching in the interval :math:`[0, 5]` for a target value of :math:`71`\n    does not yield a solution::\n\n        >>> binary_search(lambda x: x**2 + 3*x + 1, 71, 0, 5) is None\n        True\n    \"\"\"\n    lh = lower_bound\n    rh = upper_bound\n    mh: float = np.mean(np.array([lh, rh]))\n    while abs(rh - lh) > tolerance:\n        mh = np.mean(np.array([lh, rh]))\n        lx, mx, rx = (function(h) for h in (lh, mh, rh))\n        if lx == target:\n            return lh\n        if rx == target:\n            return rh\n\n        if lx <= target <= rx:\n            if mx > target:\n                rh = mh\n            else:\n                lh = mh\n        elif lx > target > rx:\n            lh, rh = rh, lh\n        else:\n            return None\n\n    return mh"}, {"name": "Blink", "code": "class Blink(Succession):\n    \"\"\"Blink the mobject.\n\n    Parameters\n    ----------\n    mobject\n        The mobject to be blinked.\n    time_on\n        The duration that the mobject is shown for one blink.\n    time_off\n        The duration that the mobject is hidden for one blink.\n    blinks\n        The number of blinks\n    hide_at_end\n        Whether to hide the mobject at the end of the animation.\n    kwargs\n        Additional arguments to be passed to the :class:`~.Succession` constructor.\n\n    Examples\n    --------\n\n    .. manim:: BlinkingExample\n\n        class BlinkingExample(Scene):\n            def construct(self):\n                text = Text(\"Blinking\").scale(1.5)\n                self.add(text)\n                self.play(Blink(text, blinks=3))\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        time_on: float = 0.5,\n        time_off: float = 0.5,\n        blinks: int = 1,\n        hide_at_end: bool = False,\n        **kwargs,\n    ):\n        animations = [\n            UpdateFromFunc(\n                mobject,\n                update_function=lambda mob: mob.set_opacity(1.0),\n                run_time=time_on,\n            ),\n            UpdateFromFunc(\n                mobject,\n                update_function=lambda mob: mob.set_opacity(0.0),\n                run_time=time_off,\n            ),\n        ] * blinks\n\n        if not hide_at_end:\n            animations.append(\n                UpdateFromFunc(\n                    mobject,\n                    update_function=lambda mob: mob.set_opacity(1.0),\n                    run_time=time_on,\n                ),\n            )\n\n        super().__init__(*animations, **kwargs)"}, {"name": "Brace", "code": "class Brace(VMobjectFromSVGPath):\n    \"\"\"Takes a mobject and draws a brace adjacent to it.\n\n    Passing a direction vector determines the direction from which the\n    brace is drawn. By default it is drawn from below.\n\n    Parameters\n    ----------\n    mobject\n        The mobject adjacent to which the brace is placed.\n    direction :\n        The direction from which the brace faces the mobject.\n\n    See Also\n    --------\n    :class:`BraceBetweenPoints`\n\n    Examples\n    --------\n    .. manim:: BraceExample\n        :save_last_frame:\n\n        class BraceExample(Scene):\n            def construct(self):\n                s = Square()\n                self.add(s)\n                for i in np.linspace(0.1,1.0,4):\n                    br = Brace(s, sharpness=i)\n                    t = Text(f\"sharpness= {i}\").next_to(br, RIGHT)\n                    self.add(t)\n                    self.add(br)\n                VGroup(*self.mobjects).arrange(DOWN, buff=0.2)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        direction: Vector3D | None = DOWN,\n        buff: float = 0.2,\n        sharpness: float = 2,\n        stroke_width: float = 0,\n        fill_opacity: float = 1.0,\n        background_stroke_width: float = 0,\n        background_stroke_color: ParsableManimColor = BLACK,\n        **kwargs,\n    ):\n        path_string_template = (\n            \"m0.01216 0c-0.01152 0-0.01216 6.103e-4 -0.01216 0.01311v0.007762c0.06776 \"\n            \"0.122 0.1799 0.1455 0.2307 0.1455h{0}c0.03046 3.899e-4 0.07964 0.00449 \"\n            \"0.1246 0.02636 0.0537 0.02695 0.07418 0.05816 0.08648 0.07769 0.001562 \"\n            \"0.002538 0.004539 0.002563 0.01098 0.002563 0.006444-2e-8 0.009421-2.47e-\"\n            \"5 0.01098-0.002563 0.0123-0.01953 0.03278-0.05074 0.08648-0.07769 0.04491\"\n            \"-0.02187 0.09409-0.02597 0.1246-0.02636h{0}c0.05077 0 0.1629-0.02346 \"\n            \"0.2307-0.1455v-0.007762c-1.78e-6 -0.0125-6.365e-4 -0.01311-0.01216-0.0131\"\n            \"1-0.006444-3.919e-8 -0.009348 2.448e-5 -0.01091 0.002563-0.0123 0.01953-\"\n            \"0.03278 0.05074-0.08648 0.07769-0.04491 0.02187-0.09416 0.02597-0.1246 \"\n            \"0.02636h{1}c-0.04786 0-0.1502 0.02094-0.2185 0.1256-0.06833-0.1046-0.1706\"\n            \"-0.1256-0.2185-0.1256h{1}c-0.03046-3.899e-4 -0.07972-0.004491-0.1246-0.02\"\n            \"636-0.0537-0.02695-0.07418-0.05816-0.08648-0.07769-0.001562-0.002538-\"\n            \"0.004467-0.002563-0.01091-0.002563z\"\n        )\n        default_min_width = 0.90552\n\n        self.buff = buff\n\n        angle = -np.arctan2(*direction[:2]) + np.pi\n        mobject.rotate(-angle, about_point=ORIGIN)\n        left = mobject.get_corner(DOWN + LEFT)\n        right = mobject.get_corner(DOWN + RIGHT)\n        target_width = right[0] - left[0]\n        linear_section_length = max(\n            0,\n            (target_width * sharpness - default_min_width) / 2,\n        )\n\n        path = se.Path(\n            path_string_template.format(\n                linear_section_length,\n                -linear_section_length,\n            )\n        )\n\n        super().__init__(\n            path_obj=path,\n            stroke_width=stroke_width,\n            fill_opacity=fill_opacity,\n            background_stroke_width=background_stroke_width,\n            background_stroke_color=background_stroke_color,\n            **kwargs,\n        )\n        self.flip(RIGHT)\n        self.stretch_to_fit_width(target_width)\n        self.shift(left - self.get_corner(UP + LEFT) + self.buff * DOWN)\n\n        for mob in mobject, self:\n            mob.rotate(angle, about_point=ORIGIN)\n\n    def put_at_tip(self, mob: Mobject, use_next_to: bool = True, **kwargs):\n        \"\"\"Puts the given mobject at the brace tip.\n\n        Parameters\n        ----------\n        mob\n            The mobject to be placed at the tip.\n        use_next_to\n            If true, then :meth:`next_to` is used to place the mobject at the\n            tip.\n        kwargs\n            Any additional keyword arguments are passed to :meth:`next_to` which\n            is used to put the mobject next to the brace tip.\n        \"\"\"\n        if use_next_to:\n            mob.next_to(self.get_tip(), np.round(self.get_direction()), **kwargs)\n        else:\n            mob.move_to(self.get_tip())\n            buff = kwargs.get(\"buff\", DEFAULT_MOBJECT_TO_MOBJECT_BUFFER)\n            shift_distance = mob.width / 2.0 + buff\n            mob.shift(self.get_direction() * shift_distance)\n        return self\n\n    def get_text(self, *text, **kwargs):\n        \"\"\"Places the text at the brace tip.\n\n        Parameters\n        ----------\n        text\n            The text to be placed at the brace tip.\n        kwargs\n            Any additional keyword arguments are passed to :meth:`.put_at_tip` which\n            is used to position the text at the brace tip.\n\n        Returns\n        -------\n        :class:`~.Tex`\n        \"\"\"\n        text_mob = Tex(*text)\n        self.put_at_tip(text_mob, **kwargs)\n        return text_mob\n\n    def get_tex(self, *tex, **kwargs):\n        \"\"\"Places the tex at the brace tip.\n\n        Parameters\n        ----------\n        tex\n            The tex to be placed at the brace tip.\n        kwargs\n            Any further keyword arguments are passed to :meth:`.put_at_tip` which\n            is used to position the tex at the brace tip.\n\n        Returns\n        -------\n        :class:`~.MathTex`\n        \"\"\"\n        tex_mob = MathTex(*tex)\n        self.put_at_tip(tex_mob, **kwargs)\n        return tex_mob\n\n    def get_tip(self):\n        \"\"\"Returns the point at the brace tip.\"\"\"\n        # Returns the position of the seventh point in the path, which is the tip.\n        if config[\"renderer\"] == \"opengl\":\n            return self.points[34]\n\n        return self.points[28]  # = 7*4\n\n    def get_direction(self):\n        \"\"\"Returns the direction from the center to the brace tip.\"\"\"\n        vect = self.get_tip() - self.get_center()\n        return vect / np.linalg.norm(vect)"}, {"name": "BraceBetweenPoints", "code": "class BraceBetweenPoints(Brace):\n    \"\"\"Similar to Brace, but instead of taking a mobject it uses 2\n    points to place the brace.\n\n    A fitting direction for the brace is\n    computed, but it still can be manually overridden.\n    If the points go from left to right, the brace is drawn from below.\n    Swapping the points places the brace on the opposite side.\n\n    Parameters\n    ----------\n    point_1 :\n        The first point.\n    point_2 :\n        The second point.\n    direction :\n        The direction from which the brace faces towards the points.\n\n    Examples\n    --------\n        .. manim:: BraceBPExample\n\n            class BraceBPExample(Scene):\n                def construct(self):\n                    p1 = [0,0,0]\n                    p2 = [1,2,0]\n                    brace = BraceBetweenPoints(p1,p2)\n                    self.play(Create(NumberPlane()))\n                    self.play(Create(brace))\n                    self.wait(2)\n    \"\"\"\n\n    def __init__(\n        self,\n        point_1: Point3DLike | None,\n        point_2: Point3DLike | None,\n        direction: Vector3D | None = ORIGIN,\n        **kwargs,\n    ):\n        if all(direction == ORIGIN):\n            line_vector = np.array(point_2) - np.array(point_1)\n            direction = np.array([line_vector[1], -line_vector[0], 0])\n        super().__init__(Line(point_1, point_2), direction=direction, **kwargs)"}, {"name": "BraceLabel", "code": "class BraceLabel(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"Create a brace with a label attached.\n\n    Parameters\n    ----------\n    obj\n        The mobject adjacent to which the brace is placed.\n    text\n        The label text.\n    brace_direction\n        The direction of the brace. By default ``DOWN``.\n    label_constructor\n        A class or function used to construct a mobject representing\n        the label. By default :class:`~.MathTex`.\n    font_size\n        The font size of the label, passed to the ``label_constructor``.\n    buff\n        The buffer between the mobject and the brace.\n    brace_config\n        Arguments to be passed to :class:`.Brace`.\n    kwargs\n        Additional arguments to be passed to :class:`~.VMobject`.\n    \"\"\"\n\n    def __init__(\n        self,\n        obj: Mobject,\n        text: str,\n        brace_direction: np.ndarray = DOWN,\n        label_constructor: type = MathTex,\n        font_size: float = DEFAULT_FONT_SIZE,\n        buff: float = 0.2,\n        brace_config: dict | None = None,\n        **kwargs,\n    ):\n        self.label_constructor = label_constructor\n        super().__init__(**kwargs)\n\n        self.brace_direction = brace_direction\n        if brace_config is None:\n            brace_config = {}\n        self.brace = Brace(obj, brace_direction, buff, **brace_config)\n\n        if isinstance(text, (tuple, list)):\n            self.label = self.label_constructor(*text, font_size=font_size, **kwargs)\n        else:\n            self.label = self.label_constructor(str(text), font_size=font_size)\n\n        self.brace.put_at_tip(self.label)\n        self.add(self.brace, self.label)\n\n    def creation_anim(self, label_anim=FadeIn, brace_anim=GrowFromCenter):\n        return AnimationGroup(brace_anim(self.brace), label_anim(self.label))\n\n    def shift_brace(self, obj, **kwargs):\n        if isinstance(obj, list):\n            obj = self.get_group_class()(*obj)\n        self.brace = Brace(obj, self.brace_direction, **kwargs)\n        self.brace.put_at_tip(self.label)\n        return self\n\n    def change_label(self, *text, **kwargs):\n        self.label = self.label_constructor(*text, **kwargs)\n\n        self.brace.put_at_tip(self.label)\n        return self\n\n    def change_brace_label(self, obj, *text, **kwargs):\n        self.shift_brace(obj)\n        self.change_label(*text, **kwargs)\n        return self"}, {"name": "BraceText", "code": "class BraceText(BraceLabel):\n    def __init__(self, obj, text, label_constructor=Tex, **kwargs):\n        super().__init__(obj, text, label_constructor=label_constructor, **kwargs)"}, {"name": "Broadcast", "code": "class Broadcast(LaggedStart):\n    \"\"\"Broadcast a mobject starting from an ``initial_width``, up to the actual size of the mobject.\n\n    Parameters\n    ----------\n    mobject\n        The mobject to be broadcast.\n    focal_point\n        The center of the broadcast, by default ORIGIN.\n    n_mobs\n        The number of mobjects that emerge from the focal point, by default 5.\n    initial_opacity\n        The starting stroke opacity of the mobjects emitted from the broadcast, by default 1.\n    final_opacity\n        The final stroke opacity of the mobjects emitted from the broadcast, by default 0.\n    initial_width\n        The initial width of the mobjects, by default 0.0.\n    remover\n        Whether the mobjects should be removed from the scene after the animation, by default True.\n    lag_ratio\n        The time between each iteration of the mobject, by default 0.2.\n    run_time\n        The total duration of the animation, by default 3.\n    kwargs\n        Additional arguments to be passed to :class:`~.LaggedStart`.\n\n    Examples\n    ---------\n\n    .. manim:: BroadcastExample\n\n        class BroadcastExample(Scene):\n            def construct(self):\n                mob = Circle(radius=4, color=TEAL_A)\n                self.play(Broadcast(mob))\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject,\n        focal_point: Sequence[float] = ORIGIN,\n        n_mobs: int = 5,\n        initial_opacity: float = 1,\n        final_opacity: float = 0,\n        initial_width: float = 0.0,\n        remover: bool = True,\n        lag_ratio: float = 0.2,\n        run_time: float = 3,\n        **kwargs: Any,\n    ):\n        self.focal_point = focal_point\n        self.n_mobs = n_mobs\n        self.initial_opacity = initial_opacity\n        self.final_opacity = final_opacity\n        self.initial_width = initial_width\n\n        anims = []\n\n        # Works by saving the mob that is passed into the animation, scaling it to 0 (or the initial_width) and then restoring the original mob.\n        fill_o = bool(mobject.fill_opacity)\n\n        for _ in range(self.n_mobs):\n            mob = mobject.copy()\n\n            if fill_o:\n                mob.set_opacity(self.final_opacity)\n            else:\n                mob.set_stroke(opacity=self.final_opacity)\n\n            mob.move_to(self.focal_point)\n            mob.save_state()\n            mob.set(width=self.initial_width)\n\n            if fill_o:\n                mob.set_opacity(self.initial_opacity)\n            else:\n                mob.set_stroke(opacity=self.initial_opacity)\n\n            anims.append(Restore(mob, remover=remover))\n\n        super().__init__(*anims, run_time=run_time, lag_ratio=lag_ratio, **kwargs)"}, {"name": "build_matrix_lists", "code": "def build_matrix_lists(mob):\n    root_hierarchical_matrix = mob.hierarchical_model_matrix()\n    matrix_to_mobject_list = collections.defaultdict(list)\n    if mob.has_points():\n        matrix_to_mobject_list[tuple(root_hierarchical_matrix.ravel())].append(mob)\n    mobject_to_hierarchical_matrix = {mob: root_hierarchical_matrix}\n    dfs = [mob]\n    while dfs:\n        parent = dfs.pop()\n        for child in parent.submobjects:\n            child_hierarchical_matrix = (\n                mobject_to_hierarchical_matrix[parent] @ child.model_matrix\n            )\n            mobject_to_hierarchical_matrix[child] = child_hierarchical_matrix\n            if child.has_points():\n                matrix_to_mobject_list[tuple(child_hierarchical_matrix.ravel())].append(\n                    child,\n                )\n            dfs.append(child)\n    return matrix_to_mobject_list"}, {"name": "BulletedList", "code": "class BulletedList(Tex):\n    \"\"\"A bulleted list.\n\n    Examples\n    --------\n\n    .. manim:: BulletedListExample\n        :save_last_frame:\n\n        class BulletedListExample(Scene):\n            def construct(self):\n                blist = BulletedList(\"Item 1\", \"Item 2\", \"Item 3\", height=2, width=2)\n                blist.set_color_by_tex(\"Item 1\", RED)\n                blist.set_color_by_tex(\"Item 2\", GREEN)\n                blist.set_color_by_tex(\"Item 3\", BLUE)\n                self.add(blist)\n    \"\"\"\n\n    def __init__(\n        self,\n        *items,\n        buff=MED_LARGE_BUFF,\n        dot_scale_factor=2,\n        tex_environment=None,\n        **kwargs,\n    ):\n        self.buff = buff\n        self.dot_scale_factor = dot_scale_factor\n        self.tex_environment = tex_environment\n        line_separated_items = [s + \"\\\\\\\\\" for s in items]\n        super().__init__(\n            *line_separated_items, tex_environment=tex_environment, **kwargs\n        )\n        for part in self:\n            dot = MathTex(\"\\\\cdot\").scale(self.dot_scale_factor)\n            dot.next_to(part[0], LEFT, SMALL_BUFF)\n            part.add_to_back(dot)\n        self.arrange(DOWN, aligned_edge=LEFT, buff=self.buff)\n\n    def fade_all_but(self, index_or_string, opacity=0.5):\n        arg = index_or_string\n        if isinstance(arg, str):\n            part = self.get_part_by_tex(arg)\n        elif isinstance(arg, int):\n            part = self.submobjects[arg]\n        else:\n            raise TypeError(f\"Expected int or string, got {arg}\")\n        for other_part in self.submobjects:\n            if other_part is part:\n                other_part.set_fill(opacity=1)\n            else:\n                other_part.set_fill(opacity=opacity)"}, {"name": "CairoRenderer", "code": "class CairoRenderer:\n    \"\"\"A renderer using Cairo.\n\n    num_plays : Number of play() functions in the scene.\n    time: time elapsed since initialisation of scene.\n    \"\"\"\n\n    def __init__(\n        self,\n        file_writer_class=SceneFileWriter,\n        camera_class=None,\n        skip_animations=False,\n        **kwargs,\n    ):\n        # All of the following are set to EITHER the value passed via kwargs,\n        # OR the value stored in the global config dict at the time of\n        # _instance construction_.\n        self._file_writer_class = file_writer_class\n        camera_cls = camera_class if camera_class is not None else Camera\n        self.camera = camera_cls()\n        self._original_skipping_status = skip_animations\n        self.skip_animations = skip_animations\n        self.animations_hashes = []\n        self.num_plays = 0\n        self.time = 0\n        self.static_image = None\n\n    def init_scene(self, scene):\n        self.file_writer: Any = self._file_writer_class(\n            self,\n            scene.__class__.__name__,\n        )\n\n    def play(\n        self,\n        scene: Scene,\n        *args: Animation | Mobject | _AnimationBuilder,\n        **kwargs,\n    ):\n        # Reset skip_animations to the original state.\n        # Needed when rendering only some animations, and skipping others.\n        self.skip_animations = self._original_skipping_status\n        self.update_skipping_status()\n\n        scene.compile_animation_data(*args, **kwargs)\n\n        if self.skip_animations:\n            logger.debug(f\"Skipping animation {self.num_plays}\")\n            hash_current_animation = None\n            self.time += scene.duration\n        else:\n            if config[\"disable_caching\"]:\n                logger.info(\"Caching disabled.\")\n                hash_current_animation = f\"uncached_{self.num_plays:05}\"\n            else:\n                hash_current_animation = get_hash_from_play_call(\n                    scene,\n                    self.camera,\n                    scene.animations,\n                    scene.mobjects,\n                )\n                if self.file_writer.is_already_cached(hash_current_animation):\n                    logger.info(\n                        f\"Animation {self.num_plays} : Using cached data (hash : %(hash_current_animation)s)\",\n                        {\"hash_current_animation\": hash_current_animation},\n                    )\n                    self.skip_animations = True\n                    self.time += scene.duration\n        # adding None as a partial movie file will make file_writer ignore the latter.\n        self.file_writer.add_partial_movie_file(hash_current_animation)\n        self.animations_hashes.append(hash_current_animation)\n        logger.debug(\n            \"List of the first few animation hashes of the scene: %(h)s\",\n            {\"h\": str(self.animations_hashes[:5])},\n        )\n\n        self.file_writer.begin_animation(not self.skip_animations)\n        scene.begin_animations()\n\n        # Save a static image, to avoid rendering non moving objects.\n        self.save_static_frame_data(scene, scene.static_mobjects)\n\n        if scene.is_current_animation_frozen_frame():\n            self.update_frame(scene, mobjects=scene.moving_mobjects)\n            # self.duration stands for the total run time of all the animations.\n            # In this case, as there is only a wait, it will be the length of the wait.\n            self.freeze_current_frame(scene.duration)\n        else:\n            scene.play_internal()\n        self.file_writer.end_animation(not self.skip_animations)\n\n        self.num_plays += 1\n\n    def update_frame(  # TODO Description in Docstring\n        self,\n        scene,\n        mobjects: typing.Iterable[Mobject] | None = None,\n        include_submobjects: bool = True,\n        ignore_skipping: bool = True,\n        **kwargs,\n    ):\n        \"\"\"Update the frame.\n\n        Parameters\n        ----------\n        scene\n\n        mobjects\n            list of mobjects\n\n        include_submobjects\n\n        ignore_skipping\n\n        **kwargs\n\n        \"\"\"\n        if self.skip_animations and not ignore_skipping:\n            return\n        if not mobjects:\n            mobjects = list_update(\n                scene.mobjects,\n                scene.foreground_mobjects,\n            )\n        if self.static_image is not None:\n            self.camera.set_frame_to_background(self.static_image)\n        else:\n            self.camera.reset()\n\n        kwargs[\"include_submobjects\"] = include_submobjects\n        self.camera.capture_mobjects(mobjects, **kwargs)\n\n    def render(self, scene, time, moving_mobjects):\n        self.update_frame(scene, moving_mobjects)\n        self.add_frame(self.get_frame())\n\n    def get_frame(self) -> PixelArray:\n        \"\"\"\n        Gets the current frame as NumPy array.\n\n        Returns\n        -------\n        np.array\n            NumPy array of pixel values of each pixel in screen.\n            The shape of the array is height x width x 3\n        \"\"\"\n        return np.array(self.camera.pixel_array)\n\n    def add_frame(self, frame: np.ndarray, num_frames: int = 1):\n        \"\"\"\n        Adds a frame to the video_file_stream\n\n        Parameters\n        ----------\n        frame\n            The frame to add, as a pixel array.\n        num_frames\n            The number of times to add frame.\n        \"\"\"\n        dt = 1 / self.camera.frame_rate\n        if self.skip_animations:\n            return\n        self.time += num_frames * dt\n        self.file_writer.write_frame(frame, num_frames=num_frames)\n\n    def freeze_current_frame(self, duration: float):\n        \"\"\"Adds a static frame to the movie for a given duration. The static frame is the current frame.\n\n        Parameters\n        ----------\n        duration\n            [description]\n        \"\"\"\n        dt = 1 / self.camera.frame_rate\n        self.add_frame(\n            self.get_frame(),\n            num_frames=int(duration / dt),\n        )\n\n    def show_frame(self):\n        \"\"\"\n        Opens the current frame in the Default Image Viewer\n        of your system.\n        \"\"\"\n        self.update_frame(ignore_skipping=True)\n        self.camera.get_image().show()\n\n    def save_static_frame_data(\n        self,\n        scene: Scene,\n        static_mobjects: typing.Iterable[Mobject],\n    ) -> typing.Iterable[Mobject] | None:\n        \"\"\"Compute and save the static frame, that will be reused at each frame\n        to avoid unnecessarily computing static mobjects.\n\n        Parameters\n        ----------\n        scene\n            The scene played.\n        static_mobjects\n            Static mobjects of the scene. If None, self.static_image is set to None\n\n        Returns\n        -------\n        typing.Iterable[Mobject]\n            The static image computed.\n        \"\"\"\n        self.static_image = None\n        if not static_mobjects:\n            return None\n        self.update_frame(scene, mobjects=static_mobjects)\n        self.static_image = self.get_frame()\n        return self.static_image\n\n    def update_skipping_status(self):\n        \"\"\"\n        This method is used internally to check if the current\n        animation needs to be skipped or not. It also checks if\n        the number of animations that were played correspond to\n        the number of animations that need to be played, and\n        raises an EndSceneEarlyException if they don't correspond.\n        \"\"\"\n        # there is always at least one section -> no out of bounds here\n        if self.file_writer.sections[-1].skip_animations:\n            self.skip_animations = True\n        if config[\"save_last_frame\"]:\n            self.skip_animations = True\n        if (\n            config.from_animation_number > 0\n            and self.num_plays < config.from_animation_number\n        ):\n            self.skip_animations = True\n        if (\n            config.upto_animation_number >= 0\n            and self.num_plays > config.upto_animation_number\n        ):\n            self.skip_animations = True\n            raise EndSceneEarlyException()\n\n    def scene_finished(self, scene):\n        # If no animations in scene, render an image instead\n        if self.num_plays:\n            self.file_writer.finish()\n        elif config.write_to_movie:\n            config.save_last_frame = True\n            config.write_to_movie = False\n        else:\n            self.static_image = None\n            self.update_frame(scene)\n\n        if config[\"save_last_frame\"]:\n            self.static_image = None\n            self.update_frame(scene)\n            self.file_writer.save_final_image(self.camera.get_image())"}, {"name": "Camera", "code": "class Camera:\n    \"\"\"Base camera class.\n\n    This is the object which takes care of what exactly is displayed\n    on screen at any given moment.\n\n    Parameters\n    ----------\n    background_image\n        The path to an image that should be the background image.\n        If not set, the background is filled with :attr:`self.background_color`\n    background\n        What :attr:`background` is set to. By default, ``None``.\n    pixel_height\n        The height of the scene in pixels.\n    pixel_width\n        The width of the scene in pixels.\n    kwargs\n        Additional arguments (``background_color``, ``background_opacity``)\n        to be set.\n    \"\"\"\n\n    def __init__(\n        self,\n        background_image: str | None = None,\n        frame_center: np.ndarray = ORIGIN,\n        image_mode: str = \"RGBA\",\n        n_channels: int = 4,\n        pixel_array_dtype: str = \"uint8\",\n        cairo_line_width_multiple: float = 0.01,\n        use_z_index: bool = True,\n        background: np.ndarray | None = None,\n        pixel_height: int | None = None,\n        pixel_width: int | None = None,\n        frame_height: float | None = None,\n        frame_width: float | None = None,\n        frame_rate: float | None = None,\n        background_color: ParsableManimColor | None = None,\n        background_opacity: float | None = None,\n        **kwargs,\n    ):\n        self.background_image = background_image\n        self.frame_center = frame_center\n        self.image_mode = image_mode\n        self.n_channels = n_channels\n        self.pixel_array_dtype = pixel_array_dtype\n        self.cairo_line_width_multiple = cairo_line_width_multiple\n        self.use_z_index = use_z_index\n        self.background = background\n\n        if pixel_height is None:\n            pixel_height = config[\"pixel_height\"]\n        self.pixel_height = pixel_height\n\n        if pixel_width is None:\n            pixel_width = config[\"pixel_width\"]\n        self.pixel_width = pixel_width\n\n        if frame_height is None:\n            frame_height = config[\"frame_height\"]\n        self.frame_height = frame_height\n\n        if frame_width is None:\n            frame_width = config[\"frame_width\"]\n        self.frame_width = frame_width\n\n        if frame_rate is None:\n            frame_rate = config[\"frame_rate\"]\n        self.frame_rate = frame_rate\n\n        if background_color is None:\n            self._background_color = ManimColor.parse(config[\"background_color\"])\n        else:\n            self._background_color = ManimColor.parse(background_color)\n        if background_opacity is None:\n            self._background_opacity = config[\"background_opacity\"]\n        else:\n            self._background_opacity = background_opacity\n\n        # This one is in the same boat as the above, but it doesn't have the\n        # same name as the corresponding key so it has to be handled on its own\n        self.max_allowable_norm = config[\"frame_width\"]\n\n        self.rgb_max_val = np.iinfo(self.pixel_array_dtype).max\n        self.pixel_array_to_cairo_context = {}\n\n        # Contains the correct method to process a list of Mobjects of the\n        # corresponding class.  If a Mobject is not an instance of a class in\n        # this dict (or an instance of a class that inherits from a class in\n        # this dict), then it cannot be rendered.\n\n        self.init_background()\n        self.resize_frame_shape()\n        self.reset()\n\n    def __deepcopy__(self, memo):\n        # This is to address a strange bug where deepcopying\n        # will result in a segfault, which is somehow related\n        # to the aggdraw library\n        self.canvas = None\n        return copy.copy(self)\n\n    @property\n    def background_color(self):\n        return self._background_color\n\n    @background_color.setter\n    def background_color(self, color):\n        self._background_color = color\n        self.init_background()\n\n    @property\n    def background_opacity(self):\n        return self._background_opacity\n\n    @background_opacity.setter\n    def background_opacity(self, alpha):\n        self._background_opacity = alpha\n        self.init_background()\n\n    def type_or_raise(self, mobject: Mobject):\n        \"\"\"Return the type of mobject, if it is a type that can be rendered.\n\n        If `mobject` is an instance of a class that inherits from a class that\n        can be rendered, return the super class.  For example, an instance of a\n        Square is also an instance of VMobject, and these can be rendered.\n        Therefore, `type_or_raise(Square())` returns True.\n\n        Parameters\n        ----------\n        mobject\n            The object to take the type of.\n\n        Notes\n        -----\n        For a list of classes that can currently be rendered, see :meth:`display_funcs`.\n\n        Returns\n        -------\n        Type[:class:`~.Mobject`]\n            The type of mobjects, if it can be rendered.\n\n        Raises\n        ------\n        :exc:`TypeError`\n            When mobject is not an instance of a class that can be rendered.\n        \"\"\"\n        self.display_funcs = {\n            VMobject: self.display_multiple_vectorized_mobjects,\n            PMobject: self.display_multiple_point_cloud_mobjects,\n            AbstractImageMobject: self.display_multiple_image_mobjects,\n            Mobject: lambda batch, pa: batch,  # Do nothing\n        }\n        # We have to check each type in turn because we are dealing with\n        # super classes.  For example, if square = Square(), then\n        # type(square) != VMobject, but isinstance(square, VMobject) == True.\n        for _type in self.display_funcs:\n            if isinstance(mobject, _type):\n                return _type\n        raise TypeError(f\"Displaying an object of class {_type} is not supported\")\n\n    def reset_pixel_shape(self, new_height: float, new_width: float):\n        \"\"\"This method resets the height and width\n        of a single pixel to the passed new_height and new_width.\n\n        Parameters\n        ----------\n        new_height\n            The new height of the entire scene in pixels\n        new_width\n            The new width of the entire scene in pixels\n        \"\"\"\n        self.pixel_width = new_width\n        self.pixel_height = new_height\n        self.init_background()\n        self.resize_frame_shape()\n        self.reset()\n\n    def resize_frame_shape(self, fixed_dimension: int = 0):\n        \"\"\"\n        Changes frame_shape to match the aspect ratio\n        of the pixels, where fixed_dimension determines\n        whether frame_height or frame_width\n        remains fixed while the other changes accordingly.\n\n        Parameters\n        ----------\n        fixed_dimension\n            If 0, height is scaled with respect to width\n            else, width is scaled with respect to height.\n        \"\"\"\n        pixel_height = self.pixel_height\n        pixel_width = self.pixel_width\n        frame_height = self.frame_height\n        frame_width = self.frame_width\n        aspect_ratio = pixel_width / pixel_height\n        if fixed_dimension == 0:\n            frame_height = frame_width / aspect_ratio\n        else:\n            frame_width = aspect_ratio * frame_height\n        self.frame_height = frame_height\n        self.frame_width = frame_width\n\n    def init_background(self):\n        \"\"\"Initialize the background.\n        If self.background_image is the path of an image\n        the image is set as background; else, the default\n        background color fills the background.\n        \"\"\"\n        height = self.pixel_height\n        width = self.pixel_width\n        if self.background_image is not None:\n            path = get_full_raster_image_path(self.background_image)\n            image = Image.open(path).convert(self.image_mode)\n            # TODO, how to gracefully handle backgrounds\n            # with different sizes?\n            self.background = np.array(image)[:height, :width]\n            self.background = self.background.astype(self.pixel_array_dtype)\n        else:\n            background_rgba = color_to_int_rgba(\n                self.background_color,\n                self.background_opacity,\n            )\n            self.background = np.zeros(\n                (height, width, self.n_channels),\n                dtype=self.pixel_array_dtype,\n            )\n            self.background[:, :] = background_rgba\n\n    def get_image(self, pixel_array: np.ndarray | list | tuple | None = None):\n        \"\"\"Returns an image from the passed\n        pixel array, or from the current frame\n        if the passed pixel array is none.\n\n        Parameters\n        ----------\n        pixel_array\n            The pixel array from which to get an image, by default None\n\n        Returns\n        -------\n        PIL.Image\n            The PIL image of the array.\n        \"\"\"\n        if pixel_array is None:\n            pixel_array = self.pixel_array\n        return Image.fromarray(pixel_array, mode=self.image_mode)\n\n    def convert_pixel_array(\n        self, pixel_array: np.ndarray | list | tuple, convert_from_floats: bool = False\n    ):\n        \"\"\"Converts a pixel array from values that have floats in then\n        to proper RGB values.\n\n        Parameters\n        ----------\n        pixel_array\n            Pixel array to convert.\n        convert_from_floats\n            Whether or not to convert float values to ints, by default False\n\n        Returns\n        -------\n        np.array\n            The new, converted pixel array.\n        \"\"\"\n        retval = np.array(pixel_array)\n        if convert_from_floats:\n            retval = np.apply_along_axis(\n                lambda f: (f * self.rgb_max_val).astype(self.pixel_array_dtype),\n                2,\n                retval,\n            )\n        return retval\n\n    def set_pixel_array(\n        self, pixel_array: np.ndarray | list | tuple, convert_from_floats: bool = False\n    ):\n        \"\"\"Sets the pixel array of the camera to the passed pixel array.\n\n        Parameters\n        ----------\n        pixel_array\n            The pixel array to convert and then set as the camera's pixel array.\n        convert_from_floats\n            Whether or not to convert float values to proper RGB values, by default False\n        \"\"\"\n        converted_array = self.convert_pixel_array(pixel_array, convert_from_floats)\n        if not (\n            hasattr(self, \"pixel_array\")\n            and self.pixel_array.shape == converted_array.shape\n        ):\n            self.pixel_array = converted_array\n        else:\n            # Set in place\n            self.pixel_array[:, :, :] = converted_array[:, :, :]\n\n    def set_background(\n        self, pixel_array: np.ndarray | list | tuple, convert_from_floats: bool = False\n    ):\n        \"\"\"Sets the background to the passed pixel_array after converting\n        to valid RGB values.\n\n        Parameters\n        ----------\n        pixel_array\n            The pixel array to set the background to.\n        convert_from_floats\n            Whether or not to convert floats values to proper RGB valid ones, by default False\n        \"\"\"\n        self.background = self.convert_pixel_array(pixel_array, convert_from_floats)\n\n    # TODO, this should live in utils, not as a method of Camera\n    def make_background_from_func(\n        self, coords_to_colors_func: Callable[[np.ndarray], np.ndarray]\n    ):\n        \"\"\"\n        Makes a pixel array for the background by using coords_to_colors_func to determine each pixel's color. Each input\n        pixel's color. Each input to coords_to_colors_func is an (x, y) pair in space (in ordinary space coordinates; not\n        pixel coordinates), and each output is expected to be an RGBA array of 4 floats.\n\n        Parameters\n        ----------\n        coords_to_colors_func\n            The function whose input is an (x,y) pair of coordinates and\n            whose return values must be the colors for that point\n\n        Returns\n        -------\n        np.array\n            The pixel array which can then be passed to set_background.\n        \"\"\"\n        logger.info(\"Starting set_background\")\n        coords = self.get_coords_of_all_pixels()\n        new_background = np.apply_along_axis(coords_to_colors_func, 2, coords)\n        logger.info(\"Ending set_background\")\n\n        return self.convert_pixel_array(new_background, convert_from_floats=True)\n\n    def set_background_from_func(\n        self, coords_to_colors_func: Callable[[np.ndarray], np.ndarray]\n    ):\n        \"\"\"\n        Sets the background to a pixel array using coords_to_colors_func to determine each pixel's color. Each input\n        pixel's color. Each input to coords_to_colors_func is an (x, y) pair in space (in ordinary space coordinates; not\n        pixel coordinates), and each output is expected to be an RGBA array of 4 floats.\n\n        Parameters\n        ----------\n        coords_to_colors_func\n            The function whose input is an (x,y) pair of coordinates and\n            whose return values must be the colors for that point\n        \"\"\"\n        self.set_background(self.make_background_from_func(coords_to_colors_func))\n\n    def reset(self):\n        \"\"\"Resets the camera's pixel array\n        to that of the background\n\n        Returns\n        -------\n        Camera\n            The camera object after setting the pixel array.\n        \"\"\"\n        self.set_pixel_array(self.background)\n        return self\n\n    def set_frame_to_background(self, background):\n        self.set_pixel_array(background)\n\n    ####\n\n    def get_mobjects_to_display(\n        self,\n        mobjects: Iterable[Mobject],\n        include_submobjects: bool = True,\n        excluded_mobjects: list | None = None,\n    ):\n        \"\"\"Used to get the list of mobjects to display\n        with the camera.\n\n        Parameters\n        ----------\n        mobjects\n            The Mobjects\n        include_submobjects\n            Whether or not to include the submobjects of mobjects, by default True\n        excluded_mobjects\n            Any mobjects to exclude, by default None\n\n        Returns\n        -------\n        list\n            list of mobjects\n        \"\"\"\n        if include_submobjects:\n            mobjects = extract_mobject_family_members(\n                mobjects,\n                use_z_index=self.use_z_index,\n                only_those_with_points=True,\n            )\n            if excluded_mobjects:\n                all_excluded = extract_mobject_family_members(\n                    excluded_mobjects,\n                    use_z_index=self.use_z_index,\n                )\n                mobjects = list_difference_update(mobjects, all_excluded)\n        return list(mobjects)\n\n    def is_in_frame(self, mobject: Mobject):\n        \"\"\"Checks whether the passed mobject is in\n        frame or not.\n\n        Parameters\n        ----------\n        mobject\n            The mobject for which the checking needs to be done.\n\n        Returns\n        -------\n        bool\n            True if in frame, False otherwise.\n        \"\"\"\n        fc = self.frame_center\n        fh = self.frame_height\n        fw = self.frame_width\n        return not reduce(\n            op.or_,\n            [\n                mobject.get_right()[0] < fc[0] - fw / 2,\n                mobject.get_bottom()[1] > fc[1] + fh / 2,\n                mobject.get_left()[0] > fc[0] + fw / 2,\n                mobject.get_top()[1] < fc[1] - fh / 2,\n            ],\n        )\n\n    def capture_mobject(self, mobject: Mobject, **kwargs: Any):\n        \"\"\"Capture mobjects by storing it in :attr:`pixel_array`.\n\n        This is a single-mobject version of :meth:`capture_mobjects`.\n\n        Parameters\n        ----------\n        mobject\n            Mobject to capture.\n\n        kwargs\n            Keyword arguments to be passed to :meth:`get_mobjects_to_display`.\n\n        \"\"\"\n        return self.capture_mobjects([mobject], **kwargs)\n\n    def capture_mobjects(self, mobjects: Iterable[Mobject], **kwargs):\n        \"\"\"Capture mobjects by printing them on :attr:`pixel_array`.\n\n        This is the essential function that converts the contents of a Scene\n        into an array, which is then converted to an image or video.\n\n        Parameters\n        ----------\n        mobjects\n            Mobjects to capture.\n\n        kwargs\n            Keyword arguments to be passed to :meth:`get_mobjects_to_display`.\n\n        Notes\n        -----\n        For a list of classes that can currently be rendered, see :meth:`display_funcs`.\n\n        \"\"\"\n        # The mobjects will be processed in batches (or runs) of mobjects of\n        # the same type.  That is, if the list mobjects contains objects of\n        # types [VMobject, VMobject, VMobject, PMobject, PMobject, VMobject],\n        # then they will be captured in three batches: [VMobject, VMobject,\n        # VMobject], [PMobject, PMobject], and [VMobject].  This must be done\n        # without altering their order.  it.groupby computes exactly this\n        # partition while at the same time preserving order.\n        mobjects = self.get_mobjects_to_display(mobjects, **kwargs)\n        for group_type, group in it.groupby(mobjects, self.type_or_raise):\n            self.display_funcs[group_type](list(group), self.pixel_array)\n\n    # Methods associated with svg rendering\n\n    # NOTE: None of the methods below have been mentioned outside of their definitions. Their DocStrings are not as\n    # detailed as possible.\n\n    def get_cached_cairo_context(self, pixel_array: np.ndarray):\n        \"\"\"Returns the cached cairo context of the passed\n        pixel array if it exists, and None if it doesn't.\n\n        Parameters\n        ----------\n        pixel_array\n            The pixel array to check.\n\n        Returns\n        -------\n        cairo.Context\n            The cached cairo context.\n        \"\"\"\n        return self.pixel_array_to_cairo_context.get(id(pixel_array), None)\n\n    def cache_cairo_context(self, pixel_array: np.ndarray, ctx: cairo.Context):\n        \"\"\"Caches the passed Pixel array into a Cairo Context\n\n        Parameters\n        ----------\n        pixel_array\n            The pixel array to cache\n        ctx\n            The context to cache it into.\n        \"\"\"\n        self.pixel_array_to_cairo_context[id(pixel_array)] = ctx\n\n    def get_cairo_context(self, pixel_array: np.ndarray):\n        \"\"\"Returns the cairo context for a pixel array after\n        caching it to self.pixel_array_to_cairo_context\n        If that array has already been cached, it returns the\n        cached version instead.\n\n        Parameters\n        ----------\n        pixel_array\n            The Pixel array to get the cairo context of.\n\n        Returns\n        -------\n        cairo.Context\n            The cairo context of the pixel array.\n        \"\"\"\n        cached_ctx = self.get_cached_cairo_context(pixel_array)\n        if cached_ctx:\n            return cached_ctx\n        pw = self.pixel_width\n        ph = self.pixel_height\n        fw = self.frame_width\n        fh = self.frame_height\n        fc = self.frame_center\n        surface = cairo.ImageSurface.create_for_data(\n            pixel_array,\n            cairo.FORMAT_ARGB32,\n            pw,\n            ph,\n        )\n        ctx = cairo.Context(surface)\n        ctx.scale(pw, ph)\n        ctx.set_matrix(\n            cairo.Matrix(\n                (pw / fw),\n                0,\n                0,\n                -(ph / fh),\n                (pw / 2) - fc[0] * (pw / fw),\n                (ph / 2) + fc[1] * (ph / fh),\n            ),\n        )\n        self.cache_cairo_context(pixel_array, ctx)\n        return ctx\n\n    def display_multiple_vectorized_mobjects(\n        self, vmobjects: list, pixel_array: np.ndarray\n    ):\n        \"\"\"Displays multiple VMobjects in the pixel_array\n\n        Parameters\n        ----------\n        vmobjects\n            list of VMobjects to display\n        pixel_array\n            The pixel array\n        \"\"\"\n        if len(vmobjects) == 0:\n            return\n        batch_image_pairs = it.groupby(vmobjects, lambda vm: vm.get_background_image())\n        for image, batch in batch_image_pairs:\n            if image:\n                self.display_multiple_background_colored_vmobjects(batch, pixel_array)\n            else:\n                self.display_multiple_non_background_colored_vmobjects(\n                    batch,\n                    pixel_array,\n                )\n\n    def display_multiple_non_background_colored_vmobjects(\n        self, vmobjects: list, pixel_array: np.ndarray\n    ):\n        \"\"\"Displays multiple VMobjects in the cairo context, as long as they don't have\n        background colors.\n\n        Parameters\n        ----------\n        vmobjects\n            list of the VMobjects\n        pixel_array\n            The Pixel array to add the VMobjects to.\n        \"\"\"\n        ctx = self.get_cairo_context(pixel_array)\n        for vmobject in vmobjects:\n            self.display_vectorized(vmobject, ctx)\n\n    def display_vectorized(self, vmobject: VMobject, ctx: cairo.Context):\n        \"\"\"Displays a VMobject in the cairo context\n\n        Parameters\n        ----------\n        vmobject\n            The Vectorized Mobject to display\n        ctx\n            The cairo context to use.\n\n        Returns\n        -------\n        Camera\n            The camera object\n        \"\"\"\n        self.set_cairo_context_path(ctx, vmobject)\n        self.apply_stroke(ctx, vmobject, background=True)\n        self.apply_fill(ctx, vmobject)\n        self.apply_stroke(ctx, vmobject)\n        return self\n\n    def set_cairo_context_path(self, ctx: cairo.Context, vmobject: VMobject):\n        \"\"\"Sets a path for the cairo context with the vmobject passed\n\n        Parameters\n        ----------\n        ctx\n            The cairo context\n        vmobject\n            The VMobject\n\n        Returns\n        -------\n        Camera\n            Camera object after setting cairo_context_path\n        \"\"\"\n        points = self.transform_points_pre_display(vmobject, vmobject.points)\n        # TODO, shouldn't this be handled in transform_points_pre_display?\n        # points = points - self.get_frame_center()\n        if len(points) == 0:\n            return\n\n        ctx.new_path()\n        subpaths = vmobject.gen_subpaths_from_points_2d(points)\n        for subpath in subpaths:\n            quads = vmobject.gen_cubic_bezier_tuples_from_points(subpath)\n            ctx.new_sub_path()\n            start = subpath[0]\n            ctx.move_to(*start[:2])\n            for _p0, p1, p2, p3 in quads:\n                ctx.curve_to(*p1[:2], *p2[:2], *p3[:2])\n            if vmobject.consider_points_equals_2d(subpath[0], subpath[-1]):\n                ctx.close_path()\n        return self\n\n    def set_cairo_context_color(\n        self, ctx: cairo.Context, rgbas: np.ndarray, vmobject: VMobject\n    ):\n        \"\"\"Sets the color of the cairo context\n\n        Parameters\n        ----------\n        ctx\n            The cairo context\n        rgbas\n            The RGBA array with which to color the context.\n        vmobject\n            The VMobject with which to set the color.\n\n        Returns\n        -------\n        Camera\n            The camera object\n        \"\"\"\n        if len(rgbas) == 1:\n            # Use reversed rgb because cairo surface is\n            # encodes it in reverse order\n            ctx.set_source_rgba(*rgbas[0][2::-1], rgbas[0][3])\n        else:\n            points = vmobject.get_gradient_start_and_end_points()\n            points = self.transform_points_pre_display(vmobject, points)\n            pat = cairo.LinearGradient(*it.chain(*(point[:2] for point in points)))\n            step = 1.0 / (len(rgbas) - 1)\n            offsets = np.arange(0, 1 + step, step)\n            for rgba, offset in zip(rgbas, offsets):\n                pat.add_color_stop_rgba(offset, *rgba[2::-1], rgba[3])\n            ctx.set_source(pat)\n        return self\n\n    def apply_fill(self, ctx: cairo.Context, vmobject: VMobject):\n        \"\"\"Fills the cairo context\n\n        Parameters\n        ----------\n        ctx\n            The cairo context\n        vmobject\n            The VMobject\n\n        Returns\n        -------\n        Camera\n            The camera object.\n        \"\"\"\n        self.set_cairo_context_color(ctx, self.get_fill_rgbas(vmobject), vmobject)\n        ctx.fill_preserve()\n        return self\n\n    def apply_stroke(\n        self, ctx: cairo.Context, vmobject: VMobject, background: bool = False\n    ):\n        \"\"\"Applies a stroke to the VMobject in the cairo context.\n\n        Parameters\n        ----------\n        ctx\n            The cairo context\n        vmobject\n            The VMobject\n        background\n            Whether or not to consider the background when applying this\n            stroke width, by default False\n\n        Returns\n        -------\n        Camera\n            The camera object with the stroke applied.\n        \"\"\"\n        width = vmobject.get_stroke_width(background)\n        if width == 0:\n            return self\n        self.set_cairo_context_color(\n            ctx,\n            self.get_stroke_rgbas(vmobject, background=background),\n            vmobject,\n        )\n        ctx.set_line_width(\n            width\n            * self.cairo_line_width_multiple\n            * (self.frame_width / self.frame_width),\n            # This ensures lines have constant width as you zoom in on them.\n        )\n        if vmobject.joint_type != LineJointType.AUTO:\n            ctx.set_line_join(LINE_JOIN_MAP[vmobject.joint_type])\n        if vmobject.cap_style != CapStyleType.AUTO:\n            ctx.set_line_cap(CAP_STYLE_MAP[vmobject.cap_style])\n        ctx.stroke_preserve()\n        return self\n\n    def get_stroke_rgbas(self, vmobject: VMobject, background: bool = False):\n        \"\"\"Gets the RGBA array for the stroke of the passed\n        VMobject.\n\n        Parameters\n        ----------\n        vmobject\n            The VMobject\n        background\n            Whether or not to consider the background when getting the stroke\n            RGBAs, by default False\n\n        Returns\n        -------\n        np.ndarray\n            The RGBA array of the stroke.\n        \"\"\"\n        return vmobject.get_stroke_rgbas(background)\n\n    def get_fill_rgbas(self, vmobject: VMobject):\n        \"\"\"Returns the RGBA array of the fill of the passed VMobject\n\n        Parameters\n        ----------\n        vmobject\n            The VMobject\n\n        Returns\n        -------\n        np.array\n            The RGBA Array of the fill of the VMobject\n        \"\"\"\n        return vmobject.get_fill_rgbas()\n\n    def get_background_colored_vmobject_displayer(self):\n        \"\"\"Returns the background_colored_vmobject_displayer\n        if it exists or makes one and returns it if not.\n\n        Returns\n        -------\n        BackGroundColoredVMobjectDisplayer\n            Object that displays VMobjects that have the same color\n            as the background.\n        \"\"\"\n        # Quite wordy to type out a bunch\n        bcvd = \"background_colored_vmobject_displayer\"\n        if not hasattr(self, bcvd):\n            setattr(self, bcvd, BackgroundColoredVMobjectDisplayer(self))\n        return getattr(self, bcvd)\n\n    def display_multiple_background_colored_vmobjects(\n        self, cvmobjects: list, pixel_array: np.ndarray\n    ):\n        \"\"\"Displays multiple vmobjects that have the same color as the background.\n\n        Parameters\n        ----------\n        cvmobjects\n            List of Colored VMobjects\n        pixel_array\n            The pixel array.\n\n        Returns\n        -------\n        Camera\n            The camera object.\n        \"\"\"\n        displayer = self.get_background_colored_vmobject_displayer()\n        cvmobject_pixel_array = displayer.display(*cvmobjects)\n        self.overlay_rgba_array(pixel_array, cvmobject_pixel_array)\n        return self\n\n    # Methods for other rendering\n\n    # NOTE: Out of the following methods, only `transform_points_pre_display` and `points_to_pixel_coords` have been mentioned outside of their definitions.\n    # As a result, the other methods do not have as detailed docstrings as would be preferred.\n\n    def display_multiple_point_cloud_mobjects(\n        self, pmobjects: list, pixel_array: np.ndarray\n    ):\n        \"\"\"Displays multiple PMobjects by modifying the passed pixel array.\n\n        Parameters\n        ----------\n        pmobjects\n            List of PMobjects\n        pixel_array\n            The pixel array to modify.\n        \"\"\"\n        for pmobject in pmobjects:\n            self.display_point_cloud(\n                pmobject,\n                pmobject.points,\n                pmobject.rgbas,\n                self.adjusted_thickness(pmobject.stroke_width),\n                pixel_array,\n            )\n\n    def display_point_cloud(\n        self,\n        pmobject: PMobject,\n        points: list,\n        rgbas: np.ndarray,\n        thickness: float,\n        pixel_array: np.ndarray,\n    ):\n        \"\"\"Displays a PMobject by modifying the pixel array suitably.\n\n        TODO: Write a description for the rgbas argument.\n\n        Parameters\n        ----------\n        pmobject\n            Point Cloud Mobject\n        points\n            The points to display in the point cloud mobject\n        rgbas\n\n        thickness\n            The thickness of each point of the PMobject\n        pixel_array\n            The pixel array to modify.\n\n        \"\"\"\n        if len(points) == 0:\n            return\n        pixel_coords = self.points_to_pixel_coords(pmobject, points)\n        pixel_coords = self.thickened_coordinates(pixel_coords, thickness)\n        rgba_len = pixel_array.shape[2]\n\n        rgbas = (self.rgb_max_val * rgbas).astype(self.pixel_array_dtype)\n        target_len = len(pixel_coords)\n        factor = target_len // len(rgbas)\n        rgbas = np.array([rgbas] * factor).reshape((target_len, rgba_len))\n\n        on_screen_indices = self.on_screen_pixels(pixel_coords)\n        pixel_coords = pixel_coords[on_screen_indices]\n        rgbas = rgbas[on_screen_indices]\n\n        ph = self.pixel_height\n        pw = self.pixel_width\n\n        flattener = np.array([1, pw], dtype=\"int\")\n        flattener = flattener.reshape((2, 1))\n        indices = np.dot(pixel_coords, flattener)[:, 0]\n        indices = indices.astype(\"int\")\n\n        new_pa = pixel_array.reshape((ph * pw, rgba_len))\n        new_pa[indices] = rgbas\n        pixel_array[:, :] = new_pa.reshape((ph, pw, rgba_len))\n\n    def display_multiple_image_mobjects(\n        self, image_mobjects: list, pixel_array: np.ndarray\n    ):\n        \"\"\"Displays multiple image mobjects by modifying the passed pixel_array.\n\n        Parameters\n        ----------\n        image_mobjects\n            list of ImageMobjects\n        pixel_array\n            The pixel array to modify.\n        \"\"\"\n        for image_mobject in image_mobjects:\n            self.display_image_mobject(image_mobject, pixel_array)\n\n    def display_image_mobject(\n        self, image_mobject: AbstractImageMobject, pixel_array: np.ndarray\n    ):\n        \"\"\"Displays an ImageMobject by changing the pixel_array suitably.\n\n        Parameters\n        ----------\n        image_mobject\n            The imageMobject to display\n        pixel_array\n            The Pixel array to put the imagemobject in.\n        \"\"\"\n        corner_coords = self.points_to_pixel_coords(image_mobject, image_mobject.points)\n        ul_coords, ur_coords, dl_coords, _ = corner_coords\n        right_vect = ur_coords - ul_coords\n        down_vect = dl_coords - ul_coords\n        center_coords = ul_coords + (right_vect + down_vect) / 2\n\n        sub_image = Image.fromarray(image_mobject.get_pixel_array(), mode=\"RGBA\")\n\n        # Reshape\n        pixel_width = max(int(pdist([ul_coords, ur_coords]).item()), 1)\n        pixel_height = max(int(pdist([ul_coords, dl_coords]).item()), 1)\n        sub_image = sub_image.resize(\n            (pixel_width, pixel_height),\n            resample=image_mobject.resampling_algorithm,\n        )\n\n        # Rotate\n        angle = angle_of_vector(right_vect)\n        adjusted_angle = -int(360 * angle / TAU)\n        if adjusted_angle != 0:\n            sub_image = sub_image.rotate(\n                adjusted_angle,\n                resample=image_mobject.resampling_algorithm,\n                expand=1,\n            )\n\n        # TODO, there is no accounting for a shear...\n\n        # Paste into an image as large as the camera's pixel array\n        full_image = Image.fromarray(\n            np.zeros((self.pixel_height, self.pixel_width)),\n            mode=\"RGBA\",\n        )\n        new_ul_coords = center_coords - np.array(sub_image.size) / 2\n        new_ul_coords = new_ul_coords.astype(int)\n        full_image.paste(\n            sub_image,\n            box=(\n                new_ul_coords[0],\n                new_ul_coords[1],\n                new_ul_coords[0] + sub_image.size[0],\n                new_ul_coords[1] + sub_image.size[1],\n            ),\n        )\n        # Paint on top of existing pixel array\n        self.overlay_PIL_image(pixel_array, full_image)\n\n    def overlay_rgba_array(self, pixel_array: np.ndarray, new_array: np.ndarray):\n        \"\"\"Overlays an RGBA array on top of the given Pixel array.\n\n        Parameters\n        ----------\n        pixel_array\n            The original pixel array to modify.\n        new_array\n            The new pixel array to overlay.\n        \"\"\"\n        self.overlay_PIL_image(pixel_array, self.get_image(new_array))\n\n    def overlay_PIL_image(self, pixel_array: np.ndarray, image: Image):\n        \"\"\"Overlays a PIL image on the passed pixel array.\n\n        Parameters\n        ----------\n        pixel_array\n            The Pixel array\n        image\n            The Image to overlay.\n        \"\"\"\n        pixel_array[:, :] = np.array(\n            Image.alpha_composite(self.get_image(pixel_array), image),\n            dtype=\"uint8\",\n        )\n\n    def adjust_out_of_range_points(self, points: np.ndarray):\n        \"\"\"If any of the points in the passed array are out of\n        the viable range, they are adjusted suitably.\n\n        Parameters\n        ----------\n        points\n            The points to adjust\n\n        Returns\n        -------\n        np.array\n            The adjusted points.\n        \"\"\"\n        if not np.any(points > self.max_allowable_norm):\n            return points\n        norms = np.apply_along_axis(np.linalg.norm, 1, points)\n        violator_indices = norms > self.max_allowable_norm\n        violators = points[violator_indices, :]\n        violator_norms = norms[violator_indices]\n        reshaped_norms = np.repeat(\n            violator_norms.reshape((len(violator_norms), 1)),\n            points.shape[1],\n            1,\n        )\n        rescaled = self.max_allowable_norm * violators / reshaped_norms\n        points[violator_indices] = rescaled\n        return points\n\n    def transform_points_pre_display(\n        self,\n        mobject,\n        points,\n    ):  # TODO: Write more detailed docstrings for this method.\n        # NOTE: There seems to be an unused argument `mobject`.\n\n        # Subclasses (like ThreeDCamera) may want to\n        # adjust points further before they're shown\n        if not np.all(np.isfinite(points)):\n            # TODO, print some kind of warning about\n            # mobject having invalid points?\n            points = np.zeros((1, 3))\n        return points\n\n    def points_to_pixel_coords(\n        self,\n        mobject,\n        points,\n    ):  # TODO: Write more detailed docstrings for this method.\n        points = self.transform_points_pre_display(mobject, points)\n        shifted_points = points - self.frame_center\n\n        result = np.zeros((len(points), 2))\n        pixel_height = self.pixel_height\n        pixel_width = self.pixel_width\n        frame_height = self.frame_height\n        frame_width = self.frame_width\n        width_mult = pixel_width / frame_width\n        width_add = pixel_width / 2\n        height_mult = pixel_height / frame_height\n        height_add = pixel_height / 2\n        # Flip on y-axis as you go\n        height_mult *= -1\n\n        result[:, 0] = shifted_points[:, 0] * width_mult + width_add\n        result[:, 1] = shifted_points[:, 1] * height_mult + height_add\n        return result.astype(\"int\")\n\n    def on_screen_pixels(self, pixel_coords: np.ndarray):\n        \"\"\"Returns array of pixels that are on the screen from a given\n        array of pixel_coordinates\n\n        Parameters\n        ----------\n        pixel_coords\n            The pixel coords to check.\n\n        Returns\n        -------\n        np.array\n            The pixel coords on screen.\n        \"\"\"\n        return reduce(\n            op.and_,\n            [\n                pixel_coords[:, 0] >= 0,\n                pixel_coords[:, 0] < self.pixel_width,\n                pixel_coords[:, 1] >= 0,\n                pixel_coords[:, 1] < self.pixel_height,\n            ],\n        )\n\n    def adjusted_thickness(self, thickness: float) -> float:\n        \"\"\"Computes the adjusted stroke width for a zoomed camera.\n\n        Parameters\n        ----------\n        thickness\n            The stroke width of a mobject.\n\n        Returns\n        -------\n        float\n            The adjusted stroke width that reflects zooming in with\n            the camera.\n        \"\"\"\n        # TODO: This seems...unsystematic\n        big_sum = op.add(config[\"pixel_height\"], config[\"pixel_width\"])\n        this_sum = op.add(self.pixel_height, self.pixel_width)\n        factor = big_sum / this_sum\n        return 1 + (thickness - 1) * factor\n\n    def get_thickening_nudges(self, thickness: float):\n        \"\"\"Determine a list of vectors used to nudge\n        two-dimensional pixel coordinates.\n\n        Parameters\n        ----------\n        thickness\n\n        Returns\n        -------\n        np.array\n\n        \"\"\"\n        thickness = int(thickness)\n        _range = list(range(-thickness // 2 + 1, thickness // 2 + 1))\n        return np.array(list(it.product(_range, _range)))\n\n    def thickened_coordinates(self, pixel_coords: np.ndarray, thickness: float):\n        \"\"\"Returns thickened coordinates for a passed array of pixel coords and\n        a thickness to thicken by.\n\n        Parameters\n        ----------\n        pixel_coords\n            Pixel coordinates\n        thickness\n            Thickness\n\n        Returns\n        -------\n        np.array\n            Array of thickened pixel coords.\n        \"\"\"\n        nudges = self.get_thickening_nudges(thickness)\n        pixel_coords = np.array([pixel_coords + nudge for nudge in nudges])\n        size = pixel_coords.size\n        return pixel_coords.reshape((size // 2, 2))\n\n    # TODO, reimplement using cairo matrix\n    def get_coords_of_all_pixels(self):\n        \"\"\"Returns the cartesian coordinates of each pixel.\n\n        Returns\n        -------\n        np.ndarray\n            The array of cartesian coordinates.\n        \"\"\"\n        # These are in x, y order, to help me keep things straight\n        full_space_dims = np.array([self.frame_width, self.frame_height])\n        full_pixel_dims = np.array([self.pixel_width, self.pixel_height])\n\n        # These are addressed in the same y, x order as in pixel_array, but the values in them\n        # are listed in x, y order\n        uncentered_pixel_coords = np.indices([self.pixel_height, self.pixel_width])[\n            ::-1\n        ].transpose(1, 2, 0)\n        uncentered_space_coords = (\n            uncentered_pixel_coords * full_space_dims\n        ) / full_pixel_dims\n        # Could structure above line's computation slightly differently, but figured (without much\n        # thought) multiplying by frame_shape first, THEN dividing by pixel_shape, is probably\n        # better than the other order, for avoiding underflow quantization in the division (whereas\n        # overflow is unlikely to be a problem)\n\n        centered_space_coords = uncentered_space_coords - (full_space_dims / 2)\n\n        # Have to also flip the y coordinates to account for pixel array being listed in\n        # top-to-bottom order, opposite of screen coordinate convention\n        centered_space_coords = centered_space_coords * (1, -1)\n\n        return centered_space_coords"}, {"name": "CapStyleType", "code": "class CapStyleType(Enum):\n    \"\"\"Collection of available cap styles.\n\n    See the example below for a visual illustration of the different\n    cap styles.\n\n    Examples\n    --------\n\n    .. manim:: CapStyleVariants\n        :save_last_frame:\n\n        class CapStyleVariants(Scene):\n            def construct(self):\n                arcs = VGroup(*[\n                    Arc(\n                        radius=1,\n                        start_angle=0,\n                        angle=TAU / 4,\n                        stroke_width=20,\n                        color=GREEN,\n                        cap_style=cap_style,\n                    )\n                    for cap_style in CapStyleType\n                ])\n                arcs.arrange(RIGHT, buff=1)\n                self.add(arcs)\n                for arc in arcs:\n                    label = Text(arc.cap_style.name, font_size=24).next_to(arc, DOWN)\n                    self.add(label)\n    \"\"\"\n\n    AUTO = 0\n    ROUND = 1\n    BUTT = 2\n    SQUARE = 3"}, {"name": "capture", "code": "def capture(\n    command: str, cwd: StrOrBytesPath | None = None, command_input: str | None = None\n) -> tuple[str, str, int]:\n    p = run(\n        command,\n        cwd=cwd,\n        input=command_input,\n        capture_output=True,\n        text=True,\n        encoding=\"utf-8\",\n    )\n    out, err = p.stdout, p.stderr\n    return out, err, p.returncode"}, {"name": "cartesian_to_spherical", "code": "def cartesian_to_spherical(vec: Sequence[float]) -> np.ndarray:\n    \"\"\"Returns an array of numbers corresponding to each\n    polar coordinate value (distance, phi, theta).\n\n    Parameters\n    ----------\n    vec\n        A numpy array ``[x, y, z]``.\n    \"\"\"\n    norm = np.linalg.norm(vec)\n    if norm == 0:\n        return 0, 0, 0\n    r = norm\n    phi = np.arccos(vec[2] / r)\n    theta = np.arctan2(vec[1], vec[0])\n    return np.array([r, theta, phi])"}, {"name": "Cell", "code": "class Cell:\n    \"\"\"\n    A square in a mesh covering the :class:`~.Polygon` passed as an argument.\n\n    Parameters\n    ----------\n    c\n        Center coordinates of the Cell.\n    h\n        Half-Size of the Cell.\n    polygon\n        :class:`~.Polygon` object for which the distance is computed.\n    \"\"\"\n\n    def __init__(self, c: Point2DLike, h: float, polygon: Polygon) -> None:\n        self.c: Point2D = np.asarray(c)\n        self.h = h\n        self.d = polygon.compute_distance(self.c)\n        self.p = self.d + self.h * np.sqrt(2)\n\n    def __lt__(self, other: Cell) -> bool:\n        return self.d < other.d\n\n    def __gt__(self, other: Cell) -> bool:\n        return self.d > other.d\n\n    def __le__(self, other: Cell) -> bool:\n        return self.d <= other.d\n\n    def __ge__(self, other: Cell) -> bool:\n        return self.d >= other.d"}, {"name": "center_of_mass", "code": "def center_of_mass(points: PointNDLike_Array) -> PointND:\n    \"\"\"Gets the center of mass of the points in space.\n\n    Parameters\n    ----------\n    points\n        The points to find the center of mass from.\n\n    Returns\n    -------\n    np.ndarray\n        The center of mass of the points.\n    \"\"\"\n    return np.average(points, 0, np.ones(len(points)))"}, {"name": "cfg", "code": "def cfg(ctx: cloup.Context) -> None:\n    \"\"\"Responsible for the cfg subcommand.\"\"\"\n    pass"}, {"name": "change_to_rgba_array", "code": "def change_to_rgba_array(image: RGBPixelArray, dtype: str = \"uint8\") -> RGBPixelArray:\n    \"\"\"Converts an RGB array into RGBA with the alpha value opacity maxed.\"\"\"\n    pa = image\n    if len(pa.shape) == 2:\n        pa = pa.reshape(list(pa.shape) + [1])\n    if pa.shape[2] == 1:\n        pa = pa.repeat(3, axis=2)\n    if pa.shape[2] == 3:\n        alphas = 255 * np.ones(\n            list(pa.shape[:2]) + [1],\n            dtype=dtype,\n        )\n        pa = np.append(pa, alphas, axis=2)\n    return pa"}, {"name": "ChangeDecimalToValue", "code": "class ChangeDecimalToValue(ChangingDecimal):\n    def __init__(\n        self, decimal_mob: DecimalNumber, target_number: int, **kwargs\n    ) -> None:\n        start_number = decimal_mob.number\n        super().__init__(\n            decimal_mob, lambda a: interpolate(start_number, target_number, a), **kwargs\n        )"}, {"name": "ChangeSpeed", "code": "class ChangeSpeed(Animation):\n    \"\"\"Modifies the speed of passed animation.\n    :class:`AnimationGroup` with different ``lag_ratio`` can also be used\n    which combines multiple animations into one.\n    The ``run_time`` of the passed animation is changed to modify the speed.\n\n    Parameters\n    ----------\n    anim\n        Animation of which the speed is to be modified.\n    speedinfo\n        Contains nodes (percentage of ``run_time``) and its corresponding speed factor.\n    rate_func\n        Overrides ``rate_func`` of passed animation, applied before changing speed.\n\n    Examples\n    --------\n\n    .. manim:: SpeedModifierExample\n\n        class SpeedModifierExample(Scene):\n            def construct(self):\n                a = Dot().shift(LEFT * 4)\n                b = Dot().shift(RIGHT * 4)\n                self.add(a, b)\n                self.play(\n                    ChangeSpeed(\n                        AnimationGroup(\n                            a.animate(run_time=1).shift(RIGHT * 8),\n                            b.animate(run_time=1).shift(LEFT * 8),\n                        ),\n                        speedinfo={0.3: 1, 0.4: 0.1, 0.6: 0.1, 1: 1},\n                        rate_func=linear,\n                    )\n                )\n\n    .. manim:: SpeedModifierUpdaterExample\n\n        class SpeedModifierUpdaterExample(Scene):\n            def construct(self):\n                a = Dot().shift(LEFT * 4)\n                self.add(a)\n\n                ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))\n                self.play(\n                    ChangeSpeed(\n                        Wait(2),\n                        speedinfo={0.4: 1, 0.5: 0.2, 0.8: 0.2, 1: 1},\n                        affects_speed_updaters=True,\n                    )\n                )\n\n    .. manim:: SpeedModifierUpdaterExample2\n\n        class SpeedModifierUpdaterExample2(Scene):\n            def construct(self):\n                a = Dot().shift(LEFT * 4)\n                self.add(a)\n\n                ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))\n                self.wait()\n                self.play(\n                    ChangeSpeed(\n                        Wait(),\n                        speedinfo={1: 0},\n                        affects_speed_updaters=True,\n                    )\n                )\n\n    \"\"\"\n\n    dt = 0\n    is_changing_dt = False\n\n    def __init__(\n        self,\n        anim: Animation | _AnimationBuilder,\n        speedinfo: dict[float, float],\n        rate_func: Callable[[float], float] | None = None,\n        affects_speed_updaters: bool = True,\n        **kwargs,\n    ) -> None:\n        if issubclass(type(anim), AnimationGroup):\n            self.anim = type(anim)(\n                *map(self.setup, anim.animations),\n                group=anim.group,\n                run_time=anim.run_time,\n                rate_func=anim.rate_func,\n                lag_ratio=anim.lag_ratio,\n            )\n        else:\n            self.anim = self.setup(anim)\n\n        if affects_speed_updaters:\n            assert ChangeSpeed.is_changing_dt is False, (\n                \"Only one animation at a time can play that changes speed (dt) for ChangeSpeed updaters\"\n            )\n            ChangeSpeed.is_changing_dt = True\n            self.t = 0\n        self.affects_speed_updaters = affects_speed_updaters\n\n        self.rate_func = self.anim.rate_func if rate_func is None else rate_func\n\n        # A function where, f(0) = 0, f'(0) = initial speed, f'( f-1(1) ) = final speed\n        # Following function obtained when conditions applied to vertical parabola\n        self.speed_modifier = lambda x, init_speed, final_speed: (\n            (final_speed**2 - init_speed**2) * x**2 / 4 + init_speed * x\n        )\n\n        # f-1(1), returns x for which f(x) = 1 in `speed_modifier` function\n        self.f_inv_1 = lambda init_speed, final_speed: 2 / (init_speed + final_speed)\n\n        # if speed factors for the starting node (0) and the final node (1) are\n        # not set, set them to 1 and the penultimate factor, respectively\n        if 0 not in speedinfo:\n            speedinfo[0] = 1\n        if 1 not in speedinfo:\n            speedinfo[1] = sorted(speedinfo.items())[-1][1]\n\n        self.speedinfo = dict(sorted(speedinfo.items()))\n        self.functions = []\n        self.conditions = []\n\n        # Get the time taken by amimation if `run_time` is assumed to be 1\n        scaled_total_time = self.get_scaled_total_time()\n\n        prevnode = 0\n        init_speed = self.speedinfo[0]\n        curr_time = 0\n        for node, final_speed in list(self.speedinfo.items())[1:]:\n            dur = node - prevnode\n\n            def condition(\n                t,\n                curr_time=curr_time,\n                init_speed=init_speed,\n                final_speed=final_speed,\n                dur=dur,\n            ):\n                lower_bound = curr_time / scaled_total_time\n                upper_bound = (\n                    curr_time + self.f_inv_1(init_speed, final_speed) * dur\n                ) / scaled_total_time\n                return lower_bound <= t <= upper_bound\n\n            self.conditions.append(condition)\n\n            def function(\n                t,\n                curr_time=curr_time,\n                init_speed=init_speed,\n                final_speed=final_speed,\n                dur=dur,\n                prevnode=prevnode,\n            ):\n                return (\n                    self.speed_modifier(\n                        (scaled_total_time * t - curr_time) / dur,\n                        init_speed,\n                        final_speed,\n                    )\n                    * dur\n                    + prevnode\n                )\n\n            self.functions.append(function)\n\n            curr_time += self.f_inv_1(init_speed, final_speed) * dur\n            prevnode = node\n            init_speed = final_speed\n\n        def func(t):\n            if t == 1:\n                ChangeSpeed.is_changing_dt = False\n            new_t = piecewise(\n                self.rate_func(t),\n                [condition(self.rate_func(t)) for condition in self.conditions],\n                self.functions,\n            )\n            if self.affects_speed_updaters:\n                ChangeSpeed.dt = (new_t - self.t) * self.anim.run_time\n                self.t = new_t\n            return new_t\n\n        self.anim.set_rate_func(func)\n\n        super().__init__(\n            self.anim.mobject,\n            rate_func=self.rate_func,\n            run_time=scaled_total_time * self.anim.run_time,\n            **kwargs,\n        )\n\n    def setup(self, anim):\n        if type(anim) is Wait:\n            anim.interpolate = types.MethodType(\n                lambda self, alpha: self.rate_func(alpha), anim\n            )\n        return prepare_animation(anim)\n\n    def get_scaled_total_time(self) -> float:\n        \"\"\"The time taken by the animation under the assumption that the ``run_time`` is 1.\"\"\"\n        prevnode = 0\n        init_speed = self.speedinfo[0]\n        total_time = 0\n        for node, final_speed in list(self.speedinfo.items())[1:]:\n            dur = node - prevnode\n            total_time += dur * self.f_inv_1(init_speed, final_speed)\n            prevnode = node\n            init_speed = final_speed\n        return total_time\n\n    @classmethod\n    def add_updater(\n        cls,\n        mobject: Mobject,\n        update_function: Updater,\n        index: int | None = None,\n        call_updater: bool = False,\n    ):\n        \"\"\"This static method can be used to apply speed change to updaters.\n\n        This updater will follow speed and rate function of any :class:`.ChangeSpeed`\n        animation that is playing with ``affects_speed_updaters=True``. By default,\n        updater functions added via the usual :meth:`.Mobject.add_updater` method\n        do not respect the change of animation speed.\n\n        Parameters\n        ----------\n        mobject\n            The mobject to which the updater should be attached.\n        update_function\n            The function that is called whenever a new frame is rendered.\n        index\n            The position in the list of the mobject's updaters at which the\n            function should be inserted.\n        call_updater\n            If ``True``, calls the update function when attaching it to the\n            mobject.\n\n        See also\n        --------\n        :class:`.ChangeSpeed`\n        :meth:`.Mobject.add_updater`\n        \"\"\"\n        if \"dt\" in inspect.signature(update_function).parameters:\n            mobject.add_updater(\n                lambda mob, dt: update_function(\n                    mob, ChangeSpeed.dt if ChangeSpeed.is_changing_dt else dt\n                ),\n                index=index,\n                call_updater=call_updater,\n            )\n        else:\n            mobject.add_updater(update_function, index=index, call_updater=call_updater)\n\n    def interpolate(self, alpha: float) -> None:\n        self.anim.interpolate(alpha)\n\n    def update_mobjects(self, dt: float) -> None:\n        self.anim.update_mobjects(dt)\n\n    def finish(self) -> None:\n        ChangeSpeed.is_changing_dt = False\n        self.anim.finish()\n\n    def begin(self) -> None:\n        self.anim.begin()\n\n    def clean_up_from_scene(self, scene: Scene) -> None:\n        self.anim.clean_up_from_scene(scene)\n\n    def _setup_scene(self, scene) -> None:\n        self.anim._setup_scene(scene)"}, {"name": "ChangingDecimal", "code": "class ChangingDecimal(Animation):\n    def __init__(\n        self,\n        decimal_mob: DecimalNumber,\n        number_update_func: typing.Callable[[float], float],\n        suspend_mobject_updating: bool | None = False,\n        **kwargs,\n    ) -> None:\n        self.check_validity_of_input(decimal_mob)\n        self.number_update_func = number_update_func\n        super().__init__(\n            decimal_mob, suspend_mobject_updating=suspend_mobject_updating, **kwargs\n        )\n\n    def check_validity_of_input(self, decimal_mob: DecimalNumber) -> None:\n        if not isinstance(decimal_mob, DecimalNumber):\n            raise TypeError(\"ChangingDecimal can only take in a DecimalNumber\")\n\n    def interpolate_mobject(self, alpha: float) -> None:\n        self.mobject.set_value(self.number_update_func(self.rate_func(alpha)))"}, {"name": "checkhealth", "code": "def checkhealth() -> None:\n    \"\"\"This subcommand checks whether Manim is installed correctly\n    and has access to its required (and optional) system dependencies.\n    \"\"\"\n    click.echo(f\"Python executable: {sys.executable}\\n\")\n    click.echo(\"Checking whether your installation of Manim Community is healthy...\")\n    failed_checks: list[HealthCheckFunction] = []\n\n    for check in HEALTH_CHECKS:\n        click.echo(f\"- {check.description} ... \", nl=False)\n        if any(\n            failed_check.__name__ in check.skip_on_failed\n            for failed_check in failed_checks\n        ):\n            click.secho(\"SKIPPED\", fg=\"blue\")\n            continue\n        check_result = check()\n        if check_result:\n            click.secho(\"PASSED\", fg=\"green\")\n        else:\n            click.secho(\"FAILED\", fg=\"red\")\n            failed_checks.append(check)\n\n    click.echo()\n\n    if failed_checks:\n        click.echo(\n            \"There are problems with your installation, \"\n            \"here are some recommendations to fix them:\"\n        )\n        for ind, failed_check in enumerate(failed_checks):\n            click.echo(failed_check.recommendation)\n            if ind + 1 < len(failed_checks):\n                click.confirm(\"Continue with next recommendation?\")\n\n    else:  # no problems detected!\n        click.echo(\"No problems detected, your installation seems healthy!\")\n        render_test_scene = click.confirm(\n            \"Would you like to render and preview a test scene?\"\n        )\n        if render_test_scene:\n            import manim as mn\n\n            class CheckHealthDemo(mn.Scene):\n                def _inner_construct(self) -> None:\n                    banner = mn.ManimBanner().shift(mn.UP * 0.5)\n                    self.play(banner.create())\n                    self.wait(0.5)\n                    self.play(banner.expand())\n                    self.wait(0.5)\n                    text_left = mn.Text(\"All systems operational!\")\n                    formula_right = mn.MathTex(r\"\\oint_{\\gamma} f(z)~dz = 0\")\n                    text_tex_group = mn.VGroup(text_left, formula_right)\n                    text_tex_group.arrange(mn.RIGHT, buff=1).next_to(banner, mn.DOWN)\n                    self.play(mn.Write(text_tex_group))\n                    self.wait(0.5)\n                    self.play(\n                        mn.FadeOut(banner, shift=mn.UP),\n                        mn.FadeOut(text_tex_group, shift=mn.DOWN),\n                    )\n\n                def construct(self) -> None:\n                    self.execution_time = timeit.timeit(self._inner_construct, number=1)\n\n            with mn.tempconfig({\"preview\": True, \"disable_caching\": True}):\n                scene = CheckHealthDemo()\n                scene.render()\n\n                click.echo(f\"Scene rendered in {scene.execution_time:.2f} seconds.\")"}, {"name": "choose", "code": "def choose(n: int, k: int) -> int:\n    r\"\"\"The binomial coefficient n choose k.\n\n    :math:`\\binom{n}{k}` describes the number of possible choices of\n    :math:`k` elements from a set of :math:`n` elements.\n\n    References\n    ----------\n    - https://en.wikipedia.org/wiki/Combination\n    - https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.comb.html\n    \"\"\"\n    value: int = special.comb(n, k, exact=True)\n    return value"}, {"name": "Circle", "code": "class Circle(Arc):\n    \"\"\"A circle.\n\n    Parameters\n    ----------\n    color\n        The color of the shape.\n    kwargs\n        Additional arguments to be passed to :class:`Arc`\n\n    Examples\n    --------\n    .. manim:: CircleExample\n        :save_last_frame:\n\n        class CircleExample(Scene):\n            def construct(self):\n                circle_1 = Circle(radius=1.0)\n                circle_2 = Circle(radius=1.5, color=GREEN)\n                circle_3 = Circle(radius=1.0, color=BLUE_B, fill_opacity=1)\n\n                circle_group = Group(circle_1, circle_2, circle_3).arrange(buff=1)\n                self.add(circle_group)\n    \"\"\"\n\n    def __init__(\n        self,\n        radius: float | None = None,\n        color: ParsableManimColor = RED,\n        **kwargs: Any,\n    ) -> None:\n        super().__init__(\n            radius=radius,\n            start_angle=0,\n            angle=TAU,\n            color=color,\n            **kwargs,\n        )\n\n    def surround(\n        self,\n        mobject: Mobject,\n        dim_to_match: int = 0,\n        stretch: bool = False,\n        buffer_factor: float = 1.2,\n    ) -> Self:\n        \"\"\"Modifies a circle so that it surrounds a given mobject.\n\n        Parameters\n        ----------\n        mobject\n            The mobject that the circle will be surrounding.\n        dim_to_match\n        buffer_factor\n            Scales the circle with respect to the mobject. A `buffer_factor` < 1 makes the circle smaller than the mobject.\n        stretch\n            Stretches the circle to fit more tightly around the mobject. Note: Does not work with :class:`Line`\n\n        Examples\n        --------\n        .. manim:: CircleSurround\n            :save_last_frame:\n\n            class CircleSurround(Scene):\n                def construct(self):\n                    triangle1 = Triangle()\n                    circle1 = Circle().surround(triangle1)\n                    group1 = Group(triangle1,circle1) # treat the two mobjects as one\n\n                    line2 = Line()\n                    circle2 = Circle().surround(line2, buffer_factor=2.0)\n                    group2 = Group(line2,circle2)\n\n                    # buffer_factor < 1, so the circle is smaller than the square\n                    square3 = Square()\n                    circle3 = Circle().surround(square3, buffer_factor=0.5)\n                    group3 = Group(square3, circle3)\n\n                    group = Group(group1, group2, group3).arrange(buff=1)\n                    self.add(group)\n        \"\"\"\n        # Ignores dim_to_match and stretch; result will always be a circle\n        # TODO: Perhaps create an ellipse class to handle single-dimension stretching\n\n        # Something goes wrong here when surrounding lines?\n        # TODO: Figure out and fix\n        self.replace(mobject, dim_to_match, stretch)\n\n        self.width = np.sqrt(mobject.width**2 + mobject.height**2)\n        return self.scale(buffer_factor)\n\n    def point_at_angle(self, angle: float) -> Point3D:\n        \"\"\"Returns the position of a point on the circle.\n\n        Parameters\n        ----------\n        angle\n            The angle of the point along the circle in radians.\n\n        Returns\n        -------\n        :class:`numpy.ndarray`\n            The location of the point along the circle's circumference.\n\n        Examples\n        --------\n        .. manim:: PointAtAngleExample\n            :save_last_frame:\n\n            class PointAtAngleExample(Scene):\n                def construct(self):\n                    circle = Circle(radius=2.0)\n                    p1 = circle.point_at_angle(PI/2)\n                    p2 = circle.point_at_angle(270*DEGREES)\n\n                    s1 = Square(side_length=0.25).move_to(p1)\n                    s2 = Square(side_length=0.25).move_to(p2)\n                    self.add(circle, s1, s2)\n\n        \"\"\"\n        start_angle = angle_of_vector(self.points[0] - self.get_center())\n        proportion = (angle - start_angle) / TAU\n        proportion -= np.floor(proportion)\n        return self.point_from_proportion(proportion)\n\n    @staticmethod\n    def from_three_points(\n        p1: Point3DLike, p2: Point3DLike, p3: Point3DLike, **kwargs: Any\n    ) -> Circle:\n        \"\"\"Returns a circle passing through the specified\n        three points.\n\n        Example\n        -------\n        .. manim:: CircleFromPointsExample\n            :save_last_frame:\n\n            class CircleFromPointsExample(Scene):\n                def construct(self):\n                    circle = Circle.from_three_points(LEFT, LEFT + UP, UP * 2, color=RED)\n                    dots = VGroup(\n                        Dot(LEFT),\n                        Dot(LEFT + UP),\n                        Dot(UP * 2),\n                    )\n                    self.add(NumberPlane(), circle, dots)\n        \"\"\"\n        center = line_intersection(\n            perpendicular_bisector([np.asarray(p1), np.asarray(p2)]),\n            perpendicular_bisector([np.asarray(p2), np.asarray(p3)]),\n        )\n        # np.linalg.norm returns floating[Any] which is not compatible with float\n        radius = cast(float, np.linalg.norm(p1 - center))\n        return Circle(radius=radius, **kwargs).shift(center)"}, {"name": "Circumscribe", "code": "class Circumscribe(Succession):\n    r\"\"\"Draw a temporary line surrounding the mobject.\n\n    Parameters\n    ----------\n    mobject\n        The mobject to be circumscribed.\n    shape\n        The shape with which to surround the given mobject. Should be either\n        :class:`~.Rectangle` or :class:`~.Circle`\n    fade_in\n        Whether to make the surrounding shape to fade in. It will be drawn otherwise.\n    fade_out\n        Whether to make the surrounding shape to fade out. It will be undrawn otherwise.\n    time_width\n        The time_width of the drawing and undrawing. Gets ignored if either `fade_in` or `fade_out` is `True`.\n    buff\n        The distance between the surrounding shape and the given mobject.\n    color\n        The color of the surrounding shape.\n    run_time\n        The duration of the entire animation.\n    kwargs\n        Additional arguments to be passed to the :class:`~.Succession` constructor\n\n    Examples\n    --------\n\n    .. manim:: UsingCircumscribe\n\n        class UsingCircumscribe(Scene):\n            def construct(self):\n                lbl = Tex(r\"Circum-\\\\scribe\").scale(2)\n                self.add(lbl)\n                self.play(Circumscribe(lbl))\n                self.play(Circumscribe(lbl, Circle))\n                self.play(Circumscribe(lbl, fade_out=True))\n                self.play(Circumscribe(lbl, time_width=2))\n                self.play(Circumscribe(lbl, Circle, True))\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        shape: type = Rectangle,\n        fade_in=False,\n        fade_out=False,\n        time_width=0.3,\n        buff: float = SMALL_BUFF,\n        color: ParsableManimColor = YELLOW,\n        run_time=1,\n        stroke_width=DEFAULT_STROKE_WIDTH,\n        **kwargs,\n    ):\n        if shape is Rectangle:\n            frame = SurroundingRectangle(\n                mobject,\n                color=color,\n                buff=buff,\n                stroke_width=stroke_width,\n            )\n        elif shape is Circle:\n            frame = Circle(color=color, stroke_width=stroke_width).surround(\n                mobject,\n                buffer_factor=1,\n            )\n            radius = frame.width / 2\n            frame.scale((radius + buff) / radius)\n        else:\n            raise ValueError(\"shape should be either Rectangle or Circle.\")\n\n        if fade_in and fade_out:\n            super().__init__(\n                FadeIn(frame, run_time=run_time / 2),\n                FadeOut(frame, run_time=run_time / 2),\n                **kwargs,\n            )\n        elif fade_in:\n            frame.reverse_direction()\n            super().__init__(\n                FadeIn(frame, run_time=run_time / 2),\n                Uncreate(frame, run_time=run_time / 2),\n                **kwargs,\n            )\n        elif fade_out:\n            super().__init__(\n                Create(frame, run_time=run_time / 2),\n                FadeOut(frame, run_time=run_time / 2),\n                **kwargs,\n            )\n        else:\n            super().__init__(\n                ShowPassingFlash(frame, time_width, run_time=run_time), **kwargs\n            )"}, {"name": "ClickArgs", "code": "class ClickArgs(Namespace):\n    def __init__(self, args: dict[str, Any]) -> None:\n        for name in args:\n            setattr(self, name, args[name])\n\n    def _get_kwargs(self) -> list[tuple[str, Any]]:\n        return list(self.__dict__.items())\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, ClickArgs):\n            return NotImplemented\n        return vars(self) == vars(other)\n\n    def __contains__(self, key: str) -> bool:\n        return key in self.__dict__\n\n    def __repr__(self) -> str:\n        return str(self.__dict__)"}, {"name": "clip", "code": "def clip(a: ComparableT, min_a: ComparableT, max_a: ComparableT) -> ComparableT:\n    \"\"\"Clips ``a`` to the interval [``min_a``, ``max_a``].\n\n    Accepts any comparable objects (i.e. those that support <, >).\n    Returns ``a`` if it is between ``min_a`` and ``max_a``.\n    Otherwise, whichever of ``min_a`` and ``max_a`` is closest.\n\n    Examples\n    --------\n    ::\n\n        >>> clip(15, 11, 20)\n        15\n        >>> clip('a', 'h', 'k')\n        'h'\n    \"\"\"\n    if a < min_a:\n        return min_a\n    elif a > max_a:\n        return max_a\n    return a"}, {"name": "clockwise_path", "code": "def clockwise_path() -> PathFuncType:\n    \"\"\"This function transforms each point by moving clockwise around a half circle.\n\n    Examples\n    --------\n\n    .. manim :: ClockwisePathExample\n\n        class ClockwisePathExample(Scene):\n            def construct(self):\n                colors = [RED, GREEN, BLUE]\n\n                starting_points = VGroup(\n                    *[\n                        Dot(LEFT + pos, color=color)\n                        for pos, color in zip([UP, DOWN, LEFT], colors)\n                    ]\n                )\n\n                finish_points = VGroup(\n                    *[\n                        Dot(RIGHT + pos, color=color)\n                        for pos, color in zip([ORIGIN, UP, DOWN], colors)\n                    ]\n                )\n\n                self.add(starting_points)\n                self.add(finish_points)\n                for dot in starting_points:\n                    self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n                self.wait()\n                self.play(\n                    Transform(\n                        starting_points,\n                        finish_points,\n                        path_func=utils.paths.clockwise_path(),\n                        run_time=2,\n                    )\n                )\n                self.wait()\n\n    \"\"\"\n    return path_along_arc(-np.pi)"}, {"name": "ClockwiseTransform", "code": "class ClockwiseTransform(Transform):\n    \"\"\"Transforms the points of a mobject along a clockwise oriented arc.\n\n    See also\n    --------\n    :class:`.Transform`, :class:`.CounterclockwiseTransform`\n\n    Examples\n    --------\n\n    .. manim:: ClockwiseExample\n\n        class ClockwiseExample(Scene):\n            def construct(self):\n                dl, dr = Dot(), Dot()\n                sl, sr = Square(), Square()\n\n                VGroup(dl, sl).arrange(DOWN).shift(2*LEFT)\n                VGroup(dr, sr).arrange(DOWN).shift(2*RIGHT)\n\n                self.add(dl, dr)\n                self.wait()\n                self.play(\n                    ClockwiseTransform(dl, sl),\n                    Transform(dr, sr)\n                )\n                self.wait()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        target_mobject: Mobject,\n        path_arc: float = -np.pi,\n        **kwargs,\n    ) -> None:\n        super().__init__(mobject, target_mobject, path_arc=path_arc, **kwargs)"}, {"name": "Code", "code": "class Code(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A highlighted source code listing.\n\n    Examples\n    --------\n\n    Normal usage::\n\n        listing = Code(\n            \"helloworldcpp.cpp\",\n            tab_width=4,\n            formatter_style=\"emacs\",\n            background=\"window\",\n            language=\"cpp\",\n            background_config={\"stroke_color\": WHITE},\n            paragraph_config={\"font\": \"Noto Sans Mono\"},\n        )\n\n    We can also render code passed as a string. As the automatic language\n    detection can be a bit flaky, it is recommended to specify the language\n    explicitly:\n\n    .. manim:: CodeFromString\n        :save_last_frame:\n\n        class CodeFromString(Scene):\n            def construct(self):\n                code = '''from manim import Scene, Square\n\n        class FadeInSquare(Scene):\n            def construct(self):\n                s = Square()\n                self.play(FadeIn(s))\n                self.play(s.animate.scale(2))\n                self.wait()'''\n\n                rendered_code = Code(\n                    code_string=code,\n                    language=\"python\",\n                    background=\"window\",\n                    background_config={\"stroke_color\": \"maroon\"},\n                )\n                self.add(rendered_code)\n\n    Parameters\n    ----------\n    code_file\n        The path to the code file to display.\n    code_string\n        Alternatively, the code string to display.\n    language\n        The programming language of the code. If not specified, it will be\n        guessed from the file extension or the code itself.\n    formatter_style\n        The style to use for the code highlighting. Defaults to ``\"vim\"``.\n        A list of all available styles can be obtained by calling\n        :meth:`.Code.get_styles_list`.\n    tab_width\n        The width of a tab character in spaces. Defaults to 4.\n    add_line_numbers\n        Whether to display line numbers. Defaults to ``True``.\n    line_numbers_from\n        The first line number to display. Defaults to 1.\n    background\n        The type of background to use. Can be either ``\"rectangle\"`` (the\n        default) or ``\"window\"``.\n    background_config\n        Keyword arguments passed to the background constructor. Default\n        settings are stored in the class attribute\n        :attr:`.default_background_config` (which can also be modified\n        directly).\n    paragraph_config\n        Keyword arguments passed to the constructor of the\n        :class:`.Paragraph` objects holding the code, and the line\n        numbers. Default settings are stored in the class attribute\n        :attr:`.default_paragraph_config` (which can also be modified\n        directly).\n    \"\"\"\n\n    _styles_list_cache: list[str] | None = None\n    default_background_config: dict[str, Any] = {\n        \"buff\": 0.3,\n        \"fill_color\": ManimColor(\"#222\"),\n        \"stroke_color\": WHITE,\n        \"corner_radius\": 0.2,\n        \"stroke_width\": 1,\n        \"fill_opacity\": 1,\n    }\n    default_paragraph_config: dict[str, Any] = {\n        \"font\": \"Monospace\",\n        \"font_size\": 24,\n        \"line_spacing\": 0.5,\n        \"disable_ligatures\": True,\n    }\n\n    def __init__(\n        self,\n        code_file: StrPath | None = None,\n        code_string: str | None = None,\n        language: str | None = None,\n        formatter_style: str = \"vim\",\n        tab_width: int = 4,\n        add_line_numbers: bool = True,\n        line_numbers_from: int = 1,\n        background: Literal[\"rectangle\", \"window\"] = \"rectangle\",\n        background_config: dict[str, Any] | None = None,\n        paragraph_config: dict[str, Any] | None = None,\n    ):\n        super().__init__()\n\n        if code_file is not None:\n            code_file = Path(code_file)\n            code_string = code_file.read_text(encoding=\"utf-8\")\n            lexer = guess_lexer_for_filename(code_file.name, code_string)\n        elif code_string is not None:\n            if language is not None:\n                lexer = get_lexer_by_name(language)\n            else:\n                lexer = guess_lexer(code_string)\n        else:\n            raise ValueError(\"Either a code file or a code string must be specified.\")\n\n        code_string = code_string.expandtabs(tabsize=tab_width)\n\n        formatter = HtmlFormatter(\n            style=formatter_style,\n            noclasses=True,\n            cssclasses=\"\",\n        )\n        soup = BeautifulSoup(\n            highlight(code_string, lexer, formatter), features=\"html.parser\"\n        )\n        self._code_html = soup.find(\"pre\")\n        assert isinstance(self._code_html, Tag)\n\n        # as we are using Paragraph to render the text, we need to find the character indices\n        # of the segments of changed color in the HTML code\n        color_ranges = []\n        current_line_color_ranges = []\n        current_line_char_index = 0\n        for child in self._code_html.children:\n            if child.name == \"span\":\n                try:\n                    child_style = child[\"style\"]\n                    if isinstance(child_style, str):\n                        color = child_style.removeprefix(\"color: \")\n                    else:\n                        color = None\n                except KeyError:\n                    color = None\n                current_line_color_ranges.append(\n                    (\n                        current_line_char_index,\n                        current_line_char_index + len(child.text),\n                        color,\n                    )\n                )\n                current_line_char_index += len(child.text)\n            else:\n                for char in child.text:\n                    if char == \"\\n\":\n                        color_ranges.append(current_line_color_ranges)\n                        current_line_color_ranges = []\n                        current_line_char_index = 0\n                    else:\n                        current_line_char_index += 1\n\n        color_ranges.append(current_line_color_ranges)\n        code_lines = self._code_html.get_text().removesuffix(\"\\n\").split(\"\\n\")\n\n        if paragraph_config is None:\n            paragraph_config = {}\n        base_paragraph_config = self.default_paragraph_config.copy()\n        base_paragraph_config.update(paragraph_config)\n\n        self.code_lines = Paragraph(\n            *code_lines,\n            **base_paragraph_config,\n        )\n        for line, color_range in zip(self.code_lines, color_ranges):\n            for start, end, color in color_range:\n                line[start:end].set_color(color)\n\n        if add_line_numbers:\n            base_paragraph_config.update({\"alignment\": \"right\"})\n            self.line_numbers = Paragraph(\n                *[\n                    str(i)\n                    for i in range(\n                        line_numbers_from, line_numbers_from + len(self.code_lines)\n                    )\n                ],\n                **base_paragraph_config,\n            )\n            self.line_numbers.next_to(self.code_lines, direction=LEFT).align_to(\n                self.code_lines, UP\n            )\n            self.add(self.line_numbers)\n\n        self.add(self.code_lines)\n\n        if background_config is None:\n            background_config = {}\n        background_config_base = self.default_background_config.copy()\n        background_config_base.update(background_config)\n\n        if background == \"rectangle\":\n            self.background = SurroundingRectangle(\n                self,\n                **background_config_base,\n            )\n        elif background == \"window\":\n            buttons = VGroup(\n                Dot(radius=0.1, stroke_width=0, color=button_color)\n                for button_color in [\"#ff5f56\", \"#ffbd2e\", \"#27c93f\"]\n            ).arrange(RIGHT, buff=0.1)\n            buttons.next_to(self, UP, buff=0.1).align_to(self, LEFT).shift(LEFT * 0.1)\n            self.background = SurroundingRectangle(\n                VGroup(self, buttons),\n                **background_config_base,\n            )\n            buttons.shift(UP * 0.1 + LEFT * 0.1)\n            self.background.add(buttons)\n        else:\n            raise ValueError(f\"Unknown background type: {background}\")\n\n        self.add_to_back(self.background)\n\n    @classmethod\n    def get_styles_list(cls) -> list[str]:\n        \"\"\"Get the list of all available formatter styles.\"\"\"\n        if cls._styles_list_cache is None:\n            cls._styles_list_cache = list(get_all_styles())\n        return cls._styles_list_cache"}, {"name": "color_gradient", "code": "def color_gradient(\n    reference_colors: Sequence[ParsableManimColor],\n    length_of_output: int,\n) -> list[ManimColor] | ManimColor:\n    \"\"\"Create a list of colors interpolated between the input array of colors with a\n    specific number of colors.\n\n    Parameters\n    ----------\n    reference_colors\n        The colors to be interpolated between or spread apart.\n    length_of_output\n        The number of colors that the output should have, ideally more than the input.\n\n    Returns\n    -------\n    list[ManimColor] | ManimColor\n        A :class:`ManimColor` or a list of interpolated :class:`ManimColor`'s.\n    \"\"\"\n    if length_of_output == 0:\n        return ManimColor(reference_colors[0])\n    if len(reference_colors) == 1:\n        return [ManimColor(reference_colors[0])] * length_of_output\n    rgbs = [color_to_rgb(color) for color in reference_colors]\n    alphas = np.linspace(0, (len(rgbs) - 1), length_of_output)\n    floors = alphas.astype(\"int\")\n    alphas_mod1 = alphas % 1\n    # End edge case\n    alphas_mod1[-1] = 1\n    floors[-1] = len(rgbs) - 2\n    return [\n        rgb_to_color((rgbs[i] * (1 - alpha)) + (rgbs[i + 1] * alpha))\n        for i, alpha in zip(floors, alphas_mod1)\n    ]"}, {"name": "color_to_int_rgb", "code": "def color_to_int_rgb(color: ParsableManimColor) -> RGB_Array_Int:\n    \"\"\"Helper function for use in functional style programming. Refer to\n    :meth:`ManimColor.to_int_rgb`.\n\n    Parameters\n    ----------\n    color\n        A color to convert to an RGB integer array.\n\n    Returns\n    -------\n    RGB_Array_Int\n        The corresponding RGB integer array.\n    \"\"\"\n    return ManimColor(color).to_int_rgb()"}, {"name": "color_to_int_rgba", "code": "def color_to_int_rgba(color: ParsableManimColor, alpha: float = 1.0) -> RGBA_Array_Int:\n    \"\"\"Helper function for use in functional style programming. Refer to\n    :meth:`ManimColor.to_int_rgba_with_alpha`.\n\n    Parameters\n    ----------\n    color\n        A color to convert to an RGBA integer array.\n    alpha\n        An alpha value between 0.0 and 1.0 to be used as opacity in the color. Default is\n        1.0.\n\n    Returns\n    -------\n    RGBA_Array_Int\n        The corresponding RGBA integer array.\n    \"\"\"\n    return ManimColor(color).to_int_rgba_with_alpha(alpha)"}, {"name": "color_to_rgb", "code": "def color_to_rgb(color: ParsableManimColor) -> RGB_Array_Float:\n    \"\"\"Helper function for use in functional style programming.\n    Refer to :meth:`ManimColor.to_rgb`.\n\n    Parameters\n    ----------\n    color\n        A color to convert to an RGB float array.\n\n    Returns\n    -------\n    RGB_Array_Float\n        The corresponding RGB float array.\n    \"\"\"\n    return ManimColor(color).to_rgb()"}, {"name": "color_to_rgba", "code": "def color_to_rgba(color: ParsableManimColor, alpha: float = 1.0) -> RGBA_Array_Float:\n    \"\"\"Helper function for use in functional style programming. Refer to\n    :meth:`ManimColor.to_rgba_with_alpha`.\n\n    Parameters\n    ----------\n    color\n        A color to convert to an RGBA float array.\n    alpha\n        An alpha value between 0.0 and 1.0 to be used as opacity in the color. Default is\n        1.0.\n\n    Returns\n    -------\n    RGBA_Array_Float\n        The corresponding RGBA float array.\n    \"\"\"\n    return ManimColor(color).to_rgba_with_alpha(alpha)"}, {"name": "Comparable", "code": "class Comparable(Protocol):\n    def __lt__(self, other: Any) -> bool: ...\n\n    def __gt__(self, other: Any) -> bool: ..."}, {"name": "compass_directions", "code": "def compass_directions(n: int = 4, start_vect: np.ndarray = RIGHT) -> np.ndarray:\n    \"\"\"Finds the cardinal directions using tau.\n\n    Parameters\n    ----------\n    n\n        The amount to be rotated, by default 4\n    start_vect\n        The direction for the angle to start with, by default RIGHT\n\n    Returns\n    -------\n    np.ndarray\n        The angle which has been rotated.\n    \"\"\"\n    angle = TAU / n\n    return np.array([rotate_vector(start_vect, k * angle) for k in range(n)])"}, {"name": "compile_tex", "code": "def compile_tex(tex_file: Path, tex_compiler: str, output_format: str) -> Path:\n    \"\"\"Compiles a tex_file into a .dvi or a .xdv or a .pdf\n\n    Parameters\n    ----------\n    tex_file\n        File name of TeX file to be typeset.\n    tex_compiler\n        String containing the compiler to be used, e.g. ``pdflatex`` or ``lualatex``\n    output_format\n        String containing the output format generated by the compiler, e.g. ``.dvi`` or ``.pdf``\n\n    Returns\n    -------\n    :class:`Path`\n        Path to generated output file in desired format (DVI, XDV or PDF).\n    \"\"\"\n    result = tex_file.with_suffix(output_format)\n    tex_dir = config.get_dir(\"tex_dir\")\n    if not result.exists():\n        command = make_tex_compilation_command(\n            tex_compiler,\n            output_format,\n            tex_file,\n            tex_dir,\n        )\n        cp = subprocess.run(command, stdout=subprocess.DEVNULL)\n        if cp.returncode != 0:\n            log_file = tex_file.with_suffix(\".log\")\n            print_all_tex_errors(log_file, tex_compiler, tex_file)\n            raise ValueError(\n                f\"{tex_compiler} error converting to\"\n                f\" {output_format[1:]}. See log output above or\"\n                f\" the log file: {log_file}\",\n            )\n    return result"}, {"name": "complex_func_to_R3_func", "code": "def complex_func_to_R3_func(\n    complex_func: Callable[[complex], complex],\n) -> Callable[[Point3DLike], Point3D]:\n    return lambda p: complex_to_R3(complex_func(R3_to_complex(p)))"}, {"name": "complex_to_R3", "code": "def complex_to_R3(complex_num: complex) -> np.ndarray:\n    return np.array((complex_num.real, complex_num.imag, 0))"}, {"name": "ComplexHomotopy", "code": "class ComplexHomotopy(Homotopy):\n    def __init__(\n        self, complex_homotopy: Callable[[complex], float], mobject: Mobject, **kwargs\n    ) -> None:\n        \"\"\"Complex Homotopy a function Cx[0, 1] to C\"\"\"\n\n        def homotopy(\n            x: float,\n            y: float,\n            z: float,\n            t: float,\n        ) -> tuple[float, float, float]:\n            c = complex_homotopy(complex(x, y), t)\n            return (c.real, c.imag, z)\n\n        super().__init__(homotopy, mobject, **kwargs)"}, {"name": "ComplexPlane", "code": "class ComplexPlane(NumberPlane):\n    \"\"\"A :class:`~.NumberPlane` specialized for use with complex numbers.\n\n    Examples\n    --------\n    .. manim:: ComplexPlaneExample\n        :save_last_frame:\n        :ref_classes: Dot MathTex\n\n        class ComplexPlaneExample(Scene):\n            def construct(self):\n                plane = ComplexPlane().add_coordinates()\n                self.add(plane)\n                d1 = Dot(plane.n2p(2 + 1j), color=YELLOW)\n                d2 = Dot(plane.n2p(-3 - 2j), color=YELLOW)\n                label1 = MathTex(\"2+i\").next_to(d1, UR, 0.1)\n                label2 = MathTex(\"-3-2i\").next_to(d2, UR, 0.1)\n                self.add(\n                    d1,\n                    label1,\n                    d2,\n                    label2,\n                )\n\n    \"\"\"\n\n    def __init__(self, **kwargs: Any) -> None:\n        super().__init__(\n            **kwargs,\n        )\n\n    def number_to_point(self, number: float | complex) -> np.ndarray:\n        \"\"\"Accepts a float/complex number and returns the equivalent point on the plane.\n\n        Parameters\n        ----------\n        number\n            The number. Can be a float or a complex number.\n\n        Returns\n        -------\n        np.ndarray\n            The point on the plane.\n        \"\"\"\n        number = complex(number)\n        return self.coords_to_point(number.real, number.imag)\n\n    def n2p(self, number: float | complex) -> np.ndarray:\n        \"\"\"Abbreviation for :meth:`number_to_point`.\"\"\"\n        return self.number_to_point(number)\n\n    def point_to_number(self, point: Point3DLike) -> complex:\n        \"\"\"Accepts a point and returns a complex number equivalent to that point on the plane.\n\n        Parameters\n        ----------\n        point\n            The point in manim's coordinate-system\n\n        Returns\n        -------\n        complex\n            A complex number consisting of real and imaginary components.\n        \"\"\"\n        x, y = self.point_to_coords(point)\n        return complex(x, y)\n\n    def p2n(self, point: Point3DLike) -> complex:\n        \"\"\"Abbreviation for :meth:`point_to_number`.\"\"\"\n        return self.point_to_number(point)\n\n    def _get_default_coordinate_values(self) -> list[float | complex]:\n        \"\"\"Generate a list containing the numerical values of the plane's labels.\n\n        Returns\n        -------\n        List[float | complex]\n            A list of floats representing the x-axis and complex numbers representing the y-axis.\n        \"\"\"\n        x_numbers = self.get_x_axis().get_tick_range()\n        y_numbers = self.get_y_axis().get_tick_range()\n        y_numbers = [complex(0, y) for y in y_numbers if y != 0]\n        return [*x_numbers, *y_numbers]\n\n    def get_coordinate_labels(\n        self, *numbers: Iterable[float | complex], **kwargs: Any\n    ) -> VGroup:\n        \"\"\"Generates the :class:`~.DecimalNumber` mobjects for the coordinates of the plane.\n\n        Parameters\n        ----------\n        numbers\n            An iterable of floats/complex numbers. Floats are positioned along the x-axis, complex numbers along the y-axis.\n        kwargs\n            Additional arguments to be passed to :meth:`~.NumberLine.get_number_mobject`, i.e. :class:`~.DecimalNumber`.\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            A :class:`~.VGroup` containing the positioned label mobjects.\n        \"\"\"\n        # TODO: Make this work the same as coord_sys.add_coordinates()\n        if len(numbers) == 0:\n            numbers = self._get_default_coordinate_values()\n\n        self.coordinate_labels = VGroup()\n        for number in numbers:\n            z = complex(number)\n            if abs(z.imag) > abs(z.real):\n                axis = self.get_y_axis()\n                value = z.imag\n                kwargs[\"unit\"] = \"i\"\n            else:\n                axis = self.get_x_axis()\n                value = z.real\n            number_mob = axis.get_number_mobject(value, **kwargs)\n            self.coordinate_labels.add(number_mob)\n        return self.coordinate_labels\n\n    def add_coordinates(\n        self, *numbers: Iterable[float | complex], **kwargs: Any\n    ) -> Self:\n        \"\"\"Adds the labels produced from :meth:`~.NumberPlane.get_coordinate_labels` to the plane.\n\n        Parameters\n        ----------\n        numbers\n            An iterable of floats/complex numbers. Floats are positioned along the x-axis, complex numbers along the y-axis.\n        kwargs\n            Additional arguments to be passed to :meth:`~.NumberLine.get_number_mobject`, i.e. :class:`~.DecimalNumber`.\n        \"\"\"\n        self.add(self.get_coordinate_labels(*numbers, **kwargs))\n        return self"}, {"name": "ComplexValueTracker", "code": "class ComplexValueTracker(ValueTracker):\n    \"\"\"Tracks a complex-valued parameter.\n\n    When the value is set through :attr:`animate`, the value will take a straight path from the\n    source point to the destination point.\n\n    Examples\n    --------\n    .. manim:: ComplexValueTrackerExample\n\n        class ComplexValueTrackerExample(Scene):\n            def construct(self):\n                tracker = ComplexValueTracker(-2+1j)\n                dot = Dot().add_updater(\n                    lambda x: x.move_to(tracker.points)\n                )\n\n                self.add(NumberPlane(), dot)\n\n                self.play(tracker.animate.set_value(3+2j))\n                self.play(tracker.animate.set_value(tracker.get_value() * 1j))\n                self.play(tracker.animate.set_value(tracker.get_value() - 2j))\n                self.play(tracker.animate.set_value(tracker.get_value() / (-2 + 3j)))\n    \"\"\"\n\n    def get_value(self):\n        \"\"\"Get the current value of this value tracker as a complex number.\n\n        The value is internally stored as a points array [a, b, 0]. This can be accessed directly\n        to represent the value geometrically, see the usage example.\n        \"\"\"\n        return complex(*self.points[0, :2])\n\n    def set_value(self, z):\n        \"\"\"Sets a new complex value to the ComplexValueTracker\"\"\"\n        z = complex(z)\n        self.points[0, :2] = (z.real, z.imag)\n        return self"}, {"name": "concatenate_lists", "code": "def concatenate_lists(*list_of_lists: Iterable[T]) -> list[T]:\n    \"\"\"Combines the Iterables provided as arguments into one list.\n\n    Examples\n    --------\n    .. code-block:: pycon\n\n        >>> concatenate_lists([1, 2], [3, 4], [5])\n        [1, 2, 3, 4, 5]\n    \"\"\"\n    return [item for lst in list_of_lists for item in lst]"}, {"name": "Cone", "code": "class Cone(Surface):\n    \"\"\"A circular cone.\n    Can be defined using 2 parameters: its height, and its base radius.\n    The polar angle, theta, can be calculated using arctan(base_radius /\n    height) The spherical radius, r, is calculated using the pythagorean\n    theorem.\n\n    Parameters\n    ----------\n    base_radius\n        The base radius from which the cone tapers.\n    height\n        The height measured from the plane formed by the base_radius to\n        the apex of the cone.\n    direction\n        The direction of the apex.\n    show_base\n        Whether to show the base plane or not.\n    v_range\n        The azimuthal angle to start and end at.\n    u_min\n        The radius at the apex.\n    checkerboard_colors\n        Show checkerboard grid texture on the cone.\n\n    Examples\n    --------\n    .. manim:: ExampleCone\n        :save_last_frame:\n\n        class ExampleCone(ThreeDScene):\n            def construct(self):\n                axes = ThreeDAxes()\n                cone = Cone(direction=X_AXIS+Y_AXIS+2*Z_AXIS, resolution=8)\n                self.set_camera_orientation(phi=5*PI/11, theta=PI/9)\n                self.add(axes, cone)\n    \"\"\"\n\n    def __init__(\n        self,\n        base_radius: float = 1,\n        height: float = 1,\n        direction: np.ndarray = Z_AXIS,\n        show_base: bool = False,\n        v_range: Sequence[float] = [0, TAU],\n        u_min: float = 0,\n        checkerboard_colors: bool = False,\n        **kwargs: Any,\n    ) -> None:\n        self.direction = direction\n        self.theta = PI - np.arctan(base_radius / height)\n\n        super().__init__(\n            self.func,\n            v_range=v_range,\n            u_range=[u_min, np.sqrt(base_radius**2 + height**2)],\n            checkerboard_colors=checkerboard_colors,\n            **kwargs,\n        )\n        # used for rotations\n        self.new_height = height\n        self._current_theta = 0\n        self._current_phi = 0\n        self.base_circle = Circle(\n            radius=base_radius,\n            color=self.fill_color,\n            fill_opacity=self.fill_opacity,\n            stroke_width=0,\n        )\n        self.base_circle.shift(height * IN)\n        self._set_start_and_end_attributes(direction)\n        if show_base:\n            self.add(self.base_circle)\n\n        self._rotate_to_direction()\n\n    def func(self, u: float, v: float) -> np.ndarray:\n        \"\"\"Converts from spherical coordinates to cartesian.\n\n        Parameters\n        ----------\n        u\n            The radius.\n        v\n            The azimuthal angle.\n\n        Returns\n        -------\n        :class:`numpy.array`\n            Points defining the :class:`Cone`.\n        \"\"\"\n        r = u\n        phi = v\n        return np.array(\n            [\n                r * np.sin(self.theta) * np.cos(phi),\n                r * np.sin(self.theta) * np.sin(phi),\n                r * np.cos(self.theta),\n            ],\n        )\n\n    def get_start(self) -> np.ndarray:\n        return self.start_point.get_center()\n\n    def get_end(self) -> np.ndarray:\n        return self.end_point.get_center()\n\n    def _rotate_to_direction(self) -> None:\n        x, y, z = self.direction\n\n        r = np.sqrt(x**2 + y**2 + z**2)\n        theta = np.arccos(z / r) if r > 0 else 0\n\n        if x == 0:\n            if y == 0:  # along the z axis\n                phi = 0\n            else:\n                phi = np.arctan(np.inf)\n                if y < 0:\n                    phi += PI\n        else:\n            phi = np.arctan(y / x)\n        if x < 0:\n            phi += PI\n\n        # Undo old rotation (in reverse order)\n        self.rotate(-self._current_phi, Z_AXIS, about_point=ORIGIN)\n        self.rotate(-self._current_theta, Y_AXIS, about_point=ORIGIN)\n\n        # Do new rotation\n        self.rotate(theta, Y_AXIS, about_point=ORIGIN)\n        self.rotate(phi, Z_AXIS, about_point=ORIGIN)\n\n        # Store values\n        self._current_theta = theta\n        self._current_phi = phi\n\n    def set_direction(self, direction: np.ndarray) -> None:\n        \"\"\"Changes the direction of the apex of the :class:`Cone`.\n\n        Parameters\n        ----------\n        direction\n            The direction of the apex.\n        \"\"\"\n        self.direction = direction\n        self._rotate_to_direction()\n\n    def get_direction(self) -> np.ndarray:\n        \"\"\"Returns the current direction of the apex of the :class:`Cone`.\n\n        Returns\n        -------\n        direction : :class:`numpy.array`\n            The direction of the apex.\n        \"\"\"\n        return self.direction\n\n    def _set_start_and_end_attributes(self, direction):\n        normalized_direction = direction * np.linalg.norm(direction)\n\n        start = self.base_circle.get_center()\n        end = start + normalized_direction * self.new_height\n        self.start_point = VectorizedPoint(start)\n        self.end_point = VectorizedPoint(end)\n        self.add(self.start_point, self.end_point)"}, {"name": "config_file_paths", "code": "def config_file_paths() -> list[Path]:\n    \"\"\"The paths where ``.cfg`` files will be searched for.\n\n    When manim is first imported, it processes any ``.cfg`` files it finds.  This\n    function returns the locations in which these files are searched for.  In\n    ascending order of precedence, these are: the library-wide config file, the\n    user-wide config file, and the folder-wide config file.\n\n    The library-wide config file determines manim's default behavior.  The\n    user-wide config file is stored in the user's home folder, and determines\n    the behavior of manim whenever the user invokes it from anywhere in the\n    system.  The folder-wide config file only affects scenes that are in the\n    same folder.  The latter two files are optional.\n\n    These files, if they exist, are meant to loaded into a single\n    :class:`configparser.ConfigParser` object, and then processed by\n    :class:`ManimConfig`.\n\n    Returns\n    -------\n    List[:class:`Path`]\n        List of paths which may contain ``.cfg`` files, in ascending order of\n        precedence.\n\n    See Also\n    --------\n    :func:`make_config_parser`, :meth:`ManimConfig.digest_file`,\n    :meth:`ManimConfig.digest_parser`\n\n    Notes\n    -----\n    The location of the user-wide config file is OS-specific.\n\n    \"\"\"\n    library_wide = Path.resolve(Path(__file__).parent / \"default.cfg\")\n    if sys.platform.startswith(\"win32\"):\n        user_wide = Path.home() / \"AppData\" / \"Roaming\" / \"Manim\" / \"manim.cfg\"\n    else:\n        user_wide = Path.home() / \".config\" / \"manim\" / \"manim.cfg\"\n    folder_wide = Path(\"manim.cfg\")\n    return [library_wide, user_wide, folder_wide]"}, {"name": "configure_pygui", "code": "def configure_pygui(renderer, widgets, update=True):\n    if not dearpygui_imported:\n        raise RuntimeError(\"Attempted to use DearPyGUI when it isn't imported.\")\n    if update:\n        dpg.delete_item(window)\n    else:\n        dpg.create_viewport()\n        dpg.setup_dearpygui()\n        dpg.show_viewport()\n\n    dpg.set_viewport_title(title=f\"Manim Community v{__version__}\")\n    dpg.set_viewport_width(1015)\n    dpg.set_viewport_height(540)\n\n    def rerun_callback(sender, data):\n        renderer.scene.queue.put((\"rerun_gui\", [], {}))\n\n    def continue_callback(sender, data):\n        renderer.scene.queue.put((\"exit_gui\", [], {}))\n\n    def scene_selection_callback(sender, data):\n        config[\"scene_names\"] = (dpg.get_value(sender),)\n        renderer.scene.queue.put((\"rerun_gui\", [], {}))\n\n    scene_classes = scene_classes_from_file(Path(config[\"input_file\"]), full_list=True)\n    scene_names = [scene_class.__name__ for scene_class in scene_classes]\n\n    with dpg.window(\n        id=window,\n        label=\"Manim GUI\",\n        pos=[config[\"gui_location\"][0], config[\"gui_location\"][1]],\n        width=1000,\n        height=500,\n    ):\n        dpg.set_global_font_scale(2)\n        dpg.add_button(label=\"Rerun\", callback=rerun_callback)\n        dpg.add_button(label=\"Continue\", callback=continue_callback)\n        dpg.add_combo(\n            label=\"Selected scene\",\n            items=scene_names,\n            callback=scene_selection_callback,\n            default_value=config[\"scene_names\"][0],\n        )\n        dpg.add_separator()\n        if len(widgets) != 0:\n            with dpg.collapsing_header(\n                label=f\"{config['scene_names'][0]} widgets\",\n                default_open=True,\n            ):\n                for widget_config in widgets:\n                    widget_config_copy = widget_config.copy()\n                    name = widget_config_copy[\"name\"]\n                    widget = widget_config_copy[\"widget\"]\n                    if widget != \"separator\":\n                        del widget_config_copy[\"name\"]\n                        del widget_config_copy[\"widget\"]\n                        getattr(dpg, f\"add_{widget}\")(label=name, **widget_config_copy)\n                    else:\n                        dpg.add_separator()\n\n    if not update:\n        dpg.start_dearpygui()"}, {"name": "convert_audio", "code": "def convert_audio(input_path: Path, output_path: Path, codec_name: str):\n    with (\n        av.open(input_path) as input_audio,\n        av.open(output_path, \"w\") as output_audio,\n    ):\n        input_audio_stream = input_audio.streams.audio[0]\n        output_audio_stream = output_audio.add_stream(codec_name)\n        for frame in input_audio.decode(input_audio_stream):\n            for packet in output_audio_stream.encode(frame):\n                output_audio.mux(packet)\n\n        for packet in output_audio_stream.encode():\n            output_audio.mux(packet)"}, {"name": "convert_to_svg", "code": "def convert_to_svg(dvi_file: Path, extension: str, page: int = 1) -> Path:\n    \"\"\"Converts a .dvi, .xdv, or .pdf file into an svg using dvisvgm.\n\n    Parameters\n    ----------\n    dvi_file\n        File name of the input file to be converted.\n    extension\n        String containing the file extension and thus indicating the file type, e.g. ``.dvi`` or ``.pdf``\n    page\n        Page to be converted if input file is multi-page.\n\n    Returns\n    -------\n    :class:`Path`\n        Path to generated SVG file.\n    \"\"\"\n    result = dvi_file.with_suffix(\".svg\")\n    if not result.exists():\n        command = [\n            \"dvisvgm\",\n            *([\"--pdf\"] if extension == \".pdf\" else []),\n            f\"--page={page}\",\n            \"--no-fonts\",\n            \"--verbosity=0\",\n            f\"--output={result.as_posix()}\",\n            f\"{dvi_file.as_posix()}\",\n        ]\n        subprocess.run(command, stdout=subprocess.DEVNULL)\n\n    # if the file does not exist now, this means conversion failed\n    if not result.exists():\n        raise ValueError(\n            f\"Your installation does not support converting {dvi_file.suffix} files to SVG.\"\n            f\" Consider updating dvisvgm to at least version 2.4.\"\n            f\" If this does not solve the problem, please refer to our troubleshooting guide at:\"\n            f\" https://docs.manim.community/en/stable/faq/general.html#my-installation-\"\n            f\"does-not-support-converting-pdf-to-svg-help\",\n        )\n\n    return result"}, {"name": "ConvertToOpenGL", "code": "class ConvertToOpenGL(ABCMeta):\n    \"\"\"Metaclass for swapping (V)Mobject with its OpenGL counterpart at runtime\n    depending on config.renderer. This metaclass should only need to be inherited\n    on the lowest order inheritance classes such as Mobject and VMobject.\n    \"\"\"\n\n    _converted_classes = []\n\n    def __new__(mcls, name, bases, namespace):\n        if config.renderer == RendererType.OPENGL:\n            # Must check class names to prevent\n            # cyclic importing.\n            base_names_to_opengl = {\n                \"Mobject\": OpenGLMobject,\n                \"VMobject\": OpenGLVMobject,\n                \"PMobject\": OpenGLPMobject,\n                \"Mobject1D\": OpenGLPMobject,\n                \"Mobject2D\": OpenGLPMobject,\n                \"Surface\": OpenGLSurface,\n            }\n\n            bases = tuple(\n                base_names_to_opengl.get(base.__name__, base) for base in bases\n            )\n\n        return super().__new__(mcls, name, bases, namespace)\n\n    def __init__(cls, name, bases, namespace):\n        super().__init__(name, bases, namespace)\n        cls._converted_classes.append(cls)"}, {"name": "ConvexHull", "code": "class ConvexHull(Polygram):\n    \"\"\"Constructs a convex hull for a set of points in no particular order.\n\n    Parameters\n    ----------\n    points\n        The points to consider.\n    tolerance\n        The tolerance used by quickhull.\n    kwargs\n        Forwarded to the parent constructor.\n\n    Examples\n    --------\n    .. manim:: ConvexHullExample\n        :save_last_frame:\n        :quality: high\n\n        class ConvexHullExample(Scene):\n            def construct(self):\n                points = [\n                    [-2.35, -2.25, 0],\n                    [1.65, -2.25, 0],\n                    [2.65, -0.25, 0],\n                    [1.65, 1.75, 0],\n                    [-0.35, 2.75, 0],\n                    [-2.35, 0.75, 0],\n                    [-0.35, -1.25, 0],\n                    [0.65, -0.25, 0],\n                    [-1.35, 0.25, 0],\n                    [0.15, 0.75, 0]\n                ]\n                hull = ConvexHull(*points, color=BLUE)\n                dots = VGroup(*[Dot(point) for point in points])\n                self.add(hull)\n                self.add(dots)\n    \"\"\"\n\n    def __init__(\n        self, *points: Point3DLike, tolerance: float = 1e-5, **kwargs: Any\n    ) -> None:\n        # Build Convex Hull\n        array = np.array(points)[:, :2]\n        hull = QuickHull(tolerance)\n        hull.build(array)\n\n        # Extract Vertices\n        facets = set(hull.facets) - hull.removed\n        facet = facets.pop()\n        subfacets = list(facet.subfacets)\n        while len(subfacets) <= len(facets):\n            sf = subfacets[-1]\n            (facet,) = hull.neighbors[sf] - {facet}\n            (sf,) = facet.subfacets - {sf}\n            subfacets.append(sf)\n\n        # Setup Vertices as Point3D\n        coordinates = np.vstack([sf.coordinates for sf in subfacets])\n        vertices = np.hstack((coordinates, np.zeros((len(coordinates), 1))))\n\n        # Call Polygram\n        super().__init__(vertices, **kwargs)"}, {"name": "ConvexHull3D", "code": "class ConvexHull3D(Polyhedron):\n    \"\"\"A convex hull for a set of points\n\n    Parameters\n    ----------\n    points\n        The points to consider.\n    tolerance\n        The tolerance used for quickhull.\n    kwargs\n        Forwarded to the parent constructor.\n\n    Examples\n    --------\n    .. manim:: ConvexHull3DExample\n        :save_last_frame:\n        :quality: high\n\n        class ConvexHull3DExample(ThreeDScene):\n            def construct(self):\n                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n                points = [\n                    [ 1.93192757,  0.44134585, -1.52407061],\n                    [-0.93302521,  1.23206983,  0.64117067],\n                    [-0.44350918, -0.61043677,  0.21723705],\n                    [-0.42640268, -1.05260843,  1.61266094],\n                    [-1.84449637,  0.91238739, -1.85172623],\n                    [ 1.72068132, -0.11880457,  0.51881751],\n                    [ 0.41904805,  0.44938012, -1.86440686],\n                    [ 0.83864666,  1.66653337,  1.88960123],\n                    [ 0.22240514, -0.80986286,  1.34249326],\n                    [-1.29585759,  1.01516189,  0.46187522],\n                    [ 1.7776499,  -1.59550796, -1.70240747],\n                    [ 0.80065226, -0.12530398,  1.70063977],\n                    [ 1.28960948, -1.44158255,  1.39938582],\n                    [-0.93538943,  1.33617705, -0.24852643],\n                    [-1.54868271,  1.7444399,  -0.46170734]\n                ]\n                hull = ConvexHull3D(\n                    *points,\n                    faces_config = {\"stroke_opacity\": 0},\n                    graph_config = {\n                        \"vertex_type\": Dot3D,\n                        \"edge_config\": {\n                            \"stroke_color\": BLUE,\n                            \"stroke_width\": 2,\n                            \"stroke_opacity\": 0.05,\n                        }\n                    }\n                )\n                dots = VGroup(*[Dot3D(point) for point in points])\n                self.add(hull)\n                self.add(dots)\n    \"\"\"\n\n    def __init__(self, *points: Point3D, tolerance: float = 1e-5, **kwargs):\n        # Build Convex Hull\n        array = np.array(points)\n        hull = QuickHull(tolerance)\n        hull.build(array)\n\n        # Setup Lists\n        vertices = []\n        faces = []\n\n        # Extract Faces\n        c = 0\n        d = {}\n        facets = set(hull.facets) - hull.removed\n        for facet in facets:\n            tmp = set()\n            for subfacet in facet.subfacets:\n                for point in subfacet.points:\n                    if point not in d:\n                        vertices.append(point.coordinates)\n                        d[point] = c\n                        c += 1\n                    tmp.add(point)\n            faces.append([d[point] for point in tmp])\n\n        # Call Polyhedron\n        super().__init__(\n            vertex_coords=vertices,\n            faces_list=faces,\n            **kwargs,\n        )"}, {"name": "CoordinateSystem", "code": "class CoordinateSystem:\n    r\"\"\"Abstract base class for Axes and NumberPlane.\n\n    Examples\n    --------\n    .. manim:: CoordSysExample\n        :save_last_frame:\n\n        class CoordSysExample(Scene):\n            def construct(self):\n                # the location of the ticks depends on the x_range and y_range.\n                grid = Axes(\n                    x_range=[0, 1, 0.05],  # step size determines num_decimal_places.\n                    y_range=[0, 1, 0.05],\n                    x_length=9,\n                    y_length=5.5,\n                    axis_config={\n                        \"numbers_to_include\": np.arange(0, 1 + 0.1, 0.1),\n                        \"font_size\": 24,\n                    },\n                    tips=False,\n                )\n\n                # Labels for the x-axis and y-axis.\n                y_label = grid.get_y_axis_label(\"y\", edge=LEFT, direction=LEFT, buff=0.4)\n                x_label = grid.get_x_axis_label(\"x\")\n                grid_labels = VGroup(x_label, y_label)\n\n                graphs = VGroup()\n                for n in np.arange(1, 20 + 0.5, 0.5):\n                    graphs += grid.plot(lambda x: x ** n, color=WHITE)\n                    graphs += grid.plot(\n                        lambda x: x ** (1 / n), color=WHITE, use_smoothing=False\n                    )\n\n                # Extra lines and labels for point (1,1)\n                graphs += grid.get_horizontal_line(grid @ (1, 1, 0), color=BLUE)\n                graphs += grid.get_vertical_line(grid @ (1, 1, 0), color=BLUE)\n                graphs += Dot(point=grid @ (1, 1, 0), color=YELLOW)\n                graphs += Tex(\"(1,1)\").scale(0.75).next_to(grid @ (1, 1, 0))\n                title = Title(\n                    # spaces between braces to prevent SyntaxError\n                    r\"Graphs of $y=x^{ {1}\\over{n} }$ and $y=x^n (n=1,2,3,...,20)$\",\n                    include_underline=False,\n                    font_size=40,\n                )\n\n                self.add(title, graphs, grid, grid_labels)\n    \"\"\"\n\n    def __init__(\n        self,\n        x_range: Sequence[float] | None = None,\n        y_range: Sequence[float] | None = None,\n        x_length: float | None = None,\n        y_length: float | None = None,\n        dimension: int = 2,\n    ) -> None:\n        self.dimension = dimension\n\n        default_step = 1\n        if x_range is None:\n            x_range = [\n                round(-config[\"frame_x_radius\"]),\n                round(config[\"frame_x_radius\"]),\n                default_step,\n            ]\n        elif len(x_range) == 2:\n            x_range = [*x_range, default_step]\n\n        if y_range is None:\n            y_range = [\n                round(-config[\"frame_y_radius\"]),\n                round(config[\"frame_y_radius\"]),\n                default_step,\n            ]\n        elif len(y_range) == 2:\n            y_range = [*y_range, default_step]\n\n        self.x_range = x_range\n        self.y_range = y_range\n        self.x_length = x_length\n        self.y_length = y_length\n        self.num_sampled_graph_points_per_tick = 10\n\n    def coords_to_point(self, *coords: ManimFloat):\n        raise NotImplementedError()\n\n    def point_to_coords(self, point: Point3DLike):\n        raise NotImplementedError()\n\n    def polar_to_point(self, radius: float, azimuth: float) -> Point2D:\n        r\"\"\"Gets a point from polar coordinates.\n\n        Parameters\n        ----------\n        radius\n            The coordinate radius (:math:`r`).\n\n        azimuth\n            The coordinate azimuth (:math:`\\theta`).\n\n        Returns\n        -------\n        numpy.ndarray\n            The point.\n\n        Examples\n        --------\n        .. manim:: PolarToPointExample\n            :ref_classes: PolarPlane Vector\n            :save_last_frame:\n\n            class PolarToPointExample(Scene):\n                def construct(self):\n                    polarplane_pi = PolarPlane(azimuth_units=\"PI radians\", size=6)\n                    polartopoint_vector = Vector(polarplane_pi.polar_to_point(3, PI/4))\n                    self.add(polarplane_pi)\n                    self.add(polartopoint_vector)\n        \"\"\"\n        return self.coords_to_point(radius * np.cos(azimuth), radius * np.sin(azimuth))\n\n    def point_to_polar(self, point: Point2DLike) -> Point2D:\n        r\"\"\"Gets polar coordinates from a point.\n\n        Parameters\n        ----------\n        point\n            The point.\n\n        Returns\n        -------\n        Tuple[:class:`float`, :class:`float`]\n            The coordinate radius (:math:`r`) and the coordinate azimuth (:math:`\\theta`).\n        \"\"\"\n        x, y = self.point_to_coords(point)\n        return np.sqrt(x**2 + y**2), np.arctan2(y, x)\n\n    def c2p(\n        self, *coords: float | Sequence[float] | Sequence[Sequence[float]] | np.ndarray\n    ) -> np.ndarray:\n        \"\"\"Abbreviation for :meth:`coords_to_point`\"\"\"\n        return self.coords_to_point(*coords)\n\n    def p2c(self, point: Point3DLike):\n        \"\"\"Abbreviation for :meth:`point_to_coords`\"\"\"\n        return self.point_to_coords(point)\n\n    def pr2pt(self, radius: float, azimuth: float) -> np.ndarray:\n        \"\"\"Abbreviation for :meth:`polar_to_point`\"\"\"\n        return self.polar_to_point(radius, azimuth)\n\n    def pt2pr(self, point: np.ndarray) -> tuple[float, float]:\n        \"\"\"Abbreviation for :meth:`point_to_polar`\"\"\"\n        return self.point_to_polar(point)\n\n    def get_axes(self):\n        raise NotImplementedError()\n\n    def get_axis(self, index: int) -> Mobject:\n        return self.get_axes()[index]\n\n    def get_origin(self) -> np.ndarray:\n        \"\"\"Gets the origin of :class:`~.Axes`.\n\n        Returns\n        -------\n        np.ndarray\n            The center point.\n        \"\"\"\n        return self.coords_to_point(0, 0)\n\n    def get_x_axis(self) -> Mobject:\n        return self.get_axis(0)\n\n    def get_y_axis(self) -> Mobject:\n        return self.get_axis(1)\n\n    def get_z_axis(self) -> Mobject:\n        return self.get_axis(2)\n\n    def get_x_unit_size(self) -> float:\n        return self.get_x_axis().get_unit_size()\n\n    def get_y_unit_size(self) -> float:\n        return self.get_y_axis().get_unit_size()\n\n    def get_x_axis_label(\n        self,\n        label: float | str | Mobject,\n        edge: Sequence[float] = UR,\n        direction: Sequence[float] = UR,\n        buff: float = SMALL_BUFF,\n        **kwargs,\n    ) -> Mobject:\n        \"\"\"Generate an x-axis label.\n\n        Parameters\n        ----------\n        label\n            The label. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n        edge\n            The edge of the x-axis to which the label will be added, by default ``UR``.\n        direction\n            Allows for further positioning of the label from an edge, by default ``UR``.\n        buff\n            The distance of the label from the line.\n\n        Returns\n        -------\n        :class:`~.Mobject`\n            The positioned label.\n\n        Examples\n        --------\n        .. manim:: GetXAxisLabelExample\n            :save_last_frame:\n\n            class GetXAxisLabelExample(Scene):\n                def construct(self):\n                    ax = Axes(x_range=(0, 8), y_range=(0, 5), x_length=8, y_length=5)\n                    x_label = ax.get_x_axis_label(\n                        Tex(\"$x$-values\").scale(0.65), edge=DOWN, direction=DOWN, buff=0.5\n                    )\n                    self.add(ax, x_label)\n        \"\"\"\n        return self._get_axis_label(\n            label, self.get_x_axis(), edge, direction, buff=buff, **kwargs\n        )\n\n    def get_y_axis_label(\n        self,\n        label: float | str | Mobject,\n        edge: Sequence[float] = UR,\n        direction: Sequence[float] = UP * 0.5 + RIGHT,\n        buff: float = SMALL_BUFF,\n        **kwargs,\n    ) -> Mobject:\n        \"\"\"Generate a y-axis label.\n\n        Parameters\n        ----------\n        label\n            The label. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n        edge\n            The edge of the y-axis to which the label will be added, by default ``UR``.\n        direction\n            Allows for further positioning of the label from an edge, by default ``UR``\n        buff\n            The distance of the label from the line.\n\n        Returns\n        -------\n        :class:`~.Mobject`\n            The positioned label.\n\n        Examples\n        --------\n        .. manim:: GetYAxisLabelExample\n            :save_last_frame:\n\n            class GetYAxisLabelExample(Scene):\n                def construct(self):\n                    ax = Axes(x_range=(0, 8), y_range=(0, 5), x_length=8, y_length=5)\n                    y_label = ax.get_y_axis_label(\n                        Tex(\"$y$-values\").scale(0.65).rotate(90 * DEGREES),\n                        edge=LEFT,\n                        direction=LEFT,\n                        buff=0.3,\n                    )\n                    self.add(ax, y_label)\n        \"\"\"\n        return self._get_axis_label(\n            label, self.get_y_axis(), edge, direction, buff=buff, **kwargs\n        )\n\n    def _get_axis_label(\n        self,\n        label: float | str | Mobject,\n        axis: Mobject,\n        edge: Sequence[float],\n        direction: Sequence[float],\n        buff: float = SMALL_BUFF,\n    ) -> Mobject:\n        \"\"\"Gets the label for an axis.\n\n        Parameters\n        ----------\n        label\n            The label. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n        axis\n            The axis to which the label will be added.\n        edge\n            The edge of the axes to which the label will be added. ``RIGHT`` adds to the right side of the axis\n        direction\n            Allows for further positioning of the label.\n        buff\n            The distance of the label from the line.\n\n        Returns\n        -------\n        :class:`~.Mobject`\n            The positioned label along the given axis.\n        \"\"\"\n        label = self.x_axis._create_label_tex(label)\n        label.next_to(axis.get_edge_center(edge), direction=direction, buff=buff)\n        label.shift_onto_screen(buff=MED_SMALL_BUFF)\n        return label\n\n    def get_axis_labels(self):\n        raise NotImplementedError()\n\n    def add_coordinates(\n        self,\n        *axes_numbers: Iterable[float] | None | dict[float, str | float | Mobject],\n        **kwargs: Any,\n    ) -> Self:\n        \"\"\"Adds labels to the axes. Use ``Axes.coordinate_labels`` to\n        access the coordinates after creation.\n\n        Parameters\n        ----------\n        axes_numbers\n            The numbers to be added to the axes. Use ``None`` to represent an axis with default labels.\n\n        Examples\n        --------\n        .. code-block:: python\n\n            ax = ThreeDAxes()\n            x_labels = range(-4, 5)\n            z_labels = range(-4, 4, 2)\n            ax.add_coordinates(\n                x_labels, None, z_labels\n            )  # default y labels, custom x & z labels\n            ax.add_coordinates(x_labels)  # only x labels\n\n        You can also specifically control the position and value of the labels using a dict.\n\n        .. code-block:: python\n\n            ax = Axes(x_range=[0, 7])\n            x_pos = [x for x in range(1, 8)]\n\n            # strings are automatically converted into a Tex mobject.\n            x_vals = [\n                \"Monday\",\n                \"Tuesday\",\n                \"Wednesday\",\n                \"Thursday\",\n                \"Friday\",\n                \"Saturday\",\n                \"Sunday\",\n            ]\n            x_dict = dict(zip(x_pos, x_vals))\n            ax.add_coordinates(x_dict)\n        \"\"\"\n        self.coordinate_labels = VGroup()\n        # if nothing is passed to axes_numbers, produce axes with default labelling\n        if not axes_numbers:\n            axes_numbers = [None for _ in range(self.dimension)]\n\n        for axis, values in zip(self.axes, axes_numbers):\n            if isinstance(values, dict):\n                axis.add_labels(values, **kwargs)\n                labels = axis.labels\n            elif values is None and axis.scaling.custom_labels:\n                tick_range = axis.get_tick_range()\n                axis.add_labels(\n                    dict(zip(tick_range, axis.scaling.get_custom_labels(tick_range)))\n                )\n                labels = axis.labels\n            else:\n                axis.add_numbers(values, **kwargs)\n                labels = axis.numbers\n            self.coordinate_labels.add(labels)\n\n        return self\n\n    # overload necessary until https://github.com/python/mypy/issues/3737 is supported\n    @overload\n    def get_line_from_axis_to_point(\n        self,\n        index: int,\n        point: Sequence[float],\n        line_config: dict | None = ...,\n        color: ParsableManimColor | None = ...,\n        stroke_width: float = ...,\n    ) -> DashedLine: ...\n\n    @overload\n    def get_line_from_axis_to_point(\n        self,\n        index: int,\n        point: Sequence[float],\n        line_func: type[LineType],\n        line_config: dict | None = ...,\n        color: ParsableManimColor | None = ...,\n        stroke_width: float = ...,\n    ) -> LineType: ...\n\n    def get_line_from_axis_to_point(  # type: ignore[no-untyped-def]\n        self,\n        index,\n        point,\n        line_func=DashedLine,\n        line_config=None,\n        color=None,\n        stroke_width=2,\n    ):\n        \"\"\"Returns a straight line from a given axis to a point in the scene.\n\n        Parameters\n        ----------\n        index\n            Specifies the axis from which to draw the line. `0 = x_axis`, `1 = y_axis`\n        point\n            The point to which the line will be drawn.\n        line_func\n            The function of the :class:`~.Line` mobject used to construct the line.\n        line_config\n            Optional arguments to passed to :attr:`line_func`.\n        color\n            The color of the line.\n        stroke_width\n            The stroke width of the line.\n\n        Returns\n        -------\n        :class:`~.Line`\n            The line from an axis to a point.\n\n\n        .. seealso::\n            :meth:`~.CoordinateSystem.get_vertical_line`\n            :meth:`~.CoordinateSystem.get_horizontal_line`\n        \"\"\"\n        line_config = line_config if line_config is not None else {}\n\n        if color is None:\n            color = VMobject().color\n\n        line_config[\"color\"] = ManimColor.parse(color)\n        line_config[\"stroke_width\"] = stroke_width\n\n        axis = self.get_axis(index)\n        line = line_func(axis.get_projection(point), point, **line_config)\n        return line\n\n    def get_vertical_line(self, point: Sequence[float], **kwargs: Any) -> Line:\n        \"\"\"A vertical line from the x-axis to a given point in the scene.\n\n        Parameters\n        ----------\n        point\n            The point to which the vertical line will be drawn.\n        kwargs\n            Additional parameters to be passed to :class:`get_line_from_axis_to_point`.\n\n        Returns\n        -------\n        :class:`Line`\n            A vertical line from the x-axis to the point.\n\n        Examples\n        --------\n        .. manim:: GetVerticalLineExample\n            :save_last_frame:\n\n            class GetVerticalLineExample(Scene):\n                def construct(self):\n                    ax = Axes().add_coordinates()\n                    point = ax.coords_to_point(-3.5, 2)\n\n                    dot = Dot(point)\n                    line = ax.get_vertical_line(point, line_config={\"dashed_ratio\": 0.85})\n\n                    self.add(ax, line, dot)\n\n\n        \"\"\"\n        return self.get_line_from_axis_to_point(0, point, **kwargs)\n\n    def get_horizontal_line(self, point: Sequence[float], **kwargs) -> Line:\n        \"\"\"A horizontal line from the y-axis to a given point in the scene.\n\n        Parameters\n        ----------\n        point\n            The point to which the horizontal line will be drawn.\n        kwargs\n            Additional parameters to be passed to :class:`get_line_from_axis_to_point`.\n\n        Returns\n        -------\n        :class:`Line`\n            A horizontal line from the y-axis to the point.\n\n        Examples\n        --------\n        .. manim:: GetHorizontalLineExample\n            :save_last_frame:\n\n            class GetHorizontalLineExample(Scene):\n                def construct(self):\n                    ax = Axes().add_coordinates()\n                    point = ax @ (-4, 1.5)\n\n                    dot = Dot(point)\n                    line = ax.get_horizontal_line(point, line_func=Line)\n\n                    self.add(ax, line, dot)\n        \"\"\"\n        return self.get_line_from_axis_to_point(1, point, **kwargs)\n\n    def get_lines_to_point(self, point: Sequence[float], **kwargs) -> VGroup:\n        \"\"\"Generate both horizontal and vertical lines from the axis to a point.\n\n        Parameters\n        ----------\n        point\n            A point on the scene.\n        kwargs\n            Additional parameters to be passed to :meth:`get_line_from_axis_to_point`\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            A :class:`~.VGroup` of the horizontal and vertical lines.\n\n\n        .. seealso::\n            :meth:`~.CoordinateSystem.get_vertical_line`\n            :meth:`~.CoordinateSystem.get_horizontal_line`\n\n        Examples\n        --------\n        .. manim:: GetLinesToPointExample\n            :save_last_frame:\n\n            class GetLinesToPointExample(Scene):\n                def construct(self):\n                    ax = Axes()\n                    circ = Circle(radius=0.5).move_to([-4, -1.5, 0])\n\n                    lines_1 = ax.get_lines_to_point(circ.get_right(), color=GREEN_B)\n                    lines_2 = ax.get_lines_to_point(circ.get_corner(DL), color=BLUE_B)\n                    self.add(ax, lines_1, lines_2, circ)\n        \"\"\"\n        return VGroup(\n            self.get_horizontal_line(point, **kwargs),\n            self.get_vertical_line(point, **kwargs),\n        )\n\n    # graphing\n\n    def plot(\n        self,\n        function: Callable[[float], float],\n        x_range: Sequence[float] | None = None,\n        use_vectorized: bool = False,\n        colorscale: Union[Iterable[Color], Iterable[Color, float]] | None = None,\n        colorscale_axis: int = 1,\n        **kwargs: Any,\n    ) -> ParametricFunction:\n        \"\"\"Generates a curve based on a function.\n\n        Parameters\n        ----------\n        function\n            The function used to construct the :class:`~.ParametricFunction`.\n        x_range\n            The range of the curve along the axes. ``x_range = [x_min, x_max, x_step]``.\n        use_vectorized\n            Whether to pass in the generated t value array to the function. Only use this if your function supports it.\n            Output should be a numpy array of shape ``[y_0, y_1, ...]``\n        colorscale\n            Colors of the function. Optional parameter used when coloring a function by values. Passing a list of colors\n            and a colorscale_axis will color the function by y-value. Passing a list of tuples in the form ``(color, pivot)``\n            allows user-defined pivots where the color transitions.\n        colorscale_axis\n            Defines the axis on which the colorscale is applied (0 = x, 1 = y), default is y-axis (1).\n        kwargs\n            Additional parameters to be passed to :class:`~.ParametricFunction`.\n\n        Returns\n        -------\n        :class:`~.ParametricFunction`\n            The plotted curve.\n\n\n        .. warning::\n            This method may not produce accurate graphs since Manim currently relies on interpolation between\n            evenly-spaced samples of the curve, instead of intelligent plotting.\n            See the example below for some solutions to this problem.\n\n        Examples\n        --------\n        .. manim:: PlotExample\n            :save_last_frame:\n\n            class PlotExample(Scene):\n                def construct(self):\n                    # construct the axes\n                    ax_1 = Axes(\n                        x_range=[0.001, 6],\n                        y_range=[-8, 2],\n                        x_length=5,\n                        y_length=3,\n                        tips=False,\n                    )\n                    ax_2 = ax_1.copy()\n                    ax_3 = ax_1.copy()\n\n                    # position the axes\n                    ax_1.to_corner(UL)\n                    ax_2.to_corner(UR)\n                    ax_3.to_edge(DOWN)\n                    axes = VGroup(ax_1, ax_2, ax_3)\n\n                    # create the logarithmic curves\n                    def log_func(x):\n                        return np.log(x)\n\n                    # a curve without adjustments; poor interpolation.\n                    curve_1 = ax_1.plot(log_func, color=PURE_RED)\n\n                    # disabling interpolation makes the graph look choppy as not enough\n                    # inputs are available\n                    curve_2 = ax_2.plot(log_func, use_smoothing=False, color=ORANGE)\n\n                    # taking more inputs of the curve by specifying a step for the\n                    # x_range yields expected results, but increases rendering time.\n                    curve_3 = ax_3.plot(\n                        log_func, x_range=(0.001, 6, 0.001), color=PURE_GREEN\n                    )\n\n                    curves = VGroup(curve_1, curve_2, curve_3)\n\n                    self.add(axes, curves)\n        \"\"\"\n        t_range = np.array(self.x_range, dtype=float)\n        if x_range is not None:\n            t_range[: len(x_range)] = x_range\n\n        if x_range is None or len(x_range) < 3:\n            # if t_range has a defined step size, increase the number of sample points per tick\n            t_range[2] /= self.num_sampled_graph_points_per_tick\n        # For axes, the third coordinate of x_range indicates\n        # tick frequency.  But for functions, it indicates a\n        # sample frequency\n\n        graph = ParametricFunction(\n            lambda t: self.coords_to_point(t, function(t)),\n            t_range=t_range,\n            scaling=self.x_axis.scaling,\n            use_vectorized=use_vectorized,\n            **kwargs,\n        )\n\n        graph.underlying_function = function\n\n        if colorscale:\n            if type(colorscale[0]) in (list, tuple):\n                new_colors, pivots = [\n                    [i for i, j in colorscale],\n                    [j for i, j in colorscale],\n                ]\n            else:\n                new_colors = colorscale\n\n                ranges = [self.x_range, self.y_range]\n                pivot_min = ranges[colorscale_axis][0]\n                pivot_max = ranges[colorscale_axis][1]\n                pivot_frequency = (pivot_max - pivot_min) / (len(new_colors) - 1)\n                pivots = np.arange(\n                    start=pivot_min,\n                    stop=pivot_max + pivot_frequency,\n                    step=pivot_frequency,\n                )\n\n            resolution = 0.01 if len(x_range) == 2 else x_range[2]\n            sample_points = np.arange(x_range[0], x_range[1] + resolution, resolution)\n            color_list = []\n            for samp_x in sample_points:\n                axis_value = (samp_x, function(samp_x))[colorscale_axis]\n                if axis_value <= pivots[0]:\n                    color_list.append(new_colors[0])\n                elif axis_value >= pivots[-1]:\n                    color_list.append(new_colors[-1])\n                else:\n                    for i, pivot in enumerate(pivots):\n                        if pivot > axis_value:\n                            color_index = (axis_value - pivots[i - 1]) / (\n                                pivots[i] - pivots[i - 1]\n                            )\n                            color_index = min(color_index, 1)\n                            mob_color = interpolate_color(\n                                new_colors[i - 1],\n                                new_colors[i],\n                                color_index,\n                            )\n                            color_list.append(mob_color)\n                            break\n            if config.renderer == RendererType.OPENGL:\n                graph.set_color(color_list)\n            else:\n                graph.set_stroke(color_list)\n                graph.set_sheen_direction(RIGHT)\n\n        return graph\n\n    def plot_implicit_curve(\n        self,\n        func: Callable[[float, float], float],\n        min_depth: int = 5,\n        max_quads: int = 1500,\n        **kwargs: Any,\n    ) -> ImplicitFunction:\n        \"\"\"Creates the curves of an implicit function.\n\n        Parameters\n        ----------\n        func\n            The function to graph, in the form of f(x, y) = 0.\n        min_depth\n            The minimum depth of the function to calculate.\n        max_quads\n            The maximum number of quads to use.\n        kwargs\n            Additional parameters to pass into :class:`ImplicitFunction`.\n\n        Examples\n        --------\n        .. manim:: ImplicitExample\n            :save_last_frame:\n\n            class ImplicitExample(Scene):\n                def construct(self):\n                    ax = Axes()\n                    a = ax.plot_implicit_curve(\n                        lambda x, y: y * (x - y) ** 2 - 4 * x - 8, color=BLUE\n                    )\n                    self.add(ax, a)\n        \"\"\"\n        x_scale = self.get_x_axis().scaling\n        y_scale = self.get_y_axis().scaling\n        graph = ImplicitFunction(\n            func=(lambda x, y: func(x_scale.function(x), y_scale.function(y))),\n            x_range=self.x_range[:2],\n            y_range=self.y_range[:2],\n            min_depth=min_depth,\n            max_quads=max_quads,\n            **kwargs,\n        )\n        (\n            graph.stretch(self.get_x_unit_size(), 0, about_point=ORIGIN)\n            .stretch(self.get_y_unit_size(), 1, about_point=ORIGIN)\n            .shift(self.get_origin())\n        )\n        return graph\n\n    def plot_parametric_curve(\n        self,\n        function: Callable[[float], np.ndarray],\n        use_vectorized: bool = False,\n        **kwargs: Any,\n    ) -> ParametricFunction:\n        \"\"\"A parametric curve.\n\n        Parameters\n        ----------\n        function\n            A parametric function mapping a number to a point in the\n            coordinate system.\n        use_vectorized\n            Whether to pass in the generated t value array to the function. Only use this if your function supports it.\n        kwargs\n            Any further keyword arguments are passed to :class:`.ParametricFunction`.\n\n        Example\n        -------\n        .. manim:: ParametricCurveExample\n            :save_last_frame:\n\n            class ParametricCurveExample(Scene):\n                def construct(self):\n                    ax = Axes()\n                    cardioid = ax.plot_parametric_curve(\n                        lambda t: np.array(\n                            [\n                                np.exp(1) * np.cos(t) * (1 - np.cos(t)),\n                                np.exp(1) * np.sin(t) * (1 - np.cos(t)),\n                                0,\n                            ]\n                        ),\n                        t_range=[0, 2 * PI],\n                        color=\"#0FF1CE\",\n                    )\n                    self.add(ax, cardioid)\n        \"\"\"\n        dim = self.dimension\n        graph = ParametricFunction(\n            lambda t: self.coords_to_point(*function(t)[:dim]),\n            use_vectorized=use_vectorized,\n            **kwargs,\n        )\n        graph.underlying_function = function\n        return graph\n\n    def plot_polar_graph(\n        self,\n        r_func: Callable[[float], float],\n        theta_range: Sequence[float] | None = None,\n        **kwargs: Any,\n    ) -> ParametricFunction:\n        \"\"\"A polar graph.\n\n        Parameters\n        ----------\n        r_func\n            The function r of theta.\n        theta_range\n            The range of theta as ``theta_range = [theta_min, theta_max, theta_step]``.\n        kwargs\n            Additional parameters passed to :class:`~.ParametricFunction`.\n\n        Examples\n        --------\n        .. manim:: PolarGraphExample\n            :ref_classes: PolarPlane\n            :save_last_frame:\n\n            class PolarGraphExample(Scene):\n                def construct(self):\n                    plane = PolarPlane()\n                    r = lambda theta: 2 * np.sin(theta * 5)\n                    graph = plane.plot_polar_graph(r, [0, 2 * PI], color=ORANGE)\n                    self.add(plane, graph)\n        \"\"\"\n        theta_range = theta_range if theta_range is not None else [0, 2 * PI]\n        graph = ParametricFunction(\n            function=lambda th: self.pr2pt(r_func(th), th),\n            t_range=theta_range,\n            **kwargs,\n        )\n        graph.underlying_function = r_func\n        return graph\n\n    def plot_surface(\n        self,\n        function: Callable[[float], float],\n        u_range: Sequence[float] | None = None,\n        v_range: Sequence[float] | None = None,\n        colorscale: (\n            Sequence[ParsableManimColor]\n            | Sequence[tuple[ParsableManimColor, float]]\n            | None\n        ) = None,\n        colorscale_axis: int = 2,\n        **kwargs: Any,\n    ) -> Surface | OpenGLSurface:\n        \"\"\"Generates a surface based on a function.\n\n        Parameters\n        ----------\n        function\n            The function used to construct the :class:`~.Surface`.\n        u_range\n            The range of the ``u`` variable: ``(u_min, u_max)``.\n        v_range\n            The range of the ``v`` variable: ``(v_min, v_max)``.\n        colorscale\n            Colors of the surface. Passing a list of colors will color the surface by z-value.\n            Passing a list of tuples in the form ``(color, pivot)`` allows user-defined pivots\n            where the color transitions.\n        colorscale_axis\n            Defines the axis on which the colorscale is applied (0 = x, 1 = y, 2 = z), default\n            is z-axis (2).\n        kwargs\n            Additional parameters to be passed to :class:`~.Surface`.\n\n        Returns\n        -------\n        :class:`~.Surface`\n            The plotted surface.\n\n        Examples\n        --------\n        .. manim:: PlotSurfaceExample\n            :save_last_frame:\n\n            class PlotSurfaceExample(ThreeDScene):\n                def construct(self):\n                    resolution_fa = 16\n                    self.set_camera_orientation(phi=75 * DEGREES, theta=-60 * DEGREES)\n                    axes = ThreeDAxes(x_range=(-3, 3, 1), y_range=(-3, 3, 1), z_range=(-5, 5, 1))\n                    def param_trig(u, v):\n                        x = u\n                        y = v\n                        z = 2 * np.sin(x) + 2 * np.cos(y)\n                        return z\n                    trig_plane = axes.plot_surface(\n                        param_trig,\n                        resolution=(resolution_fa, resolution_fa),\n                        u_range = (-3, 3),\n                        v_range = (-3, 3),\n                        colorscale = [BLUE, GREEN, YELLOW, ORANGE, RED],\n                        )\n                    self.add(axes, trig_plane)\n        \"\"\"\n        if config.renderer == RendererType.CAIRO:\n            surface = Surface(\n                lambda u, v: self.c2p(u, v, function(u, v)),\n                u_range=u_range,\n                v_range=v_range,\n                **kwargs,\n            )\n            if colorscale:\n                surface.set_fill_by_value(\n                    axes=self.copy(),\n                    colorscale=colorscale,\n                    axis=colorscale_axis,\n                )\n        elif config.renderer == RendererType.OPENGL:\n            surface = OpenGLSurface(\n                lambda u, v: self.c2p(u, v, function(u, v)),\n                u_range=u_range,\n                v_range=v_range,\n                axes=self.copy(),\n                colorscale=colorscale,\n                colorscale_axis=colorscale_axis,\n                **kwargs,\n            )\n\n        return surface\n\n    def input_to_graph_point(\n        self,\n        x: float,\n        graph: ParametricFunction | VMobject,\n    ) -> Point3D:\n        \"\"\"Returns the coordinates of the point on a ``graph`` corresponding to an ``x`` value.\n\n        Parameters\n        ----------\n        x\n            The x-value of a point on the ``graph``.\n        graph\n            The :class:`~.ParametricFunction` on which the point lies.\n\n        Returns\n        -------\n        :class:`np.ndarray`\n            The coordinates of the point on the :attr:`graph` corresponding to the :attr:`x` value.\n\n        Raises\n        ------\n        :exc:`ValueError`\n            When the target x is not in the range of the line graph.\n\n        Examples\n        --------\n        .. manim:: InputToGraphPointExample\n            :save_last_frame:\n\n            class InputToGraphPointExample(Scene):\n                def construct(self):\n                    ax = Axes()\n                    curve = ax.plot(lambda x : np.cos(x))\n\n                    # move a square to PI on the cosine curve.\n                    position = ax.input_to_graph_point(x=PI, graph=curve)\n                    sq = Square(side_length=1, color=YELLOW).move_to(position)\n\n                    self.add(ax, curve, sq)\n        \"\"\"\n        if hasattr(graph, \"underlying_function\"):\n            return graph.function(x)\n        else:\n            alpha = binary_search(\n                function=lambda a: self.point_to_coords(graph.point_from_proportion(a))[\n                    0\n                ],\n                target=x,\n                lower_bound=0,\n                upper_bound=1,\n            )\n            if alpha is not None:\n                return graph.point_from_proportion(alpha)\n            else:\n                raise ValueError(\n                    f\"x={x} not located in the range of the graph ([{self.p2c(graph.get_start())[0]}, {self.p2c(graph.get_end())[0]}])\",\n                )\n\n    def input_to_graph_coords(\n        self, x: float, graph: ParametricFunction\n    ) -> tuple[float, float]:\n        \"\"\"Returns a tuple of the axis relative coordinates of the point\n        on the graph based on the x-value given.\n\n        Examples\n        --------\n        .. code-block:: pycon\n\n            >>> from manim import Axes\n            >>> ax = Axes()\n            >>> parabola = ax.plot(lambda x: x**2)\n            >>> ax.input_to_graph_coords(x=3, graph=parabola)\n            (3, 9)\n        \"\"\"\n        return x, graph.underlying_function(x)\n\n    def i2gc(self, x: float, graph: ParametricFunction) -> tuple[float, float]:\n        \"\"\"Alias for :meth:`input_to_graph_coords`.\"\"\"\n        return self.input_to_graph_coords(x, graph)\n\n    def i2gp(self, x: float, graph: ParametricFunction) -> np.ndarray:\n        \"\"\"Alias for :meth:`input_to_graph_point`.\"\"\"\n        return self.input_to_graph_point(x, graph)\n\n    def get_graph_label(\n        self,\n        graph: ParametricFunction,\n        label: float | str | Mobject = \"f(x)\",\n        x_val: float | None = None,\n        direction: Sequence[float] = RIGHT,\n        buff: float = MED_SMALL_BUFF,\n        color: ParsableManimColor | None = None,\n        dot: bool = False,\n        dot_config: dict[str, Any] | None = None,\n    ) -> Mobject:\n        r\"\"\"Creates a properly positioned label for the passed graph, with an optional dot.\n\n        Parameters\n        ----------\n        graph\n            The curve.\n        label\n            The label for the function's curve. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n        x_val\n            The x_value along the curve that positions the label.\n        direction\n            The cartesian position, relative to the curve that the label will be at --> ``LEFT``, ``RIGHT``.\n        buff\n            The distance between the curve and the label.\n        color\n            The color of the label. Defaults to the color of the curve.\n        dot\n            Whether to add a dot at the point on the graph.\n        dot_config\n            Additional parameters to be passed to :class:`~.Dot`.\n\n        Returns\n        -------\n        :class:`Mobject`\n            The positioned label and :class:`~.Dot`, if applicable.\n\n        Examples\n        --------\n        .. manim:: GetGraphLabelExample\n            :save_last_frame:\n\n            class GetGraphLabelExample(Scene):\n                def construct(self):\n                    ax = Axes()\n                    sin = ax.plot(lambda x: np.sin(x), color=PURPLE_B)\n                    label = ax.get_graph_label(\n                        graph=sin,\n                        label= MathTex(r\"\\frac{\\pi}{2}\"),\n                        x_val=PI / 2,\n                        dot=True,\n                        direction=UR,\n                    )\n\n                    self.add(ax, sin, label)\n        \"\"\"\n        if dot_config is None:\n            dot_config = {}\n        if color is None:\n            color = graph.get_color()\n        label = self.x_axis._create_label_tex(label).set_color(color)\n\n        if x_val is None:\n            # Search from right to left\n            for x in np.linspace(self.x_range[1], self.x_range[0], 100):\n                point = self.input_to_graph_point(x, graph)\n                if point[1] < config[\"frame_y_radius\"]:\n                    break\n        else:\n            point = self.input_to_graph_point(x_val, graph)\n\n        label.next_to(point, direction, buff=buff)\n        label.shift_onto_screen()\n\n        if dot:\n            dot = Dot(point=point, **dot_config)\n            label.add(dot)\n            label.dot = dot\n        return label\n\n    # calculus\n\n    def get_riemann_rectangles(\n        self,\n        graph: ParametricFunction,\n        x_range: Sequence[float] | None = None,\n        dx: float | None = 0.1,\n        input_sample_type: str = \"left\",\n        stroke_width: float = 1,\n        stroke_color: ParsableManimColor = BLACK,\n        fill_opacity: float = 1,\n        color: Iterable[ParsableManimColor] | ParsableManimColor = (BLUE, GREEN),\n        show_signed_area: bool = True,\n        bounded_graph: ParametricFunction = None,\n        blend: bool = False,\n        width_scale_factor: float = 1.001,\n    ) -> VGroup:\n        \"\"\"Generates a :class:`~.VGroup` of the Riemann Rectangles for a given curve.\n\n        Parameters\n        ----------\n        graph\n            The graph whose area will be approximated by Riemann rectangles.\n        x_range\n            The minimum and maximum x-values of the rectangles. ``x_range = [x_min, x_max]``.\n        dx\n            The change in x-value that separates each rectangle.\n        input_sample_type\n            Can be any of ``\"left\"``, ``\"right\"`` or ``\"center\"``. Refers to where\n            the sample point for the height of each Riemann Rectangle\n            will be inside the segments of the partition.\n        stroke_width\n            The stroke_width of the border of the rectangles.\n        stroke_color\n            The color of the border of the rectangle.\n        fill_opacity\n            The opacity of the rectangles.\n        color\n            The colors of the rectangles. Creates a balanced gradient if multiple colors are passed.\n        show_signed_area\n            Indicates negative area when the curve dips below the x-axis by inverting its color.\n        blend\n            Sets the :attr:`stroke_color` to :attr:`fill_color`, blending the rectangles without clear separation.\n        bounded_graph\n            If a secondary graph is specified, encloses the area between the two curves.\n        width_scale_factor\n            The factor by which the width of the rectangles is scaled.\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            A :class:`~.VGroup` containing the Riemann Rectangles.\n\n        Examples\n        --------\n        .. manim:: GetRiemannRectanglesExample\n            :save_last_frame:\n\n            class GetRiemannRectanglesExample(Scene):\n                def construct(self):\n                    ax = Axes(y_range=[-2, 10])\n                    quadratic = ax.plot(lambda x: 0.5 * x ** 2 - 0.5)\n\n                    # the rectangles are constructed from their top right corner.\n                    # passing an iterable to `color` produces a gradient\n                    rects_right = ax.get_riemann_rectangles(\n                        quadratic,\n                        x_range=[-4, -3],\n                        dx=0.25,\n                        color=(TEAL, BLUE_B, DARK_BLUE),\n                        input_sample_type=\"right\",\n                    )\n\n                    # the colour of rectangles below the x-axis is inverted\n                    # due to show_signed_area\n                    rects_left = ax.get_riemann_rectangles(\n                        quadratic, x_range=[-1.5, 1.5], dx=0.15, color=YELLOW\n                    )\n\n                    bounding_line = ax.plot(\n                        lambda x: 1.5 * x, color=BLUE_B, x_range=[3.3, 6]\n                    )\n                    bounded_rects = ax.get_riemann_rectangles(\n                        bounding_line,\n                        bounded_graph=quadratic,\n                        dx=0.15,\n                        x_range=[4, 5],\n                        show_signed_area=False,\n                        color=(MAROON_A, RED_B, PURPLE_D),\n                    )\n\n                    self.add(\n                        ax, bounding_line, quadratic, rects_right, rects_left, bounded_rects\n                    )\n        \"\"\"\n        # setting up x_range, overwrite user's third input\n        if x_range is None:\n            if bounded_graph is None:\n                x_range = [graph.t_min, graph.t_max]\n            else:\n                x_min = max(graph.t_min, bounded_graph.t_min)\n                x_max = min(graph.t_max, bounded_graph.t_max)\n                x_range = [x_min, x_max]\n\n        x_range = [*x_range[:2], dx]\n\n        rectangles = VGroup()\n        x_range = np.arange(*x_range)\n\n        if isinstance(color, (list, tuple)):\n            color = [ManimColor(c) for c in color]\n        else:\n            color = [ManimColor(color)]\n\n        colors = color_gradient(color, len(x_range))\n\n        for x, color in zip(x_range, colors):\n            if input_sample_type == \"left\":\n                sample_input = x\n            elif input_sample_type == \"right\":\n                sample_input = x + dx\n            elif input_sample_type == \"center\":\n                sample_input = x + 0.5 * dx\n            else:\n                raise ValueError(\"Invalid input sample type\")\n            graph_point = self.input_to_graph_point(sample_input, graph)\n\n            if bounded_graph is None:\n                y_point = self._origin_shift(self.y_range)\n            else:\n                y_point = bounded_graph.underlying_function(x)\n\n            points = VGroup(\n                *list(\n                    map(\n                        VectorizedPoint,\n                        [\n                            self.coords_to_point(x, y_point),\n                            self.coords_to_point(x + width_scale_factor * dx, y_point),\n                            graph_point,\n                        ],\n                    ),\n                )\n            )\n\n            rect = Rectangle().replace(points, stretch=True)\n            rectangles.add(rect)\n\n            # checks if the rectangle is under the x-axis\n            if self.p2c(graph_point)[1] < y_point and show_signed_area:\n                color = invert_color(color)\n\n            # blends rectangles smoothly\n            if blend:\n                stroke_color = color\n\n            rect.set_style(\n                fill_color=color,\n                fill_opacity=fill_opacity,\n                stroke_color=stroke_color,\n                stroke_width=stroke_width,\n            )\n\n        return rectangles\n\n    def get_area(\n        self,\n        graph: ParametricFunction,\n        x_range: tuple[float, float] | None = None,\n        color: ParsableManimColor | Iterable[ParsableManimColor] = (BLUE, GREEN),\n        opacity: float = 0.3,\n        bounded_graph: ParametricFunction = None,\n        **kwargs: Any,\n    ) -> Polygon:\n        \"\"\"Returns a :class:`~.Polygon` representing the area under the graph passed.\n\n        Parameters\n        ----------\n        graph\n            The graph/curve for which the area needs to be gotten.\n        x_range\n            The range of the minimum and maximum x-values of the area. ``x_range = [x_min, x_max]``.\n        color\n            The color of the area. Creates a gradient if a list of colors is provided.\n        opacity\n            The opacity of the area.\n        bounded_graph\n            If a secondary :attr:`graph` is specified, encloses the area between the two curves.\n        kwargs\n            Additional parameters passed to :class:`~.Polygon`.\n\n        Returns\n        -------\n        :class:`~.Polygon`\n            The :class:`~.Polygon` representing the area.\n\n        Raises\n        ------\n        :exc:`ValueError`\n            When x_ranges do not match (either area x_range, graph's x_range or bounded_graph's x_range).\n\n        Examples\n        --------\n        .. manim:: GetAreaExample\n            :save_last_frame:\n\n            class GetAreaExample(Scene):\n                def construct(self):\n                    ax = Axes().add_coordinates()\n                    curve = ax.plot(lambda x: 2 * np.sin(x), color=DARK_BLUE)\n                    area = ax.get_area(\n                        curve,\n                        x_range=(PI / 2, 3 * PI / 2),\n                        color=(GREEN_B, GREEN_D),\n                        opacity=1,\n                    )\n\n                    self.add(ax, curve, area)\n        \"\"\"\n        if x_range is None:\n            a = graph.t_min\n            b = graph.t_max\n        else:\n            a, b = x_range\n        if bounded_graph is not None:\n            if bounded_graph.t_min > b:\n                raise ValueError(\n                    f\"Ranges not matching: {bounded_graph.t_min} < {b}\",\n                )\n            if bounded_graph.t_max < a:\n                raise ValueError(\n                    f\"Ranges not matching: {bounded_graph.t_max} > {a}\",\n                )\n            a = max(a, bounded_graph.t_min)\n            b = min(b, bounded_graph.t_max)\n\n        if bounded_graph is None:\n            points = (\n                [self.c2p(a), graph.function(a)]\n                + [p for p in graph.points if a <= self.p2c(p)[0] <= b]\n                + [graph.function(b), self.c2p(b)]\n            )\n        else:\n            graph_points, bounded_graph_points = (\n                [g.function(a)]\n                + [p for p in g.points if a <= self.p2c(p)[0] <= b]\n                + [g.function(b)]\n                for g in (graph, bounded_graph)\n            )\n            points = graph_points + bounded_graph_points[::-1]\n        return Polygon(*points, **kwargs).set_opacity(opacity).set_color(color)\n\n    def angle_of_tangent(\n        self,\n        x: float,\n        graph: ParametricFunction,\n        dx: float = 1e-8,\n    ) -> float:\n        \"\"\"Returns the angle to the x-axis of the tangent\n        to the plotted curve at a particular x-value.\n\n        Parameters\n        ----------\n        x\n            The x-value at which the tangent must touch the curve.\n        graph\n            The :class:`~.ParametricFunction` for which to calculate the tangent.\n        dx\n            The change in `x` used to determine the angle of the tangent to the curve.\n\n        Returns\n        -------\n        :class:`float`\n            The angle of the tangent to the curve.\n\n        Examples\n        --------\n        .. code-block:: python\n\n            ax = Axes()\n            curve = ax.plot(lambda x: x**2)\n            ax.angle_of_tangent(x=3, graph=curve)\n            # 1.4056476493802699\n        \"\"\"\n        p0 = np.array([*self.input_to_graph_coords(x, graph)])\n        p1 = np.array([*self.input_to_graph_coords(x + dx, graph)])\n        return angle_of_vector(p1 - p0)\n\n    def slope_of_tangent(\n        self, x: float, graph: ParametricFunction, **kwargs: Any\n    ) -> float:\n        \"\"\"Returns the slope of the tangent to the plotted curve\n        at a particular x-value.\n\n        Parameters\n        ----------\n        x\n            The x-value at which the tangent must touch the curve.\n        graph\n            The :class:`~.ParametricFunction` for which to calculate the tangent.\n\n        Returns\n        -------\n        :class:`float`\n            The slope of the tangent with the x axis.\n\n        Examples\n        --------\n        .. code-block:: python\n\n            ax = Axes()\n            curve = ax.plot(lambda x: x**2)\n            ax.slope_of_tangent(x=-2, graph=curve)\n            # -3.5000000259052038\n        \"\"\"\n        return np.tan(self.angle_of_tangent(x, graph, **kwargs))\n\n    def plot_derivative_graph(\n        self, graph: ParametricFunction, color: ParsableManimColor = GREEN, **kwargs\n    ) -> ParametricFunction:\n        \"\"\"Returns the curve of the derivative of the passed graph.\n\n        Parameters\n        ----------\n        graph\n            The graph for which the derivative will be found.\n        color\n            The color of the derivative curve.\n        kwargs\n            Any valid keyword argument of :class:`~.ParametricFunction`.\n\n        Returns\n        -------\n        :class:`~.ParametricFunction`\n            The curve of the derivative.\n\n        Examples\n        --------\n        .. manim:: DerivativeGraphExample\n            :save_last_frame:\n\n            class DerivativeGraphExample(Scene):\n                def construct(self):\n                    ax = NumberPlane(y_range=[-1, 7], background_line_style={\"stroke_opacity\": 0.4})\n\n                    curve_1 = ax.plot(lambda x: x ** 2, color=PURPLE_B)\n                    curve_2 = ax.plot_derivative_graph(curve_1)\n                    curves = VGroup(curve_1, curve_2)\n\n                    label_1 = ax.get_graph_label(curve_1, \"x^2\", x_val=-2, direction=DL)\n                    label_2 = ax.get_graph_label(curve_2, \"2x\", x_val=3, direction=RIGHT)\n                    labels = VGroup(label_1, label_2)\n\n                    self.add(ax, curves, labels)\n        \"\"\"\n\n        def deriv(x):\n            return self.slope_of_tangent(x, graph)\n\n        return self.plot(deriv, color=color, **kwargs)\n\n    def plot_antiderivative_graph(\n        self,\n        graph: ParametricFunction,\n        y_intercept: float = 0,\n        samples: int = 50,\n        use_vectorized: bool = False,\n        **kwargs: Any,\n    ) -> ParametricFunction:\n        \"\"\"Plots an antiderivative graph.\n\n        Parameters\n        ----------\n        graph\n            The graph for which the antiderivative will be found.\n        y_intercept\n            The y-value at which the graph intercepts the y-axis.\n        samples\n            The number of points to take the area under the graph.\n        use_vectorized\n            Whether to use the vectorized version of the antiderivative. This means\n            to pass in the generated t value array to the function. Only use this if your function supports it.\n            Output should be a numpy array of shape ``[y_0, y_1, ...]``\n        kwargs\n            Any valid keyword argument of :class:`~.ParametricFunction`.\n\n        Returns\n        -------\n        :class:`~.ParametricFunction`\n            The curve of the antiderivative.\n\n\n        .. note::\n            This graph is plotted from the values of area under the reference graph.\n            The result might not be ideal if the reference graph contains uncalculatable\n            areas from x=0.\n\n        Examples\n        --------\n        .. manim:: AntiderivativeExample\n            :save_last_frame:\n\n            class AntiderivativeExample(Scene):\n                def construct(self):\n                    ax = Axes()\n                    graph1 = ax.plot(\n                        lambda x: (x ** 2 - 2) / 3,\n                        color=RED,\n                    )\n                    graph2 = ax.plot_antiderivative_graph(graph1, color=BLUE)\n                    self.add(ax, graph1, graph2)\n        \"\"\"\n\n        def antideriv(x):\n            x_vals = np.linspace(0, x, samples, axis=1 if use_vectorized else 0)\n            f_vec = np.vectorize(graph.underlying_function)\n            y_vals = f_vec(x_vals)\n            return np.trapz(y_vals, x_vals) + y_intercept\n\n        return self.plot(antideriv, use_vectorized=use_vectorized, **kwargs)\n\n    def get_secant_slope_group(\n        self,\n        x: float,\n        graph: ParametricFunction,\n        dx: float | None = None,\n        dx_line_color: ParsableManimColor = YELLOW,\n        dy_line_color: ParsableManimColor | None = None,\n        dx_label: float | str | None = None,\n        dy_label: float | str | None = None,\n        include_secant_line: bool = True,\n        secant_line_color: ParsableManimColor = GREEN,\n        secant_line_length: float = 10,\n    ) -> VGroup:\n        \"\"\"Creates two lines representing `dx` and `df`, the labels for `dx` and `df`, and\n         the secant to the curve at a particular x-value.\n\n        Parameters\n        ----------\n        x\n            The x-value at which the secant intersects the graph for the first time.\n        graph\n            The curve for which the secant will be found.\n        dx\n            The change in `x` after which the secant exits.\n        dx_line_color\n            The color of the line that indicates the change in `x`.\n        dy_line_color\n            The color of the line that indicates the change in `y`. Defaults to the color of :attr:`graph`.\n        dx_label\n            The label for the `dx` line. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n        dy_label\n            The label for the `dy` line. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n        include_secant_line\n            Whether to include the secant line in the graph,\n            or just the df/dx lines and labels.\n        secant_line_color\n            The color of the secant line.\n        secant_line_length\n            The length of the secant line.\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            A group containing the elements: `dx_line`, `df_line`, and\n            if applicable also :attr:`dx_label`, :attr:`df_label`, `secant_line`.\n\n        Examples\n        --------\n         .. manim:: GetSecantSlopeGroupExample\n            :save_last_frame:\n\n            class GetSecantSlopeGroupExample(Scene):\n                def construct(self):\n                    ax = Axes(y_range=[-1, 7])\n                    graph = ax.plot(lambda x: 1 / 4 * x ** 2, color=BLUE)\n                    slopes = ax.get_secant_slope_group(\n                        x=2.0,\n                        graph=graph,\n                        dx=1.0,\n                        dx_label=Tex(\"dx = 1.0\"),\n                        dy_label=\"dy\",\n                        dx_line_color=GREEN_B,\n                        secant_line_length=4,\n                        secant_line_color=RED_D,\n                    )\n\n                    self.add(ax, graph, slopes)\n        \"\"\"\n        group = VGroup()\n\n        dx = dx or float(self.x_range[1] - self.x_range[0]) / 10\n        dy_line_color = dy_line_color or graph.get_color()\n\n        p1 = self.input_to_graph_point(x, graph)\n        p2 = self.input_to_graph_point(x + dx, graph)\n        interim_point = p2[0] * RIGHT + p1[1] * UP\n\n        group.dx_line = Line(p1, interim_point, color=dx_line_color)\n        group.df_line = Line(interim_point, p2, color=dy_line_color)\n        group.add(group.dx_line, group.df_line)\n\n        labels = VGroup()\n        if dx_label is not None:\n            group.dx_label = self.x_axis._create_label_tex(dx_label)\n            labels.add(group.dx_label)\n            group.add(group.dx_label)\n        if dy_label is not None:\n            group.df_label = self.x_axis._create_label_tex(dy_label)\n            labels.add(group.df_label)\n            group.add(group.df_label)\n\n        if len(labels) > 0:\n            max_width = 0.8 * group.dx_line.width\n            max_height = 0.8 * group.df_line.height\n            if labels.width > max_width:\n                labels.width = max_width\n            if labels.height > max_height:\n                labels.height = max_height\n\n        if dx_label is not None:\n            group.dx_label.next_to(\n                group.dx_line,\n                np.sign(dx) * DOWN,\n                buff=group.dx_label.height / 2,\n            )\n            group.dx_label.set_color(group.dx_line.get_color())\n\n        if dy_label is not None:\n            group.df_label.next_to(\n                group.df_line,\n                np.sign(dx) * RIGHT,\n                buff=group.df_label.height / 2,\n            )\n            group.df_label.set_color(group.df_line.get_color())\n\n        if include_secant_line:\n            group.secant_line = Line(p1, p2, color=secant_line_color)\n            group.secant_line.scale(\n                secant_line_length / group.secant_line.get_length(),\n            )\n            group.add(group.secant_line)\n        return group\n\n    def get_vertical_lines_to_graph(\n        self,\n        graph: ParametricFunction,\n        x_range: Sequence[float] | None = None,\n        num_lines: int = 20,\n        **kwargs: Any,\n    ) -> VGroup:\n        \"\"\"Obtains multiple lines from the x-axis to the curve.\n\n        Parameters\n        ----------\n        graph\n            The graph along which the lines are placed.\n        x_range\n            A list containing the lower and and upper bounds of the lines: ``x_range = [x_min, x_max]``.\n        num_lines\n            The number of evenly spaced lines.\n        kwargs\n            Additional arguments to be passed to :meth:`~.CoordinateSystem.get_vertical_line`.\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            The :class:`~.VGroup` of the evenly spaced lines.\n\n        Examples\n        --------\n        .. manim:: GetVerticalLinesToGraph\n            :save_last_frame:\n\n            class GetVerticalLinesToGraph(Scene):\n                def construct(self):\n                    ax = Axes(\n                        x_range=[0, 8.0, 1],\n                        y_range=[-1, 1, 0.2],\n                        axis_config={\"font_size\": 24},\n                    ).add_coordinates()\n\n                    curve = ax.plot(lambda x: np.sin(x) / np.e ** 2 * x)\n\n                    lines = ax.get_vertical_lines_to_graph(\n                        curve, x_range=[0, 4], num_lines=30, color=BLUE\n                    )\n\n                    self.add(ax, curve, lines)\n        \"\"\"\n        x_range = x_range if x_range is not None else self.x_range\n\n        return VGroup(\n            *(\n                self.get_vertical_line(self.i2gp(x, graph), **kwargs)\n                for x in np.linspace(x_range[0], x_range[1], num_lines)\n            )\n        )\n\n    def get_T_label(\n        self,\n        x_val: float,\n        graph: ParametricFunction,\n        label: float | str | Mobject | None = None,\n        label_color: ParsableManimColor | None = None,\n        triangle_size: float = MED_SMALL_BUFF,\n        triangle_color: ParsableManimColor | None = WHITE,\n        line_func: type[Line] = Line,\n        line_color: ParsableManimColor = YELLOW,\n    ) -> VGroup:\n        \"\"\"Creates a labelled triangle marker with a vertical line from the x-axis\n        to a curve at a given x-value.\n\n        Parameters\n        ----------\n        x_val\n            The position along the curve at which the label, line and triangle will be constructed.\n        graph\n            The :class:`~.ParametricFunction` for which to construct the label.\n        label\n            The label of the vertical line and triangle.\n        label_color\n            The color of the label.\n        triangle_size\n            The size of the triangle.\n        triangle_color\n            The color of the triangle.\n        line_func\n            The function used to construct the vertical line.\n        line_color\n            The color of the vertical line.\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            A :class:`~.VGroup` of the label, triangle and vertical line mobjects.\n\n        Examples\n        --------\n        .. manim:: TLabelExample\n            :save_last_frame:\n\n            class TLabelExample(Scene):\n                def construct(self):\n                    # defines the axes and linear function\n                    axes = Axes(x_range=[-1, 10], y_range=[-1, 10], x_length=9, y_length=6)\n                    func = axes.plot(lambda x: x, color=BLUE)\n                    # creates the T_label\n                    t_label = axes.get_T_label(x_val=4, graph=func, label=Tex(\"x-value\"))\n                    self.add(axes, func, t_label)\n        \"\"\"\n        T_label_group = VGroup()\n        triangle = RegularPolygon(n=3, start_angle=np.pi / 2, stroke_width=0).set_fill(\n            color=triangle_color,\n            opacity=1,\n        )\n        triangle.height = triangle_size\n        triangle.move_to(self.coords_to_point(x_val, 0), UP)\n        if label is not None:\n            t_label = self.x_axis._create_label_tex(label, color=label_color)\n            t_label.next_to(triangle, DOWN)\n            T_label_group.add(t_label)\n\n        v_line = self.get_vertical_line(\n            self.i2gp(x_val, graph),\n            color=line_color,\n            line_func=line_func,\n        )\n\n        T_label_group.add(triangle, v_line)\n\n        return T_label_group\n\n    def __matmul__(self, coord: Point3DLike | Mobject):\n        if isinstance(coord, Mobject):\n            coord = coord.get_center()\n        return self.coords_to_point(*coord)\n\n    def __rmatmul__(self, point: Point3DLike):\n        return self.point_to_coords(point)"}, {"name": "copy_template_files", "code": "def copy_template_files(\n    project_dir: Path = Path(\".\"), template_name: str = \"Default\"\n) -> None:\n    \"\"\"Copies template files from templates dir to project_dir.\n\n    Parameters\n    ----------\n        project_dir\n            Path to project directory.\n        template_name\n            Name of template.\n    \"\"\"\n    template_cfg_path = Path.resolve(\n        Path(__file__).parent.parent / \"templates/template.cfg\",\n    )\n    template_scene_path = Path.resolve(\n        Path(__file__).parent.parent / f\"templates/{template_name}.mtp\",\n    )\n\n    if not template_cfg_path.exists():\n        raise FileNotFoundError(f\"{template_cfg_path} : file does not exist\")\n    if not template_scene_path.exists():\n        raise FileNotFoundError(f\"{template_scene_path} : file does not exist\")\n\n    copyfile(template_cfg_path, Path.resolve(project_dir / \"manim.cfg\"))\n    console.print(\"\\n\\t[green]copied[/green] [blue]manim.cfg[/blue]\\n\")\n    copyfile(template_scene_path, Path.resolve(project_dir / \"main.py\"))\n    console.print(\"\\n\\t[green]copied[/green] [blue]main.py[/blue]\\n\")\n    add_import_statement(Path.resolve(project_dir / \"main.py\"))"}, {"name": "counterclockwise_path", "code": "def counterclockwise_path() -> PathFuncType:\n    \"\"\"This function transforms each point by moving counterclockwise around a half circle.\n\n    Examples\n    --------\n\n    .. manim :: CounterclockwisePathExample\n\n        class CounterclockwisePathExample(Scene):\n            def construct(self):\n                colors = [RED, GREEN, BLUE]\n\n                starting_points = VGroup(\n                    *[\n                        Dot(LEFT + pos, color=color)\n                        for pos, color in zip([UP, DOWN, LEFT], colors)\n                    ]\n                )\n\n                finish_points = VGroup(\n                    *[\n                        Dot(RIGHT + pos, color=color)\n                        for pos, color in zip([ORIGIN, UP, DOWN], colors)\n                    ]\n                )\n\n                self.add(starting_points)\n                self.add(finish_points)\n                for dot in starting_points:\n                    self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n                self.wait()\n                self.play(\n                    Transform(\n                        starting_points,\n                        finish_points,\n                        path_func=utils.paths.counterclockwise_path(),\n                        run_time=2,\n                    )\n                )\n                self.wait()\n\n    \"\"\"\n    return path_along_arc(np.pi)"}, {"name": "CounterclockwiseTransform", "code": "class CounterclockwiseTransform(Transform):\n    \"\"\"Transforms the points of a mobject along a counterclockwise oriented arc.\n\n    See also\n    --------\n    :class:`.Transform`, :class:`.ClockwiseTransform`\n\n    Examples\n    --------\n\n    .. manim:: CounterclockwiseTransform_vs_Transform\n\n        class CounterclockwiseTransform_vs_Transform(Scene):\n            def construct(self):\n                # set up the numbers\n                c_transform = VGroup(DecimalNumber(number=3.141, num_decimal_places=3), DecimalNumber(number=1.618, num_decimal_places=3))\n                text_1 = Text(\"CounterclockwiseTransform\", color=RED)\n                c_transform.add(text_1)\n\n                transform = VGroup(DecimalNumber(number=1.618, num_decimal_places=3), DecimalNumber(number=3.141, num_decimal_places=3))\n                text_2 = Text(\"Transform\", color=BLUE)\n                transform.add(text_2)\n\n                ints = VGroup(c_transform, transform)\n                texts = VGroup(text_1, text_2).scale(0.75)\n                c_transform.arrange(direction=UP, buff=1)\n                transform.arrange(direction=UP, buff=1)\n\n                ints.arrange(buff=2)\n                self.add(ints, texts)\n\n                # The mobs move in clockwise direction for ClockwiseTransform()\n                self.play(CounterclockwiseTransform(c_transform[0], c_transform[1]))\n\n                # The mobs move straight up for Transform()\n                self.play(Transform(transform[0], transform[1]))\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        target_mobject: Mobject,\n        path_arc: float = np.pi,\n        **kwargs,\n    ) -> None:\n        super().__init__(mobject, target_mobject, path_arc=path_arc, **kwargs)"}, {"name": "Create", "code": "class Create(ShowPartial):\n    \"\"\"Incrementally show a VMobject.\n\n    Parameters\n    ----------\n    mobject\n        The VMobject to animate.\n\n    Raises\n    ------\n    :class:`TypeError`\n        If ``mobject`` is not an instance of :class:`~.VMobject`.\n\n    Examples\n    --------\n    .. manim:: CreateScene\n\n        class CreateScene(Scene):\n            def construct(self):\n                self.play(Create(Square()))\n\n    See Also\n    --------\n    :class:`~.ShowPassingFlash`\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: VMobject | OpenGLVMobject | OpenGLSurface,\n        lag_ratio: float = 1.0,\n        introducer: bool = True,\n        **kwargs,\n    ) -> None:\n        super().__init__(mobject, lag_ratio=lag_ratio, introducer=introducer, **kwargs)\n\n    def _get_bounds(self, alpha: float) -> tuple[float, float]:\n        return (0, alpha)"}, {"name": "Cross", "code": "class Cross(VGroup):\n    \"\"\"Creates a cross.\n\n    Parameters\n    ----------\n    mobject\n        The mobject linked to this instance. It fits the mobject when specified. Defaults to None.\n    stroke_color\n        Specifies the color of the cross lines. Defaults to RED.\n    stroke_width\n        Specifies the width of the cross lines. Defaults to 6.\n    scale_factor\n        Scales the cross to the provided units. Defaults to 1.\n\n    Examples\n    --------\n    .. manim:: ExampleCross\n        :save_last_frame:\n\n        class ExampleCross(Scene):\n            def construct(self):\n                cross = Cross()\n                self.add(cross)\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject | None = None,\n        stroke_color: ParsableManimColor = RED,\n        stroke_width: float = 6.0,\n        scale_factor: float = 1.0,\n        **kwargs: Any,\n    ) -> None:\n        super().__init__(\n            Line(UP + LEFT, DOWN + RIGHT), Line(UP + RIGHT, DOWN + LEFT), **kwargs\n        )\n        if mobject is not None:\n            self.replace(mobject, stretch=True)\n        self.scale(scale_factor)\n        self.set_stroke(color=stroke_color, width=stroke_width)"}, {"name": "cross", "code": "def cross(v1: Vector3D, v2: Vector3D) -> Vector3D:\n    return np.array(\n        [\n            v1[1] * v2[2] - v1[2] * v2[1],\n            v1[2] * v2[0] - v1[0] * v2[2],\n            v1[0] * v2[1] - v1[1] * v2[0],\n        ]\n    )"}, {"name": "cross2d", "code": "def cross2d(\n    a: Vector2D | Vector2D_Array,\n    b: Vector2D | Vector2D_Array,\n) -> ManimFloat | npt.NDArray[ManimFloat]:\n    \"\"\"Compute the determinant(s) of the passed\n    vector (sequences).\n\n    Parameters\n    ----------\n    a\n        A vector or a sequence of vectors.\n    b\n        A vector or a sequence of vectors.\n\n    Returns\n    -------\n    Sequence[float] | float\n        The determinant or sequence of determinants\n        of the first two components of the specified\n        vectors.\n\n    Examples\n    --------\n    .. code-block:: pycon\n\n        >>> cross2d(np.array([1, 2]), np.array([3, 4]))\n        np.int64(-2)\n        >>> cross2d(\n        ...     np.array([[1, 2, 0], [1, 0, 0]]),\n        ...     np.array([[3, 4, 0], [0, 1, 0]]),\n        ... )\n        array([-2,  1])\n    \"\"\"\n    if len(a.shape) == 2:\n        return a[:, 0] * b[:, 1] - a[:, 1] * b[:, 0]\n    else:\n        return a[0] * b[1] - b[0] * a[1]"}, {"name": "Cube", "code": "class Cube(VGroup):\n    \"\"\"A three-dimensional cube.\n\n    Parameters\n    ----------\n    side_length\n        Length of each side of the :class:`Cube`.\n    fill_opacity\n        The opacity of the :class:`Cube`, from 0 being fully transparent to 1 being\n        fully opaque. Defaults to 0.75.\n    fill_color\n        The color of the :class:`Cube`.\n    stroke_width\n        The width of the stroke surrounding each face of the :class:`Cube`.\n\n    Examples\n    --------\n\n    .. manim:: CubeExample\n        :save_last_frame:\n\n        class CubeExample(ThreeDScene):\n            def construct(self):\n                self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)\n\n                axes = ThreeDAxes()\n                cube = Cube(side_length=3, fill_opacity=0.7, fill_color=BLUE)\n                self.add(cube)\n    \"\"\"\n\n    def __init__(\n        self,\n        side_length: float = 2,\n        fill_opacity: float = 0.75,\n        fill_color: ParsableManimColor = BLUE,\n        stroke_width: float = 0,\n        **kwargs,\n    ) -> None:\n        self.side_length = side_length\n        super().__init__(\n            fill_color=fill_color,\n            fill_opacity=fill_opacity,\n            stroke_width=stroke_width,\n            **kwargs,\n        )\n\n    def generate_points(self) -> None:\n        \"\"\"Creates the sides of the :class:`Cube`.\"\"\"\n        for vect in IN, OUT, LEFT, RIGHT, UP, DOWN:\n            face = Square(\n                side_length=self.side_length,\n                shade_in_3d=True,\n            )\n            face.flip()\n            face.shift(self.side_length * OUT / 2.0)\n            face.apply_matrix(z_to_vector(vect))\n\n            self.add(face)\n\n    init_points = generate_points"}, {"name": "CubicBezier", "code": "class CubicBezier(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A cubic B\u00e9zier curve.\n\n    Example\n    -------\n    .. manim:: BezierSplineExample\n        :save_last_frame:\n\n        class BezierSplineExample(Scene):\n            def construct(self):\n                p1 = np.array([-3, 1, 0])\n                p1b = p1 + [1, 0, 0]\n                d1 = Dot(point=p1).set_color(BLUE)\n                l1 = Line(p1, p1b)\n                p2 = np.array([3, -1, 0])\n                p2b = p2 - [1, 0, 0]\n                d2 = Dot(point=p2).set_color(RED)\n                l2 = Line(p2, p2b)\n                bezier = CubicBezier(p1b, p1b + 3 * RIGHT, p2b - 3 * RIGHT, p2b)\n                self.add(l1, d1, l2, d2, bezier)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        start_anchor: Point3DLike,\n        start_handle: Point3DLike,\n        end_handle: Point3DLike,\n        end_anchor: Point3DLike,\n        **kwargs: Any,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.add_cubic_bezier_curve(start_anchor, start_handle, end_handle, end_anchor)"}, {"name": "CurvedArrow", "code": "class CurvedArrow(ArcBetweenPoints):\n    def __init__(\n        self, start_point: Point3DLike, end_point: Point3DLike, **kwargs: Any\n    ) -> None:\n        from manim.mobject.geometry.tips import ArrowTriangleFilledTip\n\n        tip_shape = kwargs.pop(\"tip_shape\", ArrowTriangleFilledTip)\n        super().__init__(start_point, end_point, **kwargs)\n        self.add_tip(tip_shape=tip_shape)"}, {"name": "CurvedDoubleArrow", "code": "class CurvedDoubleArrow(CurvedArrow):\n    def __init__(\n        self, start_point: Point3DLike, end_point: Point3DLike, **kwargs: Any\n    ) -> None:\n        if \"tip_shape_end\" in kwargs:\n            kwargs[\"tip_shape\"] = kwargs.pop(\"tip_shape_end\")\n        from manim.mobject.geometry.tips import ArrowTriangleFilledTip\n\n        tip_shape_start = kwargs.pop(\"tip_shape_start\", ArrowTriangleFilledTip)\n        super().__init__(start_point, end_point, **kwargs)\n        self.add_tip(at_start=True, tip_shape=tip_shape_start)"}, {"name": "CurvesAsSubmobjects", "code": "class CurvesAsSubmobjects(VGroup):\n    \"\"\"Convert a curve's elements to submobjects.\n\n    Examples\n    --------\n    .. manim:: LineGradientExample\n        :save_last_frame:\n\n        class LineGradientExample(Scene):\n            def construct(self):\n                curve = ParametricFunction(lambda t: [t, np.sin(t), 0], t_range=[-PI, PI, 0.01], stroke_width=10)\n                new_curve = CurvesAsSubmobjects(curve)\n                new_curve.set_color_by_gradient(BLUE, RED)\n                self.add(new_curve.shift(UP), curve)\n\n    \"\"\"\n\n    def __init__(self, vmobject: VMobject, **kwargs) -> None:\n        super().__init__(**kwargs)\n        tuples = vmobject.get_cubic_bezier_tuples()\n        for tup in tuples:\n            part = VMobject()\n            part.set_points(tup)\n            part.match_style(vmobject)\n            self.add(part)\n\n    def point_from_proportion(self, alpha: float) -> Point3D:\n        \"\"\"Gets the point at a proportion along the path of the :class:`CurvesAsSubmobjects`.\n\n        Parameters\n        ----------\n        alpha\n            The proportion along the the path of the :class:`CurvesAsSubmobjects`.\n\n        Returns\n        -------\n        :class:`numpy.ndarray`\n            The point on the :class:`CurvesAsSubmobjects`.\n\n        Raises\n        ------\n        :exc:`ValueError`\n            If ``alpha`` is not between 0 and 1.\n        :exc:`Exception`\n            If the :class:`CurvesAsSubmobjects` has no submobjects, or no submobject has points.\n        \"\"\"\n        if alpha < 0 or alpha > 1:\n            raise ValueError(f\"Alpha {alpha} not between 0 and 1.\")\n\n        self._throw_error_if_no_submobjects()\n        submobjs_with_pts = self._get_submobjects_with_points()\n\n        if alpha == 1:\n            return submobjs_with_pts[-1].points[-1]\n\n        submobjs_arc_lengths = tuple(\n            part.get_arc_length() for part in submobjs_with_pts\n        )\n\n        total_length = sum(submobjs_arc_lengths)\n        target_length = alpha * total_length\n        current_length = 0\n\n        for i, part in enumerate(submobjs_with_pts):\n            part_length = submobjs_arc_lengths[i]\n            if current_length + part_length >= target_length:\n                residue = (target_length - current_length) / part_length\n                return part.point_from_proportion(residue)\n\n            current_length += part_length\n\n    def _throw_error_if_no_submobjects(self):\n        if len(self.submobjects) == 0:\n            caller_name = sys._getframe(1).f_code.co_name\n            raise Exception(\n                f\"Cannot call CurvesAsSubmobjects. {caller_name} for a CurvesAsSubmobject with no submobjects\"\n            )\n\n    def _get_submobjects_with_points(self):\n        submobjs_with_pts = tuple(\n            part for part in self.submobjects if len(part.points) > 0\n        )\n        if len(submobjs_with_pts) == 0:\n            caller_name = sys._getframe(1).f_code.co_name\n            raise Exception(\n                f\"Cannot call CurvesAsSubmobjects. {caller_name} for a CurvesAsSubmobject whose submobjects have no points\"\n            )\n        return submobjs_with_pts"}, {"name": "Cutout", "code": "class Cutout(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A shape with smaller cutouts.\n\n    Parameters\n    ----------\n    main_shape\n        The primary shape from which cutouts are made.\n    mobjects\n        The smaller shapes which are to be cut out of the ``main_shape``.\n    kwargs\n        Further keyword arguments that are passed to the constructor of\n        :class:`~.VMobject`.\n\n\n    .. warning::\n        Technically, this class behaves similar to a symmetric difference: if\n        parts of the ``mobjects`` are not located within the ``main_shape``,\n        these parts will be added to the resulting :class:`~.VMobject`.\n\n    Examples\n    --------\n    .. manim:: CutoutExample\n\n        class CutoutExample(Scene):\n            def construct(self):\n                s1 = Square().scale(2.5)\n                s2 = Triangle().shift(DOWN + RIGHT).scale(0.5)\n                s3 = Square().shift(UP + RIGHT).scale(0.5)\n                s4 = RegularPolygon(5).shift(DOWN + LEFT).scale(0.5)\n                s5 = RegularPolygon(6).shift(UP + LEFT).scale(0.5)\n                c = Cutout(s1, s2, s3, s4, s5, fill_opacity=1, color=BLUE, stroke_color=RED)\n                self.play(Write(c), run_time=4)\n                self.wait()\n    \"\"\"\n\n    def __init__(\n        self, main_shape: VMobject, *mobjects: VMobject, **kwargs: Any\n    ) -> None:\n        super().__init__(**kwargs)\n        self.append_points(main_shape.points)\n        sub_direction: Literal[\"CCW\", \"CW\"] = (\n            \"CCW\" if main_shape.get_direction() == \"CW\" else \"CW\"\n        )\n        for mobject in mobjects:\n            self.append_points(mobject.force_direction(sub_direction).points)"}, {"name": "cycle_animation", "code": "def cycle_animation(animation: Animation, **kwargs) -> Mobject:\n    return turn_animation_into_updater(animation, cycle=True, **kwargs)"}, {"name": "CyclicReplace", "code": "class CyclicReplace(Transform):\n    \"\"\"An animation moving mobjects cyclically.\n\n    In particular, this means: the first mobject takes the place\n    of the second mobject, the second one takes the place of\n    the third mobject, and so on. The last mobject takes the\n    place of the first one.\n\n    Parameters\n    ----------\n    mobjects\n        List of mobjects to be transformed.\n    path_arc\n        The angle of the arc (in radians) that the mobjects will follow to reach\n        their target.\n    kwargs\n        Further keyword arguments that are passed to :class:`.Transform`.\n\n    Examples\n    --------\n    .. manim :: CyclicReplaceExample\n\n        class CyclicReplaceExample(Scene):\n            def construct(self):\n                group = VGroup(Square(), Circle(), Triangle(), Star())\n                group.arrange(RIGHT)\n                self.add(group)\n\n                for _ in range(4):\n                    self.play(CyclicReplace(*group))\n    \"\"\"\n\n    def __init__(\n        self, *mobjects: Mobject, path_arc: float = 90 * DEGREES, **kwargs\n    ) -> None:\n        self.group = Group(*mobjects)\n        super().__init__(self.group, path_arc=path_arc, **kwargs)\n\n    def create_target(self) -> Group:\n        target = self.group.copy()\n        cycled_targets = [target[-1], *target[:-1]]\n        for m1, m2 in zip(cycled_targets, self.group):\n            m1.move_to(m2)\n        return target"}, {"name": "Cylinder", "code": "class Cylinder(Surface):\n    \"\"\"A cylinder, defined by its height, radius and direction,\n\n    Parameters\n    ----------\n    radius\n        The radius of the cylinder.\n    height\n        The height of the cylinder.\n    direction\n        The direction of the central axis of the cylinder.\n    v_range\n        The height along the height axis (given by direction) to start and end on.\n    show_ends\n        Whether to show the end caps or not.\n    resolution\n        The number of samples taken of the :class:`Cylinder`. A tuple can be used\n        to define different resolutions for ``u`` and ``v`` respectively.\n\n    Examples\n    --------\n    .. manim:: ExampleCylinder\n        :save_last_frame:\n\n        class ExampleCylinder(ThreeDScene):\n            def construct(self):\n                axes = ThreeDAxes()\n                cylinder = Cylinder(radius=2, height=3)\n                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n                self.add(axes, cylinder)\n    \"\"\"\n\n    def __init__(\n        self,\n        radius: float = 1,\n        height: float = 2,\n        direction: np.ndarray = Z_AXIS,\n        v_range: Sequence[float] = [0, TAU],\n        show_ends: bool = True,\n        resolution: Sequence[int] = (24, 24),\n        **kwargs,\n    ) -> None:\n        self._height = height\n        self.radius = radius\n        super().__init__(\n            self.func,\n            resolution=resolution,\n            u_range=[-self._height / 2, self._height / 2],\n            v_range=v_range,\n            **kwargs,\n        )\n        if show_ends:\n            self.add_bases()\n        self._current_phi = 0\n        self._current_theta = 0\n        self.set_direction(direction)\n\n    def func(self, u: float, v: float) -> np.ndarray:\n        \"\"\"Converts from cylindrical coordinates to cartesian.\n\n        Parameters\n        ----------\n        u\n            The height.\n        v\n            The azimuthal angle.\n\n        Returns\n        -------\n        :class:`numpy.ndarray`\n            Points defining the :class:`Cylinder`.\n        \"\"\"\n        height = u\n        phi = v\n        r = self.radius\n        return np.array([r * np.cos(phi), r * np.sin(phi), height])\n\n    def add_bases(self) -> None:\n        \"\"\"Adds the end caps of the cylinder.\"\"\"\n        if config.renderer == RendererType.OPENGL:\n            color = self.color\n            opacity = self.opacity\n        elif config.renderer == RendererType.CAIRO:\n            color = self.fill_color\n            opacity = self.fill_opacity\n\n        self.base_top = Circle(\n            radius=self.radius,\n            color=color,\n            fill_opacity=opacity,\n            shade_in_3d=True,\n            stroke_width=0,\n        )\n        self.base_top.shift(self.u_range[1] * IN)\n        self.base_bottom = Circle(\n            radius=self.radius,\n            color=color,\n            fill_opacity=opacity,\n            shade_in_3d=True,\n            stroke_width=0,\n        )\n        self.base_bottom.shift(self.u_range[0] * IN)\n        self.add(self.base_top, self.base_bottom)\n\n    def _rotate_to_direction(self) -> None:\n        x, y, z = self.direction\n\n        r = np.sqrt(x**2 + y**2 + z**2)\n        theta = np.arccos(z / r) if r > 0 else 0\n\n        if x == 0:\n            if y == 0:  # along the z axis\n                phi = 0\n            else:  # along the x axis\n                phi = np.arctan(np.inf)\n                if y < 0:\n                    phi += PI\n        else:\n            phi = np.arctan(y / x)\n        if x < 0:\n            phi += PI\n\n        # undo old rotation (in reverse direction)\n        self.rotate(-self._current_phi, Z_AXIS, about_point=ORIGIN)\n        self.rotate(-self._current_theta, Y_AXIS, about_point=ORIGIN)\n\n        # do new rotation\n        self.rotate(theta, Y_AXIS, about_point=ORIGIN)\n        self.rotate(phi, Z_AXIS, about_point=ORIGIN)\n\n        # store new values\n        self._current_theta = theta\n        self._current_phi = phi\n\n    def set_direction(self, direction: np.ndarray) -> None:\n        \"\"\"Sets the direction of the central axis of the :class:`Cylinder`.\n\n        Parameters\n        ----------\n        direction : :class:`numpy.array`\n            The direction of the central axis of the :class:`Cylinder`.\n        \"\"\"\n        # if get_norm(direction) is get_norm(self.direction):\n        #     pass\n        self.direction = direction\n        self._rotate_to_direction()\n\n    def get_direction(self) -> np.ndarray:\n        \"\"\"Returns the direction of the central axis of the :class:`Cylinder`.\n\n        Returns\n        -------\n        direction : :class:`numpy.array`\n            The direction of the central axis of the :class:`Cylinder`.\n        \"\"\"\n        return self.direction"}, {"name": "DashedLine", "code": "class DashedLine(Line):\n    \"\"\"A dashed :class:`Line`.\n\n    Parameters\n    ----------\n    args\n        Arguments to be passed to :class:`Line`\n    dash_length\n        The length of each individual dash of the line.\n    dashed_ratio\n        The ratio of dash space to empty space. Range of 0-1.\n    kwargs\n        Additional arguments to be passed to :class:`Line`\n\n\n    .. seealso::\n        :class:`~.DashedVMobject`\n\n    Examples\n    --------\n    .. manim:: DashedLineExample\n        :save_last_frame:\n\n        class DashedLineExample(Scene):\n            def construct(self):\n                # dash_length increased\n                dashed_1 = DashedLine(config.left_side, config.right_side, dash_length=2.0).shift(UP*2)\n                # normal\n                dashed_2 = DashedLine(config.left_side, config.right_side)\n                # dashed_ratio decreased\n                dashed_3 = DashedLine(config.left_side, config.right_side, dashed_ratio=0.1).shift(DOWN*2)\n                self.add(dashed_1, dashed_2, dashed_3)\n    \"\"\"\n\n    def __init__(\n        self,\n        *args: Any,\n        dash_length: float = DEFAULT_DASH_LENGTH,\n        dashed_ratio: float = 0.5,\n        **kwargs: Any,\n    ) -> None:\n        self.dash_length = dash_length\n        self.dashed_ratio = dashed_ratio\n        super().__init__(*args, **kwargs)\n        dashes = DashedVMobject(\n            self,\n            num_dashes=self._calculate_num_dashes(),\n            dashed_ratio=dashed_ratio,\n        )\n        self.clear_points()\n        self.add(*dashes)\n\n    def _calculate_num_dashes(self) -> int:\n        \"\"\"Returns the number of dashes in the dashed line.\n\n        Examples\n        --------\n        ::\n\n            >>> DashedLine()._calculate_num_dashes()\n            20\n        \"\"\"\n        # Minimum number of dashes has to be 2\n        return max(\n            2,\n            int(np.ceil((self.get_length() / self.dash_length) * self.dashed_ratio)),\n        )\n\n    def get_start(self) -> Point3D:\n        \"\"\"Returns the start point of the line.\n\n        Examples\n        --------\n        ::\n\n            >>> DashedLine().get_start()\n            array([-1.,  0.,  0.])\n        \"\"\"\n        if len(self.submobjects) > 0:\n            return self.submobjects[0].get_start()\n        else:\n            return super().get_start()\n\n    def get_end(self) -> Point3D:\n        \"\"\"Returns the end point of the line.\n\n        Examples\n        --------\n        ::\n\n            >>> DashedLine().get_end()\n            array([1., 0., 0.])\n        \"\"\"\n        if len(self.submobjects) > 0:\n            return self.submobjects[-1].get_end()\n        else:\n            return super().get_end()\n\n    def get_first_handle(self) -> Point3D:\n        \"\"\"Returns the point of the first handle.\n\n        Examples\n        --------\n        ::\n\n            >>> DashedLine().get_first_handle()\n            array([-0.98333333,  0.        ,  0.        ])\n        \"\"\"\n        # Type inference of extracting an element from a list, is not\n        # supported by numpy, see this numpy issue\n        # https://github.com/numpy/numpy/issues/16544\n        first_handle: Point3D = self.submobjects[0].points[1]\n        return first_handle\n\n    def get_last_handle(self) -> Point3D:\n        \"\"\"Returns the point of the last handle.\n\n        Examples\n        --------\n        ::\n\n            >>> DashedLine().get_last_handle()\n            array([0.98333333, 0.        , 0.        ])\n        \"\"\"\n        # Type inference of extracting an element from a list, is not\n        # supported by numpy, see this numpy issue\n        # https://github.com/numpy/numpy/issues/16544\n        last_handle: Point3D = self.submobjects[-1].points[2]\n        return last_handle"}, {"name": "DashedVMobject", "code": "class DashedVMobject(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A :class:`VMobject` composed of dashes instead of lines.\n\n    Parameters\n    ----------\n        vmobject\n            The object that will get dashed\n        num_dashes\n            Number of dashes to add.\n        dashed_ratio\n            Ratio of dash to empty space.\n        dash_offset\n            Shifts the starting point of dashes along the\n            path. Value 1 shifts by one full dash length.\n        equal_lengths\n            If ``True``, dashes will be (approximately) equally long.\n            If ``False``, dashes will be split evenly in the curve's\n            input t variable (legacy behavior).\n\n    Examples\n    --------\n    .. manim:: DashedVMobjectExample\n        :save_last_frame:\n\n        class DashedVMobjectExample(Scene):\n            def construct(self):\n                r = 0.5\n\n                top_row = VGroup()  # Increasing num_dashes\n                for dashes in range(1, 12):\n                    circ = DashedVMobject(Circle(radius=r, color=WHITE), num_dashes=dashes)\n                    top_row.add(circ)\n\n                middle_row = VGroup()  # Increasing dashed_ratio\n                for ratio in np.arange(1 / 11, 1, 1 / 11):\n                    circ = DashedVMobject(\n                        Circle(radius=r, color=WHITE), dashed_ratio=ratio\n                    )\n                    middle_row.add(circ)\n\n                func1 = FunctionGraph(lambda t: t**5,[-1,1],color=WHITE)\n                func_even = DashedVMobject(func1,num_dashes=6,equal_lengths=True)\n                func_stretched = DashedVMobject(func1, num_dashes=6, equal_lengths=False)\n                bottom_row = VGroup(func_even,func_stretched)\n\n\n                top_row.arrange(buff=0.3)\n                middle_row.arrange()\n                bottom_row.arrange(buff=1)\n                everything = VGroup(top_row, middle_row, bottom_row).arrange(DOWN, buff=1)\n                self.add(everything)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        vmobject: VMobject,\n        num_dashes: int = 15,\n        dashed_ratio: float = 0.5,\n        dash_offset: float = 0,\n        color: ManimColor = WHITE,\n        equal_lengths: bool = True,\n        **kwargs,\n    ) -> None:\n        self.dashed_ratio = dashed_ratio\n        self.num_dashes = num_dashes\n        super().__init__(color=color, **kwargs)\n        r = self.dashed_ratio\n        n = self.num_dashes\n        if n > 0:\n            # Assuming total length is 1\n            dash_len = r / n\n            if vmobject.is_closed():\n                void_len = (1 - r) / n\n            else:\n                void_len = 1 - r if n == 1 else (1 - r) / (n - 1)\n\n            period = dash_len + void_len\n            phase_shift = (dash_offset % 1) * period\n\n            if vmobject.is_closed():  # noqa: SIM108\n                # closed curves have equal amount of dashes and voids\n                pattern_len = 1\n            else:\n                # open curves start and end with a dash, so the whole dash pattern with the last void is longer\n                pattern_len = 1 + void_len\n\n            dash_starts = [((i * period + phase_shift) % pattern_len) for i in range(n)]\n            dash_ends = [\n                ((i * period + dash_len + phase_shift) % pattern_len) for i in range(n)\n            ]\n\n            # closed shapes can handle overflow at the 0-point\n            # open shapes need special treatment for it\n            if not vmobject.is_closed():\n                # due to phase shift being [0...1] range, always the last dash element needs attention for overflow\n                # if an entire dash moves out of the shape end:\n                if dash_ends[-1] > 1 and dash_starts[-1] > 1:\n                    # remove the last element since it is out-of-bounds\n                    dash_ends.pop()\n                    dash_starts.pop()\n                elif dash_ends[-1] < dash_len:  # if it overflowed\n                    if (\n                        dash_starts[-1] < 1\n                    ):  # if the beginning of the piece is still in range\n                        dash_starts.append(0)\n                        dash_ends.append(dash_ends[-1])\n                        dash_ends[-2] = 1\n                    else:\n                        dash_starts[-1] = 0\n                elif dash_starts[-1] > (1 - dash_len):\n                    dash_ends[-1] = 1\n\n            if equal_lengths:\n                # calculate the entire length by adding up short line-pieces\n                norms = np.array(0)\n                for k in range(vmobject.get_num_curves()):\n                    norms = np.append(norms, vmobject.get_nth_curve_length_pieces(k))\n                # add up length-pieces in array form\n                length_vals = np.cumsum(norms)\n                ref_points = np.linspace(0, 1, length_vals.size)\n                curve_length = length_vals[-1]\n                self.add(\n                    *(\n                        vmobject.get_subcurve(\n                            np.interp(\n                                dash_starts[i] * curve_length,\n                                length_vals,\n                                ref_points,\n                            ),\n                            np.interp(\n                                dash_ends[i] * curve_length,\n                                length_vals,\n                                ref_points,\n                            ),\n                        )\n                        for i in range(len(dash_starts))\n                    )\n                )\n            else:\n                self.add(\n                    *(\n                        vmobject.get_subcurve(\n                            dash_starts[i],\n                            dash_ends[i],\n                        )\n                        for i in range(len(dash_starts))\n                    )\n                )\n        # Family is already taken care of by get_subcurve\n        # implementation\n        if config.renderer == RendererType.OPENGL:\n            self.match_style(vmobject, recurse=False)\n        else:\n            self.match_style(vmobject, family=False)"}, {"name": "DecimalMatrix", "code": "class DecimalMatrix(Matrix):\n    r\"\"\"A mobject that displays a matrix with decimal entries on the screen.\n\n    Examples\n    --------\n\n    .. manim:: DecimalMatrixExample\n        :save_last_frame:\n\n        class DecimalMatrixExample(Scene):\n            def construct(self):\n                m0 = DecimalMatrix(\n                    [[3.456, 2.122], [33.2244, 12]],\n                    element_to_mobject_config={\"num_decimal_places\": 2},\n                    left_bracket=\"\\\\{\",\n                    right_bracket=\"\\\\}\")\n                self.add(m0)\n    \"\"\"\n\n    def __init__(\n        self,\n        matrix: Iterable,\n        element_to_mobject: Mobject = DecimalNumber,\n        element_to_mobject_config: dict[str, Mobject] = {\"num_decimal_places\": 1},\n        **kwargs,\n    ):\n        \"\"\"\n        Will round/truncate the decimal places as per the provided config.\n\n        Parameters\n        ----------\n        matrix\n            A numpy 2d array or list of lists\n        element_to_mobject\n            Mobject to use, by default DecimalNumber\n        element_to_mobject_config\n            Config for the desired mobject, by default {\"num_decimal_places\": 1}\n        \"\"\"\n        super().__init__(\n            matrix,\n            element_to_mobject=element_to_mobject,\n            element_to_mobject_config=element_to_mobject_config,\n            **kwargs,\n        )"}, {"name": "DecimalNumber", "code": "class DecimalNumber(VMobject, metaclass=ConvertToOpenGL):\n    r\"\"\"An mobject representing a decimal number.\n\n    Parameters\n    ----------\n    number\n        The numeric value to be displayed. It can later be modified using :meth:`.set_value`.\n    num_decimal_places\n        The number of decimal places after the decimal separator. Values are automatically rounded.\n    mob_class\n        The class for rendering digits and units, by default :class:`.MathTex`.\n    include_sign\n        Set to ``True`` to include a sign for positive numbers and zero.\n    group_with_commas\n        When ``True`` thousands groups are separated by commas for readability.\n    digit_buff_per_font_unit\n        Additional spacing between digits. Scales with font size.\n    show_ellipsis\n        When a number has been truncated by rounding, indicate with an ellipsis (``...``).\n    unit\n        A unit string which can be placed to the right of the numerical values.\n    unit_buff_per_font_unit\n        An additional spacing between the numerical values and the unit. A value\n        of ``unit_buff_per_font_unit=0.003`` gives a decent spacing. Scales with font size.\n    include_background_rectangle\n        Adds a background rectangle to increase contrast on busy scenes.\n    edge_to_fix\n        Assuring right- or left-alignment of the full object.\n    font_size\n        Size of the font.\n\n    Examples\n    --------\n\n    .. manim:: MovingSquareWithUpdaters\n\n        class MovingSquareWithUpdaters(Scene):\n            def construct(self):\n                decimal = DecimalNumber(\n                    0,\n                    show_ellipsis=True,\n                    num_decimal_places=3,\n                    include_sign=True,\n                    unit=r\"\\text{M-Units}\",\n                    unit_buff_per_font_unit=0.003\n                )\n                square = Square().to_edge(UP)\n\n                decimal.add_updater(lambda d: d.next_to(square, RIGHT))\n                decimal.add_updater(lambda d: d.set_value(square.get_center()[1]))\n                self.add(square, decimal)\n                self.play(\n                    square.animate.to_edge(DOWN),\n                    rate_func=there_and_back,\n                    run_time=5,\n                )\n                self.wait()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        number: float = 0,\n        num_decimal_places: int = 2,\n        mob_class: VMobject = MathTex,\n        include_sign: bool = False,\n        group_with_commas: bool = True,\n        digit_buff_per_font_unit: float = 0.001,\n        show_ellipsis: bool = False,\n        unit: str | None = None,  # Aligned to bottom unless it starts with \"^\"\n        unit_buff_per_font_unit: float = 0,\n        include_background_rectangle: bool = False,\n        edge_to_fix: Sequence[float] = LEFT,\n        font_size: float = DEFAULT_FONT_SIZE,\n        stroke_width: float = 0,\n        fill_opacity: float = 1.0,\n        **kwargs,\n    ):\n        super().__init__(**kwargs, fill_opacity=fill_opacity, stroke_width=stroke_width)\n        self.number = number\n        self.num_decimal_places = num_decimal_places\n        self.include_sign = include_sign\n        self.mob_class = mob_class\n        self.group_with_commas = group_with_commas\n        self.digit_buff_per_font_unit = digit_buff_per_font_unit\n        self.show_ellipsis = show_ellipsis\n        self.unit = unit\n        self.unit_buff_per_font_unit = unit_buff_per_font_unit\n        self.include_background_rectangle = include_background_rectangle\n        self.edge_to_fix = edge_to_fix\n        self._font_size = font_size\n        self.fill_opacity = fill_opacity\n\n        self.initial_config = kwargs.copy()\n        self.initial_config.update(\n            {\n                \"num_decimal_places\": num_decimal_places,\n                \"include_sign\": include_sign,\n                \"group_with_commas\": group_with_commas,\n                \"digit_buff_per_font_unit\": digit_buff_per_font_unit,\n                \"show_ellipsis\": show_ellipsis,\n                \"unit\": unit,\n                \"unit_buff_per_font_unit\": unit_buff_per_font_unit,\n                \"include_background_rectangle\": include_background_rectangle,\n                \"edge_to_fix\": edge_to_fix,\n                \"font_size\": font_size,\n                \"stroke_width\": stroke_width,\n                \"fill_opacity\": fill_opacity,\n            },\n        )\n\n        self._set_submobjects_from_number(number)\n        self.init_colors()\n\n    @property\n    def font_size(self):\n        \"\"\"The font size of the tex mobject.\"\"\"\n        return self.height / self.initial_height * self._font_size\n\n    @font_size.setter\n    def font_size(self, font_val):\n        if font_val <= 0:\n            raise ValueError(\"font_size must be greater than 0.\")\n        elif self.height > 0:\n            # sometimes manim generates a SingleStringMathex mobject with 0 height.\n            # can't be scaled regardless and will error without the elif.\n\n            # scale to a factor of the initial height so that setting\n            # font_size does not depend on current size.\n            self.scale(font_val / self.font_size)\n\n    def _set_submobjects_from_number(self, number):\n        self.number = number\n        self.submobjects = []\n\n        num_string = self._get_num_string(number)\n        self.add(*(map(self._string_to_mob, num_string)))\n\n        # Add non-numerical bits\n        if self.show_ellipsis:\n            self.add(\n                self._string_to_mob(\"\\\\dots\", SingleStringMathTex, color=self.color),\n            )\n\n        self.arrange(\n            buff=self.digit_buff_per_font_unit * self._font_size,\n            aligned_edge=DOWN,\n        )\n\n        if self.unit is not None:\n            self.unit_sign = self._string_to_mob(self.unit, SingleStringMathTex)\n            self.add(\n                self.unit_sign.next_to(\n                    self,\n                    direction=RIGHT,\n                    buff=(self.unit_buff_per_font_unit + self.digit_buff_per_font_unit)\n                    * self._font_size,\n                    aligned_edge=DOWN,\n                )\n            )\n\n        self.move_to(ORIGIN)\n\n        # Handle alignment of parts that should be aligned\n        # to the bottom\n        for i, c in enumerate(num_string):\n            if c == \"-\" and len(num_string) > i + 1:\n                self[i].align_to(self[i + 1], UP)\n                self[i].shift(self[i + 1].height * DOWN / 2)\n            elif c == \",\":\n                self[i].shift(self[i].height * DOWN / 2)\n        if self.unit and self.unit.startswith(\"^\"):\n            self.unit_sign.align_to(self, UP)\n\n        # track the initial height to enable scaling via font_size\n        self.initial_height = self.height\n\n        if self.include_background_rectangle:\n            self.add_background_rectangle()\n\n    def _get_num_string(self, number):\n        if isinstance(number, complex):\n            formatter = self._get_complex_formatter()\n        else:\n            formatter = self._get_formatter()\n        num_string = formatter.format(number)\n\n        rounded_num = np.round(number, self.num_decimal_places)\n        if num_string.startswith(\"-\") and rounded_num == 0:\n            num_string = \"+\" + num_string[1:] if self.include_sign else num_string[1:]\n\n        return num_string\n\n    def _string_to_mob(self, string: str, mob_class: VMobject | None = None, **kwargs):\n        if mob_class is None:\n            mob_class = self.mob_class\n\n        if string not in string_to_mob_map:\n            string_to_mob_map[string] = mob_class(string, **kwargs)\n        mob = string_to_mob_map[string].copy()\n        mob.font_size = self._font_size\n        return mob\n\n    def _get_formatter(self, **kwargs):\n        \"\"\"\n        Configuration is based first off instance attributes,\n        but overwritten by any kew word argument.  Relevant\n        key words:\n        - include_sign\n        - group_with_commas\n        - num_decimal_places\n        - field_name (e.g. 0 or 0.real)\n        \"\"\"\n        config = {\n            attr: getattr(self, attr)\n            for attr in [\n                \"include_sign\",\n                \"group_with_commas\",\n                \"num_decimal_places\",\n            ]\n        }\n        config.update(kwargs)\n        return \"\".join(\n            [\n                \"{\",\n                config.get(\"field_name\", \"\"),\n                \":\",\n                \"+\" if config[\"include_sign\"] else \"\",\n                \",\" if config[\"group_with_commas\"] else \"\",\n                \".\",\n                str(config[\"num_decimal_places\"]),\n                \"f\",\n                \"}\",\n            ],\n        )\n\n    def _get_complex_formatter(self):\n        return \"\".join(\n            [\n                self._get_formatter(field_name=\"0.real\"),\n                self._get_formatter(field_name=\"0.imag\", include_sign=True),\n                \"i\",\n            ],\n        )\n\n    def set_value(self, number: float):\n        \"\"\"Set the value of the :class:`~.DecimalNumber` to a new number.\n\n        Parameters\n        ----------\n        number\n            The value that will overwrite the current number of the :class:`~.DecimalNumber`.\n\n        \"\"\"\n        # creates a new number mob via `set_submobjects_from_number`\n        # then matches the properties (color, font_size, etc...)\n        # of the previous mobject to the new one\n\n        # old_family needed with cairo\n        old_family = self.get_family()\n\n        old_font_size = self.font_size\n        move_to_point = self.get_edge_center(self.edge_to_fix)\n        old_submobjects = self.submobjects\n\n        self._set_submobjects_from_number(number)\n        self.font_size = old_font_size\n        self.move_to(move_to_point, self.edge_to_fix)\n        for sm1, sm2 in zip(self.submobjects, old_submobjects):\n            sm1.match_style(sm2)\n\n        if config.renderer == RendererType.CAIRO:\n            for mob in old_family:\n                # Dumb hack...due to how scene handles families\n                # of animated mobjects\n                # for compatibility with updaters to not leave first number in place while updating,\n                # not needed with opengl renderer\n                mob.points[:] = 0\n\n        self.init_colors()\n        return self\n\n    def get_value(self):\n        return self.number\n\n    def increment_value(self, delta_t=1):\n        self.set_value(self.get_value() + delta_t)"}, {"name": "DecimalTable", "code": "class DecimalTable(Table):\n    \"\"\"A specialized :class:`~.Table` mobject for use with :class:`~.DecimalNumber` to display decimal entries.\n\n    Examples\n    --------\n\n    .. manim:: DecimalTableExample\n        :save_last_frame:\n\n        class DecimalTableExample(Scene):\n            def construct(self):\n                x_vals = [-2,-1,0,1,2]\n                y_vals = np.exp(x_vals)\n                t0 = DecimalTable(\n                    [x_vals, y_vals],\n                    row_labels=[MathTex(\"x\"), MathTex(\"f(x)=e^{x}\")],\n                    h_buff=1,\n                    element_to_mobject_config={\"num_decimal_places\": 2})\n                self.add(t0)\n    \"\"\"\n\n    def __init__(\n        self,\n        table: Iterable[Iterable[float | str]],\n        element_to_mobject: Callable[[float | str], VMobject] = DecimalNumber,\n        element_to_mobject_config: dict = {\"num_decimal_places\": 1},\n        **kwargs,\n    ):\n        \"\"\"\n        Special case of :class:`~.Table` with ``element_to_mobject`` set to :class:`~.DecimalNumber`.\n        By default, ``num_decimal_places`` is set to 1.\n        Will round/truncate the decimal places based on the provided ``element_to_mobject_config``.\n\n        Parameters\n        ----------\n        table\n            A 2D array, or a list of lists. Content of the table must be valid input\n            for :class:`~.DecimalNumber`.\n        element_to_mobject\n            The :class:`~.Mobject` class applied to the table entries. Set as :class:`~.DecimalNumber`.\n        element_to_mobject_config\n            Element to mobject config, here set as {\"num_decimal_places\": 1}.\n        kwargs\n            Additional arguments to be passed to :class:`~.Table`.\n        \"\"\"\n        super().__init__(\n            table,\n            element_to_mobject=element_to_mobject,\n            element_to_mobject_config=element_to_mobject_config,\n            **kwargs,\n        )"}, {"name": "DefaultGroup", "code": "class DefaultGroup(cloup.Group):\n    \"\"\"Invokes a subcommand marked with ``default=True`` if any subcommand is not\n    chosen.\n\n    Parameters\n    ----------\n    *args\n        Positional arguments to forward to :class:`cloup.Group`.\n    **kwargs\n        Keyword arguments to forward to :class:`cloup.Group`. The keyword\n        ``ignore_unknown_options`` must be set to ``False``.\n\n    Attributes\n    ----------\n    default_cmd_name : str | None\n        The name of the default command, if specified through the ``default``\n        keyword argument. Otherwise, this is set to ``None``.\n    default_if_no_args : bool\n        Whether to include or not the default command, if no command arguments\n        are supplied. This can be specified through the ``default_if_no_args``\n        keyword argument. Default is ``False``.\n    \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any):\n        # To resolve as the default command.\n        if not kwargs.get(\"ignore_unknown_options\", True):\n            raise ValueError(\"Default group accepts unknown options\")\n        self.ignore_unknown_options = True\n        self.default_cmd_name: str | None = kwargs.pop(\"default\", None)\n        self.default_if_no_args: bool = kwargs.pop(\"default_if_no_args\", False)\n        super().__init__(*args, **kwargs)\n\n    def set_default_command(self, command: Command) -> None:\n        \"\"\"Sets a command function as the default command.\n\n        Parameters\n        ----------\n        command\n            The command to set as default.\n        \"\"\"\n        cmd_name = command.name\n        self.add_command(command)\n        self.default_cmd_name = cmd_name\n\n    def parse_args(self, ctx: Context, args: list[str]) -> list[str]:\n        \"\"\"Parses the list of ``args`` by forwarding it to\n        :meth:`cloup.Group.parse_args`. Before doing so, if\n        :attr:`default_if_no_args` is set to ``True`` and ``args`` is empty,\n        this function appends to it the name of the default command specified\n        by :attr:`default_cmd_name`.\n\n        Parameters\n        ----------\n        ctx\n            The Click context.\n        args\n            A list of arguments. If it's empty and :attr:`default_if_no_args`\n            is ``True``, append the name of the default command to it.\n\n        Returns\n        -------\n        list[str]\n            The parsed arguments.\n        \"\"\"\n        if not args and self.default_if_no_args and self.default_cmd_name:\n            args.insert(0, self.default_cmd_name)\n        parsed_args: list[str] = super().parse_args(ctx, args)\n        return parsed_args\n\n    def get_command(self, ctx: Context, cmd_name: str) -> Command | None:\n        \"\"\"Get a command function by its name, by forwarding the arguments to\n        :meth:`cloup.Group.get_command`. If ``cmd_name`` does not match any of\n        the command names in :attr:`commands`, attempt to get the default command\n        instead.\n\n        Parameters\n        ----------\n        ctx\n            The Click context.\n        cmd_name\n            The name of the command to get.\n\n        Returns\n        -------\n        :class:`click.Command` | None\n            The command, if found. Otherwise, ``None``.\n        \"\"\"\n        if cmd_name not in self.commands and self.default_cmd_name:\n            # No command name matched.\n            ctx.meta[\"arg0\"] = cmd_name\n            cmd_name = self.default_cmd_name\n        return super().get_command(ctx, cmd_name)\n\n    def resolve_command(\n        self, ctx: Context, args: list[str]\n    ) -> tuple[str | None, Command | None, list[str]]:\n        \"\"\"Given a list of ``args`` given by a CLI, find a command which\n        matches the first element, and return its name (``cmd_name``), the\n        command function itself (``cmd``) and the rest of the arguments which\n        shall be passed to the function (``cmd_args``). If not found, return\n        ``None``, ``None`` and the rest of the arguments.\n\n        After resolving the command, if the Click context given by ``ctx``\n        contains an ``arg0`` attribute in its :attr:`click.Context.meta`\n        dictionary, insert it as the first element of the returned\n        ``cmd_args``.\n\n        Parameters\n        ----------\n        ctx\n            The Click context.\n        cmd_name\n            The name of the command to get.\n\n        Returns\n        -------\n        cmd_name : str | None\n            The command name, if found. Otherwise, ``None``.\n        cmd : :class:`click.Command` | None\n            The command, if found. Otherwise, ``None``.\n        cmd_args : list[str]\n            The rest of the arguments to be passed to ``cmd``.\n        \"\"\"\n        cmd_name, cmd, args = super().resolve_command(ctx, args)\n        if \"arg0\" in ctx.meta:\n            args.insert(0, ctx.meta[\"arg0\"])\n            if cmd is not None:\n                cmd_name = cmd.name\n        return cmd_name, cmd, args\n\n    @deprecated\n    def command(\n        self, *args: Any, **kwargs: Any\n    ) -> Callable[[Callable[..., object]], Command]:\n        \"\"\"Return a decorator which converts any function into the default\n        subcommand for this :class:`DefaultGroup`.\n\n        .. warning::\n            This method is deprecated. Use the ``default`` parameter of\n            :class:`DefaultGroup` or :meth:`set_default_command` instead.\n\n        Parameters\n        ----------\n        *args\n            Positional arguments to pass to :meth:`cloup.Group.command`.\n        **kwargs\n            Keyword arguments to pass to :meth:`cloup.Group.command`.\n\n        Returns\n        -------\n        Callable[[Callable[..., object]], click.Command]\n            A decorator which transforms its input into this\n            :class:`DefaultGroup`'s default subcommand.\n        \"\"\"\n        default = kwargs.pop(\"default\", False)\n        decorator: Callable[[Callable[..., object]], Command] = super().command(\n            *args, **kwargs\n        )\n        if not default:\n            return decorator\n        warnings.warn(\n            \"Use default param of DefaultGroup or set_default_command() instead\",\n            DeprecationWarning,\n            stacklevel=1,\n        )\n\n        def _decorator(f: Callable) -> Command:\n            cmd = decorator(f)\n            self.set_default_command(cmd)\n            return cmd\n\n        return _decorator"}, {"name": "DefaultSectionType", "code": "class DefaultSectionType(str, Enum):\n    \"\"\"The type of a section can be used for third party applications.\n    A presentation system could for example use the types to created loops.\n\n    Examples\n    --------\n    This class can be reimplemented for more types::\n\n        class PresentationSectionType(str, Enum):\n            # start, end, wait for continuation by user\n            NORMAL = \"presentation.normal\"\n            # start, end, immediately continue to next section\n            SKIP = \"presentation.skip\"\n            # start, end, restart, immediately continue to next section when continued by user\n            LOOP = \"presentation.loop\"\n            # start, end, restart, finish animation first when user continues\n            COMPLETE_LOOP = \"presentation.complete_loop\"\n    \"\"\"\n\n    NORMAL = \"default.normal\""}, {"name": "delete_nonsvg_files", "code": "def delete_nonsvg_files(additional_endings: Iterable[str] = ()) -> None:\n    \"\"\"Deletes every file that does not have a suffix in ``(\".svg\", \".tex\", *additional_endings)``\n\n    Parameters\n    ----------\n    additional_endings\n        Additional endings to whitelist\n    \"\"\"\n    tex_dir = config.get_dir(\"tex_dir\")\n    file_suffix_whitelist = {\".svg\", \".tex\", *additional_endings}\n\n    for f in tex_dir.iterdir():\n        if f.suffix not in file_suffix_whitelist:\n            f.unlink()"}, {"name": "depart", "code": "def depart(self: SkipManimNode, node: nodes.Element) -> None:\n    # TODO: Parent classes don't have a depart_admonition() method.\n    self.depart_admonition(node)"}, {"name": "deprecated", "code": "def deprecated(\n    func: Callable[..., T] | None = None,\n    since: str | None = None,\n    until: str | None = None,\n    replacement: str | None = None,\n    message: str | None = \"\",\n) -> Callable[..., T] | Callable[[Callable[..., T]], Callable[..., T]]:\n    \"\"\"Decorator to mark a callable as deprecated.\n\n    The decorated callable will cause a warning when used. The docstring of the\n    deprecated callable is adjusted to indicate that this callable is deprecated.\n\n    Parameters\n    ----------\n    func\n        The function to be decorated. Should not be set by the user.\n    since\n        The version or date since deprecation.\n    until\n        The version or date until removal of the deprecated callable.\n    replacement\n        The identifier of the callable replacing the deprecated one.\n    message\n        The reason for why the callable has been deprecated.\n\n    Returns\n    -------\n    Callable\n        The decorated callable.\n\n    Examples\n    --------\n    Basic usage::\n\n        from manim.utils.deprecation import deprecated\n\n\n        @deprecated\n        def foo(**kwargs):\n            pass\n\n\n        @deprecated\n        class Bar:\n            def __init__(self):\n                pass\n\n            @deprecated\n            def baz(self):\n                pass\n\n\n        foo()\n        # WARNING  The function foo has been deprecated and may be removed in a later version.\n\n        a = Bar()\n        # WARNING  The class Bar has been deprecated and may be removed in a later version.\n\n        a.baz()\n        # WARNING  The method Bar.baz has been deprecated and may be removed in a later version.\n\n    You can specify additional information for a more precise warning::\n\n        from manim.utils.deprecation import deprecated\n\n\n        @deprecated(\n            since=\"v0.2\", until=\"v0.4\", replacement=\"bar\", message=\"It is cooler.\"\n        )\n        def foo():\n            pass\n\n\n        foo()\n        # WARNING  The function foo has been deprecated since v0.2 and is expected to be removed after v0.4. Use bar instead. It is cooler.\n\n    You may also use dates instead of versions::\n\n        from manim.utils.deprecation import deprecated\n\n\n        @deprecated(since=\"05/01/2021\", until=\"06/01/2021\")\n        def foo():\n            pass\n\n\n        foo()\n        # WARNING  The function foo has been deprecated since 05/01/2021 and is expected to be removed after 06/01/2021.\n\n    \"\"\"\n    # If used as factory:\n    if func is None:\n        return lambda func: deprecated(func, since, until, replacement, message)\n\n    what, name = _get_callable_info(func)\n\n    def warning_msg(for_docs: bool = False) -> str:\n        \"\"\"Generate the deprecation warning message.\n\n        Parameters\n        ----------\n        for_docs\n            Whether or not to format the message for use in documentation.\n\n        Returns\n        -------\n        str\n            The deprecation message.\n        \"\"\"\n        msg = message\n        if replacement is not None:\n            repl = replacement\n            if for_docs:\n                mapper = {\"class\": \"class\", \"method\": \"meth\", \"function\": \"func\"}\n                repl = f\":{mapper[what]}:`~.{replacement}`\"\n            msg = f\"Use {repl} instead.{' ' + message if message else ''}\"\n        deprecated = _deprecation_text_component(since, until, msg)\n        return f\"The {what} {name} has been {deprecated}\"\n\n    def deprecate_docs(func: Callable) -> None:\n        \"\"\"Adjust docstring to indicate the deprecation.\n\n        Parameters\n        ----------\n        func\n            The callable whose docstring to adjust.\n        \"\"\"\n        warning = warning_msg(True)\n        doc_string = func.__doc__ or \"\"\n        func.__doc__ = f\"{doc_string}\\n\\n.. attention:: Deprecated\\n  {warning}\"\n\n    def deprecate(func: Callable[..., T], *args: Any, **kwargs: Any) -> T:\n        \"\"\"The actual decorator used to extend the callables behavior.\n\n        Logs a warning message.\n\n        Parameters\n        ----------\n        func\n            The callable to decorate.\n        args\n            The arguments passed to the given callable.\n        kwargs\n            The keyword arguments passed to the given callable.\n\n        Returns\n        -------\n        Any\n            The return value of the given callable when being passed the given\n            arguments.\n        \"\"\"\n        logger.warning(warning_msg())\n        return func(*args, **kwargs)\n\n    if type(func).__name__ != \"function\":\n        deprecate_docs(func)\n        # The following line raises this mypy error:\n        # Accessing \"__init__\" on an instance is unsound, since instance.__init__\n        # could be from an incompatible subclass  [misc]</pre>\n        func.__init__ = decorate(func.__init__, deprecate)  # type: ignore[misc]\n        return func\n\n    func = decorate(func, deprecate)\n    deprecate_docs(func)\n    return func"}, {"name": "deprecated_params", "code": "def deprecated_params(\n    params: str | Iterable[str] | None = None,\n    since: str | None = None,\n    until: str | None = None,\n    message: str = \"\",\n    redirections: None\n    | (Iterable[tuple[str, str] | Callable[..., dict[str, Any]]]) = None,\n) -> Callable[..., T]:\n    \"\"\"Decorator to mark parameters of a callable as deprecated.\n\n    It can also be used to automatically redirect deprecated parameter values to their\n    replacements.\n\n    Parameters\n    ----------\n    params\n        The parameters to be deprecated. Can consist of:\n\n        * An iterable of strings, with each element representing a parameter to deprecate\n        * A single string, with parameter names separated by commas or spaces.\n    since\n        The version or date since deprecation.\n    until\n        The version or date until removal of the deprecated callable.\n    message\n        The reason for why the callable has been deprecated.\n    redirections\n        A list of parameter redirections. Each redirection can be one of the following:\n\n        * A tuple of two strings. The first string defines the name of the deprecated\n          parameter; the second string defines the name of the parameter to redirect to,\n          when attempting to use the first string.\n\n        * A function performing the mapping operation. The parameter names of the\n          function determine which parameters are used as input. The function must\n          return a dictionary which contains the redirected arguments.\n\n        Redirected parameters are also implicitly deprecated.\n\n    Returns\n    -------\n    Callable\n        The decorated callable.\n\n    Raises\n    ------\n    ValueError\n        If no parameters are defined (neither explicitly nor implicitly).\n    ValueError\n        If defined parameters are invalid python identifiers.\n\n    Examples\n    --------\n    Basic usage::\n\n        from manim.utils.deprecation import deprecated_params\n\n\n        @deprecated_params(params=\"a, b, c\")\n        def foo(**kwargs):\n            pass\n\n\n        foo(x=2, y=3, z=4)\n        # No warning\n\n        foo(a=2, b=3, z=4)\n        # WARNING  The parameters a and b of method foo have been deprecated and may be removed in a later version.\n\n    You can also specify additional information for a more precise warning::\n\n        from manim.utils.deprecation import deprecated_params\n\n\n        @deprecated_params(\n            params=\"a, b, c\",\n            since=\"v0.2\",\n            until=\"v0.4\",\n            message=\"The letters x, y, z are cooler.\",\n        )\n        def foo(**kwargs):\n            pass\n\n\n        foo(a=2)\n        # WARNING  The parameter a of method foo has been deprecated since v0.2 and is expected to be removed after v0.4. The letters x, y, z are cooler.\n\n    Basic parameter redirection::\n\n        from manim.utils.deprecation import deprecated_params\n\n\n        @deprecated_params(\n            redirections=[\n                # Two ways to redirect one parameter to another:\n                (\"old_param\", \"new_param\"),\n                lambda old_param2: {\"new_param22\": old_param2},\n            ]\n        )\n        def foo(**kwargs):\n            return kwargs\n\n\n        foo(x=1, old_param=2)\n        # WARNING  The parameter old_param of method foo has been deprecated and may be removed in a later version.\n        # returns {\"x\": 1, \"new_param\": 2}\n\n    Redirecting using a calculated value::\n\n        from manim.utils.deprecation import deprecated_params\n\n\n        @deprecated_params(\n            redirections=[lambda runtime_in_ms: {\"run_time\": runtime_in_ms / 1000}]\n        )\n        def foo(**kwargs):\n            return kwargs\n\n\n        foo(runtime_in_ms=500)\n        # WARNING  The parameter runtime_in_ms of method foo has been deprecated and may be removed in a later version.\n        # returns {\"run_time\": 0.5}\n\n    Redirecting multiple parameter values to one::\n\n        from manim.utils.deprecation import deprecated_params\n\n\n        @deprecated_params(\n            redirections=[lambda buff_x=1, buff_y=1: {\"buff\": (buff_x, buff_y)}]\n        )\n        def foo(**kwargs):\n            return kwargs\n\n\n        foo(buff_x=2)\n        # WARNING  The parameter buff_x of method foo has been deprecated and may be removed in a later version.\n        # returns {\"buff\": (2, 1)}\n\n    Redirect one parameter to multiple::\n\n        from manim.utils.deprecation import deprecated_params\n\n\n        @deprecated_params(\n            redirections=[\n                lambda buff=1: {\"buff_x\": buff[0], \"buff_y\": buff[1]}\n                if isinstance(buff, tuple)\n                else {\"buff_x\": buff, \"buff_y\": buff}\n            ]\n        )\n        def foo(**kwargs):\n            return kwargs\n\n\n        foo(buff=0)\n        # WARNING  The parameter buff of method foo has been deprecated and may be removed in a later version.\n        # returns {\"buff_x\": 0, buff_y: 0}\n\n        foo(buff=(1, 2))\n        # WARNING  The parameter buff of method foo has been deprecated and may be removed in a later version.\n        # returns {\"buff_x\": 1, buff_y: 2}\n\n\n    \"\"\"\n    # Check if decorator is used without parenthesis\n    if callable(params):\n        raise ValueError(\"deprecate_parameters requires arguments to be specified.\")\n\n    if params is None:\n        params = []\n\n    # Construct params list\n    params = re.split(r\"[,\\s]+\", params) if isinstance(params, str) else list(params)\n\n    # Add params which are only implicitly given via redirections\n    if redirections is None:\n        redirections = []\n    for redirector in redirections:\n        if isinstance(redirector, tuple):\n            params.append(redirector[0])\n        else:\n            params.extend(list(inspect.signature(redirector).parameters))\n    # Keep ordering of params so that warning message is consistently the same\n    # This will also help pass unit testing\n    params = list(dict.fromkeys(params))\n\n    # Make sure params only contains valid identifiers\n    identifier = re.compile(r\"^[^\\d\\W]\\w*\\Z\", re.UNICODE)\n    if not all(re.match(identifier, param) for param in params):\n        raise ValueError(\"Given parameter values are invalid.\")\n\n    redirections = list(redirections)\n\n    def warning_msg(func: Callable[..., T], used: list[str]) -> str:\n        \"\"\"Generate the deprecation warning message.\n\n        Parameters\n        ----------\n        func\n            The callable with deprecated parameters.\n        used\n            The list of deprecated parameters used in a call.\n\n        Returns\n        -------\n        str\n            The deprecation message.\n        \"\"\"\n        what, name = _get_callable_info(func)\n        plural = len(used) > 1\n        parameter_s = \"s\" if plural else \"\"\n        used_ = \", \".join(used[:-1]) + \" and \" + used[-1] if plural else used[0]\n        has_have_been = \"have been\" if plural else \"has been\"\n        deprecated = _deprecation_text_component(since, until, message)\n        return f\"The parameter{parameter_s} {used_} of {what} {name} {has_have_been} {deprecated}\"\n\n    def redirect_params(kwargs: dict[str, Any], used: list[str]) -> None:\n        \"\"\"Adjust the keyword arguments as defined by the redirections.\n\n        Parameters\n        ----------\n        kwargs\n            The keyword argument dictionary to be updated.\n        used\n            The list of deprecated parameters used in a call.\n        \"\"\"\n        for redirector in redirections:\n            if isinstance(redirector, tuple):\n                old_param, new_param = redirector\n                if old_param in used:\n                    kwargs[new_param] = kwargs.pop(old_param)\n            else:\n                redirector_params = list(inspect.signature(redirector).parameters)\n                redirector_args = {}\n                for redirector_param in redirector_params:\n                    if redirector_param in used:\n                        redirector_args[redirector_param] = kwargs.pop(redirector_param)\n                if len(redirector_args) > 0:\n                    kwargs.update(redirector(**redirector_args))\n\n    def deprecate_params(func: Callable[..., T], *args: Any, **kwargs: Any) -> T:\n        \"\"\"The actual decorator function used to extend the callables behavior.\n\n        Logs a warning message when a deprecated parameter is used and redirects it if\n        specified.\n\n        Parameters\n        ----------\n        func\n            The callable to decorate.\n        args\n            The arguments passed to the given callable.\n        kwargs\n            The keyword arguments passed to the given callable.\n\n        Returns\n        -------\n        Any\n            The return value of the given callable when being passed the given\n            arguments.\n\n        \"\"\"\n        used = []\n        for param in params:\n            if param in kwargs:\n                used.append(param)\n\n        if len(used) > 0:\n            logger.warning(warning_msg(func, used))\n            redirect_params(kwargs, used)\n        return func(*args, **kwargs)\n\n    return decorator(deprecate_params)"}, {"name": "DictAsObject", "code": "class DictAsObject:\n    def __init__(self, dictin: dict[str, Any]):\n        self.__dict__ = dictin"}, {"name": "Difference", "code": "class Difference(_BooleanOps):\n    \"\"\"Subtracts one :class:`~.VMobject` from another one.\n\n    Parameters\n    ----------\n    subject\n        The 1st :class:`~.VMobject`.\n    clip\n        The 2nd :class:`~.VMobject`\n\n    Example\n    -------\n    .. manim:: DifferenceExample\n        :save_last_frame:\n\n        class DifferenceExample(Scene):\n            def construct(self):\n                sq = Square(color=RED, fill_opacity=1)\n                sq.move_to([-2, 0, 0])\n                cr = Circle(color=BLUE, fill_opacity=1)\n                cr.move_to([-1.3, 0.7, 0])\n                un = Difference(sq, cr, color=GREEN, fill_opacity=1)\n                un.move_to([1.5, 0, 0])\n                self.add(sq, cr, un)\n\n    \"\"\"\n\n    def __init__(self, subject: VMobject, clip: VMobject, **kwargs: Any) -> None:\n        super().__init__(**kwargs)\n        outpen = SkiaPath()\n        difference(\n            [self._convert_vmobject_to_skia_path(subject)],\n            [self._convert_vmobject_to_skia_path(clip)],\n            outpen.getPen(),\n        )\n        self._convert_skia_path_to_vmobject(outpen)"}, {"name": "DiGraph", "code": "class DiGraph(GenericGraph):\n    \"\"\"A directed graph.\n\n    .. note::\n\n        In contrast to undirected graphs, the order in which vertices in a given\n        edge are specified is relevant here.\n\n    See also\n    --------\n\n    :class:`.GenericGraph`\n\n    Parameters\n    ----------\n\n    vertices\n        A list of vertices. Must be hashable elements.\n    edges\n        A list of edges, specified as tuples ``(u, v)`` where both ``u``\n        and ``v`` are vertices. The edge is directed from ``u`` to ``v``.\n    labels\n        Controls whether or not vertices are labeled. If ``False`` (the default),\n        the vertices are not labeled; if ``True`` they are labeled using their\n        names (as specified in ``vertices``) via :class:`~.MathTex`. Alternatively,\n        custom labels can be specified by passing a dictionary whose keys are\n        the vertices, and whose values are the corresponding vertex labels\n        (rendered via, e.g., :class:`~.Text` or :class:`~.Tex`).\n    label_fill_color\n        Sets the fill color of the default labels generated when ``labels``\n        is set to ``True``. Has no effect for other values of ``labels``.\n    layout\n        Either one of ``\"spring\"`` (the default), ``\"circular\"``, ``\"kamada_kawai\"``,\n        ``\"planar\"``, ``\"random\"``, ``\"shell\"``, ``\"spectral\"``, ``\"spiral\"``, ``\"tree\"``, and ``\"partite\"``\n        for automatic vertex positioning using ``networkx``\n        (see `their documentation <https://networkx.org/documentation/stable/reference/drawing.html#module-networkx.drawing.layout>`_\n        for more details), or a dictionary specifying a coordinate (value)\n        for each vertex (key) for manual positioning.\n    layout_config\n        Only for automatically generated layouts. A dictionary whose entries\n        are passed as keyword arguments to the automatic layout algorithm\n        specified via ``layout`` of ``networkx``.\n        The ``tree`` layout also accepts a special parameter ``vertex_spacing``\n        passed as a keyword argument inside the ``layout_config`` dictionary.\n        Passing a tuple ``(space_x, space_y)`` as this argument overrides\n        the value of ``layout_scale`` and ensures that vertices are arranged\n        in a way such that the centers of siblings in the same layer are\n        at least ``space_x`` units apart horizontally, and neighboring layers\n        are spaced ``space_y`` units vertically.\n    layout_scale\n        The scale of automatically generated layouts: the vertices will\n        be arranged such that the coordinates are located within the\n        interval ``[-scale, scale]``. Some layouts accept a tuple ``(scale_x, scale_y)``\n        causing the first coordinate to be in the interval ``[-scale_x, scale_x]``,\n        and the second in ``[-scale_y, scale_y]``. Default: 2.\n    vertex_type\n        The mobject class used for displaying vertices in the scene.\n    vertex_config\n        Either a dictionary containing keyword arguments to be passed to\n        the class specified via ``vertex_type``, or a dictionary whose keys\n        are the vertices, and whose values are dictionaries containing keyword\n        arguments for the mobject related to the corresponding vertex.\n    vertex_mobjects\n        A dictionary whose keys are the vertices, and whose values are\n        mobjects to be used as vertices. Passing vertices here overrides\n        all other configuration options for a vertex.\n    edge_type\n        The mobject class used for displaying edges in the scene.\n    edge_config\n        Either a dictionary containing keyword arguments to be passed\n        to the class specified via ``edge_type``, or a dictionary whose\n        keys are the edges, and whose values are dictionaries containing\n        keyword arguments for the mobject related to the corresponding edge.\n        You can further customize the tip by adding a ``tip_config`` dictionary\n        for global styling, or by adding the dict to a specific ``edge_config``.\n\n    Examples\n    --------\n\n    .. manim:: MovingDiGraph\n\n        class MovingDiGraph(Scene):\n            def construct(self):\n                vertices = [1, 2, 3, 4]\n                edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]\n\n                g = DiGraph(vertices, edges)\n\n                self.add(g)\n                self.play(\n                    g[1].animate.move_to([1, 1, 1]),\n                    g[2].animate.move_to([-1, 1, 2]),\n                    g[3].animate.move_to([1, -1, -1]),\n                    g[4].animate.move_to([-1, -1, 0]),\n                )\n                self.wait()\n\n    You can customize the edges and arrow tips globally or locally.\n\n    .. manim:: CustomDiGraph\n\n        class CustomDiGraph(Scene):\n            def construct(self):\n                vertices = [i for i in range(5)]\n                edges = [\n                    (0, 1),\n                    (1, 2),\n                    (3, 2),\n                    (3, 4),\n                ]\n\n                edge_config = {\n                    \"stroke_width\": 2,\n                    \"tip_config\": {\n                        \"tip_shape\": ArrowSquareTip,\n                        \"tip_length\": 0.15,\n                    },\n                    (3, 4): {\n                        \"color\": RED,\n                        \"tip_config\": {\"tip_length\": 0.25, \"tip_width\": 0.25}\n                    },\n                }\n\n                g = DiGraph(\n                    vertices,\n                    edges,\n                    labels=True,\n                    layout=\"circular\",\n                    edge_config=edge_config,\n                ).scale(1.4)\n\n                self.play(Create(g))\n                self.wait()\n\n    Since this implementation respects the labels boundary you can also use\n    it for an undirected moving graph with labels.\n\n    .. manim:: UndirectedMovingDiGraph\n\n        class UndirectedMovingDiGraph(Scene):\n            def construct(self):\n                vertices = [i for i in range(5)]\n                edges = [\n                    (0, 1),\n                    (1, 2),\n                    (3, 2),\n                    (3, 4),\n                ]\n\n                edge_config = {\n                    \"stroke_width\": 2,\n                    \"tip_config\": {\"tip_length\": 0, \"tip_width\": 0},\n                    (3, 4): {\"color\": RED},\n                }\n\n                g = DiGraph(\n                    vertices,\n                    edges,\n                    labels=True,\n                    layout=\"circular\",\n                    edge_config=edge_config,\n                ).scale(1.4)\n\n                self.play(Create(g))\n                self.wait()\n\n                self.play(\n                    g[1].animate.move_to([1, 1, 1]),\n                    g[2].animate.move_to([-1, 1, 2]),\n                    g[3].animate.move_to([-1.5, -1.5, -1]),\n                    g[4].animate.move_to([1, -2, -1]),\n                )\n                self.wait()\n\n    \"\"\"\n\n    @staticmethod\n    def _empty_networkx_graph() -> nx.DiGraph:\n        return nx.DiGraph()\n\n    def _populate_edge_dict(\n        self, edges: list[tuple[Hashable, Hashable]], edge_type: type[Mobject]\n    ):\n        self.edges = {\n            (u, v): edge_type(\n                start=self[u],\n                end=self[v],\n                z_index=-1,\n                **self._edge_config[(u, v)],\n            )\n            for (u, v) in edges\n        }\n\n        for (u, v), edge in self.edges.items():\n            edge.add_tip(**self._tip_config[(u, v)])\n\n    def update_edges(self, graph):\n        \"\"\"Updates the edges to stick at their corresponding vertices.\n\n        Arrow tips need to be repositioned since otherwise they can be\n        deformed.\n        \"\"\"\n        for (u, v), edge in graph.edges.items():\n            tip = edge.pop_tips()[0]\n            # Passing the Mobject instead of the vertex makes the tip\n            # stop on the bounding box of the vertex.\n            edge.set_points_by_ends(\n                graph[u],\n                graph[v],\n                buff=self._edge_config.get(\"buff\", 0),\n                path_arc=self._edge_config.get(\"path_arc\", 0),\n            )\n            edge.add_tip(tip)\n\n    def __repr__(self: DiGraph) -> str:\n        return f\"Directed graph on {len(self.vertices)} vertices and {len(self.edges)} edges\""}, {"name": "Dodecahedron", "code": "class Dodecahedron(Polyhedron):\n    \"\"\"A dodecahedron, one of the five platonic solids. It has 12 faces, 30 edges and 20 vertices.\n\n    Parameters\n    ----------\n    edge_length\n        The length of an edge between any two vertices.\n\n    Examples\n    --------\n\n    .. manim:: DodecahedronScene\n        :save_last_frame:\n\n        class DodecahedronScene(ThreeDScene):\n            def construct(self):\n                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n                obj = Dodecahedron()\n                self.add(obj)\n    \"\"\"\n\n    def __init__(self, edge_length: float = 1, **kwargs):\n        unit_a = edge_length * ((1 + np.sqrt(5)) / 4)\n        unit_b = edge_length * ((3 + np.sqrt(5)) / 4)\n        unit_c = edge_length * (1 / 2)\n        super().__init__(\n            vertex_coords=[\n                np.array([unit_a, unit_a, unit_a]),\n                np.array([unit_a, unit_a, -unit_a]),\n                np.array([unit_a, -unit_a, unit_a]),\n                np.array([unit_a, -unit_a, -unit_a]),\n                np.array([-unit_a, unit_a, unit_a]),\n                np.array([-unit_a, unit_a, -unit_a]),\n                np.array([-unit_a, -unit_a, unit_a]),\n                np.array([-unit_a, -unit_a, -unit_a]),\n                np.array([0, unit_c, unit_b]),\n                np.array([0, unit_c, -unit_b]),\n                np.array([0, -unit_c, -unit_b]),\n                np.array([0, -unit_c, unit_b]),\n                np.array([unit_c, unit_b, 0]),\n                np.array([-unit_c, unit_b, 0]),\n                np.array([unit_c, -unit_b, 0]),\n                np.array([-unit_c, -unit_b, 0]),\n                np.array([unit_b, 0, unit_c]),\n                np.array([-unit_b, 0, unit_c]),\n                np.array([unit_b, 0, -unit_c]),\n                np.array([-unit_b, 0, -unit_c]),\n            ],\n            faces_list=[\n                [18, 16, 0, 12, 1],\n                [3, 18, 16, 2, 14],\n                [3, 10, 9, 1, 18],\n                [1, 9, 5, 13, 12],\n                [0, 8, 4, 13, 12],\n                [2, 16, 0, 8, 11],\n                [4, 17, 6, 11, 8],\n                [17, 19, 5, 13, 4],\n                [19, 7, 15, 6, 17],\n                [6, 15, 14, 2, 11],\n                [19, 5, 9, 10, 7],\n                [7, 10, 3, 14, 15],\n            ],\n            **kwargs,\n        )"}, {"name": "Dot", "code": "class Dot(Circle):\n    \"\"\"A circle with a very small radius.\n\n    Parameters\n    ----------\n    point\n        The location of the dot.\n    radius\n        The radius of the dot.\n    stroke_width\n        The thickness of the outline of the dot.\n    fill_opacity\n        The opacity of the dot's fill_colour\n    color\n        The color of the dot.\n    kwargs\n        Additional arguments to be passed to :class:`Circle`\n\n    Examples\n    --------\n    .. manim:: DotExample\n        :save_last_frame:\n\n        class DotExample(Scene):\n            def construct(self):\n                dot1 = Dot(point=LEFT, radius=0.08)\n                dot2 = Dot(point=ORIGIN)\n                dot3 = Dot(point=RIGHT)\n                self.add(dot1,dot2,dot3)\n    \"\"\"\n\n    def __init__(\n        self,\n        point: Point3DLike = ORIGIN,\n        radius: float = DEFAULT_DOT_RADIUS,\n        stroke_width: float = 0,\n        fill_opacity: float = 1.0,\n        color: ParsableManimColor = WHITE,\n        **kwargs: Any,\n    ) -> None:\n        super().__init__(\n            arc_center=point,\n            radius=radius,\n            stroke_width=stroke_width,\n            fill_opacity=fill_opacity,\n            color=color,\n            **kwargs,\n        )"}, {"name": "Dot3D", "code": "class Dot3D(Sphere):\n    \"\"\"A spherical dot.\n\n    Parameters\n    ----------\n    point\n        The location of the dot.\n    radius\n        The radius of the dot.\n    color\n        The color of the :class:`Dot3D`.\n    resolution\n        The number of samples taken of the :class:`Dot3D`. A tuple can be\n        used to define different resolutions for ``u`` and ``v`` respectively.\n\n    Examples\n    --------\n\n    .. manim:: Dot3DExample\n        :save_last_frame:\n\n        class Dot3DExample(ThreeDScene):\n            def construct(self):\n                self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)\n\n                axes = ThreeDAxes()\n                dot_1 = Dot3D(point=axes.coords_to_point(0, 0, 1), color=RED)\n                dot_2 = Dot3D(point=axes.coords_to_point(2, 0, 0), radius=0.1, color=BLUE)\n                dot_3 = Dot3D(point=[0, 0, 0], radius=0.1, color=ORANGE)\n                self.add(axes, dot_1, dot_2,dot_3)\n    \"\"\"\n\n    def __init__(\n        self,\n        point: list | np.ndarray = ORIGIN,\n        radius: float = DEFAULT_DOT_RADIUS,\n        color: ParsableManimColor = WHITE,\n        resolution: tuple[int, int] = (8, 8),\n        **kwargs,\n    ) -> None:\n        super().__init__(center=point, radius=radius, resolution=resolution, **kwargs)\n        self.set_color(color)"}, {"name": "DotCloud", "code": "class DotCloud(OpenGLPMobject):\n    def __init__(\n        self, color=YELLOW, stroke_width=2.0, radius=2.0, density=10, **kwargs\n    ):\n        self.radius = radius\n        self.epsilon = 1.0 / density\n        super().__init__(\n            stroke_width=stroke_width, density=density, color=color, **kwargs\n        )\n\n    def init_points(self):\n        self.points = np.array(\n            [\n                r * (np.cos(theta) * RIGHT + np.sin(theta) * UP)\n                for r in np.arange(self.epsilon, self.radius, self.epsilon)\n                # Num is equal to int(stop - start)/ (step + 1) reformulated.\n                for theta in np.linspace(\n                    0,\n                    2 * np.pi,\n                    num=int(2 * np.pi * (r + self.epsilon) / self.epsilon),\n                )\n            ],\n            dtype=np.float32,\n        )\n\n    def make_3d(self, gloss=0.5, shadow=0.2):\n        self.set_gloss(gloss)\n        self.set_shadow(shadow)\n        self.apply_depth_test()\n        return self"}, {"name": "double_smooth", "code": "def double_smooth(t: float) -> float:\n    if t < 0.5:\n        return 0.5 * smooth(2 * t)\n    else:\n        return 0.5 * (1 + smooth(2 * t - 1))"}, {"name": "DoubleArrow", "code": "class DoubleArrow(Arrow):\n    \"\"\"An arrow with tips on both ends.\n\n    Parameters\n    ----------\n    args\n        Arguments to be passed to :class:`Arrow`\n    kwargs\n        Additional arguments to be passed to :class:`Arrow`\n\n\n    .. seealso::\n        :class:`.~ArrowTip`\n        :class:`.~CurvedDoubleArrow`\n\n    Examples\n    --------\n    .. manim:: DoubleArrowExample\n        :save_last_frame:\n\n        from manim.mobject.geometry.tips import ArrowCircleFilledTip\n        class DoubleArrowExample(Scene):\n            def construct(self):\n                circle = Circle(radius=2.0)\n                d_arrow = DoubleArrow(start=circle.get_left(), end=circle.get_right())\n                d_arrow_2 = DoubleArrow(tip_shape_end=ArrowCircleFilledTip, tip_shape_start=ArrowCircleFilledTip)\n                group = Group(Group(circle, d_arrow), d_arrow_2).arrange(UP, buff=1)\n                self.add(group)\n\n\n    .. manim:: DoubleArrowExample2\n        :save_last_frame:\n\n        class DoubleArrowExample2(Scene):\n            def construct(self):\n                box = Square()\n                p1 = box.get_left()\n                p2 = box.get_right()\n                d1 = DoubleArrow(p1, p2, buff=0)\n                d2 = DoubleArrow(p1, p2, buff=0, tip_length=0.2, color=YELLOW)\n                d3 = DoubleArrow(p1, p2, buff=0, tip_length=0.4, color=BLUE)\n                Group(d1, d2, d3).arrange(DOWN)\n                self.add(box, d1, d2, d3)\n    \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        if \"tip_shape_end\" in kwargs:\n            kwargs[\"tip_shape\"] = kwargs.pop(\"tip_shape_end\")\n        tip_shape_start = kwargs.pop(\"tip_shape_start\", ArrowTriangleFilledTip)\n        super().__init__(*args, **kwargs)\n        self.add_tip(at_start=True, tip_shape=tip_shape_start)"}, {"name": "drag_pixels", "code": "def drag_pixels(frames: list[np.array]) -> list[np.array]:\n    curr = frames[0]\n    new_frames = []\n    for frame in frames:\n        curr += (curr == 0) * np.array(frame)\n        new_frames.append(np.array(curr))\n    return new_frames"}, {"name": "DrawBorderThenFill", "code": "class DrawBorderThenFill(Animation):\n    \"\"\"Draw the border first and then show the fill.\n\n    Examples\n    --------\n    .. manim:: ShowDrawBorderThenFill\n\n        class ShowDrawBorderThenFill(Scene):\n            def construct(self):\n                self.play(DrawBorderThenFill(Square(fill_opacity=1, fill_color=ORANGE)))\n    \"\"\"\n\n    def __init__(\n        self,\n        vmobject: VMobject | OpenGLVMobject,\n        run_time: float = 2,\n        rate_func: Callable[[float], float] = double_smooth,\n        stroke_width: float = 2,\n        stroke_color: str = None,\n        introducer: bool = True,\n        **kwargs,\n    ) -> None:\n        self._typecheck_input(vmobject)\n        super().__init__(\n            vmobject,\n            run_time=run_time,\n            introducer=introducer,\n            rate_func=rate_func,\n            **kwargs,\n        )\n        self.stroke_width = stroke_width\n        self.stroke_color = stroke_color\n        self.outline = self.get_outline()\n\n    def _typecheck_input(self, vmobject: VMobject | OpenGLVMobject) -> None:\n        if not isinstance(vmobject, (VMobject, OpenGLVMobject)):\n            raise TypeError(\n                f\"{self.__class__.__name__} only works for vectorized Mobjects\"\n            )\n\n    def begin(self) -> None:\n        self.outline = self.get_outline()\n        super().begin()\n\n    def get_outline(self) -> Mobject:\n        outline = self.mobject.copy()\n        outline.set_fill(opacity=0)\n        for sm in outline.family_members_with_points():\n            sm.set_stroke(color=self.get_stroke_color(sm), width=self.stroke_width)\n        return outline\n\n    def get_stroke_color(self, vmobject: VMobject | OpenGLVMobject) -> ManimColor:\n        if self.stroke_color:\n            return self.stroke_color\n        elif vmobject.get_stroke_width() > 0:\n            return vmobject.get_stroke_color()\n        return vmobject.get_color()\n\n    def get_all_mobjects(self) -> Sequence[Mobject]:\n        return [*super().get_all_mobjects(), self.outline]\n\n    def interpolate_submobject(\n        self,\n        submobject: Mobject,\n        starting_submobject: Mobject,\n        outline,\n        alpha: float,\n    ) -> None:  # Fixme: not matching the parent class? What is outline doing here?\n        index: int\n        subalpha: float\n        index, subalpha = integer_interpolate(0, 2, alpha)\n        if index == 0:\n            submobject.pointwise_become_partial(outline, 0, subalpha)\n            submobject.match_style(outline)\n        else:\n            submobject.interpolate(outline, starting_submobject, subalpha)"}, {"name": "DummySceneFileWriter", "code": "class DummySceneFileWriter(SceneFileWriter):\n    \"\"\"Delegate of SceneFileWriter used to test the frames.\"\"\"\n\n    def __init__(\n        self,\n        renderer: CairoRenderer | OpenGLRenderer,\n        scene_name: StrPath,\n        **kwargs: Any,\n    ) -> None:\n        super().__init__(renderer, scene_name, **kwargs)\n        self.i = 0\n\n    def init_output_directories(self, scene_name: StrPath) -> None:\n        pass\n\n    def add_partial_movie_file(self, hash_animation: str) -> None:\n        pass\n\n    def begin_animation(\n        self, allow_write: bool = True, file_path: StrPath | None = None\n    ) -> Any:\n        pass\n\n    def end_animation(self, allow_write: bool = False) -> None:\n        pass\n\n    def combine_to_movie(self) -> None:\n        pass\n\n    def combine_to_section_videos(self) -> None:\n        pass\n\n    def clean_cache(self) -> None:\n        pass\n\n    def write_frame(\n        self, frame_or_renderer: PixelArray | OpenGLRenderer, num_frames: int = 1\n    ) -> None:\n        self.i += 1"}, {"name": "earclip_triangulation", "code": "def earclip_triangulation(verts: np.ndarray, ring_ends: list) -> list:\n    \"\"\"Returns a list of indices giving a triangulation\n    of a polygon, potentially with holes.\n\n    Parameters\n    ----------\n    verts\n        verts is a numpy array of points.\n    ring_ends\n        ring_ends is a list of indices indicating where\n        the ends of new paths are.\n\n    Returns\n    -------\n    list\n        A list of indices giving a triangulation of a polygon.\n    \"\"\"\n    # First, connect all the rings so that the polygon\n    # with holes is instead treated as a (very convex)\n    # polygon with one edge.  Do this by drawing connections\n    # between rings close to each other\n    rings = [list(range(e0, e1)) for e0, e1 in zip([0, *ring_ends], ring_ends)]\n    attached_rings = rings[:1]\n    detached_rings = rings[1:]\n    loop_connections = {}\n\n    while detached_rings:\n        i_range, j_range = (\n            list(\n                filter(\n                    # Ignore indices that are already being\n                    # used to draw some connection\n                    lambda i: i not in loop_connections,\n                    it.chain(*ring_group),\n                ),\n            )\n            for ring_group in (attached_rings, detached_rings)\n        )\n\n        # Closest point on the attached rings to an estimated midpoint\n        # of the detached rings\n        tmp_j_vert = midpoint(verts[j_range[0]], verts[j_range[len(j_range) // 2]])\n        i = min(i_range, key=lambda i: norm_squared(verts[i] - tmp_j_vert))\n        # Closest point of the detached rings to the aforementioned\n        # point of the attached rings\n        j = min(j_range, key=lambda j: norm_squared(verts[i] - verts[j]))\n        # Recalculate i based on new j\n        i = min(i_range, key=lambda i: norm_squared(verts[i] - verts[j]))\n\n        # Remember to connect the polygon at these points\n        loop_connections[i] = j\n        loop_connections[j] = i\n\n        # Move the ring which j belongs to from the\n        # attached list to the detached list\n        new_ring = next(\n            (ring for ring in detached_rings if ring[0] <= j < ring[-1]), None\n        )\n        if new_ring is not None:\n            detached_rings.remove(new_ring)\n            attached_rings.append(new_ring)\n        else:\n            raise Exception(\"Could not find a ring to attach\")\n\n    # Setup linked list\n    after: list[int] = []\n    end0 = 0\n    for end1 in ring_ends:\n        after.extend(range(end0 + 1, end1))\n        after.append(end0)\n        end0 = end1\n\n    # Find an ordering of indices walking around the polygon\n    indices = []\n    i = 0\n    for _ in range(len(verts) + len(ring_ends) - 1):\n        # starting = False\n        if i in loop_connections:\n            j = loop_connections[i]\n            indices.extend([i, j])\n            i = after[j]\n        else:\n            indices.append(i)\n            i = after[i]\n        if i == 0:\n            break\n\n    meta_indices = earcut(verts[indices, :2], [len(indices)])\n    return [indices[mi] for mi in meta_indices]"}, {"name": "ease_in_back", "code": "def ease_in_back(t: float) -> float:\n    c1 = 1.70158\n    c3 = c1 + 1\n    return c3 * t * t * t - c1 * t * t"}, {"name": "ease_in_bounce", "code": "def ease_in_bounce(t: float) -> float:\n    return 1 - ease_out_bounce(1 - t)"}, {"name": "ease_in_circ", "code": "def ease_in_circ(t: float) -> float:\n    return 1 - sqrt(1 - pow(t, 2))"}, {"name": "ease_in_cubic", "code": "def ease_in_cubic(t: float) -> float:\n    return t * t * t"}, {"name": "ease_in_elastic", "code": "def ease_in_elastic(t: float) -> float:\n    c4 = (2 * np.pi) / 3\n    if t == 0:\n        return 0\n    elif t == 1:\n        return 1\n    else:\n        val: float = -pow(2, 10 * t - 10) * np.sin((t * 10 - 10.75) * c4)\n        return val"}, {"name": "ease_in_expo", "code": "def ease_in_expo(t: float) -> float:\n    return 0 if t == 0 else pow(2, 10 * t - 10)"}, {"name": "ease_in_out_back", "code": "def ease_in_out_back(t: float) -> float:\n    c1 = 1.70158\n    c2 = c1 * 1.525\n    return (\n        (pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2)) / 2\n        if t < 0.5\n        else (pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2\n    )"}, {"name": "ease_in_out_bounce", "code": "def ease_in_out_bounce(t: float) -> float:\n    if t < 0.5:\n        return (1 - ease_out_bounce(1 - 2 * t)) / 2\n    else:\n        return (1 + ease_out_bounce(2 * t - 1)) / 2"}, {"name": "ease_in_out_circ", "code": "def ease_in_out_circ(t: float) -> float:\n    return (\n        (1 - sqrt(1 - pow(2 * t, 2))) / 2\n        if t < 0.5\n        else (sqrt(1 - pow(-2 * t + 2, 2)) + 1) / 2\n    )"}, {"name": "ease_in_out_cubic", "code": "def ease_in_out_cubic(t: float) -> float:\n    return 4 * t * t * t if t < 0.5 else 1 - pow(-2 * t + 2, 3) / 2"}, {"name": "ease_in_out_elastic", "code": "def ease_in_out_elastic(t: float) -> float:\n    c5 = (2 * np.pi) / 4.5\n    if t == 0:\n        return 0\n    elif t == 1:\n        return 1\n    elif t < 0.5:\n        val: float = -(pow(2, 20 * t - 10) * np.sin((20 * t - 11.125) * c5)) / 2\n        return val\n    else:\n        val = (pow(2, -20 * t + 10) * np.sin((20 * t - 11.125) * c5)) / 2 + 1\n        return val"}, {"name": "ease_in_out_expo", "code": "def ease_in_out_expo(t: float) -> float:\n    if t == 0:\n        return 0\n    elif t == 1:\n        return 1\n    elif t < 0.5:\n        return pow(2, 20 * t - 10) / 2\n    else:\n        return (2 - pow(2, -20 * t + 10)) / 2"}, {"name": "ease_in_out_quad", "code": "def ease_in_out_quad(t: float) -> float:\n    return 2 * t * t if t < 0.5 else 1 - pow(-2 * t + 2, 2) / 2"}, {"name": "ease_in_out_quart", "code": "def ease_in_out_quart(t: float) -> float:\n    return 8 * t * t * t * t if t < 0.5 else 1 - pow(-2 * t + 2, 4) / 2"}, {"name": "ease_in_out_quint", "code": "def ease_in_out_quint(t: float) -> float:\n    return 16 * t * t * t * t * t if t < 0.5 else 1 - pow(-2 * t + 2, 5) / 2"}, {"name": "ease_in_out_sine", "code": "def ease_in_out_sine(t: float) -> float:\n    val: float = -(np.cos(np.pi * t) - 1) / 2\n    return val"}, {"name": "ease_in_quad", "code": "def ease_in_quad(t: float) -> float:\n    return t * t"}, {"name": "ease_in_quart", "code": "def ease_in_quart(t: float) -> float:\n    return t * t * t * t"}, {"name": "ease_in_quint", "code": "def ease_in_quint(t: float) -> float:\n    return t * t * t * t * t"}, {"name": "ease_in_sine", "code": "def ease_in_sine(t: float) -> float:\n    val: float = 1 - np.cos((t * np.pi) / 2)\n    return val"}, {"name": "ease_out_back", "code": "def ease_out_back(t: float) -> float:\n    c1 = 1.70158\n    c3 = c1 + 1\n    return 1 + c3 * pow(t - 1, 3) + c1 * pow(t - 1, 2)"}, {"name": "ease_out_bounce", "code": "def ease_out_bounce(t: float) -> float:\n    n1 = 7.5625\n    d1 = 2.75\n\n    if t < 1 / d1:\n        return n1 * t * t\n    elif t < 2 / d1:\n        return n1 * (t - 1.5 / d1) * (t - 1.5 / d1) + 0.75\n    elif t < 2.5 / d1:\n        return n1 * (t - 2.25 / d1) * (t - 2.25 / d1) + 0.9375\n    else:\n        return n1 * (t - 2.625 / d1) * (t - 2.625 / d1) + 0.984375"}, {"name": "ease_out_circ", "code": "def ease_out_circ(t: float) -> float:\n    return sqrt(1 - pow(t - 1, 2))"}, {"name": "ease_out_cubic", "code": "def ease_out_cubic(t: float) -> float:\n    return 1 - pow(1 - t, 3)"}, {"name": "ease_out_elastic", "code": "def ease_out_elastic(t: float) -> float:\n    c4 = (2 * np.pi) / 3\n    if t == 0:\n        return 0\n    elif t == 1:\n        return 1\n    else:\n        val: float = pow(2, -10 * t) * np.sin((t * 10 - 0.75) * c4) + 1\n        return val"}, {"name": "ease_out_expo", "code": "def ease_out_expo(t: float) -> float:\n    return 1 if t == 1 else 1 - pow(2, -10 * t)"}, {"name": "ease_out_quad", "code": "def ease_out_quad(t: float) -> float:\n    return 1 - (1 - t) * (1 - t)"}, {"name": "ease_out_quart", "code": "def ease_out_quart(t: float) -> float:\n    return 1 - pow(1 - t, 4)"}, {"name": "ease_out_quint", "code": "def ease_out_quint(t: float) -> float:\n    return 1 - pow(1 - t, 5)"}, {"name": "ease_out_sine", "code": "def ease_out_sine(t: float) -> float:\n    val: float = np.sin((t * np.pi) / 2)\n    return val"}, {"name": "Elbow", "code": "class Elbow(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"Two lines that create a right angle about each other: L-shape.\n\n    Parameters\n    ----------\n    width\n        The length of the elbow's sides.\n    angle\n        The rotation of the elbow.\n    kwargs\n        Additional arguments to be passed to :class:`~.VMobject`\n\n    .. seealso::\n        :class:`RightAngle`\n\n    Examples\n    --------\n    .. manim:: ElbowExample\n        :save_last_frame:\n\n        class ElbowExample(Scene):\n            def construct(self):\n                elbow_1 = Elbow()\n                elbow_2 = Elbow(width=2.0)\n                elbow_3 = Elbow(width=2.0, angle=5*PI/4)\n\n                elbow_group = Group(elbow_1, elbow_2, elbow_3).arrange(buff=1)\n                self.add(elbow_group)\n    \"\"\"\n\n    def __init__(self, width: float = 0.2, angle: float = 0, **kwargs: Any) -> None:\n        self.angle = angle\n        super().__init__(**kwargs)\n        self.set_points_as_corners(np.array([UP, UP + RIGHT, RIGHT]))\n        self.scale_to_fit_width(width, about_point=ORIGIN)\n        self.rotate(self.angle, about_point=ORIGIN)"}, {"name": "Ellipse", "code": "class Ellipse(Circle):\n    \"\"\"A circular shape; oval, circle.\n\n    Parameters\n    ----------\n    width\n       The horizontal width of the ellipse.\n    height\n       The vertical height of the ellipse.\n    kwargs\n       Additional arguments to be passed to :class:`Circle`.\n\n    Examples\n    --------\n    .. manim:: EllipseExample\n        :save_last_frame:\n\n        class EllipseExample(Scene):\n            def construct(self):\n                ellipse_1 = Ellipse(width=2.0, height=4.0, color=BLUE_B)\n                ellipse_2 = Ellipse(width=4.0, height=1.0, color=BLUE_D)\n                ellipse_group = Group(ellipse_1,ellipse_2).arrange(buff=1)\n                self.add(ellipse_group)\n    \"\"\"\n\n    def __init__(self, width: float = 2, height: float = 1, **kwargs: Any) -> None:\n        super().__init__(**kwargs)\n        self.stretch_to_fit_width(width)\n        self.stretch_to_fit_height(height)"}, {"name": "EndSceneEarlyException", "code": "class EndSceneEarlyException(Exception):\n    pass"}, {"name": "ensure_executable", "code": "def ensure_executable(path_to_exe: Path) -> bool:\n    if path_to_exe.parent == Path(\".\"):\n        executable: StrPath | None = shutil.which(path_to_exe.stem)\n        if executable is None:\n            return False\n    else:\n        executable = path_to_exe\n    return os.access(executable, os.X_OK)"}, {"name": "Exclusion", "code": "class Exclusion(_BooleanOps):\n    \"\"\"Find the XOR between two :class:`~.VMobject`.\n    This creates a new :class:`~.VMobject` consisting of the region\n    covered by exactly one of them.\n\n    Parameters\n    ----------\n    subject\n        The 1st :class:`~.VMobject`.\n    clip\n        The 2nd :class:`~.VMobject`\n\n    Example\n    -------\n    .. manim:: IntersectionExample\n        :save_last_frame:\n\n        class IntersectionExample(Scene):\n            def construct(self):\n                sq = Square(color=RED, fill_opacity=1)\n                sq.move_to([-2, 0, 0])\n                cr = Circle(color=BLUE, fill_opacity=1)\n                cr.move_to([-1.3, 0.7, 0])\n                un = Exclusion(sq, cr, color=GREEN, fill_opacity=1)\n                un.move_to([1.5, 0.4, 0])\n                self.add(sq, cr, un)\n\n    \"\"\"\n\n    def __init__(self, subject: VMobject, clip: VMobject, **kwargs: Any) -> None:\n        super().__init__(**kwargs)\n        outpen = SkiaPath()\n        xor(\n            [self._convert_vmobject_to_skia_path(subject)],\n            [self._convert_vmobject_to_skia_path(clip)],\n            outpen.getPen(),\n        )\n        self._convert_skia_path_to_vmobject(outpen)"}, {"name": "exponential_decay", "code": "def exponential_decay(t: float, half_life: float = 0.1) -> float:\n    # The half-life should be rather small to minimize\n    # the cut-off error at the end\n    val: float = 1 - np.exp(-t / half_life)\n    return val"}, {"name": "export", "code": "def export(ctx: cloup.Context, directory: str) -> None:\n    directory_path = Path(directory)\n    if directory_path.absolute == Path.cwd().absolute:\n        console.print(\n            \"\"\"You are reading the config from the same directory you are exporting to.\nThis means that the exported config will overwrite the config for this directory.\nAre you sure you want to continue? (y/n)\"\"\",\n            style=\"red bold\",\n            end=\"\",\n        )\n        proceed = input().lower() == \"y\"\n    else:\n        proceed = True\n    if proceed:\n        if not directory_path.is_dir():\n            console.print(f\"Creating folder: {directory}.\", style=\"red bold\")\n            directory_path.mkdir(parents=True)\n\n        ctx.invoke(write)\n        from_path = Path.cwd() / \"manim.cfg\"\n        to_path = directory_path / \"manim.cfg\"\n\n        console.print(f\"Exported final Config at {from_path} to {to_path}.\")\n    else:\n        console.print(\"Aborted...\", style=\"red bold\")"}, {"name": "extract_mobject_family_members", "code": "def extract_mobject_family_members(\n    mobject_list: list[Mobject], only_those_with_points: bool = False\n) -> list[Mobject]:\n    result = list(it.chain(*(mob.get_family() for mob in mobject_list)))\n    if only_those_with_points:\n        result = [mob for mob in result if mob.has_points()]\n    return result"}, {"name": "f_always", "code": "def f_always(method: Callable[[Mobject], None], *arg_generators, **kwargs) -> Mobject:\n    \"\"\"\n    More functional version of always, where instead\n    of taking in args, it takes in functions which output\n    the relevant arguments.\n    \"\"\"\n    assert_is_mobject_method(method)\n    mobject = method.__self__\n    func = method.__func__\n\n    def updater(mob):\n        args = [arg_generator() for arg_generator in arg_generators]\n        func(mob, *args, **kwargs)\n\n    mobject.add_updater(updater)\n    return mobject"}, {"name": "Facet", "code": "class Facet:\n    def __init__(self, coordinates: PointND_Array, internal: PointND) -> None:\n        self.coordinates = coordinates\n        self.center: PointND = np.mean(coordinates, axis=0)\n        self.normal = self.compute_normal(internal)\n        self.subfacets = frozenset(\n            SubFacet(np.delete(self.coordinates, i, axis=0))\n            for i in range(self.coordinates.shape[0])\n        )\n\n    def compute_normal(self, internal: PointND) -> PointND:\n        centered = self.coordinates - self.center\n        _, _, vh = np.linalg.svd(centered)\n        normal: PointND = vh[-1, :]\n        normal /= np.linalg.norm(normal)\n\n        # If the normal points towards the internal point, flip it!\n        if np.dot(normal, self.center - internal) < 0:\n            normal *= -1\n\n        return normal\n\n    def __hash__(self) -> int:\n        return hash(self.subfacets)\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Facet):\n            raise ValueError\n        return self.subfacets == other.subfacets"}, {"name": "FadeIn", "code": "class FadeIn(_Fade):\n    r\"\"\"Fade in :class:`~.Mobject` s.\n\n    Parameters\n    ----------\n    mobjects\n        The mobjects to be faded in.\n    shift\n        The vector by which the mobject shifts while being faded in.\n    target_position\n        The position from which the mobject starts while being faded in. In case\n        another mobject is given as target position, its center is used.\n    scale\n        The factor by which the mobject is scaled initially before being rescaling to\n        its original size while being faded in.\n\n    Examples\n    --------\n\n    .. manim :: FadeInExample\n\n        class FadeInExample(Scene):\n            def construct(self):\n                dot = Dot(UP * 2 + LEFT)\n                self.add(dot)\n                tex = Tex(\n                    \"FadeIn with \", \"shift \", r\" or target\\_position\", \" and scale\"\n                ).scale(1)\n                animations = [\n                    FadeIn(tex[0]),\n                    FadeIn(tex[1], shift=DOWN),\n                    FadeIn(tex[2], target_position=dot),\n                    FadeIn(tex[3], scale=1.5),\n                ]\n                self.play(AnimationGroup(*animations, lag_ratio=0.5))\n\n    \"\"\"\n\n    def __init__(self, *mobjects: Mobject, **kwargs) -> None:\n        super().__init__(*mobjects, introducer=True, **kwargs)\n\n    def create_target(self):\n        return self.mobject\n\n    def create_starting_mobject(self):\n        return self._create_faded_mobject(fadeIn=True)"}, {"name": "FadeOut", "code": "class FadeOut(_Fade):\n    r\"\"\"Fade out :class:`~.Mobject` s.\n\n    Parameters\n    ----------\n    mobjects\n        The mobjects to be faded out.\n    shift\n        The vector by which the mobject shifts while being faded out.\n    target_position\n        The position to which the mobject moves while being faded out. In case another\n        mobject is given as target position, its center is used.\n    scale\n        The factor by which the mobject is scaled while being faded out.\n\n    Examples\n    --------\n\n    .. manim :: FadeInExample\n\n        class FadeInExample(Scene):\n            def construct(self):\n                dot = Dot(UP * 2 + LEFT)\n                self.add(dot)\n                tex = Tex(\n                    \"FadeOut with \", \"shift \", r\" or target\\_position\", \" and scale\"\n                ).scale(1)\n                animations = [\n                    FadeOut(tex[0]),\n                    FadeOut(tex[1], shift=DOWN),\n                    FadeOut(tex[2], target_position=dot),\n                    FadeOut(tex[3], scale=0.5),\n                ]\n                self.play(AnimationGroup(*animations, lag_ratio=0.5))\n\n\n    \"\"\"\n\n    def __init__(self, *mobjects: Mobject, **kwargs) -> None:\n        super().__init__(*mobjects, remover=True, **kwargs)\n\n    def create_target(self):\n        return self._create_faded_mobject(fadeIn=False)\n\n    def clean_up_from_scene(self, scene: Scene = None) -> None:\n        super().clean_up_from_scene(scene)\n        self.interpolate(0)"}, {"name": "FadeToColor", "code": "class FadeToColor(ApplyMethod):\n    \"\"\"Animation that changes color of a mobject.\n\n    Examples\n    --------\n\n    .. manim:: FadeToColorExample\n\n        class FadeToColorExample(Scene):\n            def construct(self):\n                self.play(FadeToColor(Text(\"Hello World!\"), color=RED))\n\n    \"\"\"\n\n    def __init__(self, mobject: Mobject, color: str, **kwargs) -> None:\n        super().__init__(mobject.set_color, color, **kwargs)"}, {"name": "FadeTransform", "code": "class FadeTransform(Transform):\n    \"\"\"Fades one mobject into another.\n\n    Parameters\n    ----------\n    mobject\n        The starting :class:`~.Mobject`.\n    target_mobject\n        The target :class:`~.Mobject`.\n    stretch\n        Controls whether the target :class:`~.Mobject` is stretched during\n        the animation. Default: ``True``.\n    dim_to_match\n        If the target mobject is not stretched automatically, this allows\n        to adjust the initial scale of the target :class:`~.Mobject` while\n        it is shifted in. Setting this to 0, 1, and 2, respectively,\n        matches the length of the target with the length of the starting\n        :class:`~.Mobject` in x, y, and z direction, respectively.\n    kwargs\n        Further keyword arguments are passed to the parent class.\n\n    Examples\n    --------\n\n    .. manim:: DifferentFadeTransforms\n\n        class DifferentFadeTransforms(Scene):\n            def construct(self):\n                starts = [Rectangle(width=4, height=1) for _ in range(3)]\n                VGroup(*starts).arrange(DOWN, buff=1).shift(3*LEFT)\n                targets = [Circle(fill_opacity=1).scale(0.25) for _ in range(3)]\n                VGroup(*targets).arrange(DOWN, buff=1).shift(3*RIGHT)\n\n                self.play(*[FadeIn(s) for s in starts])\n                self.play(\n                    FadeTransform(starts[0], targets[0], stretch=True),\n                    FadeTransform(starts[1], targets[1], stretch=False, dim_to_match=0),\n                    FadeTransform(starts[2], targets[2], stretch=False, dim_to_match=1)\n                )\n\n                self.play(*[FadeOut(mobj) for mobj in self.mobjects])\n\n    \"\"\"\n\n    def __init__(self, mobject, target_mobject, stretch=True, dim_to_match=1, **kwargs):\n        self.to_add_on_completion = target_mobject\n        self.stretch = stretch\n        self.dim_to_match = dim_to_match\n        mobject.save_state()\n        if config.renderer == RendererType.OPENGL:\n            group = OpenGLGroup(mobject, target_mobject.copy())\n        else:\n            group = Group(mobject, target_mobject.copy())\n        super().__init__(group, **kwargs)\n\n    def begin(self):\n        \"\"\"Initial setup for the animation.\n\n        The mobject to which this animation is bound is a group consisting of\n        both the starting and the ending mobject. At the start, the ending\n        mobject replaces the starting mobject (and is completely faded). In the\n        end, it is set to be the other way around.\n        \"\"\"\n        self.ending_mobject = self.mobject.copy()\n        Animation.begin(self)\n        # Both 'start' and 'end' consists of the source and target mobjects.\n        # At the start, the target should be faded replacing the source,\n        # and at the end it should be the other way around.\n        start, end = self.starting_mobject, self.ending_mobject\n        for m0, m1 in ((start[1], start[0]), (end[0], end[1])):\n            self.ghost_to(m0, m1)\n\n    def ghost_to(self, source, target):\n        \"\"\"Replaces the source by the target and sets the opacity to 0.\n\n        If the provided target has no points, and thus a location of [0, 0, 0]\n        the source will simply fade out where it currently is.\n        \"\"\"\n        # mobject.replace() does not work if the target has no points.\n        if target.get_num_points() or target.submobjects:\n            source.replace(target, stretch=self.stretch, dim_to_match=self.dim_to_match)\n        source.set_opacity(0)\n\n    def get_all_mobjects(self) -> Sequence[Mobject]:\n        return [\n            self.mobject,\n            self.starting_mobject,\n            self.ending_mobject,\n        ]\n\n    def get_all_families_zipped(self):\n        return Animation.get_all_families_zipped(self)\n\n    def clean_up_from_scene(self, scene):\n        Animation.clean_up_from_scene(self, scene)\n        scene.remove(self.mobject)\n        self.mobject[0].restore()\n        scene.add(self.to_add_on_completion)"}, {"name": "FadeTransformPieces", "code": "class FadeTransformPieces(FadeTransform):\n    \"\"\"Fades submobjects of one mobject into submobjects of another one.\n\n    See also\n    --------\n    :class:`~.FadeTransform`\n\n    Examples\n    --------\n    .. manim:: FadeTransformSubmobjects\n\n        class FadeTransformSubmobjects(Scene):\n            def construct(self):\n                src = VGroup(Square(), Circle().shift(LEFT + UP))\n                src.shift(3*LEFT + 2*UP)\n                src_copy = src.copy().shift(4*DOWN)\n\n                target = VGroup(Circle(), Triangle().shift(RIGHT + DOWN))\n                target.shift(3*RIGHT + 2*UP)\n                target_copy = target.copy().shift(4*DOWN)\n\n                self.play(FadeIn(src), FadeIn(src_copy))\n                self.play(\n                    FadeTransform(src, target),\n                    FadeTransformPieces(src_copy, target_copy)\n                )\n                self.play(*[FadeOut(mobj) for mobj in self.mobjects])\n\n    \"\"\"\n\n    def begin(self):\n        self.mobject[0].align_submobjects(self.mobject[1])\n        super().begin()\n\n    def ghost_to(self, source, target):\n        \"\"\"Replaces the source submobjects by the target submobjects and sets\n        the opacity to 0.\n        \"\"\"\n        for sm0, sm1 in zip(source.get_family(), target.get_family()):\n            super().ghost_to(sm0, sm1)"}, {"name": "filter_attributes", "code": "def filter_attributes(unfiltered_attributes, attributes):\n    # Construct attributes for only those needed by the shader.\n    filtered_attributes_dtype = []\n    for i, dtype_name in enumerate(unfiltered_attributes.dtype.names):\n        if dtype_name in attributes:\n            filtered_attributes_dtype.append(\n                (\n                    dtype_name,\n                    unfiltered_attributes.dtype[i].subdtype[0].str,\n                    unfiltered_attributes.dtype[i].shape,\n                ),\n            )\n\n    filtered_attributes = np.zeros(\n        unfiltered_attributes[unfiltered_attributes.dtype.names[0]].shape[0],\n        dtype=filtered_attributes_dtype,\n    )\n\n    for dtype_name in unfiltered_attributes.dtype.names:\n        if dtype_name in attributes:\n            filtered_attributes[dtype_name] = unfiltered_attributes[dtype_name]\n\n    return filtered_attributes"}, {"name": "find_file", "code": "def find_file(file_name: Path, directories: list[Path]) -> Path:\n    # Check if what was passed in is already a valid path to a file\n    if file_name.exists():\n        return file_name\n    possible_paths = (directory / file_name for directory in directories)\n    for path in possible_paths:\n        if path.exists():\n            return path\n        else:\n            logger.debug(f\"{path} does not exist.\")\n    raise OSError(f\"{file_name} not Found\")"}, {"name": "find_intersection", "code": "def find_intersection(\n    p0s: Point3DLike_Array,\n    v0s: Vector3D_Array,\n    p1s: Point3DLike_Array,\n    v1s: Vector3D_Array,\n    threshold: float = 1e-5,\n) -> list[Point3D]:\n    \"\"\"\n    Return the intersection of a line passing through p0 in direction v0\n    with one passing through p1 in direction v1 (or array of intersections\n    from arrays of such points/directions).\n    For 3d values, it returns the point on the ray p0 + v0 * t closest to the\n    ray p1 + v1 * t\n    \"\"\"\n    # algorithm from https://en.wikipedia.org/wiki/Skew_lines#Nearest_points\n    result = []\n\n    for p0, v0, p1, v1 in zip(*[p0s, v0s, p1s, v1s]):\n        normal = cross(v1, cross(v0, v1))\n        denom = max(np.dot(v0, normal), threshold)\n        result += [p0 + np.dot(p1 - p0, normal) / denom * v0]\n    return result"}, {"name": "Flash", "code": "class Flash(AnimationGroup):\n    \"\"\"Send out lines in all directions.\n\n    Parameters\n    ----------\n    point\n        The center of the flash lines. If it is a :class:`.~Mobject` its center will be used.\n    line_length\n        The length of the flash lines.\n    num_lines\n        The number of flash lines.\n    flash_radius\n        The distance from `point` at which the flash lines start.\n    line_stroke_width\n        The stroke width of the flash lines.\n    color\n        The color of the flash lines.\n    time_width\n        The time width used for the flash lines. See :class:`.~ShowPassingFlash` for more details.\n    run_time\n        The duration of the animation.\n    kwargs\n        Additional arguments to be passed to the :class:`~.Succession` constructor\n\n    Examples\n    --------\n    .. manim:: UsingFlash\n\n        class UsingFlash(Scene):\n            def construct(self):\n                dot = Dot(color=YELLOW).shift(DOWN)\n                self.add(Tex(\"Flash the dot below:\"), dot)\n                self.play(Flash(dot))\n                self.wait()\n\n    .. manim:: FlashOnCircle\n\n        class FlashOnCircle(Scene):\n            def construct(self):\n                radius = 2\n                circle = Circle(radius)\n                self.add(circle)\n                self.play(Flash(\n                    circle, line_length=1,\n                    num_lines=30, color=RED,\n                    flash_radius=radius+SMALL_BUFF,\n                    time_width=0.3, run_time=2,\n                    rate_func = rush_from\n                ))\n    \"\"\"\n\n    def __init__(\n        self,\n        point: np.ndarray | Mobject,\n        line_length: float = 0.2,\n        num_lines: int = 12,\n        flash_radius: float = 0.1,\n        line_stroke_width: int = 3,\n        color: str = YELLOW,\n        time_width: float = 1,\n        run_time: float = 1.0,\n        **kwargs,\n    ) -> None:\n        if isinstance(point, Mobject):\n            self.point = point.get_center()\n        else:\n            self.point = point\n        self.color = color\n        self.line_length = line_length\n        self.num_lines = num_lines\n        self.flash_radius = flash_radius\n        self.line_stroke_width = line_stroke_width\n        self.run_time = run_time\n        self.time_width = time_width\n        self.animation_config = kwargs\n\n        self.lines = self.create_lines()\n        animations = self.create_line_anims()\n        super().__init__(*animations, group=self.lines)\n\n    def create_lines(self) -> VGroup:\n        lines = VGroup()\n        for angle in np.arange(0, TAU, TAU / self.num_lines):\n            line = Line(self.point, self.point + self.line_length * RIGHT)\n            line.shift((self.flash_radius) * RIGHT)\n            line.rotate(angle, about_point=self.point)\n            lines.add(line)\n        lines.set_color(self.color)\n        lines.set_stroke(width=self.line_stroke_width)\n        return lines\n\n    def create_line_anims(self) -> Iterable[ShowPassingFlash]:\n        return [\n            ShowPassingFlash(\n                line,\n                time_width=self.time_width,\n                run_time=self.run_time,\n                **self.animation_config,\n            )\n            for line in self.lines\n        ]"}, {"name": "flatten_iterable_parameters", "code": "def flatten_iterable_parameters(\n    args: Iterable[T | Iterable[T] | GeneratorType],\n) -> list[T]:\n    \"\"\"Flattens an iterable of parameters into a list of parameters.\n\n    Parameters\n    ----------\n    args\n        The iterable of parameters to flatten.\n        [(generator), [], (), ...]\n\n    Returns\n    -------\n    :class:`list`\n        The flattened list of parameters.\n    \"\"\"\n    flattened_parameters: list[T] = []\n    for arg in args:\n        if isinstance(arg, (Iterable, GeneratorType)):\n            flattened_parameters.extend(arg)\n        else:\n            flattened_parameters.append(arg)\n    return flattened_parameters"}, {"name": "FocusOn", "code": "class FocusOn(Transform):\n    \"\"\"Shrink a spotlight to a position.\n\n    Parameters\n    ----------\n    focus_point\n        The point at which to shrink the spotlight. If it is a :class:`.~Mobject` its center will be used.\n    opacity\n        The opacity of the spotlight.\n    color\n        The color of the spotlight.\n    run_time\n        The duration of the animation.\n\n    Examples\n    --------\n    .. manim:: UsingFocusOn\n\n        class UsingFocusOn(Scene):\n            def construct(self):\n                dot = Dot(color=YELLOW).shift(DOWN)\n                self.add(Tex(\"Focusing on the dot below:\"), dot)\n                self.play(FocusOn(dot))\n                self.wait()\n    \"\"\"\n\n    def __init__(\n        self,\n        focus_point: np.ndarray | Mobject,\n        opacity: float = 0.2,\n        color: str = GREY,\n        run_time: float = 2,\n        **kwargs,\n    ) -> None:\n        self.focus_point = focus_point\n        self.color = color\n        self.opacity = opacity\n        remover = True\n        starting_dot = Dot(\n            radius=config[\"frame_x_radius\"] + config[\"frame_y_radius\"],\n            stroke_width=0,\n            fill_color=self.color,\n            fill_opacity=0,\n        )\n        super().__init__(starting_dot, run_time=run_time, remover=remover, **kwargs)\n\n    def create_target(self) -> Dot:\n        little_dot = Dot(radius=0)\n        little_dot.set_fill(self.color, opacity=self.opacity)\n        little_dot.add_updater(lambda d: d.move_to(self.focus_point))\n        return little_dot"}, {"name": "frames_comparison", "code": "def frames_comparison(\n    func: Callable | None = None,\n    *,\n    last_frame: bool = True,\n    renderer_class: type[CairoRenderer | OpenGLRenderer] = CairoRenderer,\n    base_scene: type[Scene] = Scene,\n    **custom_config: Any,\n) -> Callable:\n    \"\"\"Compares the frames generated by the test with control frames previously registered.\n\n    If there is no control frames for this test, the test will fail. To generate\n    control frames for a given test, pass ``--set_test`` flag to pytest\n    while running the test.\n\n    Note that this decorator can be use with or without parentheses.\n\n    Parameters\n    ----------\n    last_frame\n        whether the test should test the last frame, by default True.\n    renderer_class\n        The base renderer to use (OpenGLRenderer/CairoRenderer), by default CairoRenderer\n    base_scene\n        The base class for the scene (ThreeDScene, etc.), by default Scene\n\n    .. warning::\n        By default, last_frame is True, which means that only the last frame is tested.\n        If the scene has a moving animation, then the test must set last_frame to False.\n    \"\"\"\n\n    def decorator_maker(tested_scene_construct: Callable) -> Callable:\n        if (\n            SCENE_PARAMETER_NAME\n            not in inspect.getfullargspec(tested_scene_construct).args\n        ):\n            raise Exception(\n                f\"Invalid graphical test function test function : must have '{SCENE_PARAMETER_NAME}'as one of the parameters.\",\n            )\n\n        # Exclude \"scene\" from the argument list of the signature.\n        old_sig = inspect.signature(\n            functools.partial(tested_scene_construct, scene=None),\n        )\n\n        if \"__module_test__\" not in tested_scene_construct.__globals__:\n            raise Exception(\n                \"There is no module test name indicated for the graphical unit test. You have to declare __module_test__ in the test file.\",\n            )\n        module_name = tested_scene_construct.__globals__.get(\"__module_test__\")\n        assert isinstance(module_name, str)\n        test_name = tested_scene_construct.__name__[len(\"test_\") :]\n\n        @functools.wraps(tested_scene_construct)\n        # The \"request\" parameter is meant to be used as a fixture by pytest. See below.\n        def wrapper(\n            *args: Any, request: FixtureRequest, tmp_path: StrPath, **kwargs: Any\n        ) -> None:\n            # check for cairo version\n            if (\n                renderer_class is CairoRenderer\n                and cairo.cairo_version() < MIN_CAIRO_VERSION\n            ):\n                pytest.skip(\"Cairo version is too old. Skipping cairo graphical tests.\")\n            # Wraps the test_function to a construct method, to \"freeze\" the eventual additional arguments (parametrizations fixtures).\n            construct = functools.partial(tested_scene_construct, *args, **kwargs)\n\n            # Kwargs contains the eventual parametrization arguments.\n            # This modifies the test_name so that it is defined by the parametrization\n            # arguments too.\n            # Example: if \"length\" is parametrized from 0 to 20, the kwargs\n            # will be once with {\"length\" : 1}, etc.\n            test_name_with_param = test_name + \"_\".join(\n                f\"_{str(tup[0])}[{str(tup[1])}]\" for tup in kwargs.items()\n            )\n\n            config_tests = _config_test(last_frame)\n\n            config_tests[\"text_dir\"] = tmp_path\n            config_tests[\"tex_dir\"] = tmp_path\n\n            if last_frame:\n                config_tests[\"frame_rate\"] = 1\n                config_tests[\"dry_run\"] = True\n\n            setting_test = request.config.getoption(\"--set_test\")\n            try:\n                test_file_path = tested_scene_construct.__globals__[\"__file__\"]\n            except Exception:\n                test_file_path = None\n            real_test = _make_test_comparing_frames(\n                file_path=_control_data_path(\n                    test_file_path,\n                    module_name,\n                    test_name_with_param,\n                    setting_test,\n                ),\n                base_scene=base_scene,\n                construct=construct,\n                renderer_class=renderer_class,\n                is_set_test_data_test=setting_test,\n                last_frame=last_frame,\n                show_diff=request.config.getoption(\"--show_diff\"),\n                size_frame=(config_tests[\"pixel_height\"], config_tests[\"pixel_width\"]),\n            )\n\n            # Isolate the config used for the test, to avoid modifying the global config during the test run.\n            with tempconfig({**config_tests, **custom_config}):\n                real_test()\n\n        parameters = list(old_sig.parameters.values())\n        # Adds \"request\" param into the signature of the wrapper, to use the associated pytest fixture.\n        # This fixture is needed to have access to flags value and pytest's config. See above.\n        if \"request\" not in old_sig.parameters:\n            parameters += [inspect.Parameter(\"request\", inspect.Parameter.KEYWORD_ONLY)]\n        if \"tmp_path\" not in old_sig.parameters:\n            parameters += [\n                inspect.Parameter(\"tmp_path\", inspect.Parameter.KEYWORD_ONLY),\n            ]\n        new_sig = old_sig.replace(parameters=parameters)\n        wrapper.__signature__ = new_sig  # type: ignore[attr-defined]\n\n        # Reach a bit into pytest internals to hoist the marks from our wrapped\n        # function.\n        wrapper.pytestmark = []  # type: ignore[attr-defined]\n        new_marks = getattr(tested_scene_construct, \"pytestmark\", [])\n        wrapper.pytestmark = new_marks  # type: ignore[attr-defined]\n        return wrapper\n\n    # Case where the decorator is called with and without parentheses.\n    # If func is None, callabl(None) returns False\n    if callable(func):\n        return decorator_maker(func)\n    return decorator_maker"}, {"name": "FullScreenQuad", "code": "class FullScreenQuad(Mesh):\n    def __init__(\n        self,\n        context,\n        fragment_shader_source=None,\n        fragment_shader_name=None,\n    ):\n        if fragment_shader_source is None and fragment_shader_name is None:\n            raise Exception(\"Must either pass shader name or shader source.\")\n\n        if fragment_shader_name is not None:\n            # Use the name.\n            shader_file_path = SHADER_FOLDER / f\"{fragment_shader_name}.frag\"\n            fragment_shader_source = get_shader_code_from_file(shader_file_path)\n        elif fragment_shader_source is not None:\n            fragment_shader_source = textwrap.dedent(fragment_shader_source.lstrip())\n\n        shader = Shader(\n            context,\n            source={\n                \"vertex_shader\": \"\"\"\n                #version 330\n                in vec4 in_vert;\n                uniform mat4 u_model_view_matrix;\n                uniform mat4 u_projection_matrix;\n                void main() {{\n                    vec4 camera_space_vertex = u_model_view_matrix * in_vert;\n                    vec4 clip_space_vertex = u_projection_matrix * camera_space_vertex;\n                    gl_Position = clip_space_vertex;\n                }}\n                \"\"\",\n                \"fragment_shader\": fragment_shader_source,\n            },\n        )\n        attributes = np.zeros(6, dtype=[(\"in_vert\", np.float32, (4,))])\n        attributes[\"in_vert\"] = np.array(\n            [\n                [-config[\"frame_x_radius\"], -config[\"frame_y_radius\"], 0, 1],\n                [-config[\"frame_x_radius\"], config[\"frame_y_radius\"], 0, 1],\n                [config[\"frame_x_radius\"], config[\"frame_y_radius\"], 0, 1],\n                [-config[\"frame_x_radius\"], -config[\"frame_y_radius\"], 0, 1],\n                [config[\"frame_x_radius\"], -config[\"frame_y_radius\"], 0, 1],\n                [config[\"frame_x_radius\"], config[\"frame_y_radius\"], 0, 1],\n            ],\n        )\n        shader.set_uniform(\"u_model_view_matrix\", opengl.view_matrix())\n        shader.set_uniform(\n            \"u_projection_matrix\",\n            opengl.orthographic_projection_matrix(),\n        )\n        super().__init__(shader, attributes)\n\n    def render(self):\n        super().render()"}, {"name": "FullScreenRectangle", "code": "class FullScreenRectangle(ScreenRectangle):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.height = config[\"frame_height\"]"}, {"name": "FunctionGraph", "code": "class FunctionGraph(ParametricFunction):\n    \"\"\"A :class:`ParametricFunction` that spans the length of the scene by default.\n\n    Examples\n    --------\n    .. manim:: ExampleFunctionGraph\n        :save_last_frame:\n\n        class ExampleFunctionGraph(Scene):\n            def construct(self):\n                cos_func = FunctionGraph(\n                    lambda t: np.cos(t) + 0.5 * np.cos(7 * t) + (1 / 7) * np.cos(14 * t),\n                    color=RED,\n                )\n\n                sin_func_1 = FunctionGraph(\n                    lambda t: np.sin(t) + 0.5 * np.sin(7 * t) + (1 / 7) * np.sin(14 * t),\n                    color=BLUE,\n                )\n\n                sin_func_2 = FunctionGraph(\n                    lambda t: np.sin(t) + 0.5 * np.sin(7 * t) + (1 / 7) * np.sin(14 * t),\n                    x_range=[-4, 4],\n                    color=GREEN,\n                ).move_to([0, 1, 0])\n\n                self.add(cos_func, sin_func_1, sin_func_2)\n    \"\"\"\n\n    def __init__(self, function, x_range=None, color=YELLOW, **kwargs):\n        if x_range is None:\n            x_range = np.array([-config[\"frame_x_radius\"], config[\"frame_x_radius\"]])\n\n        self.x_range = x_range\n        self.parametric_function = lambda t: np.array([t, function(t), 0])\n        self.function = function\n        super().__init__(self.parametric_function, self.x_range, color=color, **kwargs)\n\n    def get_function(self):\n        return self.function\n\n    def get_point_from_function(self, x):\n        return self.parametric_function(x)"}, {"name": "generate_tex_file", "code": "def generate_tex_file(\n    expression: str,\n    environment: str | None = None,\n    tex_template: TexTemplate | None = None,\n) -> Path:\n    r\"\"\"Takes a tex expression (and an optional tex environment),\n    and returns a fully formed tex file ready for compilation.\n\n    Parameters\n    ----------\n    expression\n        String containing the TeX expression to be rendered, e.g. ``\\\\sqrt{2}`` or ``foo``\n    environment\n        The string containing the environment in which the expression should be typeset, e.g. ``align*``\n    tex_template\n        Template class used to typesetting. If not set, use default template set via `config[\"tex_template\"]`\n\n    Returns\n    -------\n    :class:`Path`\n        Path to generated TeX file\n    \"\"\"\n    if tex_template is None:\n        tex_template = config[\"tex_template\"]\n    if environment is not None:\n        output = tex_template.get_texcode_for_expression_in_env(expression, environment)\n    else:\n        output = tex_template.get_texcode_for_expression(expression)\n\n    tex_dir = config.get_dir(\"tex_dir\")\n    if not tex_dir.exists():\n        tex_dir.mkdir()\n\n    result = tex_dir / (tex_hash(output) + \".tex\")\n    if not result.exists():\n        logger.info(\n            \"Writing %(expression)s to %(path)s\",\n            {\"expression\": expression, \"path\": f\"{result}\"},\n        )\n        result.write_text(output, encoding=\"utf-8\")\n    return result"}, {"name": "GenericGraph", "code": "class GenericGraph(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"Abstract base class for graphs (that is, a collection of vertices\n    connected with edges).\n\n    Graphs can be instantiated by passing both a list of (distinct, hashable)\n    vertex names, together with list of edges (as tuples of vertex names). See\n    the examples for concrete implementations of this class for details.\n\n    .. note::\n\n        This implementation uses updaters to make the edges move with\n        the vertices.\n\n\n    See also\n    --------\n\n    :class:`.Graph`\n    :class:`.DiGraph`\n\n\n    Parameters\n    ----------\n\n    vertices\n        A list of vertices. Must be hashable elements.\n    edges\n        A list of edges, specified as tuples ``(u, v)`` where both ``u``\n        and ``v`` are vertices.\n    labels\n        Controls whether or not vertices are labeled. If ``False`` (the default),\n        the vertices are not labeled; if ``True`` they are labeled using their\n        names (as specified in ``vertices``) via :class:`~.MathTex`. Alternatively,\n        custom labels can be specified by passing a dictionary whose keys are\n        the vertices, and whose values are the corresponding vertex labels\n        (rendered via, e.g., :class:`~.Text` or :class:`~.Tex`).\n    label_fill_color\n        Sets the fill color of the default labels generated when ``labels``\n        is set to ``True``. Has no effect for other values of ``labels``.\n    layout\n        Either one of ``\"spring\"`` (the default), ``\"circular\"``, ``\"kamada_kawai\"``,\n        ``\"planar\"``, ``\"random\"``, ``\"shell\"``, ``\"spectral\"``, ``\"spiral\"``, ``\"tree\"``, and ``\"partite\"``\n        for automatic vertex positioning primarily using ``networkx``\n        (see `their documentation <https://networkx.org/documentation/stable/reference/drawing.html#module-networkx.drawing.layout>`_\n        for more details), a dictionary specifying a coordinate (value)\n        for each vertex (key) for manual positioning, or a .:class:`~.LayoutFunction` with a user-defined automatic layout.\n    layout_config\n        Only for automatic layouts. A dictionary whose entries\n        are passed as keyword arguments to the named layout or automatic layout function\n        specified via ``layout``.\n        The ``tree`` layout also accepts a special parameter ``vertex_spacing``\n        passed as a keyword argument inside the ``layout_config`` dictionary.\n        Passing a tuple ``(space_x, space_y)`` as this argument overrides\n        the value of ``layout_scale`` and ensures that vertices are arranged\n        in a way such that the centers of siblings in the same layer are\n        at least ``space_x`` units apart horizontally, and neighboring layers\n        are spaced ``space_y`` units vertically.\n    layout_scale\n        The scale of automatically generated layouts: the vertices will\n        be arranged such that the coordinates are located within the\n        interval ``[-scale, scale]``. Some layouts accept a tuple ``(scale_x, scale_y)``\n        causing the first coordinate to be in the interval ``[-scale_x, scale_x]``,\n        and the second in ``[-scale_y, scale_y]``. Default: 2.\n    vertex_type\n        The mobject class used for displaying vertices in the scene.\n    vertex_config\n        Either a dictionary containing keyword arguments to be passed to\n        the class specified via ``vertex_type``, or a dictionary whose keys\n        are the vertices, and whose values are dictionaries containing keyword\n        arguments for the mobject related to the corresponding vertex.\n    vertex_mobjects\n        A dictionary whose keys are the vertices, and whose values are\n        mobjects to be used as vertices. Passing vertices here overrides\n        all other configuration options for a vertex.\n    edge_type\n        The mobject class used for displaying edges in the scene.\n        Must be a subclass of :class:`~.Line` for default updaters to work.\n    edge_config\n        Either a dictionary containing keyword arguments to be passed\n        to the class specified via ``edge_type``, or a dictionary whose\n        keys are the edges, and whose values are dictionaries containing\n        keyword arguments for the mobject related to the corresponding edge.\n    \"\"\"\n\n    def __init__(\n        self,\n        vertices: Sequence[Hashable],\n        edges: Sequence[tuple[Hashable, Hashable]],\n        labels: bool | dict = False,\n        label_fill_color: str = BLACK,\n        layout: LayoutName | dict[Hashable, Point3DLike] | LayoutFunction = \"spring\",\n        layout_scale: float | tuple[float, float, float] = 2,\n        layout_config: dict | None = None,\n        vertex_type: type[Mobject] = Dot,\n        vertex_config: dict | None = None,\n        vertex_mobjects: dict | None = None,\n        edge_type: type[Mobject] = Line,\n        partitions: Sequence[Sequence[Hashable]] | None = None,\n        root_vertex: Hashable | None = None,\n        edge_config: dict | None = None,\n    ) -> None:\n        super().__init__()\n\n        nx_graph = self._empty_networkx_graph()\n        nx_graph.add_nodes_from(vertices)\n        nx_graph.add_edges_from(edges)\n        self._graph = nx_graph\n\n        if isinstance(labels, dict):\n            self._labels = labels\n        elif isinstance(labels, bool):\n            if labels:\n                self._labels = {\n                    v: MathTex(v, fill_color=label_fill_color) for v in vertices\n                }\n            else:\n                self._labels = {}\n\n        if self._labels and vertex_type is Dot:\n            vertex_type = LabeledDot\n\n        if vertex_mobjects is None:\n            vertex_mobjects = {}\n\n        # build vertex_config\n        if vertex_config is None:\n            vertex_config = {}\n        default_vertex_config = {}\n        if vertex_config:\n            default_vertex_config = {\n                k: v for k, v in vertex_config.items() if k not in vertices\n            }\n        self._vertex_config = {\n            v: vertex_config.get(v, copy(default_vertex_config)) for v in vertices\n        }\n        self.default_vertex_config = default_vertex_config\n        for v, label in self._labels.items():\n            self._vertex_config[v][\"label\"] = label\n\n        self.vertices = {v: vertex_type(**self._vertex_config[v]) for v in vertices}\n        self.vertices.update(vertex_mobjects)\n\n        self.change_layout(\n            layout=layout,\n            layout_scale=layout_scale,\n            layout_config=layout_config,\n            partitions=partitions,\n            root_vertex=root_vertex,\n        )\n\n        # build edge_config\n        if edge_config is None:\n            edge_config = {}\n        default_tip_config = {}\n        default_edge_config = {}\n        if edge_config:\n            default_tip_config = edge_config.pop(\"tip_config\", {})\n            default_edge_config = {\n                k: v\n                for k, v in edge_config.items()\n                if not isinstance(\n                    k, tuple\n                )  # everything that is not an edge is an option\n            }\n        self._edge_config = {}\n        self._tip_config = {}\n        for e in edges:\n            if e in edge_config:\n                self._tip_config[e] = edge_config[e].pop(\n                    \"tip_config\", copy(default_tip_config)\n                )\n                self._edge_config[e] = edge_config[e]\n            else:\n                self._tip_config[e] = copy(default_tip_config)\n                self._edge_config[e] = copy(default_edge_config)\n\n        self.default_edge_config = default_edge_config\n        self._populate_edge_dict(edges, edge_type)\n\n        self.add(*self.vertices.values())\n        self.add(*self.edges.values())\n\n        self.add_updater(self.update_edges)\n\n    @staticmethod\n    def _empty_networkx_graph() -> nx.classes.graph.Graph:\n        \"\"\"Return an empty networkx graph for the given graph type.\"\"\"\n        raise NotImplementedError(\"To be implemented in concrete subclasses\")\n\n    def _populate_edge_dict(\n        self, edges: list[tuple[Hashable, Hashable]], edge_type: type[Mobject]\n    ):\n        \"\"\"Helper method for populating the edges of the graph.\"\"\"\n        raise NotImplementedError(\"To be implemented in concrete subclasses\")\n\n    def __getitem__(self: Graph, v: Hashable) -> Mobject:\n        return self.vertices[v]\n\n    def _create_vertex(\n        self,\n        vertex: Hashable,\n        position: Point3DLike | None = None,\n        label: bool = False,\n        label_fill_color: str = BLACK,\n        vertex_type: type[Mobject] = Dot,\n        vertex_config: dict | None = None,\n        vertex_mobject: dict | None = None,\n    ) -> tuple[Hashable, Point3D, dict, Mobject]:\n        np_position: Point3D = (\n            self.get_center() if position is None else np.asarray(position)\n        )\n\n        if vertex_config is None:\n            vertex_config = {}\n\n        if vertex in self.vertices:\n            raise ValueError(\n                f\"Vertex identifier '{vertex}' is already used for a vertex in this graph.\",\n            )\n\n        if label is True:\n            label = MathTex(vertex, fill_color=label_fill_color)\n        elif vertex in self._labels:\n            label = self._labels[vertex]\n        elif not isinstance(label, (Mobject, OpenGLMobject)):\n            label = None\n\n        base_vertex_config = copy(self.default_vertex_config)\n        base_vertex_config.update(vertex_config)\n        vertex_config = base_vertex_config\n\n        if label is not None:\n            vertex_config[\"label\"] = label\n            if vertex_type is Dot:\n                vertex_type = LabeledDot\n\n        if vertex_mobject is None:\n            vertex_mobject = vertex_type(**vertex_config)\n\n        vertex_mobject.move_to(np_position)\n\n        return (vertex, np_position, vertex_config, vertex_mobject)\n\n    def _add_created_vertex(\n        self,\n        vertex: Hashable,\n        position: Point3DLike,\n        vertex_config: dict,\n        vertex_mobject: Mobject,\n    ) -> Mobject:\n        if vertex in self.vertices:\n            raise ValueError(\n                f\"Vertex identifier '{vertex}' is already used for a vertex in this graph.\",\n            )\n\n        self._graph.add_node(vertex)\n        self._layout[vertex] = position\n\n        if \"label\" in vertex_config:\n            self._labels[vertex] = vertex_config[\"label\"]\n\n        self._vertex_config[vertex] = vertex_config\n\n        self.vertices[vertex] = vertex_mobject\n        self.vertices[vertex].move_to(position)\n        self.add(self.vertices[vertex])\n\n        return self.vertices[vertex]\n\n    def _add_vertex(\n        self,\n        vertex: Hashable,\n        position: Point3DLike | None = None,\n        label: bool = False,\n        label_fill_color: str = BLACK,\n        vertex_type: type[Mobject] = Dot,\n        vertex_config: dict | None = None,\n        vertex_mobject: dict | None = None,\n    ) -> Mobject:\n        \"\"\"Add a vertex to the graph.\n\n        Parameters\n        ----------\n\n        vertex\n            A hashable vertex identifier.\n        position\n            The coordinates where the new vertex should be added. If ``None``, the center\n            of the graph is used.\n        label\n            Controls whether or not the vertex is labeled. If ``False`` (the default),\n            the vertex is not labeled; if ``True`` it is labeled using its\n            names (as specified in ``vertex``) via :class:`~.MathTex`. Alternatively,\n            any :class:`~.Mobject` can be passed to be used as the label.\n        label_fill_color\n            Sets the fill color of the default labels generated when ``labels``\n            is set to ``True``. Has no effect for other values of ``label``.\n        vertex_type\n            The mobject class used for displaying vertices in the scene.\n        vertex_config\n            A dictionary containing keyword arguments to be passed to\n            the class specified via ``vertex_type``.\n        vertex_mobject\n            The mobject to be used as the vertex. Overrides all other\n            vertex customization options.\n        \"\"\"\n        return self._add_created_vertex(\n            *self._create_vertex(\n                vertex=vertex,\n                position=position,\n                label=label,\n                label_fill_color=label_fill_color,\n                vertex_type=vertex_type,\n                vertex_config=vertex_config,\n                vertex_mobject=vertex_mobject,\n            )\n        )\n\n    def _create_vertices(\n        self: Graph,\n        *vertices: Hashable,\n        positions: dict | None = None,\n        labels: bool = False,\n        label_fill_color: str = BLACK,\n        vertex_type: type[Mobject] = Dot,\n        vertex_config: dict | None = None,\n        vertex_mobjects: dict | None = None,\n    ) -> Iterable[tuple[Hashable, Point3D, dict, Mobject]]:\n        if positions is None:\n            positions = {}\n        if vertex_mobjects is None:\n            vertex_mobjects = {}\n\n        graph_center = self.get_center()\n        base_positions = dict.fromkeys(vertices, graph_center)\n        base_positions.update(positions)\n        positions = base_positions\n\n        if isinstance(labels, bool):\n            labels = dict.fromkeys(vertices, labels)\n        else:\n            assert isinstance(labels, dict)\n            base_labels = dict.fromkeys(vertices, False)\n            base_labels.update(labels)\n            labels = base_labels\n\n        if vertex_config is None:\n            vertex_config = copy(self.default_vertex_config)\n\n        assert isinstance(vertex_config, dict)\n        base_vertex_config = copy(self.default_vertex_config)\n        base_vertex_config.update(\n            {key: val for key, val in vertex_config.items() if key not in vertices},\n        )\n        vertex_config = {\n            v: (vertex_config[v] if v in vertex_config else copy(base_vertex_config))\n            for v in vertices\n        }\n\n        return [\n            self._create_vertex(\n                v,\n                position=positions[v],\n                label=labels[v],\n                label_fill_color=label_fill_color,\n                vertex_type=vertex_type,\n                vertex_config=vertex_config[v],\n                vertex_mobject=vertex_mobjects.get(v),\n            )\n            for v in vertices\n        ]\n\n    def add_vertices(\n        self: Graph,\n        *vertices: Hashable,\n        positions: dict | None = None,\n        labels: bool = False,\n        label_fill_color: str = BLACK,\n        vertex_type: type[Mobject] = Dot,\n        vertex_config: dict | None = None,\n        vertex_mobjects: dict | None = None,\n    ):\n        \"\"\"Add a list of vertices to the graph.\n\n        Parameters\n        ----------\n\n        vertices\n            Hashable vertex identifiers.\n        positions\n            A dictionary specifying the coordinates where the new vertices should be added.\n            If ``None``, all vertices are created at the center of the graph.\n        labels\n            Controls whether or not the vertex is labeled. If ``False`` (the default),\n            the vertex is not labeled; if ``True`` it is labeled using its\n            names (as specified in ``vertex``) via :class:`~.MathTex`. Alternatively,\n            any :class:`~.Mobject` can be passed to be used as the label.\n        label_fill_color\n            Sets the fill color of the default labels generated when ``labels``\n            is set to ``True``. Has no effect for other values of ``labels``.\n        vertex_type\n            The mobject class used for displaying vertices in the scene.\n        vertex_config\n            A dictionary containing keyword arguments to be passed to\n            the class specified via ``vertex_type``.\n        vertex_mobjects\n            A dictionary whose keys are the vertex identifiers, and whose\n            values are mobjects that should be used as vertices. Overrides\n            all other vertex customization options.\n        \"\"\"\n        return [\n            self._add_created_vertex(*v)\n            for v in self._create_vertices(\n                *vertices,\n                positions=positions,\n                labels=labels,\n                label_fill_color=label_fill_color,\n                vertex_type=vertex_type,\n                vertex_config=vertex_config,\n                vertex_mobjects=vertex_mobjects,\n            )\n        ]\n\n    @override_animate(add_vertices)\n    def _add_vertices_animation(self, *args, anim_args=None, **kwargs):\n        if anim_args is None:\n            anim_args = {}\n\n        animation = anim_args.pop(\"animation\", Create)\n\n        vertex_mobjects = self._create_vertices(*args, **kwargs)\n\n        def on_finish(scene: Scene):\n            for v in vertex_mobjects:\n                scene.remove(v[-1])\n                self._add_created_vertex(*v)\n\n        return AnimationGroup(\n            *(animation(v[-1], **anim_args) for v in vertex_mobjects),\n            group=self,\n            _on_finish=on_finish,\n        )\n\n    def _remove_vertex(self, vertex):\n        \"\"\"Remove a vertex (as well as all incident edges) from the graph.\n\n        Parameters\n        ----------\n\n        vertex\n            The identifier of a vertex to be removed.\n\n        Returns\n        -------\n\n        Group\n            A mobject containing all removed objects.\n\n        \"\"\"\n        if vertex not in self.vertices:\n            raise ValueError(\n                f\"The graph does not contain a vertex with identifier '{vertex}'\",\n            )\n\n        self._graph.remove_node(vertex)\n        self._layout.pop(vertex)\n        if vertex in self._labels:\n            self._labels.pop(vertex)\n        self._vertex_config.pop(vertex)\n\n        edge_tuples = [e for e in self.edges if vertex in e]\n        for e in edge_tuples:\n            self._edge_config.pop(e)\n        to_remove = [self.edges.pop(e) for e in edge_tuples]\n        to_remove.append(self.vertices.pop(vertex))\n\n        self.remove(*to_remove)\n        return self.get_group_class()(*to_remove)\n\n    def remove_vertices(self, *vertices):\n        \"\"\"Remove several vertices from the graph.\n\n        Parameters\n        ----------\n\n        vertices\n            Vertices to be removed from the graph.\n\n        Examples\n        --------\n        ::\n\n            >>> G = Graph([1, 2, 3], [(1, 2), (2, 3)])\n            >>> removed = G.remove_vertices(2, 3); removed\n            VGroup(Line, Line, Dot, Dot)\n            >>> G\n            Undirected graph on 1 vertices and 0 edges\n\n        \"\"\"\n        mobjects = []\n        for v in vertices:\n            mobjects.extend(self._remove_vertex(v).submobjects)\n        return self.get_group_class()(*mobjects)\n\n    @override_animate(remove_vertices)\n    def _remove_vertices_animation(self, *vertices, anim_args=None):\n        if anim_args is None:\n            anim_args = {}\n\n        animation = anim_args.pop(\"animation\", Uncreate)\n\n        mobjects = self.remove_vertices(*vertices)\n        return AnimationGroup(\n            *(animation(mobj, **anim_args) for mobj in mobjects), group=self\n        )\n\n    def _add_edge(\n        self,\n        edge: tuple[Hashable, Hashable],\n        edge_type: type[Mobject] = Line,\n        edge_config: dict | None = None,\n    ):\n        \"\"\"Add a new edge to the graph.\n\n        Parameters\n        ----------\n\n        edge\n            The edge (as a tuple of vertex identifiers) to be added. If a non-existing\n            vertex is passed, a new vertex with default settings will be created. Create\n            new vertices yourself beforehand to customize them.\n        edge_type\n            The mobject class used for displaying edges in the scene.\n        edge_config\n            A dictionary containing keyword arguments to be passed\n            to the class specified via ``edge_type``.\n\n        Returns\n        -------\n        Group\n            A group containing all newly added vertices and edges.\n\n        \"\"\"\n        if edge_config is None:\n            edge_config = self.default_edge_config.copy()\n        added_mobjects = []\n        for v in edge:\n            if v not in self.vertices:\n                added_mobjects.append(self._add_vertex(v))\n        u, v = edge\n\n        self._graph.add_edge(u, v)\n\n        base_edge_config = self.default_edge_config.copy()\n        base_edge_config.update(edge_config)\n        edge_config = base_edge_config\n        self._edge_config[(u, v)] = edge_config\n\n        edge_mobject = edge_type(\n            start=self[u].get_center(),\n            end=self[v].get_center(),\n            z_index=-1,\n            **edge_config,\n        )\n        self.edges[(u, v)] = edge_mobject\n\n        self.add(edge_mobject)\n        added_mobjects.append(edge_mobject)\n        return self.get_group_class()(*added_mobjects)\n\n    def add_edges(\n        self,\n        *edges: tuple[Hashable, Hashable],\n        edge_type: type[Mobject] = Line,\n        edge_config: dict | None = None,\n        **kwargs,\n    ):\n        \"\"\"Add new edges to the graph.\n\n        Parameters\n        ----------\n\n        edges\n            Edges (as tuples of vertex identifiers) to be added. If a non-existing\n            vertex is passed, a new vertex with default settings will be created. Create\n            new vertices yourself beforehand to customize them.\n        edge_type\n            The mobject class used for displaying edges in the scene.\n        edge_config\n            A dictionary either containing keyword arguments to be passed\n            to the class specified via ``edge_type``, or a dictionary\n            whose keys are the edge tuples, and whose values are dictionaries\n            containing keyword arguments to be passed for the construction\n            of the corresponding edge.\n        kwargs\n            Any further keyword arguments are passed to :meth:`.add_vertices`\n            which is used to create new vertices in the passed edges.\n\n        Returns\n        -------\n        Group\n            A group containing all newly added vertices and edges.\n\n        \"\"\"\n        if edge_config is None:\n            edge_config = {}\n        non_edge_settings = {k: v for (k, v) in edge_config.items() if k not in edges}\n        base_edge_config = self.default_edge_config.copy()\n        base_edge_config.update(non_edge_settings)\n        base_edge_config = {e: base_edge_config.copy() for e in edges}\n        for e in edges:\n            base_edge_config[e].update(edge_config.get(e, {}))\n        edge_config = base_edge_config\n\n        edge_vertices = set(it.chain(*edges))\n        new_vertices = [v for v in edge_vertices if v not in self.vertices]\n        added_vertices = self.add_vertices(*new_vertices, **kwargs)\n\n        added_mobjects = sum(\n            (\n                self._add_edge(\n                    edge,\n                    edge_type=edge_type,\n                    edge_config=edge_config[edge],\n                ).submobjects\n                for edge in edges\n            ),\n            added_vertices,\n        )\n        return self.get_group_class()(*added_mobjects)\n\n    @override_animate(add_edges)\n    def _add_edges_animation(self, *args, anim_args=None, **kwargs):\n        if anim_args is None:\n            anim_args = {}\n        animation = anim_args.pop(\"animation\", Create)\n\n        mobjects = self.add_edges(*args, **kwargs)\n        return AnimationGroup(\n            *(animation(mobj, **anim_args) for mobj in mobjects), group=self\n        )\n\n    def _remove_edge(self, edge: tuple[Hashable]):\n        \"\"\"Remove an edge from the graph.\n\n        Parameters\n        ----------\n\n        edge\n            The edge (i.e., a tuple of vertex identifiers) to be removed from the graph.\n\n        Returns\n        -------\n\n        Mobject\n            The removed edge.\n\n        \"\"\"\n        if edge not in self.edges:\n            raise ValueError(f\"The graph does not contain a edge '{edge}'\")\n\n        edge_mobject = self.edges.pop(edge)\n\n        self._graph.remove_edge(*edge)\n        self._edge_config.pop(edge, None)\n\n        self.remove(edge_mobject)\n        return edge_mobject\n\n    def remove_edges(self, *edges: tuple[Hashable]):\n        \"\"\"Remove several edges from the graph.\n\n        Parameters\n        ----------\n        edges\n            Edges to be removed from the graph.\n\n        Returns\n        -------\n        Group\n            A group containing all removed edges.\n\n        \"\"\"\n        edge_mobjects = [self._remove_edge(edge) for edge in edges]\n        return self.get_group_class()(*edge_mobjects)\n\n    @override_animate(remove_edges)\n    def _remove_edges_animation(self, *edges, anim_args=None):\n        if anim_args is None:\n            anim_args = {}\n\n        animation = anim_args.pop(\"animation\", Uncreate)\n\n        mobjects = self.remove_edges(*edges)\n        return AnimationGroup(*(animation(mobj, **anim_args) for mobj in mobjects))\n\n    @classmethod\n    def from_networkx(\n        cls, nxgraph: nx.classes.graph.Graph | nx.classes.digraph.DiGraph, **kwargs\n    ):\n        \"\"\"Build a :class:`~.Graph` or :class:`~.DiGraph` from a\n        given ``networkx`` graph.\n\n        Parameters\n        ----------\n\n        nxgraph\n            A ``networkx`` graph or digraph.\n        **kwargs\n            Keywords to be passed to the constructor of :class:`~.Graph`.\n\n        Examples\n        --------\n\n        .. manim:: ImportNetworkxGraph\n\n            import networkx as nx\n\n            nxgraph = nx.erdos_renyi_graph(14, 0.5)\n\n            class ImportNetworkxGraph(Scene):\n                def construct(self):\n                    G = Graph.from_networkx(nxgraph, layout=\"spring\", layout_scale=3.5)\n                    self.play(Create(G))\n                    self.play(*[G[v].animate.move_to(5*RIGHT*np.cos(ind/7 * PI) +\n                                                     3*UP*np.sin(ind/7 * PI))\n                                for ind, v in enumerate(G.vertices)])\n                    self.play(Uncreate(G))\n\n        \"\"\"\n        return cls(list(nxgraph.nodes), list(nxgraph.edges), **kwargs)\n\n    def change_layout(\n        self,\n        layout: LayoutName | dict[Hashable, Point3DLike] | LayoutFunction = \"spring\",\n        layout_scale: float | tuple[float, float, float] = 2,\n        layout_config: dict[str, Any] | None = None,\n        partitions: list[list[Hashable]] | None = None,\n        root_vertex: Hashable | None = None,\n    ) -> Graph:\n        \"\"\"Change the layout of this graph.\n\n        See the documentation of :class:`~.Graph` for details about the\n        keyword arguments.\n\n        Examples\n        --------\n\n        .. manim:: ChangeGraphLayout\n\n            class ChangeGraphLayout(Scene):\n                def construct(self):\n                    G = Graph([1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5)],\n                              layout={1: [-2, 0, 0], 2: [-1, 0, 0], 3: [0, 0, 0],\n                                      4: [1, 0, 0], 5: [2, 0, 0]}\n                              )\n                    self.play(Create(G))\n                    self.play(G.animate.change_layout(\"circular\"))\n                    self.wait()\n        \"\"\"\n        layout_config = {} if layout_config is None else layout_config\n        if partitions is not None and \"partitions\" not in layout_config:\n            layout_config[\"partitions\"] = partitions\n        if root_vertex is not None and \"root_vertex\" not in layout_config:\n            layout_config[\"root_vertex\"] = root_vertex\n\n        self._layout = _determine_graph_layout(\n            self._graph,\n            layout=layout,\n            layout_scale=layout_scale,\n            layout_config=layout_config,\n        )\n\n        for v in self.vertices:\n            self[v].move_to(self._layout[v])\n        return self"}, {"name": "get_3d_vmob_end_corner", "code": "def get_3d_vmob_end_corner(vmob) -> Point3D:\n    if vmob.get_num_points() == 0:\n        return np.array(ORIGIN)\n    return vmob.points[get_3d_vmob_end_corner_index(vmob)]"}, {"name": "get_3d_vmob_end_corner_index", "code": "def get_3d_vmob_end_corner_index(vmob) -> int:\n    return ((len(vmob.points) - 1) // 6) * 3"}, {"name": "get_3d_vmob_end_corner_unit_normal", "code": "def get_3d_vmob_end_corner_unit_normal(vmob) -> Vector3D:\n    return get_3d_vmob_unit_normal(vmob, get_3d_vmob_end_corner_index(vmob))"}, {"name": "get_3d_vmob_gradient_start_and_end_points", "code": "def get_3d_vmob_gradient_start_and_end_points(vmob) -> tuple[Point3D, Point3D]:\n    return (\n        get_3d_vmob_start_corner(vmob),\n        get_3d_vmob_end_corner(vmob),\n    )"}, {"name": "get_3d_vmob_start_corner", "code": "def get_3d_vmob_start_corner(vmob) -> Point3D:\n    if vmob.get_num_points() == 0:\n        return np.array(ORIGIN)\n    return vmob.points[get_3d_vmob_start_corner_index(vmob)]"}, {"name": "get_3d_vmob_start_corner_index", "code": "def get_3d_vmob_start_corner_index(vmob) -> Literal[0]:\n    return 0"}, {"name": "get_3d_vmob_start_corner_unit_normal", "code": "def get_3d_vmob_start_corner_unit_normal(vmob) -> Vector3D:\n    return get_3d_vmob_unit_normal(vmob, get_3d_vmob_start_corner_index(vmob))"}, {"name": "get_3d_vmob_unit_normal", "code": "def get_3d_vmob_unit_normal(vmob, point_index: int) -> Vector3D:\n    n_points = vmob.get_num_points()\n    if len(vmob.get_anchors()) <= 2:\n        return np.array(UP)\n    i = point_index\n    im3 = i - 3 if i > 2 else (n_points - 4)\n    ip3 = i + 3 if i < (n_points - 3) else 3\n    unit_normal = get_unit_normal(\n        vmob.points[ip3] - vmob.points[i],\n        vmob.points[im3] - vmob.points[i],\n    )\n    if np.linalg.norm(unit_normal) == 0:\n        return np.array(UP)\n    return unit_normal"}, {"name": "get_colormap_code", "code": "def get_colormap_code(rgb_list):\n    data = \",\".join(\"vec3({}, {}, {})\".format(*rgb) for rgb in rgb_list)\n    return f\"vec3[{len(rgb_list)}]({data})\""}, {"name": "get_det_text", "code": "def get_det_text(\n    matrix: Matrix,\n    determinant: int | str | None = None,\n    background_rect: bool = False,\n    initial_scale_factor: float = 2,\n):\n    r\"\"\"Helper function to create determinant.\n\n    Parameters\n    ----------\n    matrix\n        The matrix whose determinant is to be created\n\n    determinant\n        The value of the determinant of the matrix\n\n    background_rect\n        The background rectangle\n\n    initial_scale_factor\n        The scale of the text `det` w.r.t the matrix\n\n    Returns\n    --------\n    :class:`~.VGroup`\n        A VGroup containing the determinant\n\n    Examples\n    --------\n\n    .. manim:: DeterminantOfAMatrix\n        :save_last_frame:\n\n        class DeterminantOfAMatrix(Scene):\n            def construct(self):\n                matrix = Matrix([\n                    [2, 0],\n                    [-1, 1]\n                ])\n\n                # scaling down the `det` string\n                det = get_det_text(matrix,\n                            determinant=3,\n                            initial_scale_factor=1)\n\n                # must add the matrix\n                self.add(matrix)\n                self.add(det)\n    \"\"\"\n    parens = MathTex(\"(\", \")\")\n    parens.scale(initial_scale_factor)\n    parens.stretch_to_fit_height(matrix.height)\n    l_paren, r_paren = parens.split()\n    l_paren.next_to(matrix, LEFT, buff=0.1)\n    r_paren.next_to(matrix, RIGHT, buff=0.1)\n    det = Tex(\"det\")\n    det.scale(initial_scale_factor)\n    det.next_to(l_paren, LEFT, buff=0.1)\n    if background_rect:\n        det.add_background_rectangle()\n    det_text = VGroup(det, l_paren, r_paren)\n    if determinant is not None:\n        eq = MathTex(\"=\")\n        eq.next_to(r_paren, RIGHT, buff=0.1)\n        result = MathTex(str(determinant))\n        result.next_to(eq, RIGHT, buff=0.2)\n        det_text.add(eq, result)\n    return det_text"}, {"name": "get_dir_layout", "code": "def get_dir_layout(dirpath: Path) -> Generator[str, None, None]:\n    \"\"\"Get list of paths relative to dirpath of all files in dir and subdirs recursively.\"\"\"\n    for p in dirpath.iterdir():\n        if p.is_dir():\n            yield from get_dir_layout(p)\n            continue\n        yield str(p.relative_to(dirpath))"}, {"name": "get_full_raster_image_path", "code": "def get_full_raster_image_path(image_file_name: str | PurePath) -> Path:\n    return seek_full_path_from_defaults(\n        image_file_name,\n        default_dir=config.get_dir(\"assets_dir\"),\n        extensions=[\".jpg\", \".jpeg\", \".png\", \".gif\", \".ico\"],\n    )"}, {"name": "get_full_sound_file_path", "code": "def get_full_sound_file_path(sound_file_name: StrPath) -> Path:\n    return seek_full_path_from_defaults(\n        sound_file_name,\n        default_dir=config.get_dir(\"assets_dir\"),\n        extensions=[\".wav\", \".mp3\"],\n    )"}, {"name": "get_full_vector_image_path", "code": "def get_full_vector_image_path(image_file_name: str | PurePath) -> Path:\n    return seek_full_path_from_defaults(\n        image_file_name,\n        default_dir=config.get_dir(\"assets_dir\"),\n        extensions=[\".svg\"],\n    )"}, {"name": "get_hash_from_play_call", "code": "def get_hash_from_play_call(\n    scene_object: Scene,\n    camera_object: Camera | OpenGLCamera,\n    animations_list: typing.Iterable[Animation],\n    current_mobjects_list: typing.Iterable[Mobject],\n) -> str:\n    \"\"\"Take the list of animations and a list of mobjects and output their hashes. This is meant to be used for `scene.play` function.\n\n    Parameters\n    -----------\n    scene_object\n        The scene object.\n\n    camera_object\n        The camera object used in the scene.\n\n    animations_list\n        The list of animations.\n\n    current_mobjects_list\n        The list of mobjects.\n\n    Returns\n    -------\n    :class:`str`\n        A string concatenation of the respective hashes of `camera_object`, `animations_list` and `current_mobjects_list`, separated by `_`.\n    \"\"\"\n    logger.debug(\"Hashing ...\")\n    t_start = perf_counter()\n    _Memoizer.mark_as_processed(scene_object)\n    camera_json = get_json(camera_object)\n    animations_list_json = [get_json(x) for x in sorted(animations_list, key=str)]\n    current_mobjects_list_json = [get_json(x) for x in current_mobjects_list]\n    hash_camera, hash_animations, hash_current_mobjects = (\n        zlib.crc32(repr(json_val).encode())\n        for json_val in [camera_json, animations_list_json, current_mobjects_list_json]\n    )\n    hash_complete = f\"{hash_camera}_{hash_animations}_{hash_current_mobjects}\"\n    t_end = perf_counter()\n    logger.debug(\"Hashing done in %(time)s s.\", {\"time\": str(t_end - t_start)[:8]})\n    # End of the hashing for the animation, reset all the memoize.\n    _Memoizer.reset_already_processed()\n    logger.debug(\"Hash generated :  %(h)s\", {\"h\": hash_complete})\n    return hash_complete"}, {"name": "get_json", "code": "def get_json(obj: dict):\n    \"\"\"Recursively serialize `object` to JSON using the :class:`CustomEncoder` class.\n\n    Parameters\n    ----------\n    obj\n        The dict to flatten\n\n    Returns\n    -------\n    :class:`str`\n        The flattened object\n    \"\"\"\n    return json.dumps(obj, cls=_CustomEncoder)"}, {"name": "get_mobject_class", "code": "def get_mobject_class() -> type:\n    \"\"\"Gets the base mobject class, depending on the currently active renderer.\n\n    .. NOTE::\n\n        This method is intended to be used in the code base of Manim itself\n        or in plugins where code should work independent of the selected\n        renderer.\n\n    Examples\n    --------\n\n    The function has to be explicitly imported. We test that\n    the name of the returned class is one of the known mobject\n    base classes::\n\n        >>> from manim.mobject.utils import get_mobject_class\n        >>> get_mobject_class().__name__ in ['Mobject', 'OpenGLMobject']\n        True\n    \"\"\"\n    if config.renderer == RendererType.CAIRO:\n        return Mobject\n    if config.renderer == RendererType.OPENGL:\n        return OpenGLMobject\n    raise NotImplementedError(\n        \"Base mobjects are not implemented for the active renderer.\"\n    )"}, {"name": "get_module", "code": "def get_module(file_name: Path) -> types.ModuleType:\n    if str(file_name) == \"-\":\n        module = types.ModuleType(\"input_scenes\")\n        logger.info(\n            \"Enter the animation's code & end with an EOF (CTRL+D on Linux/Unix, CTRL+Z on Windows):\",\n        )\n        code = sys.stdin.read()\n        if not code.startswith(\"from manim import\"):\n            logger.warning(\n                \"Didn't find an import statement for Manim. Importing automatically...\",\n            )\n            code = \"from manim import *\\n\" + code\n        logger.info(\"Rendering animation from typed code...\")\n        try:\n            exec(code, module.__dict__)\n            return module\n        except Exception as e:\n            logger.error(f\"Failed to render scene: {str(e)}\")\n            sys.exit(2)\n    else:\n        if file_name.exists():\n            ext = file_name.suffix\n            if ext != \".py\":\n                raise ValueError(f\"{file_name} is not a valid Manim python script.\")\n            module_name = \".\".join(file_name.with_suffix(\"\").parts)\n\n            warnings.filterwarnings(\n                \"default\",\n                category=DeprecationWarning,\n                module=module_name,\n            )\n\n            spec = importlib.util.spec_from_file_location(module_name, file_name)\n            if isinstance(spec, importlib.machinery.ModuleSpec):\n                module = importlib.util.module_from_spec(spec)\n                sys.modules[module_name] = module\n                sys.path.insert(0, str(file_name.parent.absolute()))\n                assert spec.loader\n                spec.loader.exec_module(module)\n                return module\n            raise FileNotFoundError(f\"{file_name} not found\")\n        else:\n            raise FileNotFoundError(f\"{file_name} not found\")"}, {"name": "get_plugins", "code": "def get_plugins() -> dict[str, Any]:\n    plugins: dict[str, Any] = {\n        entry_point.name: entry_point.load()\n        for entry_point in entry_points(group=\"manim.plugins\")\n    }\n    return plugins"}, {"name": "get_point_mobject_class", "code": "def get_point_mobject_class() -> type:\n    \"\"\"Gets the point cloud mobject class, depending on the currently\n    active renderer.\n\n    .. NOTE::\n\n        This method is intended to be used in the code base of Manim itself\n        or in plugins where code should work independent of the selected\n        renderer.\n\n    Examples\n    --------\n\n    The function has to be explicitly imported. We test that\n    the name of the returned class is one of the known mobject\n    base classes::\n\n        >>> from manim.mobject.utils import get_point_mobject_class\n        >>> get_point_mobject_class().__name__ in ['PMobject', 'OpenGLPMobject']\n        True\n    \"\"\"\n    if config.renderer == RendererType.CAIRO:\n        return PMobject\n    if config.renderer == RendererType.OPENGL:\n        return OpenGLPMobject\n    raise NotImplementedError(\n        \"Point cloud mobjects are not implemented for the active renderer.\"\n    )"}, {"name": "get_quadratic_approximation_of_cubic", "code": "def get_quadratic_approximation_of_cubic(\n    a0: Point3D | Point3D_Array,\n    h0: Point3D | Point3D_Array,\n    h1: Point3D | Point3D_Array,\n    a1: Point3D | Point3D_Array,\n) -> QuadraticSpline | QuadraticBezierPath:\n    r\"\"\"If ``a0``, ``h0``, ``h1`` and ``a1`` are the control points of a cubic\n    B\u00e9zier curve, approximate the curve with two quadratic B\u00e9zier curves and\n    return an array of 6 points, where the first 3 points represent the first\n    quadratic curve and the last 3 represent the second one.\n\n    Otherwise, if ``a0``, ``h0``, ``h1`` and ``a1`` are _arrays_ of :math:`N`\n    points representing :math:`N` cubic B\u00e9zier curves, return an array of\n    :math:`6N` points where each group of :math:`6` consecutive points\n    approximates each of the :math:`N` curves in a similar way as above.\n\n    .. note::\n        If the cubic spline given by the original cubic B\u00e9zier curves is\n        smooth, this algorithm will generate a quadratic spline which is also\n        smooth.\n\n        If a cubic B\u00e9zier is given by\n\n        .. math::\n            C(t) = (1-t)^3 A_0 + 3(1-t)^2 t H_0 + 3(1-t)t^2 H_1 + t^3 A_1\n\n        where :math:`A_0`, :math:`H_0`, :math:`H_1` and :math:`A_1` are its\n        control points, then this algorithm should generate two quadratic\n        B\u00e9ziers given by\n\n        .. math::\n            Q_0(t) &= (1-t)^2 A_0 + 2(1-t)t M_0 + t^2 K \\\\\n            Q_1(t) &= (1-t)^2 K + 2(1-t)t M_1 + t^2 A_1\n\n        where :math:`M_0` and :math:`M_1` are the respective handles to be\n        found for both curves, and :math:`K` is the end anchor of the 1st curve\n        and the start anchor of the 2nd, which must also be found.\n\n        To solve for :math:`M_0`, :math:`M_1` and :math:`K`, three conditions\n        can be imposed:\n\n        1.  :math:`Q_0'(0) = \\frac{1}{2}C'(0)`. The derivative of the first\n            quadratic curve at :math:`t = 0` should be proportional to that of\n            the original cubic curve, also at :math:`t = 0`. Because the cubic\n            curve is split into two parts, it is necessary to divide this by\n            two: the speed of a point travelling through the curve should be\n            half of the original. This gives:\n\n            .. math::\n                Q_0'(0) &= \\frac{1}{2}C'(0) \\\\\n                2(M_0 - A_0) &= \\frac{3}{2}(H_0 - A_0) \\\\\n                2M_0 - 2A_0 &= \\frac{3}{2}H_0 - \\frac{3}{2}A_0 \\\\\n                2M_0 &= \\frac{3}{2}H_0 + \\frac{1}{2}A_0 \\\\\n                M_0 &= \\frac{1}{4}(3H_0 + A_0)\n\n        2.  :math:`Q_1'(1) = \\frac{1}{2}C'(1)`. The derivative of the second\n            quadratic curve at :math:`t = 1` should be half of that of the\n            original cubic curve for the same reasons as above, also at\n            :math:`t = 1`. This gives:\n\n            .. math::\n                Q_1'(1) &= \\frac{1}{2}C'(1) \\\\\n                2(A_1 - M_1) &= \\frac{3}{2}(A_1 - H_1) \\\\\n                2A_1 - 2M_1 &= \\frac{3}{2}A_1 - \\frac{3}{2}H_1 \\\\\n                -2M_1 &= -\\frac{1}{2}A_1 - \\frac{3}{2}H_1 \\\\\n                M_1 &= \\frac{1}{4}(3H_1 + A_1)\n\n        3.  :math:`Q_0'(1) = Q_1'(0)`. The derivatives of both quadratic curves\n            should match at the point :math:`K`, in order for the final spline\n            to be smooth. This gives:\n\n            .. math::\n                Q_0'(1) &= Q_1'(0) \\\\\n                2(K - M_0) &= 2(M_1 - K) \\\\\n                2K - 2M_0 &= 2M_1 - 2K \\\\\n                4K &= 2M_0 + 2M_1 \\\\\n                K &= \\frac{1}{2}(M_0 + M_1)\n\n        This is sufficient to find proper control points for the quadratic\n        B\u00e9zier curves.\n\n    Parameters\n    ----------\n    a0\n        The start anchor of a single cubic B\u00e9zier curve, or an array of\n        :math:`N` start anchors for :math:`N` curves.\n    h0\n        The first handle of a single cubic B\u00e9zier curve, or an array of\n        :math:`N` first handles for :math:`N` curves.\n    h1\n        The second handle of a single cubic B\u00e9zier curve, or an array of\n        :math:`N` second handles for :math:`N` curves.\n    a1\n        The end anchor of a single cubic B\u00e9zier curve, or an array of\n        :math:`N` end anchors for :math:`N` curves.\n\n    Returns\n    -------\n    result\n        An array containing either 6 points for 2 quadratic B\u00e9zier curves\n        approximating the original cubic curve, or :math:`6N` points for\n        :math:`2N` quadratic curves approximating :math:`N` cubic curves.\n\n    Raises\n    ------\n    ValueError\n        If ``a0``, ``h0``, ``h1`` and ``a1`` have different dimensions, or\n        if their number of dimensions is not 1 or 2.\n    \"\"\"\n    a0c = np.asarray(a0)\n    h0c = np.asarray(h0)\n    h1c = np.asarray(h1)\n    a1c = np.asarray(a1)\n\n    if all(arr.ndim == 1 for arr in (a0c, h0c, h1c, a1c)):\n        num_curves, dim = 1, a0c.shape[0]\n    elif all(arr.ndim == 2 for arr in (a0c, h0c, h1c, a1c)):\n        num_curves, dim = a0c.shape\n    else:\n        raise ValueError(\"All arguments must be Point3D or Point3D_Array.\")\n\n    m0 = 0.25 * (3 * h0c + a0c)\n    m1 = 0.25 * (3 * h1c + a1c)\n    k = 0.5 * (m0 + m1)\n\n    result = np.empty((6 * num_curves, dim))\n    result[0::6] = a0c\n    result[1::6] = m0\n    result[2::6] = k\n    result[3::6] = k\n    result[4::6] = m1\n    result[5::6] = a1c\n    return result"}, {"name": "get_scene_classes_from_module", "code": "def get_scene_classes_from_module(module: types.ModuleType) -> list[type[Scene]]:\n    from ..scene.scene import Scene\n\n    def is_child_scene(obj: Any, module: types.ModuleType) -> bool:\n        return (\n            inspect.isclass(obj)\n            and issubclass(obj, Scene)\n            and obj != Scene\n            and obj.__module__.startswith(module.__name__)\n        )\n\n    return [\n        member[1]\n        for member in inspect.getmembers(module, lambda x: is_child_scene(x, module))\n    ]"}, {"name": "get_scenes_to_render", "code": "def get_scenes_to_render(scene_classes: list[type[Scene]]) -> list[type[Scene]]:\n    if not scene_classes:\n        logger.error(NO_SCENE_MESSAGE)\n        return []\n    if config[\"write_all\"]:\n        return scene_classes\n    result = []\n    for scene_name in config[\"scene_names\"]:\n        found = False\n        for scene_class in scene_classes:\n            if scene_class.__name__ == scene_name:\n                result.append(scene_class)\n                found = True\n                break\n        if not found and (scene_name != \"\"):\n            logger.error(SCENE_NOT_FOUND_MESSAGE.format(scene_name))\n    if result:\n        return result\n    if len(scene_classes) == 1:\n        config[\"scene_names\"] = [scene_classes[0].__name__]\n        return [scene_classes[0]]\n    return prompt_user_for_choice(scene_classes)"}, {"name": "get_shaded_rgb", "code": "def get_shaded_rgb(\n    rgb: RGB_Array_Float,\n    point: Point3D,\n    unit_normal_vect: Vector3D,\n    light_source: Point3D,\n) -> RGB_Array_Float:\n    \"\"\"Add light or shadow to the ``rgb`` color of some surface which is located at a\n    given ``point`` in space and facing in the direction of ``unit_normal_vect``,\n    depending on whether the surface is facing a ``light_source`` or away from it.\n\n    Parameters\n    ----------\n    rgb\n        An RGB array of floats.\n    point\n        The location of the colored surface.\n    unit_normal_vect\n        The direction in which the colored surface is facing.\n    light_source\n        The location of a light source which might illuminate the surface.\n\n    Returns\n    -------\n    RGB_Array_Float\n        The color with added light or shadow, depending on the direction of the colored\n        surface.\n    \"\"\"\n    to_sun = normalize(light_source - point)\n    light = 0.5 * np.dot(unit_normal_vect, to_sun) ** 3\n    if light < 0:\n        light *= 0.5\n    shaded_rgb: RGB_Array_Float = rgb + light\n    return shaded_rgb"}, {"name": "get_shader_code_from_file", "code": "def get_shader_code_from_file(filename: Path) -> str | None:\n    if filename in filename_to_code_map:\n        return filename_to_code_map[filename]\n\n    try:\n        filepath = find_file(\n            filename,\n            directories=[get_shader_dir(), Path(\"/\")],\n        )\n    except OSError:\n        return None\n\n    result = filepath.read_text()\n\n    # To share functionality between shaders, some functions are read in\n    # from other files an inserted into the relevant strings before\n    # passing to ctx.program for compiling\n    # Replace \"#INSERT \" lines with relevant code\n    insertions = re.findall(\n        r\"^#include ../include/.*\\.glsl$\",\n        result,\n        flags=re.MULTILINE,\n    )\n    for line in insertions:\n        inserted_code = get_shader_code_from_file(\n            Path() / \"include\" / line.replace(\"#include ../include/\", \"\"),\n        )\n        if inserted_code is None:\n            return None\n        result = result.replace(line, inserted_code)\n    filename_to_code_map[filename] = result\n    return result"}, {"name": "get_shader_dir", "code": "def get_shader_dir():\n    return Path(__file__).parent / \"shaders\""}, {"name": "get_smooth_closed_cubic_bezier_handle_points", "code": "def get_smooth_closed_cubic_bezier_handle_points(\n    anchors: Point3DLike_Array,\n) -> tuple[Point3D_Array, Point3D_Array]:\n    r\"\"\"Special case of :func:`get_smooth_cubic_bezier_handle_points`,\n    when the ``anchors`` form a closed loop.\n\n    .. note::\n        A system of equations must be solved to get the first handles of\n        every B\u00e9zier curve (referred to as :math:`H_1`).\n        Then :math:`H_2` (the second handles) can be obtained separately.\n\n        .. seealso::\n            The equations were obtained from:\n\n            * `Conditions on control points for continuous curvature. (2016). Jaco Stuifbergen. <http://www.jacos.nl/jacos_html/spline/theory/theory_2.html>`_\n\n        In general, if there are :math:`N+1` anchors, there will be :math:`N` B\u00e9zier curves\n        and thus :math:`N` pairs of handles to find. We must solve the following\n        system of equations for the 1st handles (example for :math:`N = 5`):\n\n        .. math::\n            \\begin{pmatrix}\n                4 & 1 & 0 & 0 & 1 \\\\\n                1 & 4 & 1 & 0 & 0 \\\\\n                0 & 1 & 4 & 1 & 0 \\\\\n                0 & 0 & 1 & 4 & 1 \\\\\n                1 & 0 & 0 & 1 & 4\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                H_{1,0} \\\\\n                H_{1,1} \\\\\n                H_{1,2} \\\\\n                H_{1,3} \\\\\n                H_{1,4}\n            \\end{pmatrix}\n            =\n            \\begin{pmatrix}\n                4A_0 + 2A_1 \\\\\n                4A_1 + 2A_2 \\\\\n                4A_2 + 2A_3 \\\\\n                4A_3 + 2A_4 \\\\\n                4A_4 + 2A_5\n            \\end{pmatrix}\n\n        which will be expressed as :math:`RH_1 = D`.\n\n        :math:`R` is almost a tridiagonal matrix, so we could use Thomas' algorithm.\n\n        .. seealso::\n            `Tridiagonal matrix algorithm. Wikipedia. <https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm>`_\n\n        However, :math:`R` has ones at the opposite corners. A solution to this is\n        the first decomposition proposed in the link below, with :math:`\\alpha = 1`:\n\n        .. seealso::\n            `Tridiagonal matrix algorithm # Variants. Wikipedia. <https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm#Variants>`_\n\n        .. math::\n            R\n            =\n            \\begin{pmatrix}\n                4 & 1 & 0 & 0 & 1 \\\\\n                1 & 4 & 1 & 0 & 0 \\\\\n                0 & 1 & 4 & 1 & 0 \\\\\n                0 & 0 & 1 & 4 & 1 \\\\\n                1 & 0 & 0 & 1 & 4\n            \\end{pmatrix}\n            &=\n            \\begin{pmatrix}\n                3 & 1 & 0 & 0 & 0 \\\\\n                1 & 4 & 1 & 0 & 0 \\\\\n                0 & 1 & 4 & 1 & 0 \\\\\n                0 & 0 & 1 & 4 & 1 \\\\\n                0 & 0 & 0 & 1 & 3\n            \\end{pmatrix}\n            +\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 & 1 \\\\\n                0 & 0 & 0 & 0 & 0 \\\\\n                0 & 0 & 0 & 0 & 0 \\\\\n                0 & 0 & 0 & 0 & 0 \\\\\n                1 & 0 & 0 & 0 & 1\n            \\end{pmatrix}\n            \\\\\n            &\n            \\\\\n            &=\n            \\begin{pmatrix}\n                3 & 1 & 0 & 0 & 0 \\\\\n                1 & 4 & 1 & 0 & 0 \\\\\n                0 & 1 & 4 & 1 & 0 \\\\\n                0 & 0 & 1 & 4 & 1 \\\\\n                0 & 0 & 0 & 1 & 3\n            \\end{pmatrix}\n            +\n            \\begin{pmatrix}\n                1 \\\\\n                0 \\\\\n                0 \\\\\n                0 \\\\\n                1\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 & 1\n            \\end{pmatrix}\n            \\\\\n            &\n            \\\\\n            &=\n            T + uv^t\n\n        We decompose :math:`R = T + uv^t`, where :math:`T` is a tridiagonal matrix, and\n        :math:`u, v` are :math:`N`-D vectors such that :math:`u_0 = u_{N-1} = v_0 = v_{N-1} = 1`,\n        and :math:`u_i = v_i = 0, \\forall i \\in \\{1, ..., N-2\\}`.\n\n        Thus:\n\n        .. math::\n            RH_1 &= D \\\\\n            \\Rightarrow (T + uv^t)H_1 &= D\n\n        If we find a vector :math:`q` such that :math:`Tq = u`:\n\n        .. math::\n            \\Rightarrow (T + Tqv^t)H_1 &= D \\\\\n            \\Rightarrow T(I + qv^t)H_1 &= D \\\\\n            \\Rightarrow H_1 &= (I + qv^t)^{-1} T^{-1} D\n\n        According to Sherman-Morrison's formula:\n\n        .. seealso::\n            `Sherman-Morrison's formula. Wikipedia. <https://en.wikipedia.org/wiki/Sherman%E2%80%93Morrison_formula>`_\n\n        .. math::\n            (I + qv^t)^{-1} = I - \\frac{1}{1 + v^tq} qv^t\n\n        If we find :math:`Y = T^{-1} D`, or in other words, if we solve for\n        :math:`Y` in :math:`TY = D`:\n\n        .. math::\n            H_1 &= (I + qv^t)^{-1} T^{-1} D \\\\\n            &= (I + qv^t)^{-1} Y \\\\\n            &= (I - \\frac{1}{1 + v^tq} qv^t) Y \\\\\n            &= Y - \\frac{1}{1 + v^tq} qv^tY\n\n        Therefore, we must solve for :math:`q` and :math:`Y` in :math:`Tq = u` and :math:`TY = D`.\n        As :math:`T` is now tridiagonal, we shall use Thomas' algorithm.\n\n        Define:\n\n        *   :math:`a = [a_0, \\ a_1, \\ ..., \\ a_{N-2}]` as :math:`T`'s lower diagonal of :math:`N-1` elements,\n            such that :math:`a_0 = a_1 = ... = a_{N-2} = 1`, so this diagonal is filled with ones;\n        *   :math:`b = [b_0, \\ b_1, \\ ..., \\ b_{N-2}, \\ b_{N-1}]` as :math:`T`'s main diagonal of :math:`N` elements,\n            such that :math:`b_0 = b_{N-1} = 3`, and :math:`b_1 = b_2 = ... = b_{N-2} = 4`;\n        *   :math:`c = [c_0, \\ c_1, \\ ..., \\ c_{N-2}]` as :math:`T`'s upper diagonal of :math:`N-1` elements,\n            such that :math:`c_0 = c_1 = ... = c_{N-2} = 1`: this diagonal is also filled with ones.\n\n        If, according to Thomas' algorithm, we define:\n\n        .. math::\n            c'_0 &= \\frac{c_0}{b_0} & \\\\\n            c'_i &= \\frac{c_i}{b_i - a_{i-1} c'_{i-1}}, & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\n            & & \\\\\n            u'_0 &= \\frac{u_0}{b_0} & \\\\\n            u'_i &= \\frac{u_i - a_{i-1} u'_{i-1}}{b_i - a_{i-1} c'_{i-1}}, & \\quad \\forall i \\in \\{1, ..., N-1\\} \\\\\n            & & \\\\\n            D'_0 &= \\frac{1}{b_0} D_0 & \\\\\n            D'_i &= \\frac{1}{b_i - a_{i-1} c'_{i-1}} (D_i - a_{i-1} D'_{i-1}), & \\quad \\forall i \\in \\{1, ..., N-1\\}\n\n        Then:\n\n        .. math::\n            c'_0     &= \\frac{1}{3} & \\\\\n            c'_i     &= \\frac{1}{4 - c'_{i-1}}, & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\n            & & \\\\\n            u'_0     &= \\frac{1}{3} & \\\\\n            u'_i     &= \\frac{-u'_{i-1}}{4 - c'_{i-1}} = -c'_i u'_{i-1}, & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\n            u'_{N-1} &= \\frac{1 - u'_{N-2}}{3 - c'_{N-2}} & \\\\\n            & & \\\\\n            D'_0     &= \\frac{1}{3} (4A_0 + 2A_1) & \\\\\n            D'_i     &= \\frac{1}{4 - c'_{i-1}} (4A_i + 2A_{i+1} - D'_{i-1}) & \\\\\n            &= c_i (4A_i + 2A_{i+1} - D'_{i-1}), & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\n            D'_{N-1} &= \\frac{1}{3 - c'_{N-2}} (4A_{N-1} + 2A_N - D'_{N-2}) &\n\n        Finally, we can do Backward Substitution to find :math:`q` and :math:`Y`:\n\n        .. math::\n            q_{N-1} &= u'_{N-1} & \\\\\n            q_i     &= u'_{i} - c'_i q_{i+1}, & \\quad \\forall i \\in \\{0, ..., N-2\\} \\\\\n            & & \\\\\n            Y_{N-1} &= D'_{N-1} & \\\\\n            Y_i     &= D'_i - c'_i Y_{i+1},   & \\quad \\forall i \\in \\{0, ..., N-2\\}\n\n        With those values, we can finally calculate :math:`H_1 = Y - \\frac{1}{1 + v^tq} qv^tY`.\n        Given that :math:`v_0 = v_{N-1} = 1`, and :math:`v_1 = v_2 = ... = v_{N-2} = 0`, its dot products\n        with :math:`q` and :math:`Y` are respectively :math:`v^tq = q_0 + q_{N-1}` and\n        :math:`v^tY = Y_0 + Y_{N-1}`. Thus:\n\n        .. math::\n            H_1 = Y - \\frac{1}{1 + q_0 + q_{N-1}} q(Y_0 + Y_{N-1})\n\n        Once we have :math:`H_1`, we can get :math:`H_2` (the array of second handles) as follows:\n\n        .. math::\n            H_{2, i}   &= 2A_{i+1} - H_{1, i+1}, & \\quad \\forall i \\in \\{0, ..., N-2\\} \\\\\n            H_{2, N-1} &= 2A_0 - H_{1, 0} &\n\n        Because the matrix :math:`R` always follows the same pattern (and thus :math:`T, u, v` as well),\n        we can define a memo list for :math:`c'` and :math:`u'` to avoid recalculation. We cannot\n        memoize :math:`D` and :math:`Y`, however, because they are always different matrices. We\n        cannot make a memo for :math:`q` either, but we can calculate it faster because :math:`u'`\n        can be memoized.\n\n    Parameters\n    ----------\n    anchors\n        Anchors of a closed cubic spline.\n\n    Returns\n    -------\n    :class:`tuple` [:class:`~.Point3D_Array`, :class:`~.Point3D_Array`]\n        A tuple of two arrays: one containing the 1st handle for every curve in\n        the closed cubic spline, and the other containing the 2nd handles.\n    \"\"\"\n    global CP_CLOSED_MEMO\n    global UP_CLOSED_MEMO\n\n    A = np.asarray(anchors)\n    N = A.shape[0] - 1\n    dim = A.shape[1]\n\n    # Calculate cp (c prime) and up (u prime) with help from\n    # CP_CLOSED_MEMO and UP_CLOSED_MEMO.\n    len_memo = CP_CLOSED_MEMO.size\n    if len_memo < N - 1:\n        cp = np.empty(N - 1)\n        up = np.empty(N - 1)\n        cp[:len_memo] = CP_CLOSED_MEMO\n        up[:len_memo] = UP_CLOSED_MEMO\n        # Forward Substitution 1\n        # Calculate up (at the same time we calculate cp).\n        for i in range(len_memo, N - 1):\n            cp[i] = 1 / (4 - cp[i - 1])\n            up[i] = -cp[i] * up[i - 1]\n        CP_CLOSED_MEMO = cp\n        UP_CLOSED_MEMO = up\n    else:\n        cp = CP_CLOSED_MEMO[: N - 1]\n        up = UP_CLOSED_MEMO[: N - 1]\n\n    # The last element of u' is different\n    cp_last_division = 1 / (3 - cp[N - 2])\n    up_last = cp_last_division * (1 - up[N - 2])\n\n    # Backward Substitution 1\n    # Calculate q.\n    q = np.empty((N, dim))\n    q[N - 1] = up_last\n    for i in range(N - 2, -1, -1):\n        q[i] = up[i] - cp[i] * q[i + 1]\n\n    # Forward Substitution 2\n    # Calculate Dp (D prime).\n    Dp = np.empty((N, dim))\n    AUX = 4 * A[:N] + 2 * A[1:]  # Vectorize the sum for efficiency.\n    Dp[0] = AUX[0] / 3\n    for i in range(1, N - 1):\n        Dp[i] = cp[i] * (AUX[i] - Dp[i - 1])\n    Dp[N - 1] = cp_last_division * (AUX[N - 1] - Dp[N - 2])\n\n    # Backward Substitution\n    # Calculate Y, which is defined as a view of Dp for efficiency\n    # and semantic convenience at the same time.\n    Y = Dp\n    # Y[N-1] = Dp[N-1] (redundant)\n    for i in range(N - 2, -1, -1):\n        Y[i] = Dp[i] - cp[i] * Y[i + 1]\n\n    # Calculate H1.\n    H1 = Y - 1 / (1 + q[0] + q[N - 1]) * q * (Y[0] + Y[N - 1])\n\n    # Calculate H2.\n    H2 = np.empty((N, dim))\n    H2[0 : N - 1] = 2 * A[1:N] - H1[1:N]\n    H2[N - 1] = 2 * A[N] - H1[0]\n\n    return H1, H2"}, {"name": "get_smooth_cubic_bezier_handle_points", "code": "def get_smooth_cubic_bezier_handle_points(\n    anchors: Point3DLike_Array,\n) -> tuple[Point3D_Array, Point3D_Array]:\n    \"\"\"Given an array of anchors for a cubic spline (array of connected cubic\n    B\u00e9zier curves), compute the 1st and 2nd handle for every curve, so that\n    the resulting spline is smooth.\n\n    Parameters\n    ----------\n    anchors\n        Anchors of a cubic spline.\n\n    Returns\n    -------\n    :class:`tuple` [:class:`~.Point3D_Array`, :class:`~.Point3D_Array`]\n        A tuple of two arrays: one containing the 1st handle for every curve in\n        the cubic spline, and the other containing the 2nd handles.\n    \"\"\"\n    anchors = np.asarray(anchors)\n    n_anchors = anchors.shape[0]\n\n    # If there's a single anchor, there's no B\u00e9zier curve.\n    # Return empty arrays.\n    if n_anchors == 1:\n        dim = anchors.shape[1]\n        return np.zeros((0, dim)), np.zeros((0, dim))\n\n    # If there are only two anchors (thus only one pair of handles),\n    # they can only be an interpolation of these two anchors with alphas\n    # 1/3 and 2/3, which will draw a straight line between the anchors.\n    if n_anchors == 2:\n        val = interpolate(anchors[0], anchors[1], np.array([[1 / 3], [2 / 3]]))\n        return (val[0], val[1])\n\n    # Handle different cases depending on whether the points form a closed\n    # curve or not\n    curve_is_closed = is_closed(anchors)\n    if curve_is_closed:\n        return get_smooth_closed_cubic_bezier_handle_points(anchors)\n    else:\n        return get_smooth_open_cubic_bezier_handle_points(anchors)"}, {"name": "get_smooth_open_cubic_bezier_handle_points", "code": "def get_smooth_open_cubic_bezier_handle_points(\n    anchors: Point3DLike_Array,\n) -> tuple[Point3D_Array, Point3D_Array]:\n    r\"\"\"Special case of :func:`get_smooth_cubic_bezier_handle_points`,\n    when the ``anchors`` do not form a closed loop.\n\n    .. note::\n        A system of equations must be solved to get the first handles of\n        every B\u00e8zier curve (referred to as :math:`H_1`).\n        Then :math:`H_2` (the second handles) can be obtained separately.\n\n        .. seealso::\n            The equations were obtained from:\n\n            * `Smooth B\u00e9zier Spline Through Prescribed Points. (2012). Particle in Cell Consulting LLC. <https://www.particleincell.com/2012/bezier-splines/>`_\n            * `Conditions on control points for continuous curvature. (2016). Jaco Stuifbergen. <http://www.jacos.nl/jacos_html/spline/theory/theory_2.html>`_\n\n        .. warning::\n            The equations in the first webpage have some typos which were corrected in the comments.\n\n        In general, if there are :math:`N+1` anchors, there will be :math:`N` B\u00e9zier curves\n        and thus :math:`N` pairs of handles to find. We must solve the following\n        system of equations for the 1st handles (example for :math:`N = 5`):\n\n        .. math::\n            \\begin{pmatrix}\n                2 & 1 & 0 & 0 & 0 \\\\\n                1 & 4 & 1 & 0 & 0 \\\\\n                0 & 1 & 4 & 1 & 0 \\\\\n                0 & 0 & 1 & 4 & 1 \\\\\n                0 & 0 & 0 & 2 & 7\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                H_{1,0} \\\\\n                H_{1,1} \\\\\n                H_{1,2} \\\\\n                H_{1,3} \\\\\n                H_{1,4}\n            \\end{pmatrix}\n            =\n            \\begin{pmatrix}\n                A_0 + 2A_1 \\\\\n                4A_1 + 2A_2 \\\\\n                4A_2 + 2A_3 \\\\\n                4A_3 + 2A_4 \\\\\n                8A_4 + A_5\n            \\end{pmatrix}\n\n        which will be expressed as :math:`TH_1 = D`.\n        :math:`T` is a tridiagonal matrix, so the system can be solved in :math:`O(N)`\n        operations. Here we shall use Thomas' algorithm or the tridiagonal matrix\n        algorithm.\n\n        .. seealso::\n            `Tridiagonal matrix algorithm. Wikipedia. <https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm>`_\n\n        Define:\n\n        *   :math:`a = [a_0, \\ a_1, \\ ..., \\ a_{N-2}]` as :math:`T`'s lower diagonal of :math:`N-1` elements,\n            such that :math:`a_0 = a_1 = ... = a_{N-3} = 1`, and :math:`a_{N-2} = 2`;\n        *   :math:`b = [b_0, \\ b_1, \\ ..., \\ b_{N-2}, \\ b_{N-1}]` as :math:`T`'s main diagonal of :math:`N` elements,\n            such that :math:`b_0 = 2`, :math:`b_1 = b_2 = ... = b_{N-2} = 4`, and :math:`b_{N-1} = 7`;\n        *   :math:`c = [c_0, \\ c_1, \\ ..., \\ c_{N-2}]` as :math:`T`'s upper diagonal of :math:`{N-1}` elements,\n            such that :math:`c_0 = c_1 = ... = c_{N-2} = 1`: this diagonal is filled with ones.\n\n        If, according to Thomas' algorithm, we define:\n\n        .. math::\n            c'_0 &= \\frac{c_0}{b_0} & \\\\\n            c'_i &= \\frac{c_i}{b_i - a_{i-1} c'_{i-1}}, & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\n            & & \\\\\n            D'_0 &= \\frac{1}{b_0} D_0 & \\\\\n            D'_i &= \\frac{1}{b_i - a_{i-1} c'{i-1}} (D_i - a_{i-1} D'_{i-1}), & \\quad \\forall i \\in \\{1, ..., N-1\\}\n\n        Then:\n\n        .. math::\n            c'_0     &= 0.5 & \\\\\n            c'_i     &= \\frac{1}{4 - c'_{i-1}}, & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\n            & & \\\\\n            D'_0     &= 0.5A_0 + A_1 & \\\\\n            D'_i     &= \\frac{1}{4 - c'_{i-1}} (4A_i + 2A_{i+1} - D'_{i-1}) & \\\\\n            &= c_i (4A_i + 2A_{i+1} - D'_{i-1}), & \\quad \\forall i \\in \\{1, ..., N-2\\} \\\\\n            D'_{N-1} &= \\frac{1}{7 - 2c'_{N-2}} (8A_{N-1} + A_N - 2D'_{N-2}) &\n\n        Finally, we can do Backward Substitution to find :math:`H_1`:\n\n        .. math::\n            H_{1, N-1} &= D'_{N-1} & \\\\\n            H_{1, i}   &= D'_i - c'_i H_{1, i+1}, & \\quad \\forall i \\in \\{0, ..., N-2\\}\n\n        Once we have :math:`H_1`, we can get :math:`H_2` (the array of second handles) as follows:\n\n        .. math::\n            H_{2, i}   &= 2A_{i+1} - H_{1, i+1}, & \\quad \\forall i \\in \\{0, ..., N-2\\} \\\\\n            H_{2, N-1} &= 0.5A_N   + 0.5H_{1, N-1} &\n\n        As the matrix :math:`T` always follows the same pattern, we can define a memo list\n        for :math:`c'` to avoid recalculation. We cannot do the same for :math:`D`, however,\n        because it is always a different matrix.\n\n    Parameters\n    ----------\n    anchors\n        Anchors of an open cubic spline.\n\n    Returns\n    -------\n    :class:`tuple` [:class:`~.Point3D_Array`, :class:`~.Point3D_Array`]\n        A tuple of two arrays: one containing the 1st handle for every curve in\n        the open cubic spline, and the other containing the 2nd handles.\n    \"\"\"\n    global CP_OPEN_MEMO\n\n    A = np.asarray(anchors)\n    N = A.shape[0] - 1\n    dim = A.shape[1]\n\n    # Calculate cp (c prime) with help from CP_OPEN_MEMO.\n    len_memo = CP_OPEN_MEMO.size\n    if len_memo < N - 1:\n        cp = np.empty(N - 1)\n        cp[:len_memo] = CP_OPEN_MEMO\n        for i in range(len_memo, N - 1):\n            cp[i] = 1 / (4 - cp[i - 1])\n        CP_OPEN_MEMO = cp\n    else:\n        cp = CP_OPEN_MEMO[: N - 1]\n\n    # Calculate Dp (D prime).\n    Dp = np.empty((N, dim))\n    Dp[0] = 0.5 * A[0] + A[1]\n    AUX = 4 * A[1 : N - 1] + 2 * A[2:N]  # Vectorize the sum for efficiency.\n    for i in range(1, N - 1):\n        Dp[i] = cp[i] * (AUX[i - 1] - Dp[i - 1])\n    Dp[N - 1] = (1 / (7 - 2 * cp[N - 2])) * (8 * A[N - 1] + A[N] - 2 * Dp[N - 2])\n\n    # Backward Substitution.\n    # H1 (array of the first handles) is defined as a view of Dp for efficiency\n    # and semantic convenience at the same time.\n    H1 = Dp\n    # H1[N-1] = Dp[N-1] (redundant)\n    for i in range(N - 2, -1, -1):\n        H1[i] = Dp[i] - cp[i] * H1[i + 1]\n\n    # Calculate H2.\n    H2 = np.empty((N, dim))\n    H2[0 : N - 1] = 2 * A[1:N] - H1[1:N]\n    H2[N - 1] = 0.5 * (A[N] + H1[N - 1])\n\n    return H1, H2"}, {"name": "get_template_names", "code": "def get_template_names() -> list[str]:\n    \"\"\"Returns template names from the templates directory.\n\n    Returns\n    -------\n        :class:`list`\n    \"\"\"\n    template_path = Path.resolve(Path(__file__).parent.parent / \"templates\")\n    return [template_name.stem for template_name in template_path.glob(\"*.mtp\")]"}, {"name": "get_template_path", "code": "def get_template_path() -> Path:\n    \"\"\"Returns the Path of templates directory.\n\n    Returns\n    -------\n        :class:`Path`\n    \"\"\"\n    return Path.resolve(Path(__file__).parent.parent / \"templates\")"}, {"name": "get_unit_normal", "code": "def get_unit_normal(v1: Vector3D, v2: Vector3D, tol: float = 1e-6) -> Vector3D:\n    \"\"\"Gets the unit normal of the vectors.\n\n    Parameters\n    ----------\n    v1\n        The first vector.\n    v2\n        The second vector\n    tol\n        [description], by default 1e-6\n\n    Returns\n    -------\n    np.ndarray\n        The normal of the two vectors.\n    \"\"\"\n    # Instead of normalizing v1 and v2, just divide by the greatest\n    # of all their absolute components, which is just enough\n    div1, div2 = max(np.abs(v1)), max(np.abs(v2))\n    if div1 == 0.0:\n        if div2 == 0.0:\n            return DOWN\n        u = v2 / div2\n    elif div2 == 0.0:\n        u = v1 / div1\n    else:\n        # Normal scenario: v1 and v2 are both non-null\n        u1, u2 = v1 / div1, v2 / div2\n        cp = cross(u1, u2)\n        cp_norm = np.sqrt(norm_squared(cp))\n        if cp_norm > tol:\n            return cp / cp_norm\n        # Otherwise, v1 and v2 were aligned\n        u = u1\n\n    # If you are here, you have an \"unique\", non-zero, unit-ish vector u\n    # If it's also too aligned to the Z axis, just return DOWN\n    if abs(u[0]) < tol and abs(u[1]) < tol:\n        return DOWN\n    # Otherwise rotate u in the plane it shares with the Z axis,\n    # 90\u00b0 TOWARDS the Z axis. This is done via (u x [0, 0, 1]) x u,\n    # which gives [-xz, -yz, x\u00b2+y\u00b2] (slightly scaled as well)\n    cp = np.array([-u[0] * u[2], -u[1] * u[2], u[0] * u[0] + u[1] * u[1]])\n    cp_norm = np.sqrt(norm_squared(cp))\n    # Because the norm(u) == 0 case was filtered in the beginning,\n    # there is no need to check if the norm of cp is 0\n    return cp / cp_norm"}, {"name": "get_vectorized_mobject_class", "code": "def get_vectorized_mobject_class() -> type:\n    \"\"\"Gets the vectorized mobject class, depending on the currently\n    active renderer.\n\n    .. NOTE::\n\n        This method is intended to be used in the code base of Manim itself\n        or in plugins where code should work independent of the selected\n        renderer.\n\n    Examples\n    --------\n\n    The function has to be explicitly imported. We test that\n    the name of the returned class is one of the known mobject\n    base classes::\n\n        >>> from manim.mobject.utils import get_vectorized_mobject_class\n        >>> get_vectorized_mobject_class().__name__ in ['VMobject', 'OpenGLVMobject']\n        True\n    \"\"\"\n    if config.renderer == RendererType.CAIRO:\n        return VMobject\n    if config.renderer == RendererType.OPENGL:\n        return OpenGLVMobject\n    raise NotImplementedError(\n        \"Vectorized mobjects are not implemented for the active renderer.\"\n    )"}, {"name": "get_video_metadata", "code": "def get_video_metadata(path_to_video: str | os.PathLike) -> VideoMetadata:\n    with av.open(str(path_to_video)) as container:\n        stream = container.streams.video[0]\n        ctxt = stream.codec_context\n        rate = stream.average_rate\n        if stream.duration is not None:\n            duration = float(stream.duration * stream.time_base)\n            num_frames = stream.frames\n        else:\n            num_frames = sum(1 for _ in container.decode(video=0))\n            duration = float(num_frames / stream.base_rate)\n\n        return {\n            \"width\": ctxt.width,\n            \"height\": ctxt.height,\n            \"nb_frames\": str(num_frames),\n            \"duration\": f\"{duration:.6f}\",\n            \"avg_frame_rate\": f\"{rate.numerator}/{rate.denominator}\",  # Can be a Fraction\n            \"codec_name\": stream.codec_context.name,\n            \"pix_fmt\": stream.codec_context.pix_fmt,\n        }"}, {"name": "get_winding_number", "code": "def get_winding_number(points: Sequence[np.ndarray]) -> float:\n    \"\"\"Determine the number of times a polygon winds around the origin.\n\n    The orientation is measured mathematically positively, i.e.,\n    counterclockwise.\n\n    Parameters\n    ----------\n    points\n        The vertices of the polygon being queried.\n\n    Examples\n    --------\n\n    >>> from manim import Square, get_winding_number\n    >>> polygon = Square()\n    >>> get_winding_number(polygon.get_vertices())\n    np.float64(1.0)\n    >>> polygon.shift(2 * UP)\n    Square\n    >>> get_winding_number(polygon.get_vertices())\n    np.float64(0.0)\n    \"\"\"\n    total_angle: float = 0\n    for p1, p2 in adjacent_pairs(points):\n        d_angle = angle_of_vector(p2) - angle_of_vector(p1)\n        d_angle = ((d_angle + PI) % TAU) - PI\n        total_angle += d_angle\n    val: float = total_angle / TAU\n    return val"}, {"name": "Graph", "code": "class Graph(GenericGraph):\n    \"\"\"An undirected graph (vertices connected with edges).\n\n    The graph comes with an updater which makes the edges stick to\n    the vertices when moved around. See :class:`.DiGraph` for\n    a version with directed edges.\n\n    See also\n    --------\n\n    :class:`.GenericGraph`\n\n    Parameters\n    ----------\n\n    vertices\n        A list of vertices. Must be hashable elements.\n    edges\n        A list of edges, specified as tuples ``(u, v)`` where both ``u``\n        and ``v`` are vertices. The vertex order is irrelevant.\n    labels\n        Controls whether or not vertices are labeled. If ``False`` (the default),\n        the vertices are not labeled; if ``True`` they are labeled using their\n        names (as specified in ``vertices``) via :class:`~.MathTex`. Alternatively,\n        custom labels can be specified by passing a dictionary whose keys are\n        the vertices, and whose values are the corresponding vertex labels\n        (rendered via, e.g., :class:`~.Text` or :class:`~.Tex`).\n    label_fill_color\n        Sets the fill color of the default labels generated when ``labels``\n        is set to ``True``. Has no effect for other values of ``labels``.\n    layout\n        Either one of ``\"spring\"`` (the default), ``\"circular\"``, ``\"kamada_kawai\"``,\n        ``\"planar\"``, ``\"random\"``, ``\"shell\"``, ``\"spectral\"``, ``\"spiral\"``, ``\"tree\"``, and ``\"partite\"``\n        for automatic vertex positioning using ``networkx``\n        (see `their documentation <https://networkx.org/documentation/stable/reference/drawing.html#module-networkx.drawing.layout>`_\n        for more details), or a dictionary specifying a coordinate (value)\n        for each vertex (key) for manual positioning.\n    layout_config\n        Only for automatically generated layouts. A dictionary whose entries\n        are passed as keyword arguments to the automatic layout algorithm\n        specified via ``layout`` of ``networkx``.\n        The ``tree`` layout also accepts a special parameter ``vertex_spacing``\n        passed as a keyword argument inside the ``layout_config`` dictionary.\n        Passing a tuple ``(space_x, space_y)`` as this argument overrides\n        the value of ``layout_scale`` and ensures that vertices are arranged\n        in a way such that the centers of siblings in the same layer are\n        at least ``space_x`` units apart horizontally, and neighboring layers\n        are spaced ``space_y`` units vertically.\n    layout_scale\n        The scale of automatically generated layouts: the vertices will\n        be arranged such that the coordinates are located within the\n        interval ``[-scale, scale]``. Some layouts accept a tuple ``(scale_x, scale_y)``\n        causing the first coordinate to be in the interval ``[-scale_x, scale_x]``,\n        and the second in ``[-scale_y, scale_y]``. Default: 2.\n    vertex_type\n        The mobject class used for displaying vertices in the scene.\n    vertex_config\n        Either a dictionary containing keyword arguments to be passed to\n        the class specified via ``vertex_type``, or a dictionary whose keys\n        are the vertices, and whose values are dictionaries containing keyword\n        arguments for the mobject related to the corresponding vertex.\n    vertex_mobjects\n        A dictionary whose keys are the vertices, and whose values are\n        mobjects to be used as vertices. Passing vertices here overrides\n        all other configuration options for a vertex.\n    edge_type\n        The mobject class used for displaying edges in the scene.\n    edge_config\n        Either a dictionary containing keyword arguments to be passed\n        to the class specified via ``edge_type``, or a dictionary whose\n        keys are the edges, and whose values are dictionaries containing\n        keyword arguments for the mobject related to the corresponding edge.\n\n\n    Examples\n    --------\n\n    First, we create a small graph and demonstrate that the edges move\n    together with the vertices.\n\n    .. manim:: MovingVertices\n\n        class MovingVertices(Scene):\n            def construct(self):\n                vertices = [1, 2, 3, 4]\n                edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]\n                g = Graph(vertices, edges)\n                self.play(Create(g))\n                self.wait()\n                self.play(g[1].animate.move_to([1, 1, 0]),\n                          g[2].animate.move_to([-1, 1, 0]),\n                          g[3].animate.move_to([1, -1, 0]),\n                          g[4].animate.move_to([-1, -1, 0]))\n                self.wait()\n\n    There are several automatic positioning algorithms to choose from:\n\n    .. manim:: GraphAutoPosition\n        :save_last_frame:\n\n        class GraphAutoPosition(Scene):\n            def construct(self):\n                vertices = [1, 2, 3, 4, 5, 6, 7, 8]\n                edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),\n                         (2, 8), (3, 4), (6, 1), (6, 2),\n                         (6, 3), (7, 2), (7, 4)]\n                autolayouts = [\"spring\", \"circular\", \"kamada_kawai\",\n                               \"planar\", \"random\", \"shell\",\n                               \"spectral\", \"spiral\"]\n                graphs = [Graph(vertices, edges, layout=lt).scale(0.5)\n                          for lt in autolayouts]\n                r1 = VGroup(*graphs[:3]).arrange()\n                r2 = VGroup(*graphs[3:6]).arrange()\n                r3 = VGroup(*graphs[6:]).arrange()\n                self.add(VGroup(r1, r2, r3).arrange(direction=DOWN))\n\n    Vertices can also be positioned manually:\n\n    .. manim:: GraphManualPosition\n        :save_last_frame:\n\n        class GraphManualPosition(Scene):\n            def construct(self):\n                vertices = [1, 2, 3, 4]\n                edges = [(1, 2), (2, 3), (3, 4), (4, 1)]\n                lt = {1: [0, 0, 0], 2: [1, 1, 0], 3: [1, -1, 0], 4: [-1, 0, 0]}\n                G = Graph(vertices, edges, layout=lt)\n                self.add(G)\n\n    The vertices in graphs can be labeled, and configurations for vertices\n    and edges can be modified both by default and for specific vertices and\n    edges.\n\n    .. note::\n\n        In ``edge_config``, edges can be passed in both directions: if\n        ``(u, v)`` is an edge in the graph, both ``(u, v)`` as well\n        as ``(v, u)`` can be used as keys in the dictionary.\n\n    .. manim:: LabeledModifiedGraph\n        :save_last_frame:\n\n        class LabeledModifiedGraph(Scene):\n            def construct(self):\n                vertices = [1, 2, 3, 4, 5, 6, 7, 8]\n                edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),\n                         (2, 8), (3, 4), (6, 1), (6, 2),\n                         (6, 3), (7, 2), (7, 4)]\n                g = Graph(vertices, edges, layout=\"circular\", layout_scale=3,\n                          labels=True, vertex_config={7: {\"fill_color\": RED}},\n                          edge_config={(1, 7): {\"stroke_color\": RED},\n                                       (2, 7): {\"stroke_color\": RED},\n                                       (4, 7): {\"stroke_color\": RED}})\n                self.add(g)\n\n    You can also lay out a partite graph on columns by specifying\n    a list of the vertices on each side and choosing the partite layout.\n\n    .. note::\n\n        All vertices in your graph which are not listed in any of the partitions\n        are collected in their own partition and rendered in the rightmost column.\n\n    .. manim:: PartiteGraph\n        :save_last_frame:\n\n        import networkx as nx\n\n        class PartiteGraph(Scene):\n            def construct(self):\n                G = nx.Graph()\n                G.add_nodes_from([0, 1, 2, 3])\n                G.add_edges_from([(0, 2), (0,3), (1, 2)])\n                graph = Graph(list(G.nodes), list(G.edges), layout=\"partite\", partitions=[[0, 1]])\n                self.play(Create(graph))\n\n    The representation of a linear artificial neural network is facilitated\n    by the use of the partite layout and defining partitions for each layer.\n\n    .. manim:: LinearNN\n        :save_last_frame:\n\n        class LinearNN(Scene):\n            def construct(self):\n                edges = []\n                partitions = []\n                c = 0\n                layers = [2, 3, 3, 2]  # the number of neurons in each layer\n\n                for i in layers:\n                    partitions.append(list(range(c + 1, c + i + 1)))\n                    c += i\n                for i, v in enumerate(layers[1:]):\n                        last = sum(layers[:i+1])\n                        for j in range(v):\n                            for k in range(last - layers[i], last):\n                                edges.append((k + 1, j + last + 1))\n\n                vertices = np.arange(1, sum(layers) + 1)\n\n                graph = Graph(\n                    vertices,\n                    edges,\n                    layout='partite',\n                    partitions=partitions,\n                    layout_scale=3,\n                    vertex_config={'radius': 0.20},\n                )\n                self.add(graph)\n\n    The custom tree layout can be used to show the graph\n    by distance from the root vertex. You must pass the root vertex\n    of the tree.\n\n    .. manim:: Tree\n\n        import networkx as nx\n\n        class Tree(Scene):\n            def construct(self):\n                G = nx.Graph()\n\n                G.add_node(\"ROOT\")\n\n                for i in range(5):\n                    G.add_node(\"Child_%i\" % i)\n                    G.add_node(\"Grandchild_%i\" % i)\n                    G.add_node(\"Greatgrandchild_%i\" % i)\n\n                    G.add_edge(\"ROOT\", \"Child_%i\" % i)\n                    G.add_edge(\"Child_%i\" % i, \"Grandchild_%i\" % i)\n                    G.add_edge(\"Grandchild_%i\" % i, \"Greatgrandchild_%i\" % i)\n\n                self.play(Create(\n                    Graph(list(G.nodes), list(G.edges), layout=\"tree\", root_vertex=\"ROOT\")))\n\n    The following code sample illustrates the use of the ``vertex_spacing``\n    layout parameter specific to the ``\"tree\"`` layout. As mentioned\n    above, setting ``vertex_spacing`` overrides the specified value\n    for ``layout_scale``, and as such it is harder to control the size\n    of the mobject. However, we can adjust the captured frame and\n    zoom out by using a :class:`.MovingCameraScene`::\n\n        class LargeTreeGeneration(MovingCameraScene):\n            DEPTH = 4\n            CHILDREN_PER_VERTEX = 3\n            LAYOUT_CONFIG = {\"vertex_spacing\": (0.5, 1)}\n            VERTEX_CONF = {\"radius\": 0.25, \"color\": BLUE_B, \"fill_opacity\": 1}\n\n            def expand_vertex(self, g, vertex_id: str, depth: int):\n                new_vertices = [\n                    f\"{vertex_id}/{i}\" for i in range(self.CHILDREN_PER_VERTEX)\n                ]\n                new_edges = [(vertex_id, child_id) for child_id in new_vertices]\n                g.add_edges(\n                    *new_edges,\n                    vertex_config=self.VERTEX_CONF,\n                    positions={\n                        k: g.vertices[vertex_id].get_center() + 0.1 * DOWN\n                        for k in new_vertices\n                    },\n                )\n                if depth < self.DEPTH:\n                    for child_id in new_vertices:\n                        self.expand_vertex(g, child_id, depth + 1)\n\n                return g\n\n            def construct(self):\n                g = Graph([\"ROOT\"], [], vertex_config=self.VERTEX_CONF)\n                g = self.expand_vertex(g, \"ROOT\", 1)\n                self.add(g)\n\n                self.play(\n                    g.animate.change_layout(\n                        \"tree\",\n                        root_vertex=\"ROOT\",\n                        layout_config=self.LAYOUT_CONFIG,\n                    )\n                )\n                self.play(self.camera.auto_zoom(g, margin=1), run_time=0.5)\n    \"\"\"\n\n    @staticmethod\n    def _empty_networkx_graph() -> nx.Graph:\n        return nx.Graph()\n\n    def _populate_edge_dict(\n        self, edges: list[tuple[Hashable, Hashable]], edge_type: type[Mobject]\n    ):\n        self.edges = {\n            (u, v): edge_type(\n                start=self[u].get_center(),\n                end=self[v].get_center(),\n                z_index=-1,\n                **self._edge_config[(u, v)],\n            )\n            for (u, v) in edges\n        }\n\n    def update_edges(self, graph):\n        for (u, v), edge in graph.edges.items():\n            # Undirected graph has a Line edge\n            edge.set_points_by_ends(\n                graph[u].get_center(),\n                graph[v].get_center(),\n                buff=self._edge_config.get(\"buff\", 0),\n                path_arc=self._edge_config.get(\"path_arc\", 0),\n            )\n\n    def __repr__(self: Graph) -> str:\n        return f\"Undirected graph on {len(self.vertices)} vertices and {len(self.edges)} edges\""}, {"name": "Group", "code": "class Group(Mobject, metaclass=ConvertToOpenGL):\n    \"\"\"Groups together multiple :class:`Mobjects <.Mobject>`.\n\n    Notes\n    -----\n    When adding the same mobject more than once, repetitions are ignored.\n    Use :meth:`.Mobject.copy` to create a separate copy which can then\n    be added to the group.\n    \"\"\"\n\n    def __init__(self, *mobjects, **kwargs) -> None:\n        super().__init__(**kwargs)\n        self.add(*mobjects)"}, {"name": "GrowArrow", "code": "class GrowArrow(GrowFromPoint):\n    \"\"\"Introduce an :class:`~.Arrow` by growing it from its start toward its tip.\n\n    Parameters\n    ----------\n    arrow\n        The arrow to be introduced.\n    point_color\n        Initial color of the arrow before growing to its full size. Leave empty to match arrow's color.\n\n    Examples\n    --------\n\n    .. manim :: GrowArrowExample\n\n        class GrowArrowExample(Scene):\n            def construct(self):\n                arrows = [Arrow(2 * LEFT, 2 * RIGHT), Arrow(2 * DR, 2 * UL)]\n                VGroup(*arrows).set_x(0).arrange(buff=2)\n                self.play(GrowArrow(arrows[0]))\n                self.play(GrowArrow(arrows[1], point_color=RED))\n\n    \"\"\"\n\n    def __init__(self, arrow: Arrow, point_color: str = None, **kwargs) -> None:\n        point = arrow.get_start()\n        super().__init__(arrow, point, point_color=point_color, **kwargs)\n\n    def create_starting_mobject(self) -> Mobject:\n        start_arrow = self.mobject.copy()\n        start_arrow.scale(0, scale_tips=True, about_point=self.point)\n        if self.point_color:\n            start_arrow.set_color(self.point_color)\n        return start_arrow"}, {"name": "GrowFromCenter", "code": "class GrowFromCenter(GrowFromPoint):\n    \"\"\"Introduce an :class:`~.Mobject` by growing it from its center.\n\n    Parameters\n    ----------\n    mobject\n        The mobjects to be introduced.\n    point_color\n        Initial color of the mobject before growing to its full size. Leave empty to match mobject's color.\n\n    Examples\n    --------\n\n    .. manim :: GrowFromCenterExample\n\n        class GrowFromCenterExample(Scene):\n            def construct(self):\n                squares = [Square() for _ in range(2)]\n                VGroup(*squares).set_x(0).arrange(buff=2)\n                self.play(GrowFromCenter(squares[0]))\n                self.play(GrowFromCenter(squares[1], point_color=RED))\n\n    \"\"\"\n\n    def __init__(self, mobject: Mobject, point_color: str = None, **kwargs) -> None:\n        point = mobject.get_center()\n        super().__init__(mobject, point, point_color=point_color, **kwargs)"}, {"name": "GrowFromEdge", "code": "class GrowFromEdge(GrowFromPoint):\n    \"\"\"Introduce an :class:`~.Mobject` by growing it from one of its bounding box edges.\n\n    Parameters\n    ----------\n    mobject\n        The mobjects to be introduced.\n    edge\n        The direction to seek bounding box edge of mobject.\n    point_color\n        Initial color of the mobject before growing to its full size. Leave empty to match mobject's color.\n\n    Examples\n    --------\n\n    .. manim :: GrowFromEdgeExample\n\n        class GrowFromEdgeExample(Scene):\n            def construct(self):\n                squares = [Square() for _ in range(4)]\n                VGroup(*squares).set_x(0).arrange(buff=1)\n                self.play(GrowFromEdge(squares[0], DOWN))\n                self.play(GrowFromEdge(squares[1], RIGHT))\n                self.play(GrowFromEdge(squares[2], UR))\n                self.play(GrowFromEdge(squares[3], UP, point_color=RED))\n\n\n    \"\"\"\n\n    def __init__(\n        self, mobject: Mobject, edge: np.ndarray, point_color: str = None, **kwargs\n    ) -> None:\n        point = mobject.get_critical_point(edge)\n        super().__init__(mobject, point, point_color=point_color, **kwargs)"}, {"name": "GrowFromPoint", "code": "class GrowFromPoint(Transform):\n    \"\"\"Introduce an :class:`~.Mobject` by growing it from a point.\n\n    Parameters\n    ----------\n    mobject\n        The mobjects to be introduced.\n    point\n        The point from which the mobject grows.\n    point_color\n        Initial color of the mobject before growing to its full size. Leave empty to match mobject's color.\n\n    Examples\n    --------\n\n    .. manim :: GrowFromPointExample\n\n        class GrowFromPointExample(Scene):\n            def construct(self):\n                dot = Dot(3 * UR, color=GREEN)\n                squares = [Square() for _ in range(4)]\n                VGroup(*squares).set_x(0).arrange(buff=1)\n                self.add(dot)\n                self.play(GrowFromPoint(squares[0], ORIGIN))\n                self.play(GrowFromPoint(squares[1], [-2, 2, 0]))\n                self.play(GrowFromPoint(squares[2], [3, -2, 0], RED))\n                self.play(GrowFromPoint(squares[3], dot, dot.get_color()))\n\n    \"\"\"\n\n    def __init__(\n        self, mobject: Mobject, point: np.ndarray, point_color: str = None, **kwargs\n    ) -> None:\n        self.point = point\n        self.point_color = point_color\n        super().__init__(mobject, introducer=True, **kwargs)\n\n    def create_target(self) -> Mobject:\n        return self.mobject\n\n    def create_starting_mobject(self) -> Mobject:\n        start = super().create_starting_mobject()\n        start.scale(0)\n        start.move_to(self.point)\n        if self.point_color:\n            start.set_color(self.point_color)\n        return start"}, {"name": "guarantee_empty_existence", "code": "def guarantee_empty_existence(path: Path) -> Path:\n    if path.exists():\n        shutil.rmtree(str(path))\n    path.mkdir(parents=True)\n    return path.resolve(strict=True)"}, {"name": "guarantee_existence", "code": "def guarantee_existence(path: Path) -> Path:\n    if not path.exists():\n        path.mkdir(parents=True)\n    return path.resolve(strict=True)"}, {"name": "handle_caching_play", "code": "def handle_caching_play(func: Callable[..., None]) -> Callable[..., None]:\n    \"\"\"Decorator that returns a wrapped version of func that will compute\n    the hash of the play invocation.\n\n    The returned function will act according to the computed hash: either skip\n    the animation because it's already cached, or let the invoked function\n    play normally.\n\n    Parameters\n    ----------\n    func\n        The play like function that has to be written to the video file stream.\n        Take the same parameters as `scene.play`.\n    \"\"\"\n    # NOTE : This is only kept for OpenGL renderer.\n    # The play logic of the cairo renderer as been refactored and does not need this function anymore.\n    # When OpenGL renderer will have a proper testing system,\n    # the play logic of the latter has to be refactored in the same way the cairo renderer has been, and thus this\n    # method has to be deleted.\n\n    def wrapper(self: OpenGLRenderer, scene: Scene, *args: Any, **kwargs: Any) -> None:\n        self.skip_animations = self._original_skipping_status\n        self.update_skipping_status()\n        animations = scene.compile_animations(*args, **kwargs)\n        scene.add_mobjects_from_animations(animations)\n        if self.skip_animations:\n            logger.debug(f\"Skipping animation {self.num_plays}\")\n            func(self, scene, *args, **kwargs)\n            # If the animation is skipped, we mark its hash as None.\n            # When sceneFileWriter will start combining partial movie files, it won't take into account None hashes.\n            self.animations_hashes.append(None)\n            self.file_writer.add_partial_movie_file(None)\n            return\n        if not config[\"disable_caching\"]:\n            mobjects_on_scene = scene.mobjects\n            # TODO: the first argument seems wrong. Shouldn't it be scene instead?\n            hash_play = get_hash_from_play_call(\n                self,  # type: ignore[arg-type]\n                self.camera,\n                animations,\n                mobjects_on_scene,\n            )\n            if self.file_writer.is_already_cached(hash_play):\n                logger.info(\n                    f\"Animation {self.num_plays} : Using cached data (hash : %(hash_play)s)\",\n                    {\"hash_play\": hash_play},\n                )\n                self.skip_animations = True\n        else:\n            hash_play = f\"uncached_{self.num_plays:05}\"\n        self.animations_hashes.append(hash_play)\n        self.file_writer.add_partial_movie_file(hash_play)\n        logger.debug(\n            \"List of the first few animation hashes of the scene: %(h)s\",\n            {\"h\": str(self.animations_hashes[:5])},\n        )\n        func(self, scene, *args, **kwargs)\n\n    return wrapper"}, {"name": "hash_obj", "code": "def hash_obj(obj: object) -> int:\n    \"\"\"Determines a hash, even of potentially mutable objects.\"\"\"\n    if isinstance(obj, dict):\n        return hash(tuple(sorted((hash_obj(k), hash_obj(v)) for k, v in obj.items())))\n\n    if isinstance(obj, set):\n        return hash(tuple(sorted(hash_obj(e) for e in obj)))\n\n    if isinstance(obj, (tuple, list)):\n        return hash(tuple(hash_obj(e) for e in obj))\n\n    return hash(obj)"}, {"name": "healthcheck", "code": "def healthcheck(\n    description: str,\n    recommendation: str,\n    skip_on_failed: list[HealthCheckFunction | str] | None = None,\n    post_fail_fix_hook: Callable[..., object] | None = None,\n) -> Callable[[Callable[[], bool]], HealthCheckFunction]:\n    \"\"\"Decorator used for declaring health checks.\n\n    This decorator attaches some data to a function, which is then added to a\n    a list containing all checks.\n\n    Parameters\n    ----------\n    description\n        A brief description of this check, displayed when the ``checkhealth``\n        subcommand is run.\n    recommendation\n        Help text which is displayed in case the check fails.\n    skip_on_failed\n        A list of check functions which, if they fail, cause the current check\n        to be skipped.\n    post_fail_fix_hook\n        A function that is meant to (interactively) help to fix the detected\n        problem, if possible. This is only called upon explicit confirmation of\n        the user.\n\n    Returns\n    -------\n    Callable[Callable[[], bool], :class:`HealthCheckFunction`]\n        A decorator which converts a function into a health check function, as\n        required by the ``checkhealth`` subcommand.\n    \"\"\"\n    new_skip_on_failed: list[str]\n    if skip_on_failed is None:\n        new_skip_on_failed = []\n    else:\n        new_skip_on_failed = [\n            skip.__name__ if callable(skip) else skip for skip in skip_on_failed\n        ]\n\n    def wrapper(func: Callable[[], bool]) -> HealthCheckFunction:\n        health_func = cast(HealthCheckFunction, func)\n        health_func.description = description\n        health_func.recommendation = recommendation\n        health_func.skip_on_failed = new_skip_on_failed\n        health_func.post_fail_fix_hook = post_fail_fix_hook\n        HEALTH_CHECKS.append(health_func)\n        return health_func\n\n    return wrapper"}, {"name": "HealthCheckFunction", "code": "class HealthCheckFunction(Protocol):\n    description: str\n    recommendation: str\n    skip_on_failed: list[str]\n    post_fail_fix_hook: Callable[..., object] | None\n    __name__: str\n\n    def __call__(self) -> bool: ..."}, {"name": "hex_to_rgb", "code": "def hex_to_rgb(hex_code: str) -> RGB_Array_Float:\n    \"\"\"Helper function for use in functional style programming. Refer to\n    :meth:`ManimColor.to_rgb`.\n\n    Parameters\n    ----------\n    hex_code\n        A hex string representing a color.\n\n    Returns\n    -------\n    RGB_Array_Float\n        An RGB array representing the color.\n    \"\"\"\n    return ManimColor(hex_code).to_rgb()"}, {"name": "Homotopy", "code": "class Homotopy(Animation):\n    \"\"\"A Homotopy.\n\n    This is an animation transforming the points of a mobject according\n    to the specified transformation function. With the parameter :math:`t`\n    moving from 0 to 1 throughout the animation and :math:`(x, y, z)`\n    describing the coordinates of the point of a mobject,\n    the function passed to the ``homotopy`` keyword argument should\n    transform the tuple :math:`(x, y, z, t)` to :math:`(x', y', z')`,\n    the coordinates the original point is transformed to at time :math:`t`.\n\n    Parameters\n    ----------\n    homotopy\n        A function mapping :math:`(x, y, z, t)` to :math:`(x', y', z')`.\n    mobject\n        The mobject transformed under the given homotopy.\n    run_time\n        The run time of the animation.\n    apply_function_kwargs\n        Keyword arguments propagated to :meth:`.Mobject.apply_function`.\n    kwargs\n        Further keyword arguments passed to the parent class.\n\n    Examples\n    --------\n\n    .. manim:: HomotopyExample\n\n        class HomotopyExample(Scene):\n            def construct(self):\n                square = Square()\n\n                def homotopy(x, y, z, t):\n                    if t <= 0.25:\n                        progress = t / 0.25\n                        return (x, y + progress * 0.2 * np.sin(x), z)\n                    else:\n                        wave_progress = (t - 0.25) / 0.75\n                        return (x, y + 0.2 * np.sin(x + 10 * wave_progress), z)\n\n                self.play(Homotopy(homotopy, square, rate_func= linear, run_time=2))\n\n    \"\"\"\n\n    def __init__(\n        self,\n        homotopy: Callable[[float, float, float, float], tuple[float, float, float]],\n        mobject: Mobject,\n        run_time: float = 3,\n        apply_function_kwargs: dict[str, Any] | None = None,\n        **kwargs,\n    ) -> None:\n        self.homotopy = homotopy\n        self.apply_function_kwargs = (\n            apply_function_kwargs if apply_function_kwargs is not None else {}\n        )\n        super().__init__(mobject, run_time=run_time, **kwargs)\n\n    def function_at_time_t(self, t: float) -> tuple[float, float, float]:\n        return lambda p: self.homotopy(*p, t)\n\n    def interpolate_submobject(\n        self,\n        submobject: Mobject,\n        starting_submobject: Mobject,\n        alpha: float,\n    ) -> None:\n        submobject.points = starting_submobject.points\n        submobject.apply_function(\n            self.function_at_time_t(alpha), **self.apply_function_kwargs\n        )"}, {"name": "Horizon", "code": "class Horizon:\n    def __init__(self) -> None:\n        self.facets: set[Facet] = set()\n        self.boundary: list[SubFacet] = []"}, {"name": "HSV", "code": "class HSV(ManimColor):\n    \"\"\"HSV Color Space\"\"\"\n\n    def __init__(\n        self,\n        hsv: HSV_Array_Float | HSV_Tuple_Float | HSVA_Array_Float | HSVA_Tuple_Float,\n        alpha: float = 1.0,\n    ) -> None:\n        super().__init__(None)\n        self.__hsv: HSVA_Array_Float\n        if len(hsv) == 3:\n            self.__hsv = np.asarray((*hsv, alpha))\n        elif len(hsv) == 4:\n            self.__hsv = np.asarray(hsv)\n        else:\n            raise ValueError(\"HSV Color must be an array of 3 values\")\n\n    @classmethod\n    @override\n    def _from_internal(cls, value: ManimColorInternal) -> Self:\n        hsv = colorsys.rgb_to_hsv(*value[:3])\n        hsva = [*hsv, value[-1]]\n        return cls(np.array(hsva))\n\n    @property\n    def hue(self) -> float:\n        hue: float = self.__hsv[0]\n        return hue\n\n    @hue.setter\n    def hue(self, hue: float) -> None:\n        self.__hsv[0] = hue\n\n    @property\n    def saturation(self) -> float:\n        saturation: float = self.__hsv[1]\n        return saturation\n\n    @saturation.setter\n    def saturation(self, saturation: float) -> None:\n        self.__hsv[1] = saturation\n\n    @property\n    def value(self) -> float:\n        value: float = self.__hsv[2]\n        return value\n\n    @value.setter\n    def value(self, value: float) -> None:\n        self.__hsv[2] = value\n\n    @property\n    def h(self) -> float:\n        hue: float = self.__hsv[0]\n        return hue\n\n    @h.setter\n    def h(self, hue: float) -> None:\n        self.__hsv[0] = hue\n\n    @property\n    def s(self) -> float:\n        saturation: float = self.__hsv[1]\n        return saturation\n\n    @s.setter\n    def s(self, saturation: float) -> None:\n        self.__hsv[1] = saturation\n\n    @property\n    def v(self) -> float:\n        value: float = self.__hsv[2]\n        return value\n\n    @v.setter\n    def v(self, value: float) -> None:\n        self.__hsv[2] = value\n\n    @property\n    def _internal_space(self) -> npt.NDArray:\n        return self.__hsv\n\n    @property\n    def _internal_value(self) -> ManimColorInternal:\n        \"\"\"Return the internal value of the current :class:`ManimColor` as an\n        ``[r,g,b,a]`` float array.\n\n        Returns\n        -------\n        ManimColorInternal\n            Internal color representation.\n        \"\"\"\n        return np.array(\n            [\n                *colorsys.hsv_to_rgb(self.__hsv[0], self.__hsv[1], self.__hsv[2]),\n                self.__alpha,\n            ],\n            dtype=ManimColorDType,\n        )\n\n    @_internal_value.setter\n    def _internal_value(self, value: ManimColorInternal) -> None:\n        \"\"\"Overwrite the internal color value of this :class:`ManimColor`.\n\n        Parameters\n        ----------\n        value\n            The value which will overwrite the current color.\n\n        Raises\n        ------\n        TypeError\n            If an invalid array is passed.\n        \"\"\"\n        if not isinstance(value, np.ndarray):\n            raise TypeError(\"Value must be a NumPy array.\")\n        if value.shape[0] != 4:\n            raise TypeError(\"Array must have exactly 4 values.\")\n        tmp = colorsys.rgb_to_hsv(value[0], value[1], value[2])\n        self.__hsv = np.array(tmp)\n        self.__alpha = value[3]"}, {"name": "Icosahedron", "code": "class Icosahedron(Polyhedron):\n    \"\"\"An icosahedron, one of the five platonic solids. It has 20 faces, 30 edges and 12 vertices.\n\n    Parameters\n    ----------\n    edge_length\n        The length of an edge between any two vertices.\n\n    Examples\n    --------\n\n    .. manim:: IcosahedronScene\n        :save_last_frame:\n\n        class IcosahedronScene(ThreeDScene):\n            def construct(self):\n                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n                obj = Icosahedron()\n                self.add(obj)\n    \"\"\"\n\n    def __init__(self, edge_length: float = 1, **kwargs):\n        unit_a = edge_length * ((1 + np.sqrt(5)) / 4)\n        unit_b = edge_length * (1 / 2)\n        super().__init__(\n            vertex_coords=[\n                np.array([0, unit_b, unit_a]),\n                np.array([0, -unit_b, unit_a]),\n                np.array([0, unit_b, -unit_a]),\n                np.array([0, -unit_b, -unit_a]),\n                np.array([unit_b, unit_a, 0]),\n                np.array([unit_b, -unit_a, 0]),\n                np.array([-unit_b, unit_a, 0]),\n                np.array([-unit_b, -unit_a, 0]),\n                np.array([unit_a, 0, unit_b]),\n                np.array([unit_a, 0, -unit_b]),\n                np.array([-unit_a, 0, unit_b]),\n                np.array([-unit_a, 0, -unit_b]),\n            ],\n            faces_list=[\n                [1, 8, 0],\n                [1, 5, 7],\n                [8, 5, 1],\n                [7, 3, 5],\n                [5, 9, 3],\n                [8, 9, 5],\n                [3, 2, 9],\n                [9, 4, 2],\n                [8, 4, 9],\n                [0, 4, 8],\n                [6, 4, 0],\n                [6, 2, 4],\n                [11, 2, 6],\n                [3, 11, 2],\n                [0, 6, 10],\n                [10, 1, 0],\n                [10, 7, 1],\n                [11, 7, 3],\n                [10, 11, 7],\n                [10, 11, 6],\n            ],\n            **kwargs,\n        )"}, {"name": "ImageMobject", "code": "class ImageMobject(AbstractImageMobject):\n    \"\"\"Displays an Image from a numpy array or a file.\n\n    Parameters\n    ----------\n    scale_to_resolution\n        At this resolution the image is placed pixel by pixel onto the screen, so it\n        will look the sharpest and best.\n        This is a custom parameter of ImageMobject so that rendering a scene with\n        e.g. the ``--quality low`` or ``--quality medium`` flag for faster rendering\n        won't effect the position of the image on the screen.\n\n\n    Example\n    -------\n    .. manim:: ImageFromArray\n        :save_last_frame:\n\n        class ImageFromArray(Scene):\n            def construct(self):\n                image = ImageMobject(np.uint8([[0, 100, 30, 200],\n                                               [255, 0, 5, 33]]))\n                image.height = 7\n                self.add(image)\n\n\n    Changing interpolation style:\n\n    .. manim:: ImageInterpolationEx\n        :save_last_frame:\n\n        class ImageInterpolationEx(Scene):\n            def construct(self):\n                img = ImageMobject(np.uint8([[63, 0, 0, 0],\n                                                [0, 127, 0, 0],\n                                                [0, 0, 191, 0],\n                                                [0, 0, 0, 255]\n                                                ]))\n\n                img.height = 2\n                img1 = img.copy()\n                img2 = img.copy()\n                img3 = img.copy()\n                img4 = img.copy()\n                img5 = img.copy()\n\n                img1.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"nearest\"])\n                img2.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"lanczos\"])\n                img3.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"linear\"])\n                img4.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"cubic\"])\n                img5.set_resampling_algorithm(RESAMPLING_ALGORITHMS[\"box\"])\n                img1.add(Text(\"nearest\").scale(0.5).next_to(img1,UP))\n                img2.add(Text(\"lanczos\").scale(0.5).next_to(img2,UP))\n                img3.add(Text(\"linear\").scale(0.5).next_to(img3,UP))\n                img4.add(Text(\"cubic\").scale(0.5).next_to(img4,UP))\n                img5.add(Text(\"box\").scale(0.5).next_to(img5,UP))\n\n                x= Group(img1,img2,img3,img4,img5)\n                x.arrange()\n                self.add(x)\n    \"\"\"\n\n    def __init__(\n        self,\n        filename_or_array: StrPath | npt.NDArray,\n        scale_to_resolution: int = QUALITIES[DEFAULT_QUALITY][\"pixel_height\"],\n        invert: bool = False,\n        image_mode: str = \"RGBA\",\n        **kwargs: Any,\n    ) -> None:\n        self.fill_opacity: float = 1\n        self.stroke_opacity: float = 1\n        self.invert_image = invert\n        self.image_mode = image_mode\n        if isinstance(filename_or_array, (str, pathlib.PurePath)):\n            path = get_full_raster_image_path(filename_or_array)\n            image = Image.open(path).convert(self.image_mode)\n            self.pixel_array = np.array(image)\n            self.path = path\n        else:\n            self.pixel_array = np.array(filename_or_array)\n        self.pixel_array_dtype = kwargs.get(\"pixel_array_dtype\", \"uint8\")\n        self.pixel_array = change_to_rgba_array(\n            self.pixel_array, self.pixel_array_dtype\n        )\n        if self.invert_image:\n            self.pixel_array[:, :, :3] = (\n                np.iinfo(self.pixel_array_dtype).max - self.pixel_array[:, :, :3]\n            )\n        super().__init__(scale_to_resolution, **kwargs)\n\n    def get_pixel_array(self):\n        \"\"\"A simple getter method.\"\"\"\n        return self.pixel_array\n\n    def set_color(self, color, alpha=None, family=True):\n        rgb = color_to_int_rgb(color)\n        self.pixel_array[:, :, :3] = rgb\n        if alpha is not None:\n            self.pixel_array[:, :, 3] = int(255 * alpha)\n        for submob in self.submobjects:\n            submob.set_color(color, alpha, family)\n        self.color = color\n        return self\n\n    def set_opacity(self, alpha: float) -> Self:\n        \"\"\"Sets the image's opacity.\n\n        Parameters\n        ----------\n        alpha\n            The alpha value of the object, 1 being opaque and 0 being\n            transparent.\n        \"\"\"\n        self.pixel_array[:, :, 3] = int(255 * alpha)\n        self.fill_opacity = alpha\n        self.stroke_opacity = alpha\n        return self\n\n    def fade(self, darkness: float = 0.5, family: bool = True) -> Self:\n        \"\"\"Sets the image's opacity using a 1 - alpha relationship.\n\n        Parameters\n        ----------\n        darkness\n            The alpha value of the object, 1 being transparent and 0 being\n            opaque.\n        family\n            Whether the submobjects of the ImageMobject should be affected.\n        \"\"\"\n        self.set_opacity(1 - darkness)\n        super().fade(darkness, family)\n        return self\n\n    def interpolate_color(\n        self, mobject1: ImageMobject, mobject2: ImageMobject, alpha: float\n    ) -> None:\n        \"\"\"Interpolates the array of pixel color values from one ImageMobject\n        into an array of equal size in the target ImageMobject.\n\n        Parameters\n        ----------\n        mobject1\n            The ImageMobject to transform from.\n\n        mobject2\n            The ImageMobject to transform into.\n\n        alpha\n            Used to track the lerp relationship. Not opacity related.\n        \"\"\"\n        assert mobject1.pixel_array.shape == mobject2.pixel_array.shape, (\n            f\"Mobject pixel array shapes incompatible for interpolation.\\n\"\n            f\"Mobject 1 ({mobject1}) : {mobject1.pixel_array.shape}\\n\"\n            f\"Mobject 2 ({mobject2}) : {mobject2.pixel_array.shape}\"\n        )\n        self.fill_opacity = interpolate(\n            mobject1.fill_opacity,\n            mobject2.fill_opacity,\n            alpha,\n        )\n        self.stroke_opacity = interpolate(\n            mobject1.stroke_opacity,\n            mobject2.stroke_opacity,\n            alpha,\n        )\n        self.pixel_array = interpolate(\n            mobject1.pixel_array,\n            mobject2.pixel_array,\n            alpha,\n        ).astype(self.pixel_array_dtype)\n\n    def get_style(self) -> dict[str, Any]:\n        return {\n            \"fill_color\": ManimColor(self.color.get_rgb()).to_hex(),\n            \"fill_opacity\": self.fill_opacity,\n        }"}, {"name": "ImageMobjectFromCamera", "code": "class ImageMobjectFromCamera(AbstractImageMobject):\n    def __init__(\n        self,\n        camera,\n        default_display_frame_config: dict[str, Any] | None = None,\n        **kwargs: Any,\n    ) -> None:\n        self.camera = camera\n        if default_display_frame_config is None:\n            default_display_frame_config = {\n                \"stroke_width\": 3,\n                \"stroke_color\": WHITE,\n                \"buff\": 0,\n            }\n        self.default_display_frame_config = default_display_frame_config\n        self.pixel_array = self.camera.pixel_array\n        super().__init__(scale_to_resolution=False, **kwargs)\n\n    # TODO: Get rid of this.\n    def get_pixel_array(self):\n        self.pixel_array = self.camera.pixel_array\n        return self.pixel_array\n\n    def add_display_frame(self, **kwargs: Any) -> Self:\n        config = dict(self.default_display_frame_config)\n        config.update(kwargs)\n        self.display_frame = SurroundingRectangle(self, **config)\n        self.add(self.display_frame)\n        return self\n\n    def interpolate_color(self, mobject1, mobject2, alpha) -> None:\n        assert mobject1.pixel_array.shape == mobject2.pixel_array.shape, (\n            f\"Mobject pixel array shapes incompatible for interpolation.\\n\"\n            f\"Mobject 1 ({mobject1}) : {mobject1.pixel_array.shape}\\n\"\n            f\"Mobject 2 ({mobject2}) : {mobject2.pixel_array.shape}\"\n        )\n        self.pixel_array = interpolate(\n            mobject1.pixel_array,\n            mobject2.pixel_array,\n            alpha,\n        ).astype(self.pixel_array_dtype)"}, {"name": "ImplicitFunction", "code": "class ImplicitFunction(VMobject, metaclass=ConvertToOpenGL):\n    def __init__(\n        self,\n        func: Callable[[float, float], float],\n        x_range: Sequence[float] | None = None,\n        y_range: Sequence[float] | None = None,\n        min_depth: int = 5,\n        max_quads: int = 1500,\n        use_smoothing: bool = True,\n        **kwargs,\n    ):\n        \"\"\"An implicit function.\n\n        Parameters\n        ----------\n        func\n            The implicit function in the form ``f(x, y) = 0``.\n        x_range\n            The x min and max of the function.\n        y_range\n            The y min and max of the function.\n        min_depth\n            The minimum depth of the function to calculate.\n        max_quads\n            The maximum number of quads to use.\n        use_smoothing\n            Whether or not to smoothen the curves.\n        kwargs\n            Additional parameters to pass into :class:`VMobject`\n\n\n        .. note::\n            A small ``min_depth`` :math:`d` means that some small details might\n            be ignored if they don't cross an edge of one of the\n            :math:`4^d` uniform quads.\n\n            The value of ``max_quads`` strongly corresponds to the\n            quality of the curve, but a higher number of quads\n            may take longer to render.\n\n        Examples\n        --------\n        .. manim:: ImplicitFunctionExample\n            :save_last_frame:\n\n            class ImplicitFunctionExample(Scene):\n                def construct(self):\n                    graph = ImplicitFunction(\n                        lambda x, y: x * y ** 2 - x ** 2 * y - 2,\n                        color=YELLOW\n                    )\n                    self.add(NumberPlane(), graph)\n        \"\"\"\n        self.function = func\n        self.min_depth = min_depth\n        self.max_quads = max_quads\n        self.use_smoothing = use_smoothing\n        self.x_range = x_range or [\n            -config.frame_width / 2,\n            config.frame_width / 2,\n        ]\n        self.y_range = y_range or [\n            -config.frame_height / 2,\n            config.frame_height / 2,\n        ]\n\n        super().__init__(**kwargs)\n\n    def generate_points(self):\n        p_min, p_max = (\n            np.array([self.x_range[0], self.y_range[0]]),\n            np.array([self.x_range[1], self.y_range[1]]),\n        )\n        curves = plot_isoline(\n            fn=lambda u: self.function(u[0], u[1]),\n            pmin=p_min,\n            pmax=p_max,\n            min_depth=self.min_depth,\n            max_quads=self.max_quads,\n        )  # returns a list of lists of 2D points\n        curves = [\n            np.pad(curve, [(0, 0), (0, 1)]) for curve in curves if curve != []\n        ]  # add z coord as 0\n        for curve in curves:\n            self.start_new_path(curve[0])\n            self.add_points_as_corners(curve[1:])\n        if self.use_smoothing:\n            self.make_smooth()\n        return self\n\n    init_points = generate_points"}, {"name": "index_labels", "code": "def index_labels(\n    mobject: Mobject,\n    label_height: float = 0.15,\n    background_stroke_width: float = 5,\n    background_stroke_color: ManimColor = BLACK,\n    **kwargs: Any,\n) -> VGroup:\n    r\"\"\"Returns a :class:`~.VGroup` of :class:`~.Integer` mobjects\n    that shows the index of each submobject.\n\n    Useful for working with parts of complicated mobjects.\n\n    Parameters\n    ----------\n    mobject\n        The mobject that will have its submobjects labelled.\n    label_height\n        The height of the labels, by default 0.15.\n    background_stroke_width\n        The stroke width of the outline of the labels, by default 5.\n    background_stroke_color\n        The stroke color of the outline of labels.\n    kwargs\n        Additional parameters to be passed into the :class`~.Integer`\n        mobjects used to construct the labels.\n\n    Examples\n    --------\n    .. manim:: IndexLabelsExample\n        :save_last_frame:\n\n        class IndexLabelsExample(Scene):\n            def construct(self):\n                text = MathTex(\n                    \"\\\\frac{d}{dx}f(x)g(x)=\",\n                    \"f(x)\\\\frac{d}{dx}g(x)\",\n                    \"+\",\n                    \"g(x)\\\\frac{d}{dx}f(x)\",\n                )\n\n                #index the fist term in the MathTex mob\n                indices = index_labels(text[0])\n\n                text[0][1].set_color(PURPLE_B)\n                text[0][8:12].set_color(DARK_BLUE)\n\n                self.add(text, indices)\n    \"\"\"\n    labels = VGroup()\n    for n, submob in enumerate(mobject):\n        label = Integer(n, **kwargs)\n        label.set_stroke(\n            background_stroke_color, background_stroke_width, background=True\n        )\n        label.height = label_height\n        label.move_to(submob)\n        labels.add(label)\n    return labels"}, {"name": "Indicate", "code": "class Indicate(Transform):\n    \"\"\"Indicate a Mobject by temporarily resizing and recoloring it.\n\n    Parameters\n    ----------\n    mobject\n        The mobject to indicate.\n    scale_factor\n        The factor by which the mobject will be temporally scaled\n    color\n        The color the mobject temporally takes.\n    rate_func\n        The function defining the animation progress at every point in time.\n    kwargs\n        Additional arguments to be passed to the :class:`~.Succession` constructor\n\n    Examples\n    --------\n    .. manim:: UsingIndicate\n\n        class UsingIndicate(Scene):\n            def construct(self):\n                tex = Tex(\"Indicate\").scale(3)\n                self.play(Indicate(tex))\n                self.wait()\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        scale_factor: float = 1.2,\n        color: str = YELLOW,\n        rate_func: Callable[[float, float | None], np.ndarray] = there_and_back,\n        **kwargs,\n    ) -> None:\n        self.color = color\n        self.scale_factor = scale_factor\n        super().__init__(mobject, rate_func=rate_func, **kwargs)\n\n    def create_target(self) -> Mobject:\n        target = self.mobject.copy()\n        target.scale(self.scale_factor)\n        target.set_color(self.color)\n        return target"}, {"name": "init", "code": "def init(ctx: cloup.Context) -> None:\n    pass"}, {"name": "insight_inputenc_error", "code": "def insight_inputenc_error(matching: Match[str]) -> Generator[str]:\n    code_point = chr(int(matching[1], 16))\n    name = unicodedata.name(code_point)\n    yield f\"TexTemplate does not support character '{name}' (U+{matching[1]}).\"\n    yield \"See the documentation for manim.mobject.svg.tex_mobject for details on using a custom TexTemplate.\""}, {"name": "insight_package_not_found_error", "code": "def insight_package_not_found_error(matching: Match[str]) -> Generator[str]:\n    yield f\"You do not have package {matching[1]} installed.\"\n    yield f\"Install {matching[1]} it using your LaTeX package manager, or check for typos.\""}, {"name": "Integer", "code": "class Integer(DecimalNumber):\n    \"\"\"A class for displaying Integers.\n\n    Examples\n    --------\n\n    .. manim:: IntegerExample\n        :save_last_frame:\n\n        class IntegerExample(Scene):\n            def construct(self):\n                self.add(Integer(number=2.5).set_color(ORANGE).scale(2.5).set_x(-0.5).set_y(0.8))\n                self.add(Integer(number=3.14159, show_ellipsis=True).set_x(3).set_y(3.3).scale(3.14159))\n                self.add(Integer(number=42).set_x(2.5).set_y(-2.3).set_color_by_gradient(BLUE, TEAL).scale(1.7))\n                self.add(Integer(number=6.28).set_x(-1.5).set_y(-2).set_color(YELLOW).scale(1.4))\n    \"\"\"\n\n    def __init__(\n        self, number: float = 0, num_decimal_places: int = 0, **kwargs: Any\n    ) -> None:\n        super().__init__(number=number, num_decimal_places=num_decimal_places, **kwargs)\n\n    def get_value(self):\n        return int(np.round(super().get_value()))"}, {"name": "integer_interpolate", "code": "def integer_interpolate(\n    start: float,\n    end: float,\n    alpha: float,\n) -> tuple[int, float]:\n    \"\"\"\n    This is a variant of interpolate that returns an integer and the residual\n\n    Parameters\n    ----------\n    start\n        The start of the range\n    end\n        The end of the range\n    alpha\n        a float between 0 and 1.\n\n    Returns\n    -------\n    tuple[int, float]\n        This returns an integer between start and end (inclusive) representing\n        appropriate interpolation between them, along with a\n        \"residue\" representing a new proportion between the\n        returned integer and the next one of the\n        list.\n\n    Example\n    -------\n\n    .. code-block:: pycon\n\n        >>> integer, residue = integer_interpolate(start=0, end=10, alpha=0.46)\n        >>> np.allclose((integer, residue), (4, 0.6))\n        True\n    \"\"\"\n    if alpha >= 1:\n        return (int(end - 1), 1.0)\n    if alpha <= 0:\n        return (int(start), 0)\n    value = int(interpolate(start, end, alpha))\n    residue = ((end - start) * alpha) % 1\n    return (value, residue)"}, {"name": "IntegerMatrix", "code": "class IntegerMatrix(Matrix):\n    \"\"\"A mobject that displays a matrix with integer entries on the screen.\n\n    Examples\n    --------\n\n    .. manim:: IntegerMatrixExample\n        :save_last_frame:\n\n        class IntegerMatrixExample(Scene):\n            def construct(self):\n                m0 = IntegerMatrix(\n                    [[3.7, 2], [42.2, 12]],\n                    left_bracket=\"(\",\n                    right_bracket=\")\")\n                self.add(m0)\n    \"\"\"\n\n    def __init__(\n        self, matrix: Iterable, element_to_mobject: Mobject = Integer, **kwargs\n    ):\n        \"\"\"\n        Will round if there are decimal entries in the matrix.\n\n        Parameters\n        ----------\n        matrix\n            A numpy 2d array or list of lists\n        element_to_mobject\n            Mobject to use, by default Integer\n        \"\"\"\n        super().__init__(matrix, element_to_mobject=element_to_mobject, **kwargs)"}, {"name": "IntegerTable", "code": "class IntegerTable(Table):\n    r\"\"\"A specialized :class:`~.Table` mobject for use with :class:`~.Integer`.\n\n    Examples\n    --------\n\n    .. manim:: IntegerTableExample\n        :save_last_frame:\n\n        class IntegerTableExample(Scene):\n            def construct(self):\n                t0 = IntegerTable(\n                    [[0,30,45,60,90],\n                    [90,60,45,30,0]],\n                    col_labels=[\n                        MathTex(r\"\\frac{\\sqrt{0}}{2}\"),\n                        MathTex(r\"\\frac{\\sqrt{1}}{2}\"),\n                        MathTex(r\"\\frac{\\sqrt{2}}{2}\"),\n                        MathTex(r\"\\frac{\\sqrt{3}}{2}\"),\n                        MathTex(r\"\\frac{\\sqrt{4}}{2}\")],\n                    row_labels=[MathTex(r\"\\sin\"), MathTex(r\"\\cos\")],\n                    h_buff=1,\n                    element_to_mobject_config={\"unit\": r\"^{\\circ}\"})\n                self.add(t0)\n    \"\"\"\n\n    def __init__(\n        self,\n        table: Iterable[Iterable[float | str]],\n        element_to_mobject: Callable[[float | str], VMobject] = Integer,\n        **kwargs,\n    ):\n        \"\"\"\n        Special case of :class:`~.Table` with `element_to_mobject` set to :class:`~.Integer`.\n        Will round if there are decimal entries in the table.\n\n        Parameters\n        ----------\n        table\n            A 2d array or list of lists. Content of the table has to be valid input\n            for :class:`~.Integer`.\n        element_to_mobject\n            The :class:`~.Mobject` class applied to the table entries. Set as :class:`~.Integer`.\n        kwargs\n            Additional arguments to be passed to :class:`~.Table`.\n        \"\"\"\n        super().__init__(table, element_to_mobject=element_to_mobject, **kwargs)"}, {"name": "interpolate", "code": "def interpolate(\n    start: float | Point3D,\n    end: float | Point3D,\n    alpha: float | ColVector,\n) -> float | ColVector | Point3D | Point3D_Array:\n    \"\"\"Linearly interpolates between two values ``start`` and ``end``.\n\n    Parameters\n    ----------\n    start\n        The start of the range.\n    end\n        The end of the range.\n    alpha\n        A float between 0 and 1, or an :math:`(n, 1)` column vector containing\n        :math:`n` floats between 0 and 1 to interpolate in a vectorized fashion.\n\n    Returns\n    -------\n    :class:`float` | :class:`~.ColVector` | :class:`~.Point3D` | :class:`~.Point3D_Array`\n        The result of the linear interpolation.\n\n        *   If ``start`` and ``end`` are of type :class:`float`, and:\n\n            * ``alpha`` is also a :class:`float`, the return is simply another :class:`float`.\n            * ``alpha`` is a :class:`~.ColVector`, the return is another :class:`~.ColVector`.\n\n        *   If ``start`` and ``end`` are of type :class:`~.Point3D`, and:\n\n            * ``alpha`` is a :class:`float`, the return is another :class:`~.Point3D`.\n            * ``alpha`` is a :class:`~.ColVector`, the return is a :class:`~.Point3D_Array`.\n    \"\"\"\n    return (1 - alpha) * start + alpha * end"}, {"name": "interpolate_color", "code": "def interpolate_color(\n    color1: ManimColorT, color2: ManimColorT, alpha: float\n) -> ManimColorT:\n    \"\"\"Standalone function to interpolate two ManimColors and get the result. Refer to\n    :meth:`ManimColor.interpolate`.\n\n    Parameters\n    ----------\n    color1\n        The first :class:`ManimColor`.\n    color2\n        The second :class:`ManimColor`.\n    alpha\n        The alpha value determining the point of interpolation between the colors.\n\n    Returns\n    -------\n    ManimColor\n        The interpolated ManimColor.\n    \"\"\"\n    return color1.interpolate(color2, alpha)"}, {"name": "Intersection", "code": "class Intersection(_BooleanOps):\n    \"\"\"Find the intersection of two :class:`~.VMobject` s.\n    This keeps the parts covered by both :class:`~.VMobject` s.\n\n    Parameters\n    ----------\n    vmobjects\n        The :class:`~.VMobject` to find the intersection.\n\n    Raises\n    ------\n    ValueError\n        If less the 2 :class:`~.VMobject` are passed.\n\n    Example\n    -------\n    .. manim:: IntersectionExample\n        :save_last_frame:\n\n        class IntersectionExample(Scene):\n            def construct(self):\n                sq = Square(color=RED, fill_opacity=1)\n                sq.move_to([-2, 0, 0])\n                cr = Circle(color=BLUE, fill_opacity=1)\n                cr.move_to([-1.3, 0.7, 0])\n                un = Intersection(sq, cr, color=GREEN, fill_opacity=1)\n                un.move_to([1.5, 0, 0])\n                self.add(sq, cr, un)\n\n    \"\"\"\n\n    def __init__(self, *vmobjects: VMobject, **kwargs: Any) -> None:\n        if len(vmobjects) < 2:\n            raise ValueError(\"At least 2 mobjects needed for Intersection.\")\n\n        super().__init__(**kwargs)\n        outpen = SkiaPath()\n        intersection(\n            [self._convert_vmobject_to_skia_path(vmobjects[0])],\n            [self._convert_vmobject_to_skia_path(vmobjects[1])],\n            outpen.getPen(),\n        )\n        new_outpen = outpen\n        for _i in range(2, len(vmobjects)):\n            new_outpen = SkiaPath()\n            intersection(\n                [outpen],\n                [self._convert_vmobject_to_skia_path(vmobjects[_i])],\n                new_outpen.getPen(),\n            )\n            outpen = new_outpen\n\n        self._convert_skia_path_to_vmobject(outpen)"}, {"name": "inverse_interpolate", "code": "def inverse_interpolate(\n    start: float | Point3D,\n    end: float | Point3D,\n    value: float | Point3D,\n) -> float | Point3D:\n    \"\"\"Perform inverse interpolation to determine the alpha\n    values that would produce the specified ``value``\n    given the ``start`` and ``end`` values or points.\n\n    Parameters\n    ----------\n    start\n        The start value or point of the interpolation.\n    end\n        The end value or point of the interpolation.\n    value\n        The value or point for which the alpha value\n        should be determined.\n\n    Returns\n    -------\n        The alpha values producing the given input\n        when interpolating between ``start`` and ``end``.\n\n    Example\n    -------\n\n    .. code-block:: pycon\n\n        >>> inverse_interpolate(start=2, end=6, value=4)\n        np.float64(0.5)\n\n        >>> start = np.array([1, 2, 1])\n        >>> end = np.array([7, 8, 11])\n        >>> value = np.array([4, 5, 5])\n        >>> inverse_interpolate(start, end, value)\n        array([0.5, 0.5, 0.4])\n    \"\"\"\n    return np.true_divide(value - start, end - start)"}, {"name": "invert_color", "code": "def invert_color(color: ManimColorT) -> ManimColorT:\n    \"\"\"Helper function for use in functional style programming. Refer to\n    :meth:`ManimColor.invert`\n\n    Parameters\n    ----------\n    color\n        The :class:`ManimColor` to invert.\n\n    Returns\n    -------\n    ManimColor\n        The linearly inverted :class:`ManimColor`.\n    \"\"\"\n    return color.invert()"}, {"name": "invert_image", "code": "def invert_image(image: np.array) -> Image:\n    arr = np.array(image)\n    arr = (255 * np.ones(arr.shape)).astype(arr.dtype) - arr\n    return Image.fromarray(arr)"}, {"name": "is_closed", "code": "def is_closed(points: Point3D_Array) -> bool:\n    \"\"\"Returns ``True`` if the spline given by ``points`` is closed, by\n    checking if its first and last points are close to each other, or``False``\n    otherwise.\n\n    .. note::\n\n        This function reimplements :meth:`np.allclose`, because repeated\n        calling of :meth:`np.allclose` for only 2 points is inefficient.\n\n    Parameters\n    ----------\n    points\n        An array of points defining a spline.\n\n    Returns\n    -------\n    :class:`bool`\n        Whether the first and last points of the array are close enough or not\n        to be considered the same, thus considering the defined spline as\n        closed.\n\n    Examples\n    --------\n    .. code-block:: pycon\n\n        >>> import numpy as np\n        >>> from manim import is_closed\n        >>> is_closed(\n        ...     np.array(\n        ...         [\n        ...             [0, 0, 0],\n        ...             [1, 2, 3],\n        ...             [3, 2, 1],\n        ...             [0, 0, 0],\n        ...         ]\n        ...     )\n        ... )\n        True\n        >>> is_closed(\n        ...     np.array(\n        ...         [\n        ...             [0, 0, 0],\n        ...             [1, 2, 3],\n        ...             [3, 2, 1],\n        ...             [1e-10, 1e-10, 1e-10],\n        ...         ]\n        ...     )\n        ... )\n        True\n        >>> is_closed(\n        ...     np.array(\n        ...         [\n        ...             [0, 0, 0],\n        ...             [1, 2, 3],\n        ...             [3, 2, 1],\n        ...             [1e-2, 1e-2, 1e-2],\n        ...         ]\n        ...     )\n        ... )\n        False\n    \"\"\"\n    start, end = points[0], points[-1]\n    rtol = 1e-5\n    atol = 1e-8\n    tolerance = atol + rtol * start\n    if abs(end[0] - start[0]) > tolerance[0]:\n        return False\n    if abs(end[1] - start[1]) > tolerance[1]:\n        return False\n    return bool(abs(end[2] - start[2]) <= tolerance[2])"}, {"name": "is_dvisvgm_available", "code": "def is_dvisvgm_available() -> bool:\n    \"\"\"Check whether ``dvisvgm`` is in ``PATH`` and can be executed.\n\n    Returns\n    -------\n    :class:`bool`\n        Whether ``dvisvgm`` is in ``PATH`` and can be executed or not.\n    \"\"\"\n    path_to_dvisvgm = shutil.which(\"dvisvgm\")\n    return path_to_dvisvgm is not None and os.access(path_to_dvisvgm, os.X_OK)"}, {"name": "is_gif_format", "code": "def is_gif_format() -> bool:\n    \"\"\"\n    Determines if output format is .gif\n\n    Returns\n    -------\n    class:`bool`\n        ``True`` if format is set as gif\n\n    \"\"\"\n    val: bool = config[\"format\"] == \"gif\"\n    return val"}, {"name": "is_latex_available", "code": "def is_latex_available() -> bool:\n    \"\"\"Check whether ``latex`` is in ``PATH`` and can be executed.\n\n    Returns\n    -------\n    :class:`bool`\n        Whether ``latex`` is in ``PATH`` and can be executed or not.\n    \"\"\"\n    path_to_latex = shutil.which(\"latex\")\n    return path_to_latex is not None and os.access(path_to_latex, os.X_OK)"}, {"name": "is_manim_executable_associated_to_this_library", "code": "def is_manim_executable_associated_to_this_library() -> bool:\n    \"\"\"Check whether the ``manim`` executable in ``PATH`` is associated to this\n    library. To verify this, the executable should look like this:\n\n    .. code-block:: python\n\n        #!<MANIM_PATH>/.../python\n        import sys\n        from manim.__main__ import main\n\n        if __name__ == \"__main__\":\n            sys.exit(main())\n\n\n    Returns\n    -------\n    :class:`bool`\n        Whether the ``manim`` executable in ``PATH`` is associated to this\n        library or not.\n    \"\"\"\n    path_to_manim = shutil.which(\"manim\")\n    assert path_to_manim is not None\n    with open(path_to_manim, \"rb\") as manim_binary:\n        manim_exec = manim_binary.read()\n\n    # first condition below corresponds to the executable being\n    # some sort of python script. second condition happens when\n    # the executable is actually a Windows batch file.\n    return b\"manim.__main__\" in manim_exec or b'\"%~dp0\\\\manim\"' in manim_exec"}, {"name": "is_manim_on_path", "code": "def is_manim_on_path() -> bool:\n    \"\"\"Check whether ``manim`` is in ``PATH``.\n\n    Returns\n    -------\n    :class:`bool`\n        Whether ``manim`` is in ``PATH`` or not.\n    \"\"\"\n    path_to_manim = shutil.which(\"manim\")\n    return path_to_manim is not None"}, {"name": "is_mov_format", "code": "def is_mov_format() -> bool:\n    \"\"\"\n    Determines if output format is .mov\n\n    Returns\n    -------\n    class:`bool`\n        ``True`` if format is set as mov\n\n    \"\"\"\n    val: bool = config[\"format\"] == \"mov\"\n    return val"}, {"name": "is_mp4_format", "code": "def is_mp4_format() -> bool:\n    \"\"\"\n    Determines if output format is .mp4\n\n    Returns\n    -------\n    class:`bool`\n        ``True`` if format is set as mp4\n\n    \"\"\"\n    val: bool = config[\"format\"] == \"mp4\"\n    return val"}, {"name": "is_png_format", "code": "def is_png_format() -> bool:\n    \"\"\"\n    Determines if output format is .png\n\n    Returns\n    -------\n    class:`bool`\n        ``True`` if format is set as png\n\n    \"\"\"\n    val: bool = config[\"format\"] == \"png\"\n    return val"}, {"name": "is_valid_style", "code": "def is_valid_style(style: str) -> bool:\n    \"\"\"Checks whether the entered color style is valid, according to ``rich``.\n\n    Parameters\n    ----------\n    style\n        The style to check whether it is valid.\n\n    Returns\n    -------\n    :class:`bool`\n        Whether the color style is valid or not, according to ``rich``.\n    \"\"\"\n    try:\n        Style.parse(style)\n        return True\n    except StyleSyntaxError:\n        return False"}, {"name": "is_webm_format", "code": "def is_webm_format() -> bool:\n    \"\"\"\n    Determines if output format is .webm\n\n    Returns\n    -------\n    class:`bool`\n        ``True`` if format is set as webm\n\n    \"\"\"\n    val: bool = config[\"format\"] == \"webm\"\n    return val"}, {"name": "JSONFormatter", "code": "class JSONFormatter(logging.Formatter):\n    \"\"\"A formatter that outputs logs in a custom JSON format.\n\n    This class is used internally for testing purposes.\n\n    \"\"\"\n\n    def format(self, record: logging.LogRecord) -> str:\n        \"\"\"Format the record in a custom JSON format.\"\"\"\n        record_c = copy.deepcopy(record)\n        if record_c.args:\n            if isinstance(record_c.args, dict):\n                for arg in record_c.args:\n                    record_c.args[arg] = \"<>\"\n            else:\n                record_c.args = (\"<>\",) * len(record_c.args)\n        return json.dumps(\n            {\n                \"levelname\": record_c.levelname,\n                \"module\": record_c.module,\n                \"message\": super().format(record_c),\n            },\n        )"}, {"name": "Label", "code": "class Label(VGroup):\n    \"\"\"A Label consisting of text surrounded by a frame.\n\n    Parameters\n    ----------\n    label\n        Label that will be displayed.\n    label_config\n        A dictionary containing the configuration for the label.\n        This is only applied if ``label`` is of type ``str``.\n    box_config\n        A dictionary containing the configuration for the background box.\n    frame_config\n         A dictionary containing the configuration for the frame.\n\n    Examples\n    --------\n    .. manim:: LabelExample\n        :save_last_frame:\n        :quality: high\n\n        class LabelExample(Scene):\n            def construct(self):\n                label = Label(\n                    label=Text('Label Text', font='sans-serif'),\n                    box_config = {\n                        \"color\" : BLUE,\n                        \"fill_opacity\" : 0.75\n                    }\n                )\n                label.scale(3)\n                self.add(label)\n    \"\"\"\n\n    def __init__(\n        self,\n        label: str | Tex | MathTex | Text,\n        label_config: dict[str, Any] | None = None,\n        box_config: dict[str, Any] | None = None,\n        frame_config: dict[str, Any] | None = None,\n        **kwargs: Any,\n    ) -> None:\n        super().__init__(**kwargs)\n\n        # Setup Defaults\n        default_label_config: dict[str, Any] = {\n            \"color\": WHITE,\n            \"font_size\": DEFAULT_FONT_SIZE,\n        }\n\n        default_box_config: dict[str, Any] = {\n            \"color\": None,\n            \"buff\": 0.05,\n            \"fill_opacity\": 1,\n            \"stroke_width\": 0.5,\n        }\n\n        default_frame_config: dict[str, Any] = {\n            \"color\": WHITE,\n            \"buff\": 0.05,\n            \"stroke_width\": 0.5,\n        }\n\n        # Merge Defaults\n        label_config = default_label_config | (label_config or {})\n        box_config = default_box_config | (box_config or {})\n        frame_config = default_frame_config | (frame_config or {})\n\n        # Determine the type of label and instantiate the appropriate object\n        self.rendered_label: MathTex | Tex | Text\n        if isinstance(label, str):\n            self.rendered_label = MathTex(label, **label_config)\n        elif isinstance(label, (MathTex, Tex, Text)):\n            self.rendered_label = label\n        else:\n            raise TypeError(\"Unsupported label type. Must be MathTex, Tex, or Text.\")\n\n        # Add a background box\n        self.background_rect = BackgroundRectangle(self.rendered_label, **box_config)\n\n        # Add a frame around the label\n        self.frame = SurroundingRectangle(self.rendered_label, **frame_config)\n\n        # Add components to the VGroup\n        self.add(self.background_rect, self.rendered_label, self.frame)"}, {"name": "LabeledArrow", "code": "class LabeledArrow(LabeledLine, Arrow):\n    \"\"\"Constructs an arrow containing a label box somewhere along its length.\n    This class inherits its label properties from `LabeledLine`, so the main parameters controlling it are the same.\n\n    Parameters\n    ----------\n    label\n        Label that will be displayed on the Arrow.\n    label_position\n        A ratio in the range [0-1] to indicate the position of the label with respect to the length of the line. Default value is 0.5.\n    label_config\n        A dictionary containing the configuration for the label.\n        This is only applied if ``label`` is of type ``str``.\n    box_config\n        A dictionary containing the configuration for the background box.\n    frame_config\n         A dictionary containing the configuration for the frame.\n\n        .. seealso::\n            :class:`LabeledLine`\n\n    Examples\n    --------\n    .. manim:: LabeledArrowExample\n        :save_last_frame:\n        :quality: high\n\n        class LabeledArrowExample(Scene):\n            def construct(self):\n                l_arrow = LabeledArrow(\"0.5\", start=LEFT*3, end=RIGHT*3 + UP*2, label_position=0.5)\n\n                self.add(l_arrow)\n    \"\"\"\n\n    def __init__(\n        self,\n        *args: Any,\n        **kwargs: Any,\n    ) -> None:\n        super().__init__(*args, **kwargs)"}, {"name": "LabeledDot", "code": "class LabeledDot(Dot):\n    \"\"\"A :class:`Dot` containing a label in its center.\n\n    Parameters\n    ----------\n    label\n        The label of the :class:`Dot`. This is rendered as :class:`~.MathTex`\n        by default (i.e., when passing a :class:`str`), but other classes\n        representing rendered strings like :class:`~.Text` or :class:`~.Tex`\n        can be passed as well.\n    radius\n        The radius of the :class:`Dot`. If ``None`` (the default), the radius\n        is calculated based on the size of the ``label``.\n\n    Examples\n    --------\n    .. manim:: SeveralLabeledDots\n        :save_last_frame:\n\n        class SeveralLabeledDots(Scene):\n            def construct(self):\n                sq = Square(fill_color=RED, fill_opacity=1)\n                self.add(sq)\n                dot1 = LabeledDot(Tex(\"42\", color=RED))\n                dot2 = LabeledDot(MathTex(\"a\", color=GREEN))\n                dot3 = LabeledDot(Text(\"ii\", color=BLUE))\n                dot4 = LabeledDot(\"3\")\n                dot1.next_to(sq, UL)\n                dot2.next_to(sq, UR)\n                dot3.next_to(sq, DL)\n                dot4.next_to(sq, DR)\n                self.add(dot1, dot2, dot3, dot4)\n    \"\"\"\n\n    def __init__(\n        self,\n        label: str | SingleStringMathTex | Text | Tex,\n        radius: float | None = None,\n        **kwargs: Any,\n    ) -> None:\n        if isinstance(label, str):\n            from manim import MathTex\n\n            rendered_label: VMobject = MathTex(label, color=BLACK)\n        else:\n            rendered_label = label\n\n        if radius is None:\n            radius = 0.1 + max(rendered_label.width, rendered_label.height) / 2\n        super().__init__(radius=radius, **kwargs)\n        rendered_label.move_to(self.get_center())\n        self.add(rendered_label)"}, {"name": "LabeledLine", "code": "class LabeledLine(Line):\n    \"\"\"Constructs a line containing a label box somewhere along its length.\n\n    Parameters\n    ----------\n    label\n        Label that will be displayed on the line.\n    label_position\n        A ratio in the range [0-1] to indicate the position of the label with respect to the length of the line. Default value is 0.5.\n    label_config\n        A dictionary containing the configuration for the label.\n        This is only applied if ``label`` is of type ``str``.\n    box_config\n        A dictionary containing the configuration for the background box.\n    frame_config\n         A dictionary containing the configuration for the frame.\n\n        .. seealso::\n            :class:`LabeledArrow`\n\n    Examples\n    --------\n    .. manim:: LabeledLineExample\n        :save_last_frame:\n        :quality: high\n\n        class LabeledLineExample(Scene):\n            def construct(self):\n                line = LabeledLine(\n                    label          = '0.5',\n                    label_position = 0.8,\n                    label_config = {\n                        \"font_size\" : 20\n                    },\n                    start=LEFT+DOWN,\n                    end=RIGHT+UP)\n\n                line.set_length(line.get_length() * 2)\n                self.add(line)\n    \"\"\"\n\n    def __init__(\n        self,\n        label: str | Tex | MathTex | Text,\n        label_position: float = 0.5,\n        label_config: dict[str, Any] | None = None,\n        box_config: dict[str, Any] | None = None,\n        frame_config: dict[str, Any] | None = None,\n        *args: Any,\n        **kwargs: Any,\n    ) -> None:\n        super().__init__(*args, **kwargs)\n\n        # Create Label\n        self.label = Label(\n            label=label,\n            label_config=label_config,\n            box_config=box_config,\n            frame_config=frame_config,\n        )\n\n        # Compute Label Position\n        line_start, line_end = self.get_start_and_end()\n        new_vec = (line_end - line_start) * label_position\n        label_coords = line_start + new_vec\n\n        self.label.move_to(label_coords)\n        self.add(self.label)"}, {"name": "LabeledPolygram", "code": "class LabeledPolygram(Polygram):\n    \"\"\"Constructs a polygram containing a label box at its pole of inaccessibility.\n\n    Parameters\n    ----------\n    vertex_groups\n        Vertices passed to the :class:`~.Polygram` constructor.\n    label\n        Label that will be displayed on the Polygram.\n    precision\n        The precision used by the PolyLabel algorithm.\n    label_config\n        A dictionary containing the configuration for the label.\n        This is only applied if ``label`` is of type ``str``.\n    box_config\n        A dictionary containing the configuration for the background box.\n    frame_config\n         A dictionary containing the configuration for the frame.\n\n        .. note::\n            The PolyLabel Algorithm expects each vertex group to form a closed ring.\n            If the input is open, :class:`LabeledPolygram` will attempt to close it.\n            This may cause the polygon to intersect itself leading to unexpected results.\n\n        .. tip::\n            Make sure the precision corresponds to the scale of your inputs!\n            For instance, if the bounding box of your polygon stretches from 0 to 10,000, a precision of 1.0 or 10.0 should be sufficient.\n\n    Examples\n    --------\n    .. manim:: LabeledPolygramExample\n        :save_last_frame:\n        :quality: high\n\n        class LabeledPolygramExample(Scene):\n            def construct(self):\n                # Define Rings\n                ring1 = [\n                    [-3.8, -2.4, 0], [-2.4, -2.5, 0], [-1.3, -1.6, 0], [-0.2, -1.7, 0],\n                    [1.7, -2.5, 0], [2.9, -2.6, 0], [3.5, -1.5, 0], [4.9, -1.4, 0],\n                    [4.5, 0.2, 0], [4.7, 1.6, 0], [3.5, 2.4, 0], [1.1, 2.5, 0],\n                    [-0.1, 0.9, 0], [-1.2, 0.5, 0], [-1.6, 0.7, 0], [-1.4, 1.9, 0],\n                    [-2.6, 2.6, 0], [-4.4, 1.2, 0], [-4.9, -0.8, 0], [-3.8, -2.4, 0]\n                ]\n                ring2 = [\n                    [0.2, -1.2, 0], [0.9, -1.2, 0], [1.4, -2.0, 0], [2.1, -1.6, 0],\n                    [2.2, -0.5, 0], [1.4, 0.0, 0], [0.4, -0.2, 0], [0.2, -1.2, 0]\n                ]\n                ring3 = [[-2.7, 1.4, 0], [-2.3, 1.7, 0], [-2.8, 1.9, 0], [-2.7, 1.4, 0]]\n\n                # Create Polygons (for reference)\n                p1 = Polygon(*ring1, fill_opacity=0.75)\n                p2 = Polygon(*ring2, fill_color=BLACK, fill_opacity=1)\n                p3 = Polygon(*ring3, fill_color=BLACK, fill_opacity=1)\n\n                # Create Labeled Polygram\n                polygram = LabeledPolygram(\n                    *[ring1, ring2, ring3],\n                    label=Text('Pole', font='sans-serif'),\n                    precision=0.01,\n                )\n\n                # Display Circle (for reference)\n                circle = Circle(radius=polygram.radius, color=WHITE).move_to(polygram.pole)\n\n                self.add(p1, p2, p3)\n                self.add(polygram)\n                self.add(circle)\n\n    .. manim:: LabeledCountryExample\n        :save_last_frame:\n        :quality: high\n\n        import requests\n        import json\n\n        class LabeledCountryExample(Scene):\n            def construct(self):\n                # Fetch JSON data and process arcs\n                data = requests.get('https://cdn.jsdelivr.net/npm/us-atlas@3/nation-10m.json').json()\n                arcs, transform = data['arcs'], data['transform']\n                sarcs = [np.cumsum(arc, axis=0) * transform['scale'] + transform['translate'] for arc in arcs]\n                ssarcs = sorted(sarcs, key=len, reverse=True)[:1]\n\n                # Compute Bounding Box\n                points = np.concatenate(ssarcs)\n                mins, maxs = np.min(points, axis=0), np.max(points, axis=0)\n\n                # Build Axes\n                ax = Axes(\n                    x_range=[mins[0], maxs[0], maxs[0] - mins[0]], x_length=10,\n                    y_range=[mins[1], maxs[1], maxs[1] - mins[1]], y_length=7,\n                    tips=False\n                )\n\n                # Adjust Coordinates\n                array = [[ax.c2p(*point) for point in sarc] for sarc in ssarcs]\n\n                # Add Polygram\n                polygram = LabeledPolygram(\n                    *array,\n                    label=Text('USA', font='sans-serif'),\n                    precision=0.01,\n                    fill_color=BLUE,\n                    stroke_width=0,\n                    fill_opacity=0.75\n                )\n\n                # Display Circle (for reference)\n                circle = Circle(radius=polygram.radius, color=WHITE).move_to(polygram.pole)\n\n                self.add(ax)\n                self.add(polygram)\n                self.add(circle)\n    \"\"\"\n\n    def __init__(\n        self,\n        *vertex_groups: Point3DLike_Array,\n        label: str | Tex | MathTex | Text,\n        precision: float = 0.01,\n        label_config: dict[str, Any] | None = None,\n        box_config: dict[str, Any] | None = None,\n        frame_config: dict[str, Any] | None = None,\n        **kwargs: Any,\n    ) -> None:\n        # Initialize the Polygram with the vertex groups\n        super().__init__(*vertex_groups, **kwargs)\n\n        # Create Label\n        self.label = Label(\n            label=label,\n            label_config=label_config,\n            box_config=box_config,\n            frame_config=frame_config,\n        )\n\n        # Close Vertex Groups\n        rings = [\n            group if np.array_equal(group[0], group[-1]) else list(group) + [group[0]]\n            for group in vertex_groups\n        ]\n\n        # Compute the Pole of Inaccessibility\n        cell = polylabel(rings, precision=precision)\n        self.pole, self.radius = np.pad(cell.c, (0, 1), \"constant\"), cell.d\n\n        # Position the label at the pole\n        self.label.move_to(self.pole)\n        self.add(self.label)"}, {"name": "LaggedStart", "code": "class LaggedStart(AnimationGroup):\n    \"\"\"Adjusts the timing of a series of :class:`~.Animation` according to ``lag_ratio``.\n\n    Parameters\n    ----------\n    animations\n        Sequence of :class:`~.Animation` objects to be played.\n    lag_ratio\n        Defines the delay after which the animation is applied to submobjects. A lag_ratio of\n        ``n.nn`` means the next animation will play when ``nnn%`` of the current animation has played.\n        Defaults to 0.05, meaning that the next animation will begin when 5% of the current\n        animation has played.\n\n        This does not influence the total runtime of the animation. Instead the runtime\n        of individual animations is adjusted so that the complete animation has the defined\n        run time.\n\n    Examples\n    --------\n    .. manim:: LaggedStartExample\n\n        class LaggedStartExample(Scene):\n            def construct(self):\n                title = Text(\"lag_ratio = 0.25\").to_edge(UP)\n\n                dot1 = Dot(point=LEFT * 2 + UP, radius=0.16)\n                dot2 = Dot(point=LEFT * 2, radius=0.16)\n                dot3 = Dot(point=LEFT * 2 + DOWN, radius=0.16)\n                line_25 = DashedLine(\n                    start=LEFT + UP * 2,\n                    end=LEFT + DOWN * 2,\n                    color=RED\n                )\n                label = Text(\"25%\", font_size=24).next_to(line_25, UP)\n                self.add(title, dot1, dot2, dot3, line_25, label)\n\n                self.play(LaggedStart(\n                    dot1.animate.shift(RIGHT * 4),\n                    dot2.animate.shift(RIGHT * 4),\n                    dot3.animate.shift(RIGHT * 4),\n                    lag_ratio=0.25,\n                    run_time=4\n                ))\n    \"\"\"\n\n    def __init__(\n        self,\n        *animations: Animation,\n        lag_ratio: float = DEFAULT_LAGGED_START_LAG_RATIO,\n        **kwargs,\n    ):\n        super().__init__(*animations, lag_ratio=lag_ratio, **kwargs)"}, {"name": "LaggedStartMap", "code": "class LaggedStartMap(LaggedStart):\n    \"\"\"Plays a series of :class:`~.Animation` while mapping a function to submobjects.\n\n    Parameters\n    ----------\n    AnimationClass\n        :class:`~.Animation` to apply to mobject.\n    mobject\n        :class:`~.Mobject` whose submobjects the animation, and optionally the function,\n        are to be applied.\n    arg_creator\n        Function which will be applied to :class:`~.Mobject`.\n    run_time\n        The duration of the animation in seconds.\n\n    Examples\n    --------\n    .. manim:: LaggedStartMapExample\n\n        class LaggedStartMapExample(Scene):\n            def construct(self):\n                title = Tex(\"LaggedStartMap\").to_edge(UP, buff=LARGE_BUFF)\n                dots = VGroup(\n                    *[Dot(radius=0.16) for _ in range(35)]\n                    ).arrange_in_grid(rows=5, cols=7, buff=MED_LARGE_BUFF)\n                self.add(dots, title)\n\n                # Animate yellow ripple effect\n                for mob in dots, title:\n                    self.play(LaggedStartMap(\n                        ApplyMethod, mob,\n                        lambda m : (m.set_color, YELLOW),\n                        lag_ratio = 0.1,\n                        rate_func = there_and_back,\n                        run_time = 2\n                    ))\n    \"\"\"\n\n    def __init__(\n        self,\n        AnimationClass: Callable[..., Animation],\n        mobject: Mobject,\n        arg_creator: Callable[[Mobject], str] = None,\n        run_time: float = 2,\n        **kwargs,\n    ) -> None:\n        args_list = []\n        for submob in mobject:\n            if arg_creator:\n                args_list.append(arg_creator(submob))\n            else:\n                args_list.append((submob,))\n        anim_kwargs = dict(kwargs)\n        if \"lag_ratio\" in anim_kwargs:\n            anim_kwargs.pop(\"lag_ratio\")\n        animations = [AnimationClass(*args, **anim_kwargs) for args in args_list]\n        super().__init__(*animations, run_time=run_time, **kwargs)"}, {"name": "LayoutFunction", "code": "class LayoutFunction(Protocol):\n    \"\"\"A protocol for automatic layout functions that compute a layout for a graph to be used in :meth:`~.Graph.change_layout`.\n\n    .. note:: The layout function must be a pure function, i.e., it must not modify the graph passed to it.\n\n    Examples\n    --------\n\n    Here is an example that arranges nodes in an n x m grid in sorted order.\n\n    .. manim:: CustomLayoutExample\n        :save_last_frame:\n\n        class CustomLayoutExample(Scene):\n            def construct(self):\n                import numpy as np\n                import networkx as nx\n\n                # create custom layout\n                def custom_layout(\n                    graph: nx.Graph,\n                    scale: float | tuple[float, float, float] = 2,\n                    n: int | None = None,\n                    *args: Any,\n                    **kwargs: Any,\n                ):\n                    nodes = sorted(list(graph))\n                    height = len(nodes) // n\n                    return {\n                        node: (scale * np.array([\n                            (i % n) - (n-1)/2,\n                            -(i // n) + height/2,\n                            0\n                        ])) for i, node in enumerate(graph)\n                    }\n\n                # draw graph\n                n = 4\n                graph = Graph(\n                    [i for i in range(4 * 2 - 1)],\n                    [(0, 1), (0, 4), (1, 2), (1, 5), (2, 3), (2, 6), (4, 5), (5, 6)],\n                    labels=True,\n                    layout=custom_layout,\n                    layout_config={'n': n}\n                )\n                self.add(graph)\n\n    Several automatic layouts are provided by manim, and can be used by passing their name as the ``layout`` parameter to :meth:`~.Graph.change_layout`.\n    Alternatively, a custom layout function can be passed to :meth:`~.Graph.change_layout` as the ``layout`` parameter. Such a function must adhere to the :class:`~.LayoutFunction` protocol.\n\n    The :class:`~.LayoutFunction` s provided by manim are illustrated below:\n\n    - Circular Layout: places the vertices on a circle\n\n    .. manim:: CircularLayout\n        :save_last_frame:\n\n        class CircularLayout(Scene):\n            def construct(self):\n                graph = Graph(\n                    [1, 2, 3, 4, 5, 6],\n                    [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n                    layout=\"circular\",\n                    labels=True\n                )\n                self.add(graph)\n\n    - Kamada Kawai Layout: tries to place the vertices such that the given distances between them are respected\n\n    .. manim:: KamadaKawaiLayout\n        :save_last_frame:\n\n        class KamadaKawaiLayout(Scene):\n            def construct(self):\n                from collections import defaultdict\n                distances: dict[int, dict[int, float]] = defaultdict(dict)\n\n                # set desired distances\n                distances[1][2] = 1  # distance between vertices 1 and 2 is 1\n                distances[2][3] = 1  # distance between vertices 2 and 3 is 1\n                distances[3][4] = 2  # etc\n                distances[4][5] = 3\n                distances[5][6] = 5\n                distances[6][1] = 8\n\n                graph = Graph(\n                    [1, 2, 3, 4, 5, 6],\n                    [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)],\n                    layout=\"kamada_kawai\",\n                    layout_config={\"dist\": distances},\n                    layout_scale=4,\n                    labels=True\n                )\n                self.add(graph)\n\n    - Partite Layout: places vertices into distinct partitions\n\n    .. manim:: PartiteLayout\n        :save_last_frame:\n\n        class PartiteLayout(Scene):\n            def construct(self):\n                graph = Graph(\n                    [1, 2, 3, 4, 5, 6],\n                    [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n                    layout=\"partite\",\n                    layout_config={\"partitions\": [[1,2],[3,4],[5,6]]},\n                    labels=True\n                )\n                self.add(graph)\n\n    - Planar Layout: places vertices such that edges do not cross\n\n    .. manim:: PlanarLayout\n        :save_last_frame:\n\n        class PlanarLayout(Scene):\n            def construct(self):\n                graph = Graph(\n                    [1, 2, 3, 4, 5, 6],\n                    [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n                    layout=\"planar\",\n                    layout_scale=4,\n                    labels=True\n                )\n                self.add(graph)\n\n    - Random Layout: randomly places vertices\n\n    .. manim:: RandomLayout\n        :save_last_frame:\n\n        class RandomLayout(Scene):\n            def construct(self):\n                graph = Graph(\n                    [1, 2, 3, 4, 5, 6],\n                    [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n                    layout=\"random\",\n                    labels=True\n                )\n                self.add(graph)\n\n    - Shell Layout: places vertices in concentric circles\n\n    .. manim:: ShellLayout\n        :save_last_frame:\n\n        class ShellLayout(Scene):\n            def construct(self):\n                nlist = [[1, 2, 3], [4, 5, 6, 7, 8, 9]]\n                graph = Graph(\n                    [1, 2, 3, 4, 5, 6, 7, 8, 9],\n                    [(1, 2), (2, 3), (3, 1), (4, 1), (4, 2), (5, 2), (6, 2), (6, 3), (7, 3), (8, 3), (8, 1), (9, 1)],\n                    layout=\"shell\",\n                    layout_config={\"nlist\": nlist},\n                    labels=True\n                )\n                self.add(graph)\n\n    - Spectral Layout: places vertices using the eigenvectors of the graph Laplacian (clusters nodes which are an approximation of the ratio cut)\n\n    .. manim:: SpectralLayout\n        :save_last_frame:\n\n        class SpectralLayout(Scene):\n            def construct(self):\n                graph = Graph(\n                    [1, 2, 3, 4, 5, 6],\n                    [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n                    layout=\"spectral\",\n                    labels=True\n                )\n                self.add(graph)\n\n    - Sprial Layout: places vertices in a spiraling pattern\n\n    .. manim:: SpiralLayout\n        :save_last_frame:\n\n        class SpiralLayout(Scene):\n            def construct(self):\n                graph = Graph(\n                    [1, 2, 3, 4, 5, 6],\n                    [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n                    layout=\"spiral\",\n                    labels=True\n                )\n                self.add(graph)\n\n    - Spring Layout: places nodes according to the Fruchterman-Reingold force-directed algorithm (attempts to minimize edge length while maximizing node separation)\n\n    .. manim:: SpringLayout\n        :save_last_frame:\n\n        class SpringLayout(Scene):\n            def construct(self):\n                graph = Graph(\n                    [1, 2, 3, 4, 5, 6],\n                    [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],\n                    layout=\"spring\",\n                    labels=True\n                )\n                self.add(graph)\n\n    - Tree Layout: places vertices into a tree with a root node and branches (can only be used with legal trees)\n\n    .. manim:: TreeLayout\n        :save_last_frame:\n\n        class TreeLayout(Scene):\n            def construct(self):\n                graph = Graph(\n                    [1, 2, 3, 4, 5, 6, 7],\n                    [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)],\n                    layout=\"tree\",\n                    layout_config={\"root_vertex\": 1},\n                    labels=True\n                )\n                self.add(graph)\n\n    \"\"\"\n\n    def __call__(\n        self,\n        graph: NxGraph,\n        scale: float | tuple[float, float, float] = 2,\n        *args: Any,\n        **kwargs: Any,\n    ) -> dict[Hashable, Point3D]:\n        \"\"\"Given a graph and a scale, return a dictionary of coordinates.\n\n        Parameters\n        ----------\n        graph\n            The underlying NetworkX graph to be laid out. DO NOT MODIFY.\n        scale\n            Either a single float value, or a tuple of three float values specifying the scale along each axis.\n\n        Returns\n        -------\n        dict[Hashable, Point3D]\n            A dictionary mapping vertices to their positions.\n        \"\"\"\n        ..."}, {"name": "Line", "code": "class Line(TipableVMobject):\n    \"\"\"A straight or curved line segment between two points or mobjects.\n\n    Parameters\n    ----------\n    start\n        The starting point or Mobject of the line.\n    end\n        The ending point or Mobject of the line.\n    buff\n        The distance to shorten the line from both ends.\n    path_arc\n        If nonzero, the line will be curved into an arc with this angle (in radians).\n    kwargs\n        Additional arguments to be passed to :class:`TipableVMobject`\n\n    Examples\n    --------\n    .. manim:: LineExample\n        :save_last_frame:\n\n        class LineExample(Scene):\n            def construct(self):\n                line1 = Line(LEFT*2, RIGHT*2)\n                line2 = Line(LEFT*2, RIGHT*2, buff=0.5)\n                line3 = Line(LEFT*2, RIGHT*2, path_arc=PI/2)\n                grp = VGroup(line1,line2,line3).arrange(DOWN, buff=2)\n                self.add(grp)\n    \"\"\"\n\n    def __init__(\n        self,\n        start: Point3DLike | Mobject = LEFT,\n        end: Point3DLike | Mobject = RIGHT,\n        buff: float = 0,\n        path_arc: float = 0,\n        **kwargs: Any,\n    ) -> None:\n        self.dim = 3\n        self.buff = buff\n        self.path_arc = path_arc\n        self._set_start_and_end_attrs(start, end)\n        super().__init__(**kwargs)\n\n    def generate_points(self) -> None:\n        self.set_points_by_ends(\n            start=self.start,\n            end=self.end,\n            buff=self.buff,\n            path_arc=self.path_arc,\n        )\n\n    def set_points_by_ends(\n        self,\n        start: Point3DLike | Mobject,\n        end: Point3DLike | Mobject,\n        buff: float = 0,\n        path_arc: float = 0,\n    ) -> None:\n        \"\"\"Sets the points of the line based on its start and end points.\n        Unlike :meth:`put_start_and_end_on`, this method respects `self.buff` and\n        Mobject bounding boxes.\n\n        Parameters\n        ----------\n        start\n            The start point or Mobject of the line.\n        end\n            The end point or Mobject of the line.\n        buff\n            The empty space between the start and end of the line, by default 0.\n        path_arc\n            The angle of a circle spanned by this arc, by default 0 which is a straight line.\n        \"\"\"\n        self._set_start_and_end_attrs(start, end)\n        if path_arc:\n            arc = ArcBetweenPoints(self.start, self.end, angle=self.path_arc)\n            self.set_points(arc.points)\n        else:\n            self.set_points_as_corners(np.asarray([self.start, self.end]))\n\n        self._account_for_buff(buff)\n\n    init_points = generate_points\n\n    def _account_for_buff(self, buff: float) -> None:\n        if buff <= 0:\n            return\n        length = self.get_length() if self.path_arc == 0 else self.get_arc_length()\n        if length < 2 * buff:\n            return\n        buff_proportion = buff / length\n        self.pointwise_become_partial(self, buff_proportion, 1 - buff_proportion)\n\n    def _set_start_and_end_attrs(\n        self, start: Point3DLike | Mobject, end: Point3DLike | Mobject\n    ) -> None:\n        # If either start or end are Mobjects, this\n        # gives their centers\n        rough_start = self._pointify(start)\n        rough_end = self._pointify(end)\n        vect = normalize(rough_end - rough_start)\n        # Now that we know the direction between them,\n        # we can find the appropriate boundary point from\n        # start and end, if they're mobjects\n        self.start = self._pointify(start, vect)\n        self.end = self._pointify(end, -vect)\n\n    def _pointify(\n        self,\n        mob_or_point: Mobject | Point3DLike,\n        direction: Vector3D | None = None,\n    ) -> Point3D:\n        \"\"\"Transforms a mobject into its corresponding point. Does nothing if a point is passed.\n\n        ``direction`` determines the location of the point along its bounding box in that direction.\n\n        Parameters\n        ----------\n        mob_or_point\n            The mobject or point.\n        direction\n            The direction.\n        \"\"\"\n        if isinstance(mob_or_point, (Mobject, OpenGLMobject)):\n            mob = mob_or_point\n            if direction is None:\n                return mob.get_center()\n            else:\n                return mob.get_boundary_point(direction)\n        return np.array(mob_or_point)\n\n    def set_path_arc(self, new_value: float) -> None:\n        self.path_arc = new_value\n        self.init_points()\n\n    def put_start_and_end_on(\n        self,\n        start: Point3DLike,\n        end: Point3DLike,\n    ) -> Self:\n        \"\"\"Sets starts and end coordinates of a line.\n\n        Examples\n        --------\n        .. manim:: LineExample\n\n            class LineExample(Scene):\n                def construct(self):\n                    d = VGroup()\n                    for i in range(0,10):\n                        d.add(Dot())\n                    d.arrange_in_grid(buff=1)\n                    self.add(d)\n                    l= Line(d[0], d[1])\n                    self.add(l)\n                    self.wait()\n                    l.put_start_and_end_on(d[1].get_center(), d[2].get_center())\n                    self.wait()\n                    l.put_start_and_end_on(d[4].get_center(), d[7].get_center())\n                    self.wait()\n        \"\"\"\n        curr_start, curr_end = self.get_start_and_end()\n        if np.all(curr_start == curr_end):\n            # TODO, any problems with resetting\n            # these attrs?\n            self.start = np.asarray(start)\n            self.end = np.asarray(end)\n            self.generate_points()\n        return super().put_start_and_end_on(start, end)\n\n    def get_vector(self) -> Vector3D:\n        return self.get_end() - self.get_start()\n\n    def get_unit_vector(self) -> Vector3D:\n        return normalize(self.get_vector())\n\n    def get_angle(self) -> float:\n        return angle_of_vector(self.get_vector())\n\n    def get_projection(self, point: Point3DLike) -> Point3D:\n        \"\"\"Returns the projection of a point onto a line.\n\n        Parameters\n        ----------\n        point\n            The point to which the line is projected.\n        \"\"\"\n        start = self.get_start()\n        end = self.get_end()\n        unit_vect = normalize(end - start)\n        return start + float(np.dot(point - start, unit_vect)) * unit_vect\n\n    def get_slope(self) -> float:\n        return float(np.tan(self.get_angle()))\n\n    def set_angle(self, angle: float, about_point: Point3DLike | None = None) -> Self:\n        if about_point is None:\n            about_point = self.get_start()\n\n        self.rotate(\n            angle - self.get_angle(),\n            about_point=about_point,\n        )\n\n        return self\n\n    def set_length(self, length: float) -> Self:\n        scale_factor: float = length / self.get_length()\n        return self.scale(scale_factor)"}, {"name": "Line3D", "code": "class Line3D(Cylinder):\n    \"\"\"A cylindrical line, for use in ThreeDScene.\n\n    Parameters\n    ----------\n    start\n        The start point of the line.\n    end\n        The end point of the line.\n    thickness\n        The thickness of the line.\n    color\n        The color of the line.\n    resolution\n        The resolution of the line.\n        By default this value is the number of points the line will sampled at.\n        If you want the line to also come out checkered, use a tuple.\n        For example, for a line made of 24 points with 4 checker points on each\n        cylinder, pass the tuple (4, 24).\n\n    Examples\n    --------\n    .. manim:: ExampleLine3D\n        :save_last_frame:\n\n        class ExampleLine3D(ThreeDScene):\n            def construct(self):\n                axes = ThreeDAxes()\n                line = Line3D(start=np.array([0, 0, 0]), end=np.array([2, 2, 2]))\n                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n                self.add(axes, line)\n    \"\"\"\n\n    def __init__(\n        self,\n        start: np.ndarray = LEFT,\n        end: np.ndarray = RIGHT,\n        thickness: float = 0.02,\n        color: ParsableManimColor | None = None,\n        resolution: int | Sequence[int] = 24,\n        **kwargs,\n    ):\n        self.thickness = thickness\n        self.resolution = (2, resolution) if isinstance(resolution, int) else resolution\n        self.set_start_and_end_attrs(start, end, **kwargs)\n        if color is not None:\n            self.set_color(color)\n\n    def set_start_and_end_attrs(\n        self, start: np.ndarray, end: np.ndarray, **kwargs\n    ) -> None:\n        \"\"\"Sets the start and end points of the line.\n\n        If either ``start`` or ``end`` are :class:`Mobjects <.Mobject>`,\n        this gives their centers.\n\n        Parameters\n        ----------\n        start\n            Starting point or :class:`Mobject`.\n        end\n            Ending point or :class:`Mobject`.\n        \"\"\"\n        rough_start = self.pointify(start)\n        rough_end = self.pointify(end)\n        self.vect = rough_end - rough_start\n        self.length = np.linalg.norm(self.vect)\n        self.direction = normalize(self.vect)\n        # Now that we know the direction between them,\n        # we can the appropriate boundary point from\n        # start and end, if they're mobjects\n        self.start = self.pointify(start, self.direction)\n        self.end = self.pointify(end, -self.direction)\n        super().__init__(\n            height=np.linalg.norm(self.vect),\n            radius=self.thickness,\n            direction=self.direction,\n            resolution=self.resolution,\n            **kwargs,\n        )\n        self.shift((self.start + self.end) / 2)\n\n    def pointify(\n        self,\n        mob_or_point: Mobject | Point3DLike,\n        direction: Vector3D = None,\n    ) -> np.ndarray:\n        \"\"\"Gets a point representing the center of the :class:`Mobjects <.Mobject>`.\n\n        Parameters\n        ----------\n        mob_or_point\n            :class:`Mobjects <.Mobject>` or point whose center should be returned.\n        direction\n            If an edge of a :class:`Mobjects <.Mobject>` should be returned, the direction of the edge.\n\n        Returns\n        -------\n        :class:`numpy.array`\n            Center of the :class:`Mobjects <.Mobject>` or point, or edge if direction is given.\n        \"\"\"\n        if isinstance(mob_or_point, (Mobject, OpenGLMobject)):\n            mob = mob_or_point\n            if direction is None:\n                return mob.get_center()\n            else:\n                return mob.get_boundary_point(direction)\n        return np.array(mob_or_point)\n\n    def get_start(self) -> np.ndarray:\n        \"\"\"Returns the starting point of the :class:`Line3D`.\n\n        Returns\n        -------\n        start : :class:`numpy.array`\n            Starting point of the :class:`Line3D`.\n        \"\"\"\n        return self.start\n\n    def get_end(self) -> np.ndarray:\n        \"\"\"Returns the ending point of the :class:`Line3D`.\n\n        Returns\n        -------\n        end : :class:`numpy.array`\n            Ending point of the :class:`Line3D`.\n        \"\"\"\n        return self.end\n\n    @classmethod\n    def parallel_to(\n        cls,\n        line: Line3D,\n        point: Vector3D = ORIGIN,\n        length: float = 5,\n        **kwargs,\n    ) -> Line3D:\n        \"\"\"Returns a line parallel to another line going through\n        a given point.\n\n        Parameters\n        ----------\n        line\n            The line to be parallel to.\n        point\n            The point to pass through.\n        length\n            Length of the parallel line.\n        kwargs\n            Additional parameters to be passed to the class.\n\n        Returns\n        -------\n        :class:`Line3D`\n            Line parallel to ``line``.\n\n        Examples\n        --------\n        .. manim:: ParallelLineExample\n            :save_last_frame:\n\n            class ParallelLineExample(ThreeDScene):\n                def construct(self):\n                    self.set_camera_orientation(PI / 3, -PI / 4)\n                    ax = ThreeDAxes((-5, 5), (-5, 5), (-5, 5), 10, 10, 10)\n                    line1 = Line3D(RIGHT * 2, UP + OUT, color=RED)\n                    line2 = Line3D.parallel_to(line1, color=YELLOW)\n                    self.add(ax, line1, line2)\n        \"\"\"\n        point = np.array(point)\n        vect = normalize(line.vect)\n        return cls(\n            point + vect * length / 2,\n            point - vect * length / 2,\n            **kwargs,\n        )\n\n    @classmethod\n    def perpendicular_to(\n        cls,\n        line: Line3D,\n        point: Vector3D = ORIGIN,\n        length: float = 5,\n        **kwargs,\n    ) -> Line3D:\n        \"\"\"Returns a line perpendicular to another line going through\n        a given point.\n\n        Parameters\n        ----------\n        line\n            The line to be perpendicular to.\n        point\n            The point to pass through.\n        length\n            Length of the perpendicular line.\n        kwargs\n            Additional parameters to be passed to the class.\n\n        Returns\n        -------\n        :class:`Line3D`\n            Line perpendicular to ``line``.\n\n        Examples\n        --------\n        .. manim:: PerpLineExample\n            :save_last_frame:\n\n            class PerpLineExample(ThreeDScene):\n                def construct(self):\n                    self.set_camera_orientation(PI / 3, -PI / 4)\n                    ax = ThreeDAxes((-5, 5), (-5, 5), (-5, 5), 10, 10, 10)\n                    line1 = Line3D(RIGHT * 2, UP + OUT, color=RED)\n                    line2 = Line3D.perpendicular_to(line1, color=BLUE)\n                    self.add(ax, line1, line2)\n        \"\"\"\n        point = np.array(point)\n\n        norm = np.cross(line.vect, point - line.start)\n        if all(np.linalg.norm(norm) == np.zeros(3)):\n            raise ValueError(\"Could not find the perpendicular.\")\n\n        start, end = perpendicular_bisector([line.start, line.end], norm)\n        vect = normalize(end - start)\n        return cls(\n            point + vect * length / 2,\n            point - vect * length / 2,\n            **kwargs,\n        )"}, {"name": "line_intersection", "code": "def line_intersection(\n    line1: Sequence[np.ndarray], line2: Sequence[np.ndarray]\n) -> np.ndarray:\n    \"\"\"Returns the intersection point of two lines, each defined by\n    a pair of distinct points lying on the line.\n\n    Parameters\n    ----------\n    line1\n        A list of two points that determine the first line.\n    line2\n        A list of two points that determine the second line.\n\n    Returns\n    -------\n    np.ndarray\n        The intersection points of the two lines which are intersecting.\n\n    Raises\n    ------\n    ValueError\n        Error is produced if the two lines don't intersect with each other\n        or if the coordinates don't lie on the xy-plane.\n    \"\"\"\n    if any(np.array([line1, line2])[:, :, 2].reshape(-1)):\n        # checks for z coordinates != 0\n        raise ValueError(\"Coords must be in the xy-plane.\")\n\n    # algorithm from https://stackoverflow.com/a/42727584\n    padded = (\n        np.pad(np.array(i)[:, :2], ((0, 0), (0, 1)), constant_values=1)\n        for i in (line1, line2)\n    )\n    line1, line2 = (cross(*i) for i in padded)\n    x, y, z = cross(line1, line2)\n\n    if z == 0:\n        raise ValueError(\n            \"The lines are parallel, there is no unique intersection point.\"\n        )\n\n    return np.array([x / z, y / z, 0])"}, {"name": "linear", "code": "def linear(t: float) -> float:\n    return t"}, {"name": "LinearBase", "code": "class LinearBase(_ScaleBase):\n    def __init__(self, scale_factor: float = 1.0):\n        \"\"\"The default scaling class.\n\n        Parameters\n        ----------\n        scale_factor\n            The slope of the linear function, by default 1.0\n        \"\"\"\n        super().__init__()\n        self.scale_factor = scale_factor\n\n    def function(self, value: float) -> float:\n        \"\"\"Multiplies the value by the scale factor.\n\n        Parameters\n        ----------\n        value\n            Value to be multiplied by the scale factor.\n        \"\"\"\n        return self.scale_factor * value\n\n    def inverse_function(self, value: float) -> float:\n        \"\"\"Inverse of function. Divides the value by the scale factor.\n\n        Parameters\n        ----------\n        value\n            value to be divided by the scale factor.\n        \"\"\"\n        return value / self.scale_factor"}, {"name": "LinearTransformationScene", "code": "class LinearTransformationScene(VectorScene):\n    \"\"\"\n    This scene contains special methods that make it\n    especially suitable for showing linear transformations.\n\n    Parameters\n    ----------\n    include_background_plane\n        Whether or not to include the background plane in the scene.\n    include_foreground_plane\n        Whether or not to include the foreground plane in the scene.\n    background_plane_kwargs\n        Parameters to be passed to :class:`NumberPlane` to adjust the background plane.\n    foreground_plane_kwargs\n        Parameters to be passed to :class:`NumberPlane` to adjust the foreground plane.\n    show_coordinates\n        Whether or not to include the coordinates for the background plane.\n    show_basis_vectors\n        Whether to show the basis x_axis -> ``i_hat`` and y_axis -> ``j_hat`` vectors.\n    basis_vector_stroke_width\n        The ``stroke_width`` of the basis vectors.\n    i_hat_color\n        The color of the ``i_hat`` vector.\n    j_hat_color\n        The color of the ``j_hat`` vector.\n    leave_ghost_vectors\n        Indicates the previous position of the basis vectors following a transformation.\n\n    Examples\n    -------\n\n    .. manim:: LinearTransformationSceneExample\n\n        class LinearTransformationSceneExample(LinearTransformationScene):\n            def __init__(self, **kwargs):\n                LinearTransformationScene.__init__(\n                    self,\n                    show_coordinates=True,\n                    leave_ghost_vectors=True,\n                    **kwargs\n                )\n\n            def construct(self):\n                matrix = [[1, 1], [0, 1]]\n                self.apply_matrix(matrix)\n                self.wait()\n    \"\"\"\n\n    def __init__(\n        self,\n        include_background_plane: bool = True,\n        include_foreground_plane: bool = True,\n        background_plane_kwargs: dict | None = None,\n        foreground_plane_kwargs: dict | None = None,\n        show_coordinates: bool = False,\n        show_basis_vectors: bool = True,\n        basis_vector_stroke_width: float = 6,\n        i_hat_color: ParsableManimColor = X_COLOR,\n        j_hat_color: ParsableManimColor = Y_COLOR,\n        leave_ghost_vectors: bool = False,\n        **kwargs,\n    ):\n        super().__init__(**kwargs)\n\n        self.include_background_plane = include_background_plane\n        self.include_foreground_plane = include_foreground_plane\n        self.show_coordinates = show_coordinates\n        self.show_basis_vectors = show_basis_vectors\n        self.basis_vector_stroke_width = basis_vector_stroke_width\n        self.i_hat_color = ManimColor(i_hat_color)\n        self.j_hat_color = ManimColor(j_hat_color)\n        self.leave_ghost_vectors = leave_ghost_vectors\n        self.background_plane_kwargs = {\n            \"color\": GREY,\n            \"axis_config\": {\n                \"color\": GREY,\n            },\n            \"background_line_style\": {\n                \"stroke_color\": GREY,\n                \"stroke_width\": 1,\n            },\n        }\n\n        self.ghost_vectors = VGroup()\n\n        self.foreground_plane_kwargs = {\n            \"x_range\": np.array([-config[\"frame_width\"], config[\"frame_width\"], 1.0]),\n            \"y_range\": np.array([-config[\"frame_width\"], config[\"frame_width\"], 1.0]),\n            \"faded_line_ratio\": 1,\n        }\n\n        self.update_default_configs(\n            (self.foreground_plane_kwargs, self.background_plane_kwargs),\n            (foreground_plane_kwargs, background_plane_kwargs),\n        )\n\n    @staticmethod\n    def update_default_configs(default_configs, passed_configs):\n        for default_config, passed_config in zip(default_configs, passed_configs):\n            if passed_config is not None:\n                update_dict_recursively(default_config, passed_config)\n\n    def setup(self):\n        # The has_already_setup attr is to not break all the old Scenes\n        if hasattr(self, \"has_already_setup\"):\n            return\n        self.has_already_setup = True\n        self.background_mobjects = []\n        self.foreground_mobjects = []\n        self.transformable_mobjects = []\n        self.moving_vectors = []\n        self.transformable_labels = []\n        self.moving_mobjects = []\n\n        self.background_plane = NumberPlane(**self.background_plane_kwargs)\n\n        if self.show_coordinates:\n            self.background_plane.add_coordinates()\n        if self.include_background_plane:\n            self.add_background_mobject(self.background_plane)\n        if self.include_foreground_plane:\n            self.plane = NumberPlane(**self.foreground_plane_kwargs)\n            self.add_transformable_mobject(self.plane)\n        if self.show_basis_vectors:\n            self.basis_vectors = self.get_basis_vectors(\n                i_hat_color=self.i_hat_color,\n                j_hat_color=self.j_hat_color,\n            )\n            self.moving_vectors += list(self.basis_vectors)\n            self.i_hat, self.j_hat = self.basis_vectors\n            self.add(self.basis_vectors)\n\n    def add_special_mobjects(self, mob_list: list, *mobs_to_add: Mobject):\n        \"\"\"\n        Adds mobjects to a separate list that can be tracked,\n        if these mobjects have some extra importance.\n\n        Parameters\n        ----------\n        mob_list\n            The special list to which you want to add\n            these mobjects.\n\n        *mobs_to_add\n            The mobjects to add.\n\n        \"\"\"\n        for mobject in mobs_to_add:\n            if mobject not in mob_list:\n                mob_list.append(mobject)\n                self.add(mobject)\n\n    def add_background_mobject(self, *mobjects: Mobject):\n        \"\"\"\n        Adds the mobjects to the special list\n        self.background_mobjects.\n\n        Parameters\n        ----------\n        *mobjects\n            The mobjects to add to the list.\n        \"\"\"\n        self.add_special_mobjects(self.background_mobjects, *mobjects)\n\n    # TODO, this conflicts with Scene.add_fore\n    def add_foreground_mobject(self, *mobjects: Mobject):\n        \"\"\"\n        Adds the mobjects to the special list\n        self.foreground_mobjects.\n\n        Parameters\n        ----------\n        *mobjects\n            The mobjects to add to the list\n        \"\"\"\n        self.add_special_mobjects(self.foreground_mobjects, *mobjects)\n\n    def add_transformable_mobject(self, *mobjects: Mobject):\n        \"\"\"\n        Adds the mobjects to the special list\n        self.transformable_mobjects.\n\n        Parameters\n        ----------\n        *mobjects\n            The mobjects to add to the list.\n        \"\"\"\n        self.add_special_mobjects(self.transformable_mobjects, *mobjects)\n\n    def add_moving_mobject(\n        self, mobject: Mobject, target_mobject: Mobject | None = None\n    ):\n        \"\"\"\n        Adds the mobject to the special list\n        self.moving_mobject, and adds a property\n        to the mobject called mobject.target, which\n        keeps track of what the mobject will move to\n        or become etc.\n\n        Parameters\n        ----------\n        mobject\n            The mobjects to add to the list\n\n        target_mobject\n            What the moving_mobject goes to, etc.\n        \"\"\"\n        mobject.target = target_mobject\n        self.add_special_mobjects(self.moving_mobjects, mobject)\n\n    def get_ghost_vectors(self) -> VGroup:\n        \"\"\"\n        Returns all ghost vectors ever added to ``self``. Each element is a ``VGroup`` of\n        two ghost vectors.\n        \"\"\"\n        return self.ghost_vectors\n\n    def get_unit_square(\n        self, color: str = YELLOW, opacity: float = 0.3, stroke_width: float = 3\n    ):\n        \"\"\"\n        Returns a unit square for the current NumberPlane.\n\n        Parameters\n        ----------\n        color\n            The string of the hex color code of the color wanted.\n\n        opacity\n            The opacity of the square\n\n        stroke_width\n            The stroke_width in pixels of the border of the square\n\n        Returns\n        -------\n        Square\n        \"\"\"\n        square = self.square = Rectangle(\n            color=color,\n            width=self.plane.get_x_unit_size(),\n            height=self.plane.get_y_unit_size(),\n            stroke_color=color,\n            stroke_width=stroke_width,\n            fill_color=color,\n            fill_opacity=opacity,\n        )\n        square.move_to(self.plane.coords_to_point(0, 0), DL)\n        return square\n\n    def add_unit_square(self, animate: bool = False, **kwargs):\n        \"\"\"\n        Adds a unit square to the scene via\n        self.get_unit_square.\n\n        Parameters\n        ----------\n        animate\n            Whether or not to animate the addition\n            with DrawBorderThenFill.\n        **kwargs\n            Any valid keyword arguments of\n            self.get_unit_square()\n\n        Returns\n        -------\n        Square\n            The unit square.\n        \"\"\"\n        square = self.get_unit_square(**kwargs)\n        if animate:\n            self.play(\n                DrawBorderThenFill(square),\n                Animation(Group(*self.moving_vectors)),\n            )\n        self.add_transformable_mobject(square)\n        self.bring_to_front(*self.moving_vectors)\n        self.square = square\n        return self\n\n    def add_vector(\n        self, vector: Arrow | list | tuple | np.ndarray, color: str = YELLOW, **kwargs\n    ):\n        \"\"\"\n        Adds a vector to the scene, and puts it in the special\n        list self.moving_vectors.\n\n        Parameters\n        ----------\n        vector\n            It can be a pre-made graphical vector, or the\n            coordinates of one.\n\n        color\n            The string of the hex color of the vector.\n            This is only taken into consideration if\n            'vector' is not an Arrow. Defaults to YELLOW.\n\n        **kwargs\n            Any valid keyword argument of VectorScene.add_vector.\n\n        Returns\n        -------\n        Arrow\n            The arrow representing the vector.\n        \"\"\"\n        vector = super().add_vector(vector, color=color, **kwargs)\n        self.moving_vectors.append(vector)\n        return vector\n\n    def write_vector_coordinates(self, vector: Arrow, **kwargs):\n        \"\"\"\n        Returns a column matrix indicating the vector coordinates,\n        after writing them to the screen, and adding them to the\n        special list self.foreground_mobjects\n\n        Parameters\n        ----------\n        vector\n            The arrow representing the vector.\n\n        **kwargs\n            Any valid keyword arguments of VectorScene.write_vector_coordinates\n\n        Returns\n        -------\n        Matrix\n            The column matrix representing the vector.\n        \"\"\"\n        coords = super().write_vector_coordinates(vector, **kwargs)\n        self.add_foreground_mobject(coords)\n        return coords\n\n    def add_transformable_label(\n        self,\n        vector: Vector,\n        label: MathTex | str,\n        transformation_name: str | MathTex = \"L\",\n        new_label: str | MathTex | None = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Method for creating, and animating the addition of\n        a transformable label for the vector.\n\n        Parameters\n        ----------\n        vector\n            The vector for which the label must be added.\n\n        label\n            The MathTex/string of the label.\n\n        transformation_name\n            The name to give the transformation as a label.\n\n        new_label\n            What the label should display after a Linear Transformation\n\n        **kwargs\n            Any valid keyword argument of get_vector_label\n\n        Returns\n        -------\n        :class:`~.MathTex`\n            The MathTex of the label.\n        \"\"\"\n        label_mob = self.label_vector(vector, label, **kwargs)\n        if new_label:\n            label_mob.target_text = new_label\n        else:\n            label_mob.target_text = (\n                f\"{transformation_name}({label_mob.get_tex_string()})\"\n            )\n        label_mob.vector = vector\n        label_mob.kwargs = kwargs\n        if \"animate\" in label_mob.kwargs:\n            label_mob.kwargs.pop(\"animate\")\n        self.transformable_labels.append(label_mob)\n        return label_mob\n\n    def add_title(\n        self,\n        title: str | MathTex | Tex,\n        scale_factor: float = 1.5,\n        animate: bool = False,\n    ):\n        \"\"\"\n        Adds a title, after scaling it, adding a background rectangle,\n        moving it to the top and adding it to foreground_mobjects adding\n        it as a local variable of self. Returns the Scene.\n\n        Parameters\n        ----------\n        title\n            What the title should be.\n\n        scale_factor\n            How much the title should be scaled by.\n\n        animate\n            Whether or not to animate the addition.\n\n        Returns\n        -------\n        LinearTransformationScene\n            The scene with the title added to it.\n        \"\"\"\n        if not isinstance(title, (Mobject, OpenGLMobject)):\n            title = Tex(title).scale(scale_factor)\n        title.to_edge(UP)\n        title.add_background_rectangle()\n        if animate:\n            self.play(Write(title))\n        self.add_foreground_mobject(title)\n        self.title = title\n        return self\n\n    def get_matrix_transformation(self, matrix: np.ndarray | list | tuple):\n        \"\"\"\n        Returns a function corresponding to the linear\n        transformation represented by the matrix passed.\n\n        Parameters\n        ----------\n        matrix\n            The matrix.\n        \"\"\"\n        return self.get_transposed_matrix_transformation(np.array(matrix).T)\n\n    def get_transposed_matrix_transformation(\n        self, transposed_matrix: np.ndarray | list | tuple\n    ):\n        \"\"\"\n        Returns a function corresponding to the linear\n        transformation represented by the transposed\n        matrix passed.\n\n        Parameters\n        ----------\n        transposed_matrix\n            The matrix.\n        \"\"\"\n        transposed_matrix = np.array(transposed_matrix)\n        if transposed_matrix.shape == (2, 2):\n            new_matrix = np.identity(3)\n            new_matrix[:2, :2] = transposed_matrix\n            transposed_matrix = new_matrix\n        elif transposed_matrix.shape != (3, 3):\n            raise ValueError(\"Matrix has bad dimensions\")\n        return lambda point: np.dot(point, transposed_matrix)\n\n    def get_piece_movement(self, pieces: list | tuple | np.ndarray):\n        \"\"\"\n        This method returns an animation that moves an arbitrary\n        mobject in \"pieces\" to its corresponding .target value.\n        If self.leave_ghost_vectors is True, ghosts of the original\n        positions/mobjects are left on screen\n\n        Parameters\n        ----------\n        pieces\n            The pieces for which the movement must be shown.\n\n        Returns\n        -------\n        Animation\n            The animation of the movement.\n        \"\"\"\n        v_pieces = [piece for piece in pieces if isinstance(piece, VMobject)]\n        start = VGroup(*v_pieces)\n        target = VGroup(*(mob.target for mob in v_pieces))\n\n        # don't add empty VGroups\n        if self.leave_ghost_vectors and start.submobjects:\n            # start.copy() gives a VGroup of Vectors\n            self.ghost_vectors.add(start.copy().fade(0.7))\n            self.add(self.ghost_vectors[-1])\n        return Transform(start, target, lag_ratio=0)\n\n    def get_moving_mobject_movement(self, func: Callable[[np.ndarray], np.ndarray]):\n        \"\"\"\n        This method returns an animation that moves a mobject\n        in \"self.moving_mobjects\"  to its corresponding .target value.\n        func is a function that determines where the .target goes.\n\n        Parameters\n        ----------\n\n        func\n            The function that determines where the .target of\n            the moving mobject goes.\n\n        Returns\n        -------\n        Animation\n            The animation of the movement.\n        \"\"\"\n        for m in self.moving_mobjects:\n            if m.target is None:\n                m.target = m.copy()\n            target_point = func(m.get_center())\n            m.target.move_to(target_point)\n        return self.get_piece_movement(self.moving_mobjects)\n\n    def get_vector_movement(self, func: Callable[[np.ndarray], np.ndarray]):\n        \"\"\"\n        This method returns an animation that moves a mobject\n        in \"self.moving_vectors\"  to its corresponding .target value.\n        func is a function that determines where the .target goes.\n\n        Parameters\n        ----------\n\n        func\n            The function that determines where the .target of\n            the moving mobject goes.\n\n        Returns\n        -------\n        Animation\n            The animation of the movement.\n        \"\"\"\n        for v in self.moving_vectors:\n            v.target = Vector(func(v.get_end()), color=v.get_color())\n            norm = np.linalg.norm(v.target.get_end())\n            if norm < 0.1:\n                v.target.get_tip().scale(norm)\n        return self.get_piece_movement(self.moving_vectors)\n\n    def get_transformable_label_movement(self):\n        \"\"\"\n        This method returns an animation that moves all labels\n        in \"self.transformable_labels\" to its corresponding .target .\n\n        Returns\n        -------\n        Animation\n            The animation of the movement.\n        \"\"\"\n        for label in self.transformable_labels:\n            label.target = self.get_vector_label(\n                label.vector.target, label.target_text, **label.kwargs\n            )\n        return self.get_piece_movement(self.transformable_labels)\n\n    def apply_matrix(self, matrix: np.ndarray | list | tuple, **kwargs):\n        \"\"\"\n        Applies the transformation represented by the\n        given matrix to the number plane, and each vector/similar\n        mobject on it.\n\n        Parameters\n        ----------\n        matrix\n            The matrix.\n        **kwargs\n            Any valid keyword argument of self.apply_transposed_matrix()\n        \"\"\"\n        self.apply_transposed_matrix(np.array(matrix).T, **kwargs)\n\n    def apply_inverse(self, matrix: np.ndarray | list | tuple, **kwargs):\n        \"\"\"\n        This method applies the linear transformation\n        represented by the inverse of the passed matrix\n        to the number plane, and each vector/similar mobject on it.\n\n        Parameters\n        ----------\n        matrix\n            The matrix whose inverse is to be applied.\n        **kwargs\n            Any valid keyword argument of self.apply_matrix()\n        \"\"\"\n        self.apply_matrix(np.linalg.inv(matrix), **kwargs)\n\n    def apply_transposed_matrix(\n        self, transposed_matrix: np.ndarray | list | tuple, **kwargs\n    ):\n        \"\"\"\n        Applies the transformation represented by the\n        given transposed matrix to the number plane,\n        and each vector/similar mobject on it.\n\n        Parameters\n        ----------\n        transposed_matrix\n            The matrix.\n        **kwargs\n            Any valid keyword argument of self.apply_function()\n        \"\"\"\n        func = self.get_transposed_matrix_transformation(transposed_matrix)\n        if \"path_arc\" not in kwargs:\n            net_rotation = np.mean(\n                [angle_of_vector(func(RIGHT)), angle_of_vector(func(UP)) - np.pi / 2],\n            )\n            kwargs[\"path_arc\"] = net_rotation\n        self.apply_function(func, **kwargs)\n\n    def apply_inverse_transpose(self, t_matrix: np.ndarray | list | tuple, **kwargs):\n        \"\"\"\n        Applies the inverse of the transformation represented\n        by the given transposed matrix to the number plane and each\n        vector/similar mobject on it.\n\n        Parameters\n        ----------\n        t_matrix\n            The matrix.\n        **kwargs\n            Any valid keyword argument of self.apply_transposed_matrix()\n        \"\"\"\n        t_inv = np.linalg.inv(np.array(t_matrix).T).T\n        self.apply_transposed_matrix(t_inv, **kwargs)\n\n    def apply_nonlinear_transformation(\n        self, function: Callable[[np.ndarray], np.ndarray], **kwargs\n    ):\n        \"\"\"\n        Applies the non-linear transformation represented\n        by the given function to the number plane and each\n        vector/similar mobject on it.\n\n        Parameters\n        ----------\n        function\n            The function.\n        **kwargs\n            Any valid keyword argument of self.apply_function()\n        \"\"\"\n        self.plane.prepare_for_nonlinear_transform()\n        self.apply_function(function, **kwargs)\n\n    def apply_function(\n        self,\n        function: Callable[[np.ndarray], np.ndarray],\n        added_anims: list = [],\n        **kwargs,\n    ):\n        \"\"\"\n        Applies the given function to each of the mobjects in\n        self.transformable_mobjects, and plays the animation showing\n        this.\n\n        Parameters\n        ----------\n        function\n            The function that affects each point\n            of each mobject in self.transformable_mobjects.\n\n        added_anims\n            Any other animations that need to be played\n            simultaneously with this.\n\n        **kwargs\n            Any valid keyword argument of a self.play() call.\n        \"\"\"\n        if \"run_time\" not in kwargs:\n            kwargs[\"run_time\"] = 3\n        anims = (\n            [\n                ApplyPointwiseFunction(function, t_mob)\n                for t_mob in self.transformable_mobjects\n            ]\n            + [\n                self.get_vector_movement(function),\n                self.get_transformable_label_movement(),\n                self.get_moving_mobject_movement(function),\n            ]\n            + [Animation(f_mob) for f_mob in self.foreground_mobjects]\n            + added_anims\n        )\n        self.play(*anims, **kwargs)"}, {"name": "LineJointType", "code": "class LineJointType(Enum):\n    \"\"\"Collection of available line joint types.\n\n    See the example below for a visual illustration of the different\n    joint types.\n\n    Examples\n    --------\n\n    .. manim:: LineJointVariants\n        :save_last_frame:\n\n        class LineJointVariants(Scene):\n            def construct(self):\n                mob = VMobject(stroke_width=20, color=GREEN).set_points_as_corners([\n                    np.array([-2, 0, 0]),\n                    np.array([0, 0, 0]),\n                    np.array([-2, 1, 0]),\n                ])\n                lines = VGroup(*[mob.copy() for _ in range(len(LineJointType))])\n                for line, joint_type in zip(lines, LineJointType):\n                    line.joint_type = joint_type\n\n                lines.arrange(RIGHT, buff=1)\n                self.add(lines)\n                for line in lines:\n                    label = Text(line.joint_type.name).next_to(line, DOWN)\n                    self.add(label)\n    \"\"\"\n\n    AUTO = 0\n    ROUND = 1\n    BEVEL = 2\n    MITER = 3"}, {"name": "lingering", "code": "def lingering(t: float) -> float:\n    def identity(t: float) -> float:\n        return t\n\n    # TODO: Isn't this just 0.8 * t?\n    return squish_rate_func(identity, 0, 0.8)(t)"}, {"name": "list_difference_update", "code": "def list_difference_update(l1: Iterable[T], l2: Iterable[T]) -> list[T]:\n    \"\"\"Returns a list containing all the elements of l1 not in l2.\n\n    Examples\n    --------\n    .. code-block:: pycon\n\n        >>> list_difference_update([1, 2, 3, 4], [2, 4])\n        [1, 3]\n    \"\"\"\n    return [e for e in l1 if e not in l2]"}, {"name": "list_plugins", "code": "def list_plugins() -> None:\n    console.print(\"[green bold]Plugins:[/green bold]\", justify=\"left\")\n\n    plugins = get_plugins()\n    for plugin_name in plugins:\n        console.print(f\" \u2022 {plugin_name}\")"}, {"name": "list_update", "code": "def list_update(l1: Iterable[T], l2: Iterable[T]) -> list[T]:\n    \"\"\"Used instead of ``set.update()`` to maintain order,\n        making sure duplicates are removed from l1, not l2.\n        Removes overlap of l1 and l2 and then concatenates l2 unchanged.\n\n    Examples\n    --------\n    .. code-block:: pycon\n\n        >>> list_update([1, 2, 3], [2, 4, 4])\n        [1, 3, 2, 4, 4]\n    \"\"\"\n    return [e for e in l1 if e not in l2] + list(l2)"}, {"name": "listify", "code": "def listify(obj: str | Iterable[T] | T) -> list[str] | list[T]:\n    \"\"\"Converts obj to a list intelligently.\n\n    Examples\n    --------\n    .. code-block:: pycon\n\n        >>> listify(\"str\")\n        ['str']\n        >>> listify((1, 2))\n        [1, 2]\n        >>> listify(len)\n        [<built-in function len>]\n    \"\"\"\n    if isinstance(obj, str):\n        return [obj]\n    if isinstance(obj, Iterable):\n        return list(obj)\n    else:\n        return [obj]"}, {"name": "LogBase", "code": "class LogBase(_ScaleBase):\n    def __init__(self, base: float = 10, custom_labels: bool = True):\n        \"\"\"Scale for logarithmic graphs/functions.\n\n        Parameters\n        ----------\n        base\n            The base of the log, by default 10.\n        custom_labels\n            For use with :class:`~.Axes`:\n            Whether or not to include ``LaTeX`` axis labels, by default True.\n\n        Examples\n        --------\n        .. code-block:: python\n\n            func = ParametricFunction(lambda x: x, scaling=LogBase(base=2))\n\n        \"\"\"\n        super().__init__()\n        self.base = base\n        self.custom_labels = custom_labels\n\n    def function(self, value: float) -> float:\n        \"\"\"Scales the value to fit it to a logarithmic scale.``self.function(5)==10**5``\"\"\"\n        return self.base**value\n\n    def inverse_function(self, value: float) -> float:\n        \"\"\"Inverse of ``function``. The value must be greater than 0\"\"\"\n        if isinstance(value, np.ndarray):\n            condition = value.any() <= 0\n\n            def func(value, base):\n                return np.log(value) / np.log(base)\n        else:\n            condition = value <= 0\n            func = math.log\n\n        if condition:\n            raise ValueError(\n                \"log(0) is undefined. Make sure the value is in the domain of the function\"\n            )\n        value = func(value, self.base)\n        return value\n\n    def get_custom_labels(\n        self,\n        val_range: Iterable[float],\n        unit_decimal_places: int = 0,\n        **base_config: dict[str, Any],\n    ) -> list[Mobject]:\n        \"\"\"Produces custom :class:`~.Integer` labels in the form of ``10^2``.\n\n        Parameters\n        ----------\n        val_range\n            The iterable of values used to create the labels. Determines the exponent.\n        unit_decimal_places\n            The number of decimal places to include in the exponent\n        base_config\n            Additional arguments to be passed to :class:`~.Integer`.\n        \"\"\"\n        # uses `format` syntax to control the number of decimal places.\n        tex_labels = [\n            Integer(\n                self.base,\n                unit=\"^{%s}\" % (f\"{self.inverse_function(i):.{unit_decimal_places}f}\"),  # noqa: UP031\n                **base_config,\n            )\n            for i in val_range\n        ]\n        return tex_labels"}, {"name": "main", "code": "def main(ctx: click.Context) -> None:\n    \"\"\"The entry point for Manim.\n\n    Parameters\n    ----------\n    ctx\n        The Click context.\n    \"\"\"\n    pass"}, {"name": "MaintainPositionRelativeTo", "code": "class MaintainPositionRelativeTo(Animation):\n    def __init__(self, mobject: Mobject, tracked_mobject: Mobject, **kwargs) -> None:\n        self.tracked_mobject = tracked_mobject\n        self.diff = op.sub(\n            mobject.get_center(),\n            tracked_mobject.get_center(),\n        )\n        super().__init__(mobject, **kwargs)\n\n    def interpolate_mobject(self, alpha: float) -> None:\n        target = self.tracked_mobject.get_center()\n        location = self.mobject.get_center()\n        self.mobject.shift(target - location + self.diff)"}, {"name": "make_config_parser", "code": "def make_config_parser(\n    custom_file: StrPath | None = None,\n) -> configparser.ConfigParser:\n    \"\"\"Make a :class:`ConfigParser` object and load any ``.cfg`` files.\n\n    The user-wide file, if it exists, overrides the library-wide file.  The\n    folder-wide file, if it exists, overrides the other two.\n\n    The folder-wide file can be ignored by passing ``custom_file``.  However,\n    the user-wide and library-wide config files cannot be ignored.\n\n    Parameters\n    ----------\n    custom_file\n        Path to a custom config file.  If used, the folder-wide file in the\n        relevant directory will be ignored, if it exists.  If None, the\n        folder-wide file will be used, if it exists.\n\n    Returns\n    -------\n    :class:`ConfigParser`\n        A parser containing the config options found in the .cfg files that\n        were found.  It is guaranteed to contain at least the config options\n        found in the library-wide file.\n\n    See Also\n    --------\n    :func:`config_file_paths`\n\n    \"\"\"\n    library_wide, user_wide, folder_wide = config_file_paths()\n    # From the documentation: \"An application which requires initial values to\n    # be loaded from a file should load the required file or files using\n    # read_file() before calling read() for any optional files.\"\n    # https://docs.python.org/3/library/configparser.html#configparser.ConfigParser.read\n    parser = configparser.ConfigParser()\n    with library_wide.open() as file:\n        parser.read_file(file)  # necessary file\n\n    other_files = [user_wide, Path(custom_file) if custom_file else folder_wide]\n    parser.read(other_files)  # optional files\n\n    return parser"}, {"name": "make_even", "code": "def make_even(\n    iterable_1: Iterable[T], iterable_2: Iterable[U]\n) -> tuple[list[T], list[U]]:\n    \"\"\"Extends the shorter of the two iterables with duplicate values until its\n        length is equal to the longer iterable (favours earlier elements).\n\n    See Also\n    --------\n    make_even_by_cycling : cycles elements instead of favouring earlier ones\n\n    Examples\n    --------\n    .. code-block:: pycon\n\n        >>> make_even([1, 2], [3, 4, 5, 6])\n        ([1, 1, 2, 2], [3, 4, 5, 6])\n\n        >>> make_even([1, 2], [3, 4, 5, 6, 7])\n        ([1, 1, 1, 2, 2], [3, 4, 5, 6, 7])\n    \"\"\"\n    list_1, list_2 = list(iterable_1), list(iterable_2)\n    len_list_1 = len(list_1)\n    len_list_2 = len(list_2)\n    length = max(len_list_1, len_list_2)\n    return (\n        [list_1[(n * len_list_1) // length] for n in range(length)],\n        [list_2[(n * len_list_2) // length] for n in range(length)],\n    )"}, {"name": "make_even_by_cycling", "code": "def make_even_by_cycling(\n    iterable_1: Collection[T], iterable_2: Collection[U]\n) -> tuple[list[T], list[U]]:\n    \"\"\"Extends the shorter of the two iterables with duplicate values until its\n        length is equal to the longer iterable (cycles over shorter iterable).\n\n    See Also\n    --------\n    make_even : favours earlier elements instead of cycling them\n\n    Examples\n    --------\n    .. code-block:: pycon\n\n        >>> make_even_by_cycling([1, 2], [3, 4, 5, 6])\n        ([1, 2, 1, 2], [3, 4, 5, 6])\n\n        >>> make_even_by_cycling([1, 2], [3, 4, 5, 6, 7])\n        ([1, 2, 1, 2, 1], [3, 4, 5, 6, 7])\n    \"\"\"\n    length = max(len(iterable_1), len(iterable_2))\n    cycle1 = it.cycle(iterable_1)\n    cycle2 = it.cycle(iterable_2)\n    return (\n        [next(cycle1) for _ in range(length)],\n        [next(cycle2) for _ in range(length)],\n    )"}, {"name": "make_logger", "code": "def make_logger(\n    parser: configparser.SectionProxy,\n    verbosity: str,\n) -> tuple[logging.Logger, Console, Console]:\n    \"\"\"Make the manim logger and console.\n\n    Parameters\n    ----------\n    parser\n        A parser containing any .cfg files in use.\n\n    verbosity\n        The verbosity level of the logger.\n\n    Returns\n    -------\n    :class:`logging.Logger`, :class:`rich.Console`, :class:`rich.Console`\n        The manim logger and consoles. The first console outputs\n        to stdout, the second to stderr. All use the theme returned by\n        :func:`parse_theme`.\n\n    See Also\n    --------\n    :func:`~._config.utils.make_config_parser`, :func:`parse_theme`\n\n    Notes\n    -----\n    The ``parser`` is assumed to contain only the options related to\n    configuring the logger at the top level.\n\n    \"\"\"\n    # Throughout the codebase, use console.print() instead of print()\n    theme = parse_theme(parser)\n    console = Console(theme=theme)\n\n    error_console = Console(theme=theme, stderr=True)\n\n    # set the rich handler\n    rich_handler = RichHandler(\n        console=console,\n        show_time=parser.getboolean(\"log_timestamps\", fallback=False),\n        keywords=HIGHLIGHTED_KEYWORDS,\n    )\n\n    # finally, the logger\n    logger = logging.getLogger(\"manim\")\n    logger.addHandler(rich_handler)\n    logger.setLevel(verbosity)\n    logger.propagate = False\n\n    if not (libav_logger := logging.getLogger()).hasHandlers():\n        libav_logger.addHandler(rich_handler)\n        libav_logger.setLevel(verbosity)\n\n    return logger, console, error_console"}, {"name": "make_tex_compilation_command", "code": "def make_tex_compilation_command(\n    tex_compiler: str, output_format: str, tex_file: Path, tex_dir: Path\n) -> list[str]:\n    \"\"\"Prepares the TeX compilation command, i.e. the TeX compiler name\n    and all necessary CLI flags.\n\n    Parameters\n    ----------\n    tex_compiler\n        String containing the compiler to be used, e.g. ``pdflatex`` or ``lualatex``\n    output_format\n        String containing the output format generated by the compiler, e.g. ``.dvi`` or ``.pdf``\n    tex_file\n        File name of TeX file to be typeset.\n    tex_dir\n        Path to the directory where compiler output will be stored.\n\n    Returns\n    -------\n    :class:`list[str]`\n        Compilation command according to given parameters\n    \"\"\"\n    if tex_compiler in {\"latex\", \"pdflatex\", \"luatex\", \"lualatex\"}:\n        command = [\n            tex_compiler,\n            \"-interaction=batchmode\",\n            f\"-output-format={output_format[1:]}\",\n            \"-halt-on-error\",\n            f\"-output-directory={tex_dir.as_posix()}\",\n            f\"{tex_file.as_posix()}\",\n        ]\n    elif tex_compiler == \"xelatex\":\n        if output_format == \".xdv\":\n            outflag = [\"-no-pdf\"]\n        elif output_format == \".pdf\":\n            outflag = []\n        else:\n            raise ValueError(\"xelatex output is either pdf or xdv\")\n        command = [\n            \"xelatex\",\n            *outflag,\n            \"-interaction=batchmode\",\n            \"-halt-on-error\",\n            f\"-output-directory={tex_dir.as_posix()}\",\n            f\"{tex_file.as_posix()}\",\n        ]\n    else:\n        raise ValueError(f\"Tex compiler {tex_compiler} unknown.\")\n    return command"}, {"name": "ManimBanner", "code": "class ManimBanner(VGroup):\n    r\"\"\"Convenience class representing Manim's banner.\n\n    Can be animated using custom methods.\n\n    Parameters\n    ----------\n    dark_theme\n        If ``True`` (the default), the dark theme version of the logo\n        (with light text font) will be rendered. Otherwise, if ``False``,\n        the light theme version (with dark text font) is used.\n\n    Examples\n    --------\n    .. manim:: DarkThemeBanner\n\n        class DarkThemeBanner(Scene):\n            def construct(self):\n                banner = ManimBanner()\n                self.play(banner.create())\n                self.play(banner.expand())\n                self.wait()\n                self.play(Unwrite(banner))\n\n    .. manim:: LightThemeBanner\n\n        class LightThemeBanner(Scene):\n            def construct(self):\n                self.camera.background_color = \"#ece6e2\"\n                banner = ManimBanner(dark_theme=False)\n                self.play(banner.create())\n                self.play(banner.expand())\n                self.wait()\n                self.play(Unwrite(banner))\n\n    \"\"\"\n\n    def __init__(self, dark_theme: bool = True):\n        super().__init__()\n\n        logo_green = \"#81b29a\"\n        logo_blue = \"#454866\"\n        logo_red = \"#e07a5f\"\n        m_height_over_anim_height = 0.75748\n\n        self.font_color = \"#ece6e2\" if dark_theme else \"#343434\"\n        self.scale_factor = 1\n\n        self.M = VMobjectFromSVGPath(MANIM_SVG_PATHS[0]).flip(cst.RIGHT).center()\n        self.M.set(stroke_width=0).scale(\n            7 * cst.DEFAULT_FONT_SIZE * cst.SCALE_FACTOR_PER_FONT_POINT\n        )\n        self.M.set_fill(color=self.font_color, opacity=1).shift(\n            2.25 * cst.LEFT + 1.5 * cst.UP\n        )\n\n        self.circle = Circle(color=logo_green, fill_opacity=1).shift(cst.LEFT)\n        self.square = Square(color=logo_blue, fill_opacity=1).shift(cst.UP)\n        self.triangle = Triangle(color=logo_red, fill_opacity=1).shift(cst.RIGHT)\n        self.shapes = VGroup(self.triangle, self.square, self.circle)\n        self.add(self.shapes, self.M)\n        self.move_to(cst.ORIGIN)\n\n        anim = VGroup()\n        for ind, path in enumerate(MANIM_SVG_PATHS[1:]):\n            tex = VMobjectFromSVGPath(path).flip(cst.RIGHT).center()\n            tex.set(stroke_width=0).scale(\n                cst.DEFAULT_FONT_SIZE * cst.SCALE_FACTOR_PER_FONT_POINT\n            )\n            if ind > 0:\n                tex.next_to(anim, buff=0.01)\n            tex.align_to(self.M, cst.DOWN)\n            anim.add(tex)\n        anim.set_fill(color=self.font_color, opacity=1)\n        anim.height = m_height_over_anim_height * self.M.height\n\n        # Note: \"anim\" is only shown in the expanded state\n        # and thus not yet added to the submobjects of self.\n        self.anim = anim\n\n    def scale(self, scale_factor: float, **kwargs) -> ManimBanner:\n        \"\"\"Scale the banner by the specified scale factor.\n\n        Parameters\n        ----------\n        scale_factor\n            The factor used for scaling the banner.\n\n        Returns\n        -------\n        :class:`~.ManimBanner`\n            The scaled banner.\n        \"\"\"\n        self.scale_factor *= scale_factor\n        # Note: self.anim is only added to self after expand()\n        if self.anim not in self.submobjects:\n            self.anim.scale(scale_factor, **kwargs)\n        return super().scale(scale_factor, **kwargs)\n\n    @override_animation(Create)\n    def create(self, run_time: float = 2) -> AnimationGroup:\n        \"\"\"The creation animation for Manim's logo.\n\n        Parameters\n        ----------\n        run_time\n            The run time of the animation.\n\n        Returns\n        -------\n        :class:`~.AnimationGroup`\n            An animation to be used in a :meth:`.Scene.play` call.\n        \"\"\"\n        return AnimationGroup(\n            SpiralIn(self.shapes, run_time=run_time),\n            FadeIn(self.M, run_time=run_time / 2),\n            lag_ratio=0.1,\n        )\n\n    def expand(self, run_time: float = 1.5, direction=\"center\") -> Succession:\n        \"\"\"An animation that expands Manim's logo into its banner.\n\n        The returned animation transforms the banner from its initial\n        state (representing Manim's logo with just the icons) to its\n        expanded state (showing the full name together with the icons).\n\n        See the class documentation for how to use this.\n\n        .. note::\n\n            Before calling this method, the text \"anim\" is not a\n            submobject of the banner object. After the expansion,\n            it is added as a submobject so subsequent animations\n            to the banner object apply to the text \"anim\" as well.\n\n        Parameters\n        ----------\n        run_time\n            The run time of the animation.\n        direction\n            The direction in which the logo is expanded.\n\n        Returns\n        -------\n        :class:`~.Succession`\n            An animation to be used in a :meth:`.Scene.play` call.\n\n        Examples\n        --------\n        .. manim:: ExpandDirections\n\n            class ExpandDirections(Scene):\n                def construct(self):\n                    banners = [ManimBanner().scale(0.5).shift(UP*x) for x in [-2, 0, 2]]\n                    self.play(\n                        banners[0].expand(direction=\"right\"),\n                        banners[1].expand(direction=\"center\"),\n                        banners[2].expand(direction=\"left\"),\n                    )\n\n        \"\"\"\n        if direction not in [\"left\", \"right\", \"center\"]:\n            raise ValueError(\"direction must be 'left', 'right' or 'center'.\")\n\n        m_shape_offset = 6.25 * self.scale_factor\n        shape_sliding_overshoot = self.scale_factor * 0.8\n        m_anim_buff = 0.06\n        self.anim.next_to(self.M, buff=m_anim_buff).align_to(self.M, cst.DOWN)\n        self.anim.set_opacity(0)\n        self.shapes.save_state()\n        m_clone = self.anim[-1].copy()\n        self.add(m_clone)\n        m_clone.move_to(self.shapes)\n\n        self.M.save_state()\n        left_group = VGroup(self.M, self.anim, m_clone)\n\n        def shift(vector):\n            self.shapes.restore()\n            left_group.align_to(self.M.saved_state, cst.LEFT)\n            if direction == \"right\":\n                self.shapes.shift(vector)\n            elif direction == \"center\":\n                self.shapes.shift(vector / 2)\n                left_group.shift(-vector / 2)\n            elif direction == \"left\":\n                left_group.shift(-vector)\n\n        def slide_and_uncover(mob, alpha):\n            shift(alpha * (m_shape_offset + shape_sliding_overshoot) * cst.RIGHT)\n\n            # Add letters when they are covered\n            for letter in mob.anim:\n                if mob.square.get_center()[0] > letter.get_center()[0]:\n                    letter.set_opacity(1)\n                    self.add_to_back(letter)\n\n            # Finish animation\n            if alpha == 1:\n                self.remove(*[self.anim])\n                self.add_to_back(self.anim)\n                mob.shapes.set_z_index(0)\n                mob.shapes.save_state()\n                mob.M.save_state()\n\n        def slide_back(mob, alpha):\n            if alpha == 0:\n                m_clone.set_opacity(1)\n                m_clone.move_to(mob.anim[-1])\n                mob.anim.set_opacity(1)\n\n            shift(alpha * shape_sliding_overshoot * cst.LEFT)\n\n            if alpha == 1:\n                mob.remove(m_clone)\n                mob.add_to_back(mob.shapes)\n\n        return Succession(\n            UpdateFromAlphaFunc(\n                self,\n                slide_and_uncover,\n                run_time=run_time * 2 / 3,\n                rate_func=ease_in_out_cubic,\n            ),\n            UpdateFromAlphaFunc(\n                self,\n                slide_back,\n                run_time=run_time * 1 / 3,\n                rate_func=smooth,\n            ),\n        )"}, {"name": "ManimColor", "code": "class ManimColor:\n    \"\"\"Internal representation of a color.\n\n    The :class:`ManimColor` class is the main class for the representation of a color.\n    Its internal representation is an array of 4 floats corresponding to a ``[r,g,b,a]``\n    value where ``r,g,b,a`` can be between 0.0 and 1.0.\n\n    This is done in order to reduce the amount of color inconsistencies by constantly\n    casting between integers and floats which introduces errors.\n\n    The class can accept any value of type :class:`ParsableManimColor` i.e.\n\n    ``ManimColor, int, str, RGB_Tuple_Int, RGB_Tuple_Float, RGBA_Tuple_Int, RGBA_Tuple_Float, RGB_Array_Int,\n    RGB_Array_Float, RGBA_Array_Int, RGBA_Array_Float``\n\n    :class:`ManimColor` itself only accepts singular values and will directly interpret\n    them into a single color if possible. Be careful when passing strings to\n    :class:`ManimColor`: it can create a big overhead for the color processing.\n\n    If you want to parse a list of colors, use the :meth:`parse` method, which assumes\n    that you're going to pass a list of colors so that arrays will not be interpreted as\n    a single color.\n\n    .. warning::\n        If you pass an array of numbers to :meth:`parse`, it will interpret the\n        ``r,g,b,a`` numbers in that array as colors: Instead of the expected\n        singular color, you will get an array with 4 colors.\n\n    For conversion behaviors, see the ``_internal`` functions for further documentation.\n\n    You can create a :class:`ManimColor` instance via its classmethods. See the\n    respective methods for more info.\n\n    .. code-block:: python\n\n        mycolor = ManimColor.from_rgb((0, 1, 0.4, 0.5))\n        myothercolor = ManimColor.from_rgb((153, 255, 255))\n\n    You can also convert between different color spaces:\n\n    .. code-block:: python\n\n        mycolor_hex = mycolor.to_hex()\n        myoriginalcolor = ManimColor.from_hex(mycolor_hex).to_hsv()\n\n    Parameters\n    ----------\n    value\n        Some representation of a color (e.g., a string or\n        a suitable tuple). The default ``None`` is ``BLACK``.\n    alpha\n        The opacity of the color. By default, colors are\n        fully opaque (value 1.0).\n    \"\"\"\n\n    def __init__(\n        self,\n        value: ParsableManimColor | None,\n        alpha: float = 1.0,\n    ) -> None:\n        if value is None:\n            self._internal_value = np.array((0, 0, 0, alpha), dtype=ManimColorDType)\n        elif isinstance(value, ManimColor):\n            # logger.info(\n            #     \"ManimColor was passed another ManimColor. This is probably not what \"\n            #     \"you want. Created a copy of the passed ManimColor instead.\"\n            # )\n            self._internal_value = value._internal_value\n        elif isinstance(value, int):\n            self._internal_value = ManimColor._internal_from_integer(value, alpha)\n        elif isinstance(value, str):\n            result = re_hex.search(value)\n            if result is not None:\n                self._internal_value = ManimColor._internal_from_hex_string(\n                    result.group(), alpha\n                )\n            else:\n                # This is not expected to be called on module initialization time\n                # It can be horribly slow to convert a string to a color because\n                # it has to access the dictionary of colors and find the right color\n                self._internal_value = ManimColor._internal_from_string(value, alpha)\n        elif isinstance(value, (list, tuple, np.ndarray)):\n            length = len(value)\n            if all(isinstance(x, float) for x in value):\n                if length == 3:\n                    self._internal_value = ManimColor._internal_from_rgb(value, alpha)  # type: ignore[arg-type]\n                elif length == 4:\n                    self._internal_value = ManimColor._internal_from_rgba(value)  # type: ignore[arg-type]\n                else:\n                    raise ValueError(\n                        f\"ManimColor only accepts lists/tuples/arrays of length 3 or 4, not {length}\"\n                    )\n            else:\n                if length == 3:\n                    self._internal_value = ManimColor._internal_from_int_rgb(\n                        value,  # type: ignore[arg-type]\n                        alpha,\n                    )\n                elif length == 4:\n                    self._internal_value = ManimColor._internal_from_int_rgba(value)  # type: ignore[arg-type]\n                else:\n                    raise ValueError(\n                        f\"ManimColor only accepts lists/tuples/arrays of length 3 or 4, not {length}\"\n                    )\n        elif hasattr(value, \"get_hex\") and callable(value.get_hex):\n            result = re_hex.search(value.get_hex())\n            if result is None:\n                raise ValueError(f\"Failed to parse a color from {value}\")\n            self._internal_value = ManimColor._internal_from_hex_string(\n                result.group(), alpha\n            )\n        else:\n            # logger.error(f\"Invalid color value: {value}\")\n            raise TypeError(\n                \"ManimColor only accepts int, str, list[int, int, int], \"\n                \"list[int, int, int, int], list[float, float, float], \"\n                f\"list[float, float, float, float], not {type(value)}\"\n            )\n\n    @property\n    def _internal_space(self) -> npt.NDArray[ManimFloat]:\n        \"\"\"This is a readonly property which is a custom representation for color space\n        operations. It is used for operators and can be used when implementing a custom\n        color space.\n        \"\"\"\n        return self._internal_value\n\n    @property\n    def _internal_value(self) -> ManimColorInternal:\n        \"\"\"Return the internal value of the current Manim color ``[r,g,b,a]`` float\n        array.\n\n        Returns\n        -------\n        ManimColorInternal\n            Internal color representation.\n        \"\"\"\n        return self.__value\n\n    @_internal_value.setter\n    def _internal_value(self, value: ManimColorInternal) -> None:\n        \"\"\"Overwrite the internal color value of this :class:`ManimColor`.\n\n        Parameters\n        ----------\n        value\n            The value which will overwrite the current color.\n\n        Raises\n        ------\n        TypeError\n            If an invalid array is passed.\n        \"\"\"\n        if not isinstance(value, np.ndarray):\n            raise TypeError(\"Value must be a NumPy array.\")\n        if value.shape[0] != 4:\n            raise TypeError(\"Array must have exactly 4 values.\")\n        self.__value: ManimColorInternal = value\n\n    @classmethod\n    def _construct_from_space(\n        cls,\n        _space: npt.NDArray[ManimFloat]\n        | tuple[float, float, float]\n        | tuple[float, float, float, float],\n    ) -> Self:\n        \"\"\"This function is used as a proxy for constructing a color with an internal\n        value. This can be used by subclasses to hook into the construction of new\n        objects using the internal value format.\n        \"\"\"\n        return cls(_space)\n\n    @staticmethod\n    def _internal_from_integer(value: int, alpha: float) -> ManimColorInternal:\n        return np.asarray(\n            (\n                ((value >> 16) & 0xFF) / 255,\n                ((value >> 8) & 0xFF) / 255,\n                ((value >> 0) & 0xFF) / 255,\n                alpha,\n            ),\n            dtype=ManimColorDType,\n        )\n\n    @staticmethod\n    def _internal_from_hex_string(hex_: str, alpha: float) -> ManimColorInternal:\n        \"\"\"Internal function for converting a hex string into the internal representation\n        of a :class:`ManimColor`.\n\n        .. warning::\n            This does not accept any prefixes like # or similar in front of the hex string.\n            This is just intended for the raw hex part.\n\n        *For internal use only*\n\n        Parameters\n        ----------\n        hex\n            Hex string to be parsed.\n        alpha\n            Alpha value used for the color, if the color is only 3 bytes long. Otherwise,\n            if the color is 4 bytes long, this parameter will not be used.\n\n        Returns\n        -------\n        ManimColorInternal\n            Internal color representation\n        \"\"\"\n        if len(hex_) in (3, 4):\n            hex_ = \"\".join([x * 2 for x in hex_])\n        if len(hex_) == 6:\n            hex_ += \"FF\"\n        elif len(hex_) == 8:\n            alpha = (int(hex_, 16) & 0xFF) / 255\n        else:\n            raise ValueError(\n                \"Hex colors must be specified with either 0x or # as prefix and contain 6 or 8 hexadecimal numbers\"\n            )\n        tmp = int(hex_, 16)\n        return np.asarray(\n            (\n                ((tmp >> 24) & 0xFF) / 255,\n                ((tmp >> 16) & 0xFF) / 255,\n                ((tmp >> 8) & 0xFF) / 255,\n                alpha,\n            ),\n            dtype=ManimColorDType,\n        )\n\n    @staticmethod\n    def _internal_from_int_rgb(\n        rgb: RGB_Tuple_Int, alpha: float = 1.0\n    ) -> ManimColorInternal:\n        \"\"\"Internal function for converting an RGB tuple of integers into the internal\n        representation of a :class:`ManimColor`.\n\n        *For internal use only*\n\n        Parameters\n        ----------\n        rgb\n            Integer RGB tuple to be parsed\n        alpha\n            Optional alpha value. Default is 1.0.\n\n        Returns\n        -------\n        ManimColorInternal\n            Internal color representation.\n        \"\"\"\n        value: np.ndarray = np.asarray(rgb, dtype=ManimColorDType).copy() / 255\n        value.resize(4, refcheck=False)\n        value[3] = alpha\n        return value\n\n    @staticmethod\n    def _internal_from_rgb(\n        rgb: RGB_Tuple_Float, alpha: float = 1.0\n    ) -> ManimColorInternal:\n        \"\"\"Internal function for converting a rgb tuple of floats into the internal\n        representation of a :class:`ManimColor`.\n\n        *For internal use only*\n\n        Parameters\n        ----------\n        rgb\n            Float RGB tuple to be parsed.\n        alpha\n            Optional alpha value. Default is 1.0.\n\n        Returns\n        -------\n        ManimColorInternal\n            Internal color representation.\n        \"\"\"\n        value: np.ndarray = np.asarray(rgb, dtype=ManimColorDType).copy()\n        value.resize(4, refcheck=False)\n        value[3] = alpha\n        return value\n\n    @staticmethod\n    def _internal_from_int_rgba(rgba: RGBA_Tuple_Int) -> ManimColorInternal:\n        \"\"\"Internal function for converting an RGBA tuple of integers into the internal\n        representation of a :class:`ManimColor`.\n\n        *For internal use only*\n\n        Parameters\n        ----------\n        rgba\n            Int RGBA tuple to be parsed.\n\n        Returns\n        -------\n        ManimColorInternal\n            Internal color representation.\n        \"\"\"\n        return np.asarray(rgba, dtype=ManimColorDType) / 255\n\n    @staticmethod\n    def _internal_from_rgba(rgba: RGBA_Tuple_Float) -> ManimColorInternal:\n        \"\"\"Internal function for converting an RGBA tuple of floats into the internal\n        representation of a :class:`ManimColor`.\n\n        *For internal use only*\n\n        Parameters\n        ----------\n        rgba\n            Int RGBA tuple to be parsed.\n\n        Returns\n        -------\n        ManimColorInternal\n            Internal color representation.\n        \"\"\"\n        return np.asarray(rgba, dtype=ManimColorDType)\n\n    @staticmethod\n    def _internal_from_string(name: str, alpha: float) -> ManimColorInternal:\n        \"\"\"Internal function for converting a string into the internal representation of\n        a :class:`ManimColor`. This is not used for hex strings: please refer to\n        :meth:`_internal_from_hex` for this functionality.\n\n        *For internal use only*\n\n        Parameters\n        ----------\n        name\n            The color name to be parsed into a color. Refer to the different color\n            modules in the documentation page to find the corresponding color names.\n\n        Returns\n        -------\n        ManimColorInternal\n            Internal color representation.\n\n        Raises\n        ------\n        ValueError\n            If the color name is not present in Manim.\n        \"\"\"\n        from . import _all_color_dict\n\n        if tmp := _all_color_dict.get(name.upper()):\n            tmp._internal_value[3] = alpha\n            return tmp._internal_value.copy()\n        else:\n            raise ValueError(f\"Color {name} not found\")\n\n    def to_integer(self) -> int:\n        \"\"\"Convert the current :class:`ManimColor` into an integer.\n\n        .. warning::\n            This will return only the RGB part of the color.\n\n        Returns\n        -------\n        int\n            Integer representation of the color.\n        \"\"\"\n        tmp = (self._internal_value[:3] * 255).astype(dtype=np.byte).tobytes()\n        return int.from_bytes(tmp, \"big\")\n\n    def to_rgb(self) -> RGB_Array_Float:\n        \"\"\"Convert the current :class:`ManimColor` into an RGB array of floats.\n\n        Returns\n        -------\n        RGB_Array_Float\n            RGB array of 3 floats from 0.0 to 1.0.\n        \"\"\"\n        return self._internal_value[:3]\n\n    def to_int_rgb(self) -> RGB_Array_Int:\n        \"\"\"Convert the current :class:`ManimColor` into an RGB array of integers.\n\n        Returns\n        -------\n        RGB_Array_Int\n            RGB array of 3 integers from 0 to 255.\n        \"\"\"\n        return (self._internal_value[:3] * 255).astype(int)\n\n    def to_rgba(self) -> RGBA_Array_Float:\n        \"\"\"Convert the current :class:`ManimColor` into an RGBA array of floats.\n\n        Returns\n        -------\n        RGBA_Array_Float\n            RGBA array of 4 floats from 0.0 to 1.0.\n        \"\"\"\n        return self._internal_value\n\n    def to_int_rgba(self) -> RGBA_Array_Int:\n        \"\"\"Convert the current ManimColor into an RGBA array of integers.\n\n\n        Returns\n        -------\n        RGBA_Array_Int\n            RGBA array of 4 integers from 0 to 255.\n        \"\"\"\n        return (self._internal_value * 255).astype(int)\n\n    def to_rgba_with_alpha(self, alpha: float) -> RGBA_Array_Float:\n        \"\"\"Convert the current :class:`ManimColor` into an RGBA array of floats. This is\n        similar to :meth:`to_rgba`, but you can change the alpha value.\n\n        Parameters\n        ----------\n        alpha\n            Alpha value to be used in the return value.\n\n        Returns\n        -------\n        RGBA_Array_Float\n            RGBA array of 4 floats from 0.0 to 1.0.\n        \"\"\"\n        return np.fromiter((*self._internal_value[:3], alpha), dtype=ManimColorDType)\n\n    def to_int_rgba_with_alpha(self, alpha: float) -> RGBA_Array_Int:\n        \"\"\"Convert the current :class:`ManimColor` into an RGBA array of integers. This\n        is similar to :meth:`to_int_rgba`, but you can change the alpha value.\n\n        Parameters\n        ----------\n        alpha\n            Alpha value to be used for the return value. Pass a float between 0.0 and\n            1.0: it will automatically be scaled to an integer between 0 and 255.\n\n        Returns\n        -------\n        RGBA_Array_Int\n            RGBA array of 4 integers from 0 to 255.\n        \"\"\"\n        tmp = self._internal_value * 255\n        tmp[3] = alpha * 255\n        return tmp.astype(int)\n\n    def to_hex(self, with_alpha: bool = False) -> str:\n        \"\"\"Convert the :class:`ManimColor` to a hexadecimal representation of the color.\n\n        Parameters\n        ----------\n        with_alpha\n            If ``True``, append 2 extra characters to the hex string which represent the\n            alpha value of the color between 0 and 255. Default is ``False``.\n\n        Returns\n        -------\n        str\n            A hex string starting with a ``#``, with either 6 or 8 nibbles depending on\n            the ``with_alpha`` parameter. By default, it has 6 nibbles, i.e. ``#XXXXXX``.\n        \"\"\"\n        tmp = (\n            f\"#{int(self._internal_value[0] * 255):02X}\"\n            f\"{int(self._internal_value[1] * 255):02X}\"\n            f\"{int(self._internal_value[2] * 255):02X}\"\n        )\n        if with_alpha:\n            tmp += f\"{int(self._internal_value[3] * 255):02X}\"\n        return tmp\n\n    def to_hsv(self) -> HSV_Array_Float:\n        \"\"\"Convert the :class:`ManimColor` to an HSV array.\n\n        .. note::\n           Be careful: this returns an array in the form ``[h, s, v]``, where the\n           elements are floats. This might be confusing, because RGB can also be an array\n           of floats. You might want to annotate the usage of this function in your code\n           by typing your HSV array variables as :class:`HSV_Array_Float` in order to\n           differentiate them from RGB arrays.\n\n        Returns\n        -------\n        HSV_Array_Float\n            An HSV array of 3 floats from 0.0 to 1.0.\n        \"\"\"\n        return np.array(colorsys.rgb_to_hsv(*self.to_rgb()))\n\n    def to_hsl(self) -> HSL_Array_Float:\n        \"\"\"Convert the :class:`ManimColor` to an HSL array.\n\n        .. note::\n           Be careful: this returns an array in the form ``[h, s, l]``, where the\n           elements are floats. This might be confusing, because RGB can also be an array\n           of floats. You might want to annotate the usage of this function in your code\n           by typing your HSL array variables as :class:`HSL_Array_Float` in order to\n           differentiate them from RGB arrays.\n\n        Returns\n        -------\n        HSL_Array_Float\n            An HSL array of 3 floats from 0.0 to 1.0.\n        \"\"\"\n        hls = colorsys.rgb_to_hls(*self.to_rgb())\n        return np.array([hls[0], hls[2], hls[1]])\n\n    def invert(self, with_alpha: bool = False) -> Self:\n        \"\"\"Return a new, linearly inverted version of this :class:`ManimColor` (no\n        inplace changes).\n\n        Parameters\n        ----------\n        with_alpha\n            If ``True``, the alpha value will be inverted too. Default is ``False``.\n\n            .. note::\n                Setting ``with_alpha=True`` can result in unintended behavior where\n                objects are not displayed because their new alpha value is suddenly 0 or\n                very low.\n\n        Returns\n        -------\n        ManimColor\n            The linearly inverted :class:`ManimColor`.\n        \"\"\"\n        if with_alpha:\n            return self._construct_from_space(1.0 - self._internal_space)\n        else:\n            alpha = self._internal_space[3]\n            new = 1.0 - self._internal_space\n            new[-1] = alpha\n            return self._construct_from_space(new)\n\n    def interpolate(self, other: Self, alpha: float) -> Self:\n        \"\"\"Interpolate between the current and the given :class:`ManimColor`, and return\n        the result.\n\n        Parameters\n        ----------\n        other\n            The other :class:`ManimColor` to be used for interpolation.\n        alpha\n            A point on the line in RGBA colorspace connecting the two colors, i.e. the\n            interpolation point. 0.0 corresponds to the current :class:`ManimColor` and\n            1.0 corresponds to the other :class:`ManimColor`.\n\n        Returns\n        -------\n        ManimColor\n            The interpolated :class:`ManimColor`.\n        \"\"\"\n        return self._construct_from_space(\n            self._internal_space * (1 - alpha) + other._internal_space * alpha\n        )\n\n    def darker(self, blend: float = 0.2) -> Self:\n        \"\"\"Return a new color that is darker than the current color, i.e.\n        interpolated with ``BLACK``. The opacity is unchanged.\n\n        Parameters\n        ----------\n        blend\n            The blend ratio for the interpolation, from 0.0 (the current color\n            unchanged) to 1.0 (pure black). Default is 0.2, which results in a\n            slightly darker color.\n\n        Returns\n        -------\n        ManimColor\n            The darker :class:`ManimColor`.\n\n        See Also\n        --------\n        :meth:`lighter`\n        \"\"\"\n        from manim.utils.color.manim_colors import BLACK\n\n        alpha = self._internal_space[3]\n        black = self._from_internal(BLACK._internal_value)\n        return self.interpolate(black, blend).opacity(alpha)\n\n    def lighter(self, blend: float = 0.2) -> Self:\n        \"\"\"Return a new color that is lighter than the current color, i.e.\n        interpolated with ``WHITE``. The opacity is unchanged.\n\n        Parameters\n        ----------\n        blend\n            The blend ratio for the interpolation, from 0.0 (the current color\n            unchanged) to 1.0 (pure white). Default is 0.2, which results in a\n            slightly lighter color.\n\n        Returns\n        -------\n        ManimColor\n            The lighter :class:`ManimColor`.\n\n        See Also\n        --------\n        :meth:`darker`\n        \"\"\"\n        from manim.utils.color.manim_colors import WHITE\n\n        alpha = self._internal_space[3]\n        white = self._from_internal(WHITE._internal_value)\n        return self.interpolate(white, blend).opacity(alpha)\n\n    def contrasting(\n        self,\n        threshold: float = 0.5,\n        light: Self | None = None,\n        dark: Self | None = None,\n    ) -> Self:\n        \"\"\"Return one of two colors, light or dark (by default white or black),\n        that contrasts with the current color (depending on its luminance).\n        This is typically used to set text in a contrasting color that ensures\n        it is readable against a background of the current color.\n\n        Parameters\n        ----------\n        threshold\n            The luminance threshold which dictates whether the current color is\n            considered light or dark (and thus whether to return the dark or\n            light color, respectively). Default is 0.5.\n        light\n            The light color to return if the current color is considered dark.\n            Default is ``None``: in this case, pure ``WHITE`` will be returned.\n        dark\n            The dark color to return if the current color is considered light,\n            Default is ``None``: in this case, pure ``BLACK`` will be returned.\n\n        Returns\n        -------\n        ManimColor\n            The contrasting :class:`ManimColor`.\n        \"\"\"\n        from manim.utils.color.manim_colors import BLACK, WHITE\n\n        luminance, _, _ = colorsys.rgb_to_yiq(*self.to_rgb())\n        if luminance < threshold:\n            if light is not None:\n                return light\n            return self._from_internal(WHITE._internal_value)\n        else:\n            if dark is not None:\n                return dark\n            return self._from_internal(BLACK._internal_value)\n\n    def opacity(self, opacity: float) -> Self:\n        \"\"\"Create a new :class:`ManimColor` with the given opacity and the same color\n        values as before.\n\n        Parameters\n        ----------\n        opacity\n            The new opacity value to be used.\n\n        Returns\n        -------\n        ManimColor\n            The new :class:`ManimColor` with the same color values and the new opacity.\n        \"\"\"\n        tmp = self._internal_space.copy()\n        tmp[-1] = opacity\n        return self._construct_from_space(tmp)\n\n    def into(self, class_type: type[ManimColorT]) -> ManimColorT:\n        \"\"\"Convert the current color into a different colorspace given by ``class_type``,\n        without changing the :attr:`_internal_value`.\n\n        Parameters\n        ----------\n        class_type\n            The class that is used for conversion. It must be a subclass of\n            :class:`ManimColor` which respects the specification HSV, RGBA, ...\n\n        Returns\n        -------\n        ManimColorT\n            A new color object of type ``class_type`` and the same\n            :attr:`_internal_value` as the original color.\n        \"\"\"\n        return class_type._from_internal(self._internal_value)\n\n    @classmethod\n    def _from_internal(cls, value: ManimColorInternal) -> Self:\n        \"\"\"This method is intended to be overwritten by custom color space classes\n        which are subtypes of :class:`ManimColor`.\n\n        The method constructs a new object of the given class by transforming the value\n        in the internal format ``[r,g,b,a]`` into a format which the constructor of the\n        custom class can understand. Look at :class:`.HSV` for an example.\n        \"\"\"\n        return cls(value)\n\n    @classmethod\n    def from_rgb(\n        cls,\n        rgb: RGB_Array_Float | RGB_Tuple_Float | RGB_Array_Int | RGB_Tuple_Int,\n        alpha: float = 1.0,\n    ) -> Self:\n        \"\"\"Create a ManimColor from an RGB array. Automagically decides which type it\n        is: ``int`` or ``float``.\n\n        .. warning::\n            Please make sure that your elements are not floats if you want integers. A\n            ``5.0`` will result in the input being interpreted as if it was an RGB float\n            array with the value ``5.0`` and not the integer ``5``.\n\n\n        Parameters\n        ----------\n        rgb\n            Any iterable of 3 floats or 3 integers.\n        alpha\n            Alpha value to be used in the color. Default is 1.0.\n\n        Returns\n        -------\n        ManimColor\n            The :class:`ManimColor` which corresponds to the given ``rgb``.\n        \"\"\"\n        return cls._from_internal(ManimColor(rgb, alpha)._internal_value)\n\n    @classmethod\n    def from_rgba(\n        cls, rgba: RGBA_Array_Float | RGBA_Tuple_Float | RGBA_Array_Int | RGBA_Tuple_Int\n    ) -> Self:\n        \"\"\"Create a ManimColor from an RGBA Array. Automagically decides which type it\n        is: ``int`` or ``float``.\n\n        .. warning::\n            Please make sure that your elements are not floats if you want integers. A\n            ``5.0`` will result in the input being interpreted as if it was a float RGB\n            array with the float ``5.0`` and not the integer ``5``.\n\n        Parameters\n        ----------\n        rgba\n            Any iterable of 4 floats or 4 integers.\n\n        Returns\n        -------\n        ManimColor\n            The :class:`ManimColor` corresponding to the given ``rgba``.\n        \"\"\"\n        return cls(rgba)\n\n    @classmethod\n    def from_hex(cls, hex_str: str, alpha: float = 1.0) -> Self:\n        \"\"\"Create a :class:`ManimColor` from a hex string.\n\n        Parameters\n        ----------\n        hex_str\n            The hex string to be converted.  The allowed prefixes for this string are\n            ``#`` and ``0x``. Currently, this method only supports 6 nibbles, i.e. only\n            strings in the format ``#XXXXXX`` or ``0xXXXXXX``.\n        alpha\n            Alpha value to be used for the hex string. Default is 1.0.\n\n        Returns\n        -------\n        ManimColor\n            The :class:`ManimColor` represented by the hex string.\n        \"\"\"\n        return cls._from_internal(ManimColor(hex_str, alpha)._internal_value)\n\n    @classmethod\n    def from_hsv(\n        cls, hsv: HSV_Array_Float | HSV_Tuple_Float, alpha: float = 1.0\n    ) -> Self:\n        \"\"\"Create a :class:`ManimColor` from an HSV array.\n\n        Parameters\n        ----------\n        hsv\n            Any iterable containing 3 floats from 0.0 to 1.0.\n        alpha\n            The alpha value to be used. Default is 1.0.\n\n        Returns\n        -------\n        ManimColor\n            The :class:`ManimColor` with the corresponding RGB values to the given HSV\n            array.\n        \"\"\"\n        rgb = colorsys.hsv_to_rgb(*hsv)\n        return cls._from_internal(ManimColor(rgb, alpha)._internal_value)\n\n    @classmethod\n    def from_hsl(\n        cls, hsl: HSL_Array_Float | HSL_Tuple_Float, alpha: float = 1.0\n    ) -> Self:\n        \"\"\"Create a :class:`ManimColor` from an HSL array.\n\n        Parameters\n        ----------\n        hsl\n            Any iterable containing 3 floats from 0.0 to 1.0.\n        alpha\n            The alpha value to be used. Default is 1.0.\n\n        Returns\n        -------\n        ManimColor\n            The :class:`ManimColor` with the corresponding RGB values to the given HSL\n            array.\n        \"\"\"\n        rgb = colorsys.hls_to_rgb(hsl[0], hsl[2], hsl[1])\n        return cls._from_internal(ManimColor(rgb, alpha)._internal_value)\n\n    @overload\n    @classmethod\n    def parse(\n        cls,\n        color: ParsableManimColor | None,\n        alpha: float = ...,\n    ) -> Self: ...\n\n    @overload\n    @classmethod\n    def parse(\n        cls,\n        color: Sequence[ParsableManimColor],\n        alpha: float = ...,\n    ) -> list[Self]: ...\n\n    @classmethod\n    def parse(\n        cls,\n        color: ParsableManimColor | Sequence[ParsableManimColor] | None,\n        alpha: float = 1.0,\n    ) -> Self | list[Self]:\n        \"\"\"Parse one color as a :class:`ManimColor` or a sequence of colors as a list of\n        :class:`ManimColor`'s.\n\n        Parameters\n        ----------\n        color\n            The color or list of colors to parse. Note that this function can not accept\n            tuples: it will assume that you mean ``Sequence[ParsableManimColor]`` and will\n            return a ``list[ManimColor]``.\n        alpha\n            The alpha (opacity) value to use for the passed color(s).\n\n        Returns\n        -------\n        ManimColor | list[ManimColor]\n            Either a list of colors or a singular color, depending on the input.\n        \"\"\"\n\n        def is_sequence(\n            color: ParsableManimColor | Sequence[ParsableManimColor] | None,\n        ) -> TypeIs[Sequence[ParsableManimColor]]:\n            return isinstance(color, (list, tuple))\n\n        if is_sequence(color):\n            return [\n                cls._from_internal(ManimColor(c, alpha)._internal_value) for c in color\n            ]\n        else:\n            return cls._from_internal(ManimColor(color, alpha)._internal_value)\n\n    @staticmethod\n    def gradient(\n        colors: list[ManimColor], length: int\n    ) -> ManimColor | list[ManimColor]:\n        \"\"\"This method is currently not implemented. Refer to :func:`color_gradient` for\n        a working implementation for now.\n        \"\"\"\n        # TODO: implement proper gradient, research good implementation for this or look at 3b1b implementation\n        raise NotImplementedError\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}('{self.to_hex()}')\"\n\n    def __str__(self) -> str:\n        return f\"{self.to_hex()}\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, ManimColor):\n            raise TypeError(\n                f\"Cannot compare {self.__class__.__name__} with {other.__class__.__name__}\"\n            )\n        are_equal: bool = np.allclose(self._internal_value, other._internal_value)\n        return are_equal\n\n    def __add__(self, other: int | float | Self) -> Self:\n        if isinstance(other, (int, float)):\n            return self._construct_from_space(self._internal_space + other)\n        else:\n            return self._construct_from_space(\n                self._internal_space + other._internal_space\n            )\n\n    def __radd__(self, other: int | float | Self) -> Self:\n        return self + other\n\n    def __sub__(self, other: int | float | Self) -> Self:\n        if isinstance(other, (int, float)):\n            return self._construct_from_space(self._internal_space - other)\n        else:\n            return self._construct_from_space(\n                self._internal_space - other._internal_space\n            )\n\n    def __rsub__(self, other: int | float | Self) -> Self:\n        return self - other\n\n    def __mul__(self, other: int | float | Self) -> Self:\n        if isinstance(other, (int, float)):\n            return self._construct_from_space(self._internal_space * other)\n        else:\n            return self._construct_from_space(\n                self._internal_space * other._internal_space\n            )\n\n    def __rmul__(self, other: int | float | Self) -> Self:\n        return self * other\n\n    def __truediv__(self, other: int | float | Self) -> Self:\n        if isinstance(other, (int, float)):\n            return self._construct_from_space(self._internal_space / other)\n        else:\n            return self._construct_from_space(\n                self._internal_space / other._internal_space\n            )\n\n    def __rtruediv__(self, other: int | float | Self) -> Self:\n        return self / other\n\n    def __floordiv__(self, other: int | float | Self) -> Self:\n        if isinstance(other, (int, float)):\n            return self._construct_from_space(self._internal_space // other)\n        else:\n            return self._construct_from_space(\n                self._internal_space // other._internal_space\n            )\n\n    def __rfloordiv__(self, other: int | float | Self) -> Self:\n        return self // other\n\n    def __mod__(self, other: int | float | Self) -> Self:\n        if isinstance(other, (int, float)):\n            return self._construct_from_space(self._internal_space % other)\n        else:\n            return self._construct_from_space(\n                self._internal_space % other._internal_space\n            )\n\n    def __rmod__(self, other: int | float | Self) -> Self:\n        return self % other\n\n    def __pow__(self, other: int | float | Self) -> Self:\n        if isinstance(other, (int, float)):\n            return self._construct_from_space(self._internal_space**other)\n        else:\n            return self._construct_from_space(\n                self._internal_space**other._internal_space\n            )\n\n    def __rpow__(self, other: int | float | Self) -> Self:\n        return self**other\n\n    def __invert__(self) -> Self:\n        return self.invert()\n\n    def __int__(self) -> int:\n        return self.to_integer()\n\n    def __getitem__(self, index: int) -> float:\n        item: float = self._internal_space[index]\n        return item\n\n    def __and__(self, other: Self) -> Self:\n        return self._construct_from_space(\n            self._internal_from_integer(self.to_integer() & int(other), 1.0)\n        )\n\n    def __or__(self, other: Self) -> Self:\n        return self._construct_from_space(\n            self._internal_from_integer(self.to_integer() | int(other), 1.0)\n        )\n\n    def __xor__(self, other: Self) -> Self:\n        return self._construct_from_space(\n            self._internal_from_integer(self.to_integer() ^ int(other), 1.0)\n        )\n\n    def __hash__(self) -> int:\n        return hash(self.to_hex(with_alpha=True))"}, {"name": "ManimColorModuleDocumenter", "code": "class ManimColorModuleDocumenter(Directive):\n    objtype = \"automanimcolormodule\"\n    required_arguments = 1\n    has_content = True\n\n    def add_directive_header(self, sig: str) -> None:\n        # TODO: The Directive class has no method named\n        # add_directive_header.\n        super().add_directive_header(sig)  # type: ignore[misc]\n\n    def run(self) -> list[nodes.Element]:\n        module_name = self.arguments[0]\n        try:\n            import importlib\n\n            module = importlib.import_module(module_name)\n        except ImportError:\n            return [\n                nodes.error(\n                    None,  # type: ignore[arg-type]\n                    nodes.paragraph(text=f\"Failed to import module '{module_name}'\"),\n                )\n            ]\n\n        # Number of Colors displayed in one row\n        num_color_cols = 2\n        table = nodes.table(align=\"center\")\n\n        tgroup = nodes.tgroup(cols=num_color_cols * 2)\n        table += tgroup\n        for _ in range(num_color_cols * 2):\n            tgroup += nodes.colspec(colwidth=1)\n\n        # Create header rows for the table\n        thead = nodes.thead()\n        header_row = nodes.row()\n        for _ in range(num_color_cols):\n            header_col1 = nodes.paragraph(text=\"Color Name\")\n            header_col2 = nodes.paragraph(text=\"RGB Hex Code\")\n            header_row += nodes.entry(\"\", header_col1)\n            header_row += nodes.entry(\"\", header_col2)\n        thead += header_row\n        tgroup += thead\n\n        color_elements = []\n        for member_name, member_obj in inspect.getmembers(module):\n            if isinstance(member_obj, ManimColor):\n                r, g, b = member_obj.to_rgb()\n                luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\n                # Choose the font color based on the background luminance\n                font_color = \"black\" if luminance > 0.5 else \"white\"\n\n                color_elements.append((member_name, member_obj.to_hex(), font_color))\n\n        tbody = nodes.tbody()\n\n        for base_i in range(0, len(color_elements), num_color_cols):\n            row = nodes.row()\n            for member_name, hex_code, font_color in color_elements[\n                base_i : base_i + num_color_cols\n            ]:\n                col1 = nodes.literal(text=member_name)\n                col2 = nodes.raw(\n                    \"\",\n                    f'<div style=\"background-color:{hex_code};padding: 0.25rem 0;border-radius:8px;margin: 0.5rem 0.2rem\"><code style=\"color:{font_color};\">{hex_code}</code></div>',\n                    format=\"html\",\n                )\n                row += nodes.entry(\"\", col1)\n                row += nodes.entry(\"\", col2)\n            tbody += row\n        tgroup += tbody\n\n        return [table]"}, {"name": "ManimConfig", "code": "class ManimConfig(MutableMapping):\n    \"\"\"Dict-like class storing all config options.\n\n    The global ``config`` object is an instance of this class, and acts as a\n    single source of truth for all of the library's customizable behavior.\n\n    The global ``config`` object is capable of digesting different types of\n    sources and converting them into a uniform interface.  These sources are\n    (in ascending order of precedence): configuration files, command line\n    arguments, and programmatic changes.  Regardless of how the user chooses to\n    set a config option, she can access its current value using\n    :class:`ManimConfig`'s attributes and properties.\n\n    Notes\n    -----\n    Each config option is implemented as a property of this class.\n\n    Each config option can be set via a config file, using the full name of the\n    property.  If a config option has an associated CLI flag, then the flag is\n    equal to the full name of the property.  Those that admit an alternative\n    flag or no flag at all are documented in the individual property's\n    docstring.\n\n    Examples\n    --------\n    We use a copy of the global configuration object in the following\n    examples for the sake of demonstration; you can skip these lines\n    and just import ``config`` directly if you actually want to modify\n    the configuration:\n\n    .. code-block:: pycon\n\n        >>> from manim import config as global_config\n        >>> config = global_config.copy()\n\n    Each config option allows for dict syntax and attribute syntax.  For\n    example, the following two lines are equivalent,\n\n    .. code-block:: pycon\n\n        >>> from manim import WHITE\n        >>> config.background_color = WHITE\n        >>> config[\"background_color\"] = WHITE\n\n    The former is preferred; the latter is provided mostly for backwards\n    compatibility.\n\n    The config options are designed to keep internal consistency.  For example,\n    setting ``frame_y_radius`` will affect ``frame_height``:\n\n    .. code-block:: pycon\n\n        >>> config.frame_height\n        8.0\n        >>> config.frame_y_radius = 5.0\n        >>> config.frame_height\n        10.0\n\n    There are many ways of interacting with config options.  Take for example\n    the config option ``background_color``.  There are three ways to change it:\n    via a config file, via CLI flags, or programmatically.\n\n    To set the background color via a config file, save the following\n    ``manim.cfg`` file with the following contents.\n\n    .. code-block::\n\n       [CLI]\n       background_color = WHITE\n\n    In order to have this ``.cfg`` file apply to a manim scene, it needs to be\n    placed in the same directory as the script,\n\n    .. code-block:: bash\n\n          project/\n          \u251c\u2500scene.py\n          \u2514\u2500manim.cfg\n\n    Now, when the user executes\n\n    .. code-block:: bash\n\n        manim scene.py\n\n    the background of the scene will be set to ``WHITE``.  This applies regardless\n    of where the manim command is invoked from.\n\n    Command line arguments override ``.cfg`` files.  In the previous example,\n    executing\n\n    .. code-block:: bash\n\n        manim scene.py -c BLUE\n\n    will set the background color to BLUE, regardless of the contents of\n    ``manim.cfg``.\n\n    Finally, any programmatic changes made within the scene script itself will\n    override the command line arguments.  For example, if ``scene.py`` contains\n    the following\n\n    .. code-block:: python\n\n        from manim import *\n\n        config.background_color = RED\n\n\n        class MyScene(Scene): ...\n\n    the background color will be set to RED, regardless of the contents of\n    ``manim.cfg`` or the CLI arguments used when invoking manim.\n\n    \"\"\"\n\n    _OPTS = {\n        \"assets_dir\",\n        \"background_color\",\n        \"background_opacity\",\n        \"custom_folders\",\n        \"disable_caching\",\n        \"disable_caching_warning\",\n        \"dry_run\",\n        \"enable_wireframe\",\n        \"ffmpeg_loglevel\",\n        \"format\",\n        \"flush_cache\",\n        \"frame_height\",\n        \"frame_rate\",\n        \"frame_width\",\n        \"frame_x_radius\",\n        \"frame_y_radius\",\n        \"from_animation_number\",\n        \"images_dir\",\n        \"input_file\",\n        \"media_embed\",\n        \"media_width\",\n        \"log_dir\",\n        \"log_to_file\",\n        \"max_files_cached\",\n        \"media_dir\",\n        \"movie_file_extension\",\n        \"notify_outdated_version\",\n        \"output_file\",\n        \"partial_movie_dir\",\n        \"pixel_height\",\n        \"pixel_width\",\n        \"plugins\",\n        \"preview\",\n        \"progress_bar\",\n        \"quality\",\n        \"save_as_gif\",\n        \"save_sections\",\n        \"save_last_frame\",\n        \"save_pngs\",\n        \"scene_names\",\n        \"show_in_file_browser\",\n        \"tex_dir\",\n        \"tex_template\",\n        \"tex_template_file\",\n        \"text_dir\",\n        \"upto_animation_number\",\n        \"renderer\",\n        \"enable_gui\",\n        \"gui_location\",\n        \"use_projection_fill_shaders\",\n        \"use_projection_stroke_shaders\",\n        \"verbosity\",\n        \"video_dir\",\n        \"sections_dir\",\n        \"fullscreen\",\n        \"window_position\",\n        \"window_size\",\n        \"window_monitor\",\n        \"write_all\",\n        \"write_to_movie\",\n        \"zero_pad\",\n        \"force_window\",\n        \"no_latex_cleanup\",\n        \"preview_command\",\n    }\n\n    def __init__(self) -> None:\n        self._d: dict[str, Any | None] = dict.fromkeys(self._OPTS)\n\n    # behave like a dict\n    def __iter__(self) -> Iterator[str]:\n        return iter(self._d)\n\n    def __len__(self) -> int:\n        return len(self._d)\n\n    def __contains__(self, key: object) -> bool:\n        try:\n            self.__getitem__(key)\n            return True\n        except AttributeError:\n            return False\n\n    def __getitem__(self, key: str) -> Any:\n        return getattr(self, key)\n\n    def __setitem__(self, key: str, val: Any) -> None:\n        getattr(ManimConfig, key).fset(self, val)  # fset is the property's setter\n\n    def update(self, obj: ManimConfig | dict[str, Any]) -> None:  # type: ignore[override]\n        \"\"\"Digest the options found in another :class:`ManimConfig` or in a dict.\n\n        Similar to :meth:`dict.update`, replaces the values of this object with\n        those of ``obj``.\n\n        Parameters\n        ----------\n        obj\n            The object to copy values from.\n\n        Returns\n        -------\n        None\n\n        Raises\n        -----\n        :class:`AttributeError`\n            If ``obj`` is a dict but contains keys that do not belong to any\n            config options.\n\n        See Also\n        --------\n        :meth:`~ManimConfig.digest_file`, :meth:`~ManimConfig.digest_args`,\n        :meth:`~ManimConfig.digest_parser`\n\n        \"\"\"\n        if isinstance(obj, ManimConfig):\n            self._d.update(obj._d)\n            if obj.tex_template:\n                self.tex_template = obj.tex_template\n\n        elif isinstance(obj, dict):\n            # First update the underlying _d, then update other properties\n            _dict = {k: v for k, v in obj.items() if k in self._d}\n            for k, v in _dict.items():\n                self[k] = v\n\n            _dict = {k: v for k, v in obj.items() if k not in self._d}\n            for k, v in _dict.items():\n                self[k] = v\n\n    # don't allow to delete anything\n    def __delitem__(self, key: str) -> NoReturn:\n        raise AttributeError(\"'ManimConfig' object does not support item deletion\")\n\n    def __delattr__(self, key: str) -> NoReturn:\n        raise AttributeError(\"'ManimConfig' object does not support item deletion\")\n\n    # copy functions\n    def copy(self) -> Self:\n        \"\"\"Deepcopy the contents of this ManimConfig.\n\n        Returns\n        -------\n        :class:`ManimConfig`\n            A copy of this object containing no shared references.\n\n        See Also\n        --------\n        :func:`tempconfig`\n\n        Notes\n        -----\n        This is the main mechanism behind :func:`tempconfig`.\n\n        \"\"\"\n        return copy.deepcopy(self)\n\n    def __copy__(self) -> Self:\n        \"\"\"See ManimConfig.copy().\"\"\"\n        return copy.deepcopy(self)\n\n    def __deepcopy__(self, memo: dict[str, Any]) -> Self:\n        \"\"\"See ManimConfig.copy().\"\"\"\n        c = type(self)()\n        # Deepcopying the underlying dict is enough because all properties\n        # either read directly from it or compute their value on the fly from\n        # values read directly from it.\n        c._d = copy.deepcopy(self._d, memo)\n        return c\n\n    # helper type-checking methods\n    def _set_from_list(self, key: str, val: Any, values: list[Any]) -> None:\n        \"\"\"Set ``key`` to ``val`` if ``val`` is contained in ``values``.\"\"\"\n        if val in values:\n            self._d[key] = val\n        else:\n            raise ValueError(f\"attempted to set {key} to {val}; must be in {values}\")\n\n    def _set_from_enum(self, key: str, enum_value: Any, enum_class: EnumMeta) -> None:\n        \"\"\"Set ``key`` to the enum object with value ``enum_value`` in the given\n        ``enum_class``.\n\n        Tests::\n\n            >>> from enum import Enum\n            >>> class Fruit(Enum):\n            ...     APPLE = 1\n            ...     BANANA = 2\n            ...     CANTALOUPE = 3\n            >>> test_config = ManimConfig()\n            >>> test_config._set_from_enum(\"fruit\", 1, Fruit)\n            >>> test_config._d['fruit']\n            <Fruit.APPLE: 1>\n            >>> test_config._set_from_enum(\"fruit\", Fruit.BANANA, Fruit)\n            >>> test_config._d['fruit']\n            <Fruit.BANANA: 2>\n            >>> test_config._set_from_enum(\"fruit\", 42, Fruit)\n            Traceback (most recent call last):\n            ...\n            ValueError: 42 is not a valid Fruit\n        \"\"\"\n        self._d[key] = enum_class(enum_value)\n\n    def _set_boolean(self, key: str, val: Any) -> None:\n        \"\"\"Set ``key`` to ``val`` if ``val`` is Boolean.\"\"\"\n        if val in [True, False]:\n            self._d[key] = val\n        else:\n            raise ValueError(f\"{key} must be boolean\")\n\n    def _set_tuple(self, key: str, val: tuple[Any]) -> None:\n        if isinstance(val, tuple):\n            self._d[key] = val\n        else:\n            raise ValueError(f\"{key} must be tuple\")\n\n    def _set_str(self, key: str, val: Any) -> None:\n        \"\"\"Set ``key`` to ``val`` if ``val`` is a string.\"\"\"\n        if isinstance(val, str):\n            self._d[key] = val\n        elif not val:\n            self._d[key] = \"\"\n        else:\n            raise ValueError(f\"{key} must be str or falsy value\")\n\n    def _set_between(self, key: str, val: float, lo: float, hi: float) -> None:\n        \"\"\"Set ``key`` to ``val`` if lo <= val <= hi.\"\"\"\n        if lo <= val <= hi:\n            self._d[key] = val\n        else:\n            raise ValueError(f\"{key} must be {lo} <= {key} <= {hi}\")\n\n    def _set_int_between(self, key: str, val: int, lo: int, hi: int) -> None:\n        \"\"\"Set ``key`` to ``val`` if lo <= val <= hi.\"\"\"\n        if lo <= val <= hi:\n            self._d[key] = val\n        else:\n            raise ValueError(\n                f\"{key} must be an integer such that {lo} <= {key} <= {hi}\",\n            )\n\n    def _set_pos_number(self, key: str, val: int, allow_inf: bool) -> None:\n        \"\"\"Set ``key`` to ``val`` if ``val`` is a positive integer.\"\"\"\n        if isinstance(val, int) and val > -1:\n            self._d[key] = val\n        elif allow_inf and val in [-1, float(\"inf\")]:\n            self._d[key] = float(\"inf\")\n        else:\n            raise ValueError(\n                f\"{key} must be a non-negative integer (use -1 for infinity)\",\n            )\n\n    def __repr__(self) -> str:\n        rep = \"\"\n        for k, v in sorted(self._d.items(), key=lambda x: x[0]):\n            rep += f\"{k}: {v}, \"\n        return rep\n\n    # builders\n    def digest_parser(self, parser: configparser.ConfigParser) -> Self:\n        \"\"\"Process the config options present in a :class:`ConfigParser` object.\n\n        This method processes arbitrary parsers, not only those read from a\n        single file, whereas :meth:`~ManimConfig.digest_file` can only process one\n        file at a time.\n\n        Parameters\n        ----------\n        parser\n            An object reflecting the contents of one or many ``.cfg`` files.  In\n            particular, it may reflect the contents of multiple files that have\n            been parsed in a cascading fashion.\n\n        Returns\n        -------\n        self : :class:`ManimConfig`\n            This object, after processing the contents of ``parser``.\n\n        See Also\n        --------\n        :func:`make_config_parser`, :meth:`~.ManimConfig.digest_file`,\n        :meth:`~.ManimConfig.digest_args`,\n\n        Notes\n        -----\n        If there are multiple ``.cfg`` files to process, it is always more\n        efficient to parse them into a single :class:`ConfigParser` object\n        first, and then call this function once (instead of calling\n        :meth:`~.ManimConfig.digest_file` multiple times).\n\n        Examples\n        --------\n        To digest the config options set in two files, first create a\n        ConfigParser and parse both files and then digest the parser:\n\n        .. code-block:: python\n\n            parser = configparser.ConfigParser()\n            parser.read([file1, file2])\n            config = ManimConfig().digest_parser(parser)\n\n        In fact, the global ``config`` object is initialized like so:\n\n        .. code-block:: python\n\n            parser = make_config_parser()\n            config = ManimConfig().digest_parser(parser)\n\n        \"\"\"\n        self._parser = parser\n\n        # boolean keys\n        for key in [\n            \"notify_outdated_version\",\n            \"write_to_movie\",\n            \"save_last_frame\",\n            \"write_all\",\n            \"save_pngs\",\n            \"save_as_gif\",\n            \"save_sections\",\n            \"preview\",\n            \"show_in_file_browser\",\n            \"log_to_file\",\n            \"disable_caching\",\n            \"disable_caching_warning\",\n            \"flush_cache\",\n            \"custom_folders\",\n            \"enable_gui\",\n            \"fullscreen\",\n            \"use_projection_fill_shaders\",\n            \"use_projection_stroke_shaders\",\n            \"enable_wireframe\",\n            \"force_window\",\n            \"no_latex_cleanup\",\n        ]:\n            setattr(self, key, parser[\"CLI\"].getboolean(key, fallback=False))\n\n        # int keys\n        for key in [\n            \"from_animation_number\",\n            \"upto_animation_number\",\n            \"max_files_cached\",\n            # the next two must be set BEFORE digesting frame_width and frame_height\n            \"pixel_height\",\n            \"pixel_width\",\n            \"window_monitor\",\n            \"zero_pad\",\n        ]:\n            setattr(self, key, parser[\"CLI\"].getint(key))\n\n        # str keys\n        for key in [\n            \"assets_dir\",\n            \"verbosity\",\n            \"media_dir\",\n            \"log_dir\",\n            \"video_dir\",\n            \"sections_dir\",\n            \"images_dir\",\n            \"text_dir\",\n            \"tex_dir\",\n            \"partial_movie_dir\",\n            \"input_file\",\n            \"output_file\",\n            \"movie_file_extension\",\n            \"background_color\",\n            \"renderer\",\n            \"window_position\",\n        ]:\n            setattr(self, key, parser[\"CLI\"].get(key, fallback=\"\", raw=True))\n\n        # float keys\n        for key in [\n            \"background_opacity\",\n            \"frame_rate\",\n            # the next two are floats but have their own logic, applied later\n            # \"frame_width\",\n            # \"frame_height\",\n        ]:\n            setattr(self, key, parser[\"CLI\"].getfloat(key))\n\n        # tuple keys\n        gui_location = tuple(\n            map(int, re.split(r\"[;,\\-]\", parser[\"CLI\"][\"gui_location\"])),\n        )\n        self.gui_location = gui_location\n\n        window_size = parser[\"CLI\"][\n            \"window_size\"\n        ]  # if not \"default\", get a tuple of the position\n        if window_size != \"default\":\n            window_size = tuple(map(int, re.split(r\"[;,\\-]\", window_size)))\n        self.window_size = window_size\n\n        # plugins\n        plugins = parser[\"CLI\"].get(\"plugins\", fallback=\"\", raw=True)\n        plugins = [] if plugins == \"\" else plugins.split(\",\")\n        self.plugins = plugins\n        # the next two must be set AFTER digesting pixel_width and pixel_height\n        self[\"frame_height\"] = parser[\"CLI\"].getfloat(\"frame_height\", 8.0)\n        width = parser[\"CLI\"].getfloat(\"frame_width\", None)\n        if width is None:\n            self[\"frame_width\"] = self[\"frame_height\"] * self[\"aspect_ratio\"]\n        else:\n            self[\"frame_width\"] = width\n\n        # other logic\n        val = parser[\"CLI\"].get(\"tex_template_file\")\n        if val:\n            self.tex_template_file = val\n\n        val = parser[\"CLI\"].get(\"progress_bar\")\n        if val:\n            self.progress_bar = val\n\n        val = parser[\"ffmpeg\"].get(\"loglevel\")\n        if val:\n            self.ffmpeg_loglevel = val\n\n        try:\n            val = parser[\"jupyter\"].getboolean(\"media_embed\")\n        except ValueError:\n            val = None\n        self.media_embed = val\n\n        val = parser[\"jupyter\"].get(\"media_width\")\n        if val:\n            self.media_width = val\n\n        val = parser[\"CLI\"].get(\"quality\", fallback=\"\", raw=True)\n        if val:\n            self.quality = _determine_quality(val)\n\n        return self\n\n    def digest_args(self, args: argparse.Namespace) -> Self:\n        \"\"\"Process the config options present in CLI arguments.\n\n        Parameters\n        ----------\n        args\n            An object returned by :func:`.main_utils.parse_args()`.\n\n        Returns\n        -------\n        self : :class:`ManimConfig`\n            This object, after processing the contents of ``parser``.\n\n        See Also\n        --------\n        :func:`.main_utils.parse_args()`, :meth:`~.ManimConfig.digest_parser`,\n        :meth:`~.ManimConfig.digest_file`\n\n        Notes\n        -----\n        If ``args.config_file`` is a non-empty string, ``ManimConfig`` tries to digest the\n        contents of said file with :meth:`~ManimConfig.digest_file` before\n        digesting any other CLI arguments.\n\n        \"\"\"\n        # if the input file is a config file, parse it properly\n        if args.file.suffix == \".cfg\":\n            args.config_file = args.file\n\n        # if args.file is `-`, the animation code has to be taken from STDIN, so the\n        # input file path shouldn't be absolute, since that file won't be read.\n        if str(args.file) == \"-\":\n            self.input_file = args.file\n\n        # if a config file has been passed, digest it first so that other CLI\n        # flags supersede it\n        if args.config_file:\n            self.digest_file(args.config_file)\n\n        # read input_file from the args if it wasn't set by the config file\n        if not self.input_file:\n            self.input_file = Path(args.file).absolute()\n\n        self.scene_names = args.scene_names if args.scene_names is not None else []\n        self.output_file = args.output_file\n\n        for key in [\n            \"notify_outdated_version\",\n            \"preview\",\n            \"show_in_file_browser\",\n            \"write_to_movie\",\n            \"save_last_frame\",\n            \"save_pngs\",\n            \"save_as_gif\",\n            \"save_sections\",\n            \"write_all\",\n            \"disable_caching\",\n            \"format\",\n            \"flush_cache\",\n            \"progress_bar\",\n            \"transparent\",\n            \"scene_names\",\n            \"verbosity\",\n            \"renderer\",\n            \"background_color\",\n            \"enable_gui\",\n            \"fullscreen\",\n            \"use_projection_fill_shaders\",\n            \"use_projection_stroke_shaders\",\n            \"zero_pad\",\n            \"enable_wireframe\",\n            \"force_window\",\n            \"dry_run\",\n            \"no_latex_cleanup\",\n            \"preview_command\",\n        ]:\n            if hasattr(args, key):\n                attr = getattr(args, key)\n                # if attr is None, then no argument was passed and we should\n                # not change the current config\n                if attr is not None:\n                    self[key] = attr\n\n        for key in [\n            \"media_dir\",  # always set this one first\n            \"log_dir\",\n            \"log_to_file\",  # always set this one last\n        ]:\n            if hasattr(args, key):\n                attr = getattr(args, key)\n                # if attr is None, then no argument was passed and we should\n                # not change the current config\n                if attr is not None:\n                    self[key] = attr\n\n        if self[\"save_last_frame\"]:\n            self[\"write_to_movie\"] = False\n\n        # Handle the -n flag.\n        nflag = args.from_animation_number\n        if nflag:\n            self.from_animation_number = nflag[0]\n            try:\n                self.upto_animation_number = nflag[1]\n            except Exception:\n                logger.info(\n                    f\"No end scene number specified in -n option. Rendering from {nflag[0]} onwards...\",\n                )\n\n        # Handle the quality flags\n        self.quality = _determine_quality(getattr(args, \"quality\", None))\n\n        # Handle the -r flag.\n        rflag = args.resolution\n        if rflag:\n            self.pixel_width = int(rflag[0])\n            self.pixel_height = int(rflag[1])\n\n        fps = args.frame_rate\n        if fps:\n            self.frame_rate = float(fps)\n\n        # Handle --custom_folders\n        if args.custom_folders:\n            for opt in [\n                \"media_dir\",\n                \"video_dir\",\n                \"sections_dir\",\n                \"images_dir\",\n                \"text_dir\",\n                \"tex_dir\",\n                \"log_dir\",\n                \"partial_movie_dir\",\n            ]:\n                self[opt] = self._parser[\"custom_folders\"].get(opt, raw=True)\n            # --media_dir overrides the default.cfg file\n            if hasattr(args, \"media_dir\") and args.media_dir:\n                self.media_dir = args.media_dir\n\n        # Handle --tex_template\n        if args.tex_template:\n            self.tex_template = TexTemplate.from_file(args.tex_template)\n\n        if self.renderer == RendererType.OPENGL and args.write_to_movie is None:\n            # --write_to_movie was not passed on the command line, so don't generate video.\n            self[\"write_to_movie\"] = False\n\n        # Handle --gui_location flag.\n        if args.gui_location is not None:\n            self.gui_location = args.gui_location\n\n        return self\n\n    def digest_file(self, filename: StrPath) -> Self:\n        \"\"\"Process the config options present in a ``.cfg`` file.\n\n        This method processes a single ``.cfg`` file, whereas\n        :meth:`~ManimConfig.digest_parser` can process arbitrary parsers, built\n        perhaps from multiple ``.cfg`` files.\n\n        Parameters\n        ----------\n        filename\n            Path to the ``.cfg`` file.\n\n        Returns\n        -------\n        self : :class:`ManimConfig`\n            This object, after processing the contents of ``filename``.\n\n        See Also\n        --------\n        :meth:`~ManimConfig.digest_file`, :meth:`~ManimConfig.digest_args`,\n        :func:`make_config_parser`\n\n        Notes\n        -----\n        If there are multiple ``.cfg`` files to process, it is always more\n        efficient to parse them into a single :class:`ConfigParser` object\n        first and digesting them with one call to\n        :meth:`~ManimConfig.digest_parser`, instead of calling this method\n        multiple times.\n\n        \"\"\"\n        if not Path(filename).is_file():\n            raise FileNotFoundError(\n                errno.ENOENT,\n                \"Error: --config_file could not find a valid config file.\",\n                str(filename),\n            )\n\n        return self.digest_parser(make_config_parser(filename))\n\n    # config options are properties\n\n    @property\n    def preview(self) -> bool:\n        \"\"\"Whether to play the rendered movie (-p).\"\"\"\n        return self._d[\"preview\"] or self._d[\"enable_gui\"]\n\n    @preview.setter\n    def preview(self, value: bool) -> None:\n        self._set_boolean(\"preview\", value)\n\n    @property\n    def show_in_file_browser(self) -> bool:\n        \"\"\"Whether to show the output file in the file browser (-f).\"\"\"\n        return self._d[\"show_in_file_browser\"]\n\n    @show_in_file_browser.setter\n    def show_in_file_browser(self, value: bool) -> None:\n        self._set_boolean(\"show_in_file_browser\", value)\n\n    @property\n    def progress_bar(self) -> str:\n        \"\"\"Whether to show progress bars while rendering animations.\"\"\"\n        return self._d[\"progress_bar\"]\n\n    @progress_bar.setter\n    def progress_bar(self, value: str) -> None:\n        self._set_from_list(\"progress_bar\", value, [\"none\", \"display\", \"leave\"])\n\n    @property\n    def log_to_file(self) -> bool:\n        \"\"\"Whether to save logs to a file.\"\"\"\n        return self._d[\"log_to_file\"]\n\n    @log_to_file.setter\n    def log_to_file(self, value: bool) -> None:\n        self._set_boolean(\"log_to_file\", value)\n\n    @property\n    def notify_outdated_version(self) -> bool:\n        \"\"\"Whether to notify if there is a version update available.\"\"\"\n        return self._d[\"notify_outdated_version\"]\n\n    @notify_outdated_version.setter\n    def notify_outdated_version(self, value: bool) -> None:\n        self._set_boolean(\"notify_outdated_version\", value)\n\n    @property\n    def write_to_movie(self) -> bool:\n        \"\"\"Whether to render the scene to a movie file (-w).\"\"\"\n        return self._d[\"write_to_movie\"]\n\n    @write_to_movie.setter\n    def write_to_movie(self, value: bool) -> None:\n        self._set_boolean(\"write_to_movie\", value)\n\n    @property\n    def save_last_frame(self) -> bool:\n        \"\"\"Whether to save the last frame of the scene as an image file (-s).\"\"\"\n        return self._d[\"save_last_frame\"]\n\n    @save_last_frame.setter\n    def save_last_frame(self, value: bool) -> None:\n        self._set_boolean(\"save_last_frame\", value)\n\n    @property\n    def write_all(self) -> bool:\n        \"\"\"Whether to render all scenes in the input file (-a).\"\"\"\n        return self._d[\"write_all\"]\n\n    @write_all.setter\n    def write_all(self, value: bool) -> None:\n        self._set_boolean(\"write_all\", value)\n\n    @property\n    def save_pngs(self) -> bool:\n        \"\"\"Whether to save all frames in the scene as images files (-g).\"\"\"\n        return self._d[\"save_pngs\"]\n\n    @save_pngs.setter\n    def save_pngs(self, value: bool) -> None:\n        self._set_boolean(\"save_pngs\", value)\n\n    @property\n    def save_as_gif(self) -> bool:\n        \"\"\"Whether to save the rendered scene in .gif format (-i).\"\"\"\n        return self._d[\"save_as_gif\"]\n\n    @save_as_gif.setter\n    def save_as_gif(self, value: bool) -> None:\n        self._set_boolean(\"save_as_gif\", value)\n\n    @property\n    def save_sections(self) -> bool:\n        \"\"\"Whether to save single videos for each section in addition to the movie file.\"\"\"\n        return self._d[\"save_sections\"]\n\n    @save_sections.setter\n    def save_sections(self, value: bool) -> None:\n        self._set_boolean(\"save_sections\", value)\n\n    @property\n    def enable_wireframe(self) -> bool:\n        \"\"\"Whether to enable wireframe debugging mode in opengl.\"\"\"\n        return self._d[\"enable_wireframe\"]\n\n    @enable_wireframe.setter\n    def enable_wireframe(self, value: bool) -> None:\n        self._set_boolean(\"enable_wireframe\", value)\n\n    @property\n    def force_window(self) -> bool:\n        \"\"\"Whether to force window when using the opengl renderer.\"\"\"\n        return self._d[\"force_window\"]\n\n    @force_window.setter\n    def force_window(self, value: bool) -> None:\n        self._set_boolean(\"force_window\", value)\n\n    @property\n    def no_latex_cleanup(self) -> bool:\n        \"\"\"Prevents deletion of .aux, .dvi, and .log files produced by Tex and MathTex.\"\"\"\n        return self._d[\"no_latex_cleanup\"]\n\n    @no_latex_cleanup.setter\n    def no_latex_cleanup(self, value: bool) -> None:\n        self._set_boolean(\"no_latex_cleanup\", value)\n\n    @property\n    def preview_command(self) -> str:\n        return self._d[\"preview_command\"]\n\n    @preview_command.setter\n    def preview_command(self, value: str) -> None:\n        self._set_str(\"preview_command\", value)\n\n    @property\n    def verbosity(self) -> str:\n        \"\"\"Logger verbosity; \"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", or \"CRITICAL\" (-v).\"\"\"\n        return self._d[\"verbosity\"]\n\n    @verbosity.setter\n    def verbosity(self, val: str) -> None:\n        self._set_from_list(\n            \"verbosity\",\n            val,\n            [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"],\n        )\n        logger.setLevel(val)\n\n    @property\n    def format(self) -> str:\n        \"\"\"File format; \"png\", \"gif\", \"mp4\", \"webm\" or \"mov\".\"\"\"\n        return self._d[\"format\"]\n\n    @format.setter\n    def format(self, val: str) -> None:\n        self._set_from_list(\n            \"format\",\n            val,\n            [None, \"png\", \"gif\", \"mp4\", \"mov\", \"webm\"],\n        )\n        self.resolve_movie_file_extension(self.transparent)\n        if self.format == \"webm\":\n            logger.warning(\n                \"Output format set as webm, this can be slower than other formats\",\n            )\n\n    @property\n    def ffmpeg_loglevel(self) -> str:\n        \"\"\"Verbosity level of ffmpeg (no flag).\"\"\"\n        return self._d[\"ffmpeg_loglevel\"]\n\n    @ffmpeg_loglevel.setter\n    def ffmpeg_loglevel(self, val: str) -> None:\n        self._set_from_list(\n            \"ffmpeg_loglevel\",\n            val,\n            [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"],\n        )\n        logging.getLogger(\"libav\").setLevel(self.ffmpeg_loglevel)\n\n    @property\n    def media_embed(self) -> bool:\n        \"\"\"Whether to embed videos in Jupyter notebook.\"\"\"\n        return self._d[\"media_embed\"]\n\n    @media_embed.setter\n    def media_embed(self, value: bool) -> None:\n        self._set_boolean(\"media_embed\", value)\n\n    @property\n    def media_width(self) -> str:\n        \"\"\"Media width in Jupyter notebook.\"\"\"\n        return self._d[\"media_width\"]\n\n    @media_width.setter\n    def media_width(self, value: str) -> None:\n        self._set_str(\"media_width\", value)\n\n    @property\n    def pixel_width(self) -> int:\n        \"\"\"Frame width in pixels (--resolution, -r).\"\"\"\n        return self._d[\"pixel_width\"]\n\n    @pixel_width.setter\n    def pixel_width(self, value: int) -> None:\n        self._set_pos_number(\"pixel_width\", value, False)\n\n    @property\n    def pixel_height(self) -> int:\n        \"\"\"Frame height in pixels (--resolution, -r).\"\"\"\n        return self._d[\"pixel_height\"]\n\n    @pixel_height.setter\n    def pixel_height(self, value: int) -> None:\n        self._set_pos_number(\"pixel_height\", value, False)\n\n    @property\n    def aspect_ratio(self) -> int:\n        \"\"\"Aspect ratio (width / height) in pixels (--resolution, -r).\"\"\"\n        return self._d[\"pixel_width\"] / self._d[\"pixel_height\"]\n\n    @property\n    def frame_height(self) -> float:\n        \"\"\"Frame height in logical units (no flag).\"\"\"\n        return self._d[\"frame_height\"]\n\n    @frame_height.setter\n    def frame_height(self, value: float) -> None:\n        self._d.__setitem__(\"frame_height\", value)\n\n    @property\n    def frame_width(self) -> float:\n        \"\"\"Frame width in logical units (no flag).\"\"\"\n        return self._d[\"frame_width\"]\n\n    @frame_width.setter\n    def frame_width(self, value: float) -> None:\n        self._d.__setitem__(\"frame_width\", value)\n\n    @property\n    def frame_y_radius(self) -> float:\n        \"\"\"Half the frame height (no flag).\"\"\"\n        return self._d[\"frame_height\"] / 2\n\n    @frame_y_radius.setter\n    def frame_y_radius(self, value: float) -> None:\n        self._d.__setitem__(\"frame_y_radius\", value) or self._d.__setitem__(\n            \"frame_height\", 2 * value\n        )\n\n    @property\n    def frame_x_radius(self) -> float:\n        \"\"\"Half the frame width (no flag).\"\"\"\n        return self._d[\"frame_width\"] / 2\n\n    @frame_x_radius.setter\n    def frame_x_radius(self, value: float) -> None:\n        self._d.__setitem__(\"frame_x_radius\", value) or self._d.__setitem__(\n            \"frame_width\", 2 * value\n        )\n\n    @property\n    def top(self) -> Vector3D:\n        \"\"\"Coordinate at the center top of the frame.\"\"\"\n        return self.frame_y_radius * constants.UP\n\n    @property\n    def bottom(self) -> Vector3D:\n        \"\"\"Coordinate at the center bottom of the frame.\"\"\"\n        return self.frame_y_radius * constants.DOWN\n\n    @property\n    def left_side(self) -> Vector3D:\n        \"\"\"Coordinate at the middle left of the frame.\"\"\"\n        return self.frame_x_radius * constants.LEFT\n\n    @property\n    def right_side(self) -> Vector3D:\n        \"\"\"Coordinate at the middle right of the frame.\"\"\"\n        return self.frame_x_radius * constants.RIGHT\n\n    @property\n    def frame_rate(self) -> float:\n        \"\"\"Frame rate in frames per second.\"\"\"\n        return self._d[\"frame_rate\"]\n\n    @frame_rate.setter\n    def frame_rate(self, value: float) -> None:\n        self._d.__setitem__(\"frame_rate\", value)\n\n    # TODO: This was parsed before maybe add ManimColor(val), but results in circular import\n    @property\n    def background_color(self) -> ManimColor:\n        \"\"\"Background color of the scene (-c).\"\"\"\n        return self._d[\"background_color\"]\n\n    @background_color.setter\n    def background_color(self, value: Any) -> None:\n        self._d.__setitem__(\"background_color\", ManimColor(value))\n\n    @property\n    def from_animation_number(self) -> int:\n        \"\"\"Start rendering animations at this number (-n).\"\"\"\n        return self._d[\"from_animation_number\"]\n\n    @from_animation_number.setter\n    def from_animation_number(self, value: int) -> None:\n        self._d.__setitem__(\"from_animation_number\", value)\n\n    @property\n    def upto_animation_number(self) -> int:\n        \"\"\"Stop rendering animations at this number. Use -1 to avoid skipping (-n).\"\"\"\n        return self._d[\"upto_animation_number\"]\n\n    @upto_animation_number.setter\n    def upto_animation_number(self, value: int) -> None:\n        self._set_pos_number(\"upto_animation_number\", value, True)\n\n    @property\n    def max_files_cached(self) -> int:\n        \"\"\"Maximum number of files cached.  Use -1 for infinity (no flag).\"\"\"\n        return self._d[\"max_files_cached\"]\n\n    @max_files_cached.setter\n    def max_files_cached(self, value: int) -> None:\n        self._set_pos_number(\"max_files_cached\", value, True)\n\n    @property\n    def window_monitor(self) -> int:\n        \"\"\"The monitor on which the scene will be rendered.\"\"\"\n        return self._d[\"window_monitor\"]\n\n    @window_monitor.setter\n    def window_monitor(self, value: int) -> None:\n        self._set_pos_number(\"window_monitor\", value, True)\n\n    @property\n    def flush_cache(self) -> bool:\n        \"\"\"Whether to delete all the cached partial movie files.\"\"\"\n        return self._d[\"flush_cache\"]\n\n    @flush_cache.setter\n    def flush_cache(self, value: bool) -> None:\n        self._set_boolean(\"flush_cache\", value)\n\n    @property\n    def disable_caching(self) -> bool:\n        \"\"\"Whether to use scene caching.\"\"\"\n        return self._d[\"disable_caching\"]\n\n    @disable_caching.setter\n    def disable_caching(self, value: bool) -> None:\n        self._set_boolean(\"disable_caching\", value)\n\n    @property\n    def disable_caching_warning(self) -> bool:\n        \"\"\"Whether a warning is raised if there are too much submobjects to hash.\"\"\"\n        return self._d[\"disable_caching_warning\"]\n\n    @disable_caching_warning.setter\n    def disable_caching_warning(self, value: bool) -> None:\n        self._set_boolean(\"disable_caching_warning\", value)\n\n    @property\n    def movie_file_extension(self) -> str:\n        \"\"\"Either .mp4, .webm or .mov.\"\"\"\n        return self._d[\"movie_file_extension\"]\n\n    @movie_file_extension.setter\n    def movie_file_extension(self, value: str) -> None:\n        self._set_from_list(\"movie_file_extension\", value, [\".mp4\", \".mov\", \".webm\"])\n\n    @property\n    def background_opacity(self) -> float:\n        \"\"\"A number between 0.0 (fully transparent) and 1.0 (fully opaque).\"\"\"\n        return self._d[\"background_opacity\"]\n\n    @background_opacity.setter\n    def background_opacity(self, value: float) -> None:\n        self._set_between(\"background_opacity\", value, 0, 1)\n        if self.background_opacity < 1:\n            self.resolve_movie_file_extension(is_transparent=True)\n\n    @property\n    def frame_size(self) -> tuple[int, int]:\n        \"\"\"Tuple with (pixel width, pixel height) (no flag).\"\"\"\n        return (self._d[\"pixel_width\"], self._d[\"pixel_height\"])\n\n    @frame_size.setter\n    def frame_size(self, value: tuple[int, int]) -> None:\n        self._d.__setitem__(\"pixel_width\", value[0]) or self._d.__setitem__(\n            \"pixel_height\", value[1]\n        )\n\n    @property\n    def quality(self) -> str | None:\n        \"\"\"Video quality (-q).\"\"\"\n        keys = [\"pixel_width\", \"pixel_height\", \"frame_rate\"]\n        q = {k: self[k] for k in keys}\n        for qual in constants.QUALITIES:\n            if all(q[k] == constants.QUALITIES[qual][k] for k in keys):\n                return qual\n        return None\n\n    @quality.setter\n    def quality(self, value: str | None) -> None:\n        if value is None:\n            return\n        if value not in constants.QUALITIES:\n            raise KeyError(f\"quality must be one of {list(constants.QUALITIES.keys())}\")\n        q = constants.QUALITIES[value]\n        self.frame_size = q[\"pixel_width\"], q[\"pixel_height\"]\n        self.frame_rate = q[\"frame_rate\"]\n\n    @property\n    def transparent(self) -> bool:\n        \"\"\"Whether the background opacity is less than 1.0 (-t).\"\"\"\n        return self._d[\"background_opacity\"] < 1.0\n\n    @transparent.setter\n    def transparent(self, value: bool) -> None:\n        self._d[\"background_opacity\"] = float(not value)\n        self.resolve_movie_file_extension(value)\n\n    @property\n    def dry_run(self) -> bool:\n        \"\"\"Whether dry run is enabled.\"\"\"\n        return self._d[\"dry_run\"]\n\n    @dry_run.setter\n    def dry_run(self, val: bool) -> None:\n        self._d[\"dry_run\"] = val\n        if val:\n            self.write_to_movie = False\n            self.write_all = False\n            self.save_last_frame = False\n            self.format = None\n\n    @property\n    def renderer(self) -> RendererType:\n        \"\"\"The currently active renderer.\n\n        Populated with one of the available renderers in :class:`.RendererType`.\n\n        Tests::\n\n            >>> test_config = ManimConfig()\n            >>> test_config.renderer is None  # a new ManimConfig is unpopulated\n            True\n            >>> test_config.renderer = 'opengl'\n            >>> test_config.renderer\n            <RendererType.OPENGL: 'opengl'>\n            >>> test_config.renderer = 42\n            Traceback (most recent call last):\n            ...\n            ValueError: 42 is not a valid RendererType\n\n        Check that capitalization of renderer types is irrelevant::\n\n            >>> test_config.renderer = 'OpenGL'\n            >>> test_config.renderer = 'cAirO'\n        \"\"\"\n        return self._d[\"renderer\"]\n\n    @renderer.setter\n    def renderer(self, value: str | RendererType) -> None:\n        \"\"\"The setter of the renderer property.\n\n        Takes care of switching inheritance bases using the\n        :class:`.ConvertToOpenGL` metaclass.\n        \"\"\"\n        if isinstance(value, str):\n            value = value.lower()\n        renderer = RendererType(value)\n        try:\n            from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL\n            from manim.mobject.opengl.opengl_mobject import OpenGLMobject\n            from manim.mobject.opengl.opengl_vectorized_mobject import OpenGLVMobject\n\n            from ..mobject.mobject import Mobject\n            from ..mobject.types.vectorized_mobject import VMobject\n\n            for cls in ConvertToOpenGL._converted_classes:\n                if renderer == RendererType.OPENGL:\n                    conversion_dict = {\n                        Mobject: OpenGLMobject,\n                        VMobject: OpenGLVMobject,\n                    }\n                else:\n                    conversion_dict = {\n                        OpenGLMobject: Mobject,\n                        OpenGLVMobject: VMobject,\n                    }\n\n                cls.__bases__ = tuple(\n                    conversion_dict.get(base, base) for base in cls.__bases__\n                )\n        except ImportError:\n            # The renderer is set during the initial import of the\n            # library for the first time. The imports above cause an\n            # ImportError due to circular imports. However, the\n            # metaclass sets stuff up correctly in this case, so we\n            # can just do nothing.\n            pass\n\n        self._set_from_enum(\"renderer\", renderer, RendererType)\n\n    @property\n    def media_dir(self) -> str:\n        \"\"\"Main output directory.  See :meth:`ManimConfig.get_dir`.\"\"\"\n        return self._d[\"media_dir\"]\n\n    @media_dir.setter\n    def media_dir(self, value: str | Path) -> None:\n        self._set_dir(\"media_dir\", value)\n\n    @property\n    def window_position(self) -> str:\n        \"\"\"Set the position of preview window. You can use directions, e.g. UL/DR/ORIGIN/LEFT...or the position(pixel) of the upper left corner of the window, e.g. '960,540'.\"\"\"\n        return self._d[\"window_position\"]\n\n    @window_position.setter\n    def window_position(self, value: str) -> None:\n        self._d.__setitem__(\"window_position\", value)\n\n    @property\n    def window_size(self) -> str:\n        \"\"\"The size of the opengl window. 'default' to automatically scale the window based on the display monitor.\"\"\"\n        return self._d[\"window_size\"]\n\n    @window_size.setter\n    def window_size(self, value: str) -> None:\n        self._d.__setitem__(\"window_size\", value)\n\n    def resolve_movie_file_extension(self, is_transparent: bool) -> None:\n        prev_file_extension = self.movie_file_extension\n        if is_transparent:\n            self.movie_file_extension = \".webm\" if self.format == \"webm\" else \".mov\"\n        elif self.format == \"webm\":\n            self.movie_file_extension = \".webm\"\n        elif self.format == \"mov\":\n            self.movie_file_extension = \".mov\"\n        else:\n            self.movie_file_extension = \".mp4\"\n        if self.movie_file_extension != prev_file_extension:\n            logger.warning(\n                f\"Output format changed to '{self.movie_file_extension}' \"\n                \"to support transparency\",\n            )\n\n    @property\n    def enable_gui(self) -> bool:\n        \"\"\"Enable GUI interaction.\"\"\"\n        return self._d[\"enable_gui\"]\n\n    @enable_gui.setter\n    def enable_gui(self, value: bool) -> None:\n        self._set_boolean(\"enable_gui\", value)\n\n    @property\n    def gui_location(self) -> tuple[Any]:\n        \"\"\"Location parameters for the GUI window (e.g., screen coordinates or layout settings).\"\"\"\n        return self._d[\"gui_location\"]\n\n    @gui_location.setter\n    def gui_location(self, value: tuple[Any]) -> None:\n        self._set_tuple(\"gui_location\", value)\n\n    @property\n    def fullscreen(self) -> bool:\n        \"\"\"Expand the window to its maximum possible size.\"\"\"\n        return self._d[\"fullscreen\"]\n\n    @fullscreen.setter\n    def fullscreen(self, value: bool) -> None:\n        self._set_boolean(\"fullscreen\", value)\n\n    @property\n    def use_projection_fill_shaders(self) -> bool:\n        \"\"\"Use shaders for OpenGLVMobject fill which are compatible with transformation matrices.\"\"\"\n        return self._d[\"use_projection_fill_shaders\"]\n\n    @use_projection_fill_shaders.setter\n    def use_projection_fill_shaders(self, value: bool) -> None:\n        self._set_boolean(\"use_projection_fill_shaders\", value)\n\n    @property\n    def use_projection_stroke_shaders(self) -> bool:\n        \"\"\"Use shaders for OpenGLVMobject stroke which are compatible with transformation matrices.\"\"\"\n        return self._d[\"use_projection_stroke_shaders\"]\n\n    @use_projection_stroke_shaders.setter\n    def use_projection_stroke_shaders(self, value: bool) -> None:\n        self._set_boolean(\"use_projection_stroke_shaders\", value)\n\n    @property\n    def zero_pad(self) -> int:\n        \"\"\"PNG zero padding. A number between 0 (no zero padding) and 9 (9 columns minimum).\"\"\"\n        return self._d[\"zero_pad\"]\n\n    @zero_pad.setter\n    def zero_pad(self, value: int) -> None:\n        self._set_int_between(\"zero_pad\", value, 0, 9)\n\n    def get_dir(self, key: str, **kwargs: Any) -> Path:\n        \"\"\"Resolve a config option that stores a directory.\n\n        Config options that store directories may depend on one another.  This\n        method is used to provide the actual directory to the end user.\n\n        Parameters\n        ----------\n        key\n            The config option to be resolved.  Must be an option ending in\n            ``'_dir'``, for example ``'media_dir'`` or ``'video_dir'``.\n\n        kwargs\n            Any strings to be used when resolving the directory.\n\n        Returns\n        -------\n        :class:`pathlib.Path`\n            Path to the requested directory.  If the path resolves to the empty\n            string, return ``None`` instead.\n\n        Raises\n        ------\n        :class:`KeyError`\n            When ``key`` is not a config option that stores a directory and\n            thus :meth:`~ManimConfig.get_dir` is not appropriate; or when\n            ``key`` is appropriate but there is not enough information to\n            resolve the directory.\n\n        Notes\n        -----\n        Standard :meth:`str.format` syntax is used to resolve the paths so the\n        paths may contain arbitrary placeholders using f-string notation.\n        However, these will require ``kwargs`` to contain the required values.\n\n        Examples\n        --------\n\n        The value of ``config.tex_dir`` is ``'{media_dir}/Tex'`` by default,\n        i.e. it is a subfolder of wherever ``config.media_dir`` is located.  In\n        order to get the *actual* directory, use :meth:`~ManimConfig.get_dir`.\n\n        .. code-block:: pycon\n\n            >>> from manim import config as globalconfig\n            >>> config = globalconfig.copy()\n            >>> config.tex_dir\n            '{media_dir}/Tex'\n            >>> config.media_dir\n            './media'\n            >>> config.get_dir(\"tex_dir\").as_posix()\n            'media/Tex'\n\n        Resolving directories is done in a lazy way, at the last possible\n        moment, to reflect any changes in other config options:\n\n        .. code-block:: pycon\n\n            >>> config.media_dir = \"my_media_dir\"\n            >>> config.get_dir(\"tex_dir\").as_posix()\n            'my_media_dir/Tex'\n\n        Some directories depend on information that is not available to\n        :class:`ManimConfig`. For example, the default value of `video_dir`\n        includes the name of the input file and the video quality\n        (e.g. 480p15). This informamtion has to be supplied via ``kwargs``:\n\n        .. code-block:: pycon\n\n            >>> config.video_dir\n            '{media_dir}/videos/{module_name}/{quality}'\n            >>> config.get_dir(\"video_dir\")\n            Traceback (most recent call last):\n            KeyError: 'video_dir {media_dir}/videos/{module_name}/{quality} requires the following keyword arguments: module_name'\n            >>> config.get_dir(\"video_dir\", module_name=\"myfile\").as_posix()\n            'my_media_dir/videos/myfile/1080p60'\n\n        Note the quality does not need to be passed as keyword argument since\n        :class:`ManimConfig` does store information about quality.\n\n        Directories may be recursively defined.  For example, the config option\n        ``partial_movie_dir`` depends on ``video_dir``, which in turn depends\n        on ``media_dir``:\n\n        .. code-block:: pycon\n\n            >>> config.partial_movie_dir\n            '{video_dir}/partial_movie_files/{scene_name}'\n            >>> config.get_dir(\"partial_movie_dir\")\n            Traceback (most recent call last):\n            KeyError: 'partial_movie_dir {video_dir}/partial_movie_files/{scene_name} requires the following keyword arguments: scene_name'\n            >>> config.get_dir(\n            ...     \"partial_movie_dir\", module_name=\"myfile\", scene_name=\"myscene\"\n            ... ).as_posix()\n            'my_media_dir/videos/myfile/1080p60/partial_movie_files/myscene'\n\n        Standard f-string syntax is used.  Arbitrary names can be used when\n        defining directories, as long as the corresponding values are passed to\n        :meth:`ManimConfig.get_dir` via ``kwargs``.\n\n        .. code-block:: pycon\n\n            >>> config.media_dir = \"{dir1}/{dir2}\"\n            >>> config.get_dir(\"media_dir\")\n            Traceback (most recent call last):\n            KeyError: 'media_dir {dir1}/{dir2} requires the following keyword arguments: dir1'\n            >>> config.get_dir(\"media_dir\", dir1=\"foo\", dir2=\"bar\").as_posix()\n            'foo/bar'\n            >>> config.media_dir = \"./media\"\n            >>> config.get_dir(\"media_dir\").as_posix()\n            'media'\n\n        \"\"\"\n        dirs = [\n            \"assets_dir\",\n            \"media_dir\",\n            \"video_dir\",\n            \"sections_dir\",\n            \"images_dir\",\n            \"text_dir\",\n            \"tex_dir\",\n            \"log_dir\",\n            \"input_file\",\n            \"output_file\",\n            \"partial_movie_dir\",\n        ]\n        if key not in dirs:\n            raise KeyError(\n                \"must pass one of \"\n                \"{media,video,images,text,tex,log}_dir \"\n                \"or {input,output}_file\",\n            )\n\n        dirs.remove(key)  # a path cannot contain itself\n\n        all_args = {k: self._d[k] for k in dirs}\n        all_args.update(kwargs)\n        all_args[\"quality\"] = f\"{self.pixel_height}p{self.frame_rate:g}\"\n\n        path = self._d[key]\n        while \"{\" in path:\n            try:\n                path = path.format(**all_args)\n            except KeyError as exc:\n                raise KeyError(\n                    f\"{key} {self._d[key]} requires the following \"\n                    + \"keyword arguments: \"\n                    + \" \".join(exc.args),\n                ) from exc\n        return Path(path) if path else None\n\n    def _set_dir(self, key: str, val: str | Path) -> None:\n        if isinstance(val, Path):\n            self._d.__setitem__(key, str(val))\n        else:\n            self._d.__setitem__(key, val)\n\n    @property\n    def assets_dir(self) -> str:\n        \"\"\"Directory to locate video assets (no flag).\"\"\"\n        return self._d[\"assets_dir\"]\n\n    @assets_dir.setter\n    def assets_dir(self, value: str | Path) -> None:\n        self._set_dir(\"assets_dir\", value)\n\n    @property\n    def log_dir(self) -> str:\n        \"\"\"Directory to place logs. See :meth:`ManimConfig.get_dir`.\"\"\"\n        return self._d[\"log_dir\"]\n\n    @log_dir.setter\n    def log_dir(self, value: str | Path) -> None:\n        self._set_dir(\"log_dir\", value)\n\n    @property\n    def video_dir(self) -> str:\n        \"\"\"Directory to place videos (no flag). See :meth:`ManimConfig.get_dir`.\"\"\"\n        return self._d[\"video_dir\"]\n\n    @video_dir.setter\n    def video_dir(self, value: str | Path) -> None:\n        self._set_dir(\"video_dir\", value)\n\n    @property\n    def sections_dir(self) -> str:\n        \"\"\"Directory to place section videos (no flag). See :meth:`ManimConfig.get_dir`.\"\"\"\n        return self._d[\"sections_dir\"]\n\n    @sections_dir.setter\n    def sections_dir(self, value: str | Path) -> None:\n        self._set_dir(\"sections_dir\", value)\n\n    @property\n    def images_dir(self) -> str:\n        \"\"\"Directory to place images (no flag).  See :meth:`ManimConfig.get_dir`.\"\"\"\n        return self._d[\"images_dir\"]\n\n    @images_dir.setter\n    def images_dir(self, value: str | Path) -> None:\n        self._set_dir(\"images_dir\", value)\n\n    @property\n    def text_dir(self) -> str:\n        \"\"\"Directory to place text (no flag).  See :meth:`ManimConfig.get_dir`.\"\"\"\n        return self._d[\"text_dir\"]\n\n    @text_dir.setter\n    def text_dir(self, value: str | Path) -> None:\n        self._set_dir(\"text_dir\", value)\n\n    @property\n    def tex_dir(self) -> str:\n        \"\"\"Directory to place tex (no flag).  See :meth:`ManimConfig.get_dir`.\"\"\"\n        return self._d[\"tex_dir\"]\n\n    @tex_dir.setter\n    def tex_dir(self, value: str | Path) -> None:\n        self._set_dir(\"tex_dir\", value)\n\n    @property\n    def partial_movie_dir(self) -> str:\n        \"\"\"Directory to place partial movie files (no flag).  See :meth:`ManimConfig.get_dir`.\"\"\"\n        return self._d[\"partial_movie_dir\"]\n\n    @partial_movie_dir.setter\n    def partial_movie_dir(self, value: str | Path) -> None:\n        self._set_dir(\"partial_movie_dir\", value)\n\n    @property\n    def custom_folders(self) -> str:\n        \"\"\"Whether to use custom folder output.\"\"\"\n        return self._d[\"custom_folders\"]\n\n    @custom_folders.setter\n    def custom_folders(self, value: str | Path) -> None:\n        self._set_dir(\"custom_folders\", value)\n\n    @property\n    def input_file(self) -> str:\n        \"\"\"Input file name.\"\"\"\n        return self._d[\"input_file\"]\n\n    @input_file.setter\n    def input_file(self, value: str | Path) -> None:\n        self._set_dir(\"input_file\", value)\n\n    @property\n    def output_file(self) -> str:\n        \"\"\"Output file name (-o).\"\"\"\n        return self._d[\"output_file\"]\n\n    @output_file.setter\n    def output_file(self, value: str | Path) -> None:\n        self._set_dir(\"output_file\", value)\n\n    @property\n    def scene_names(self) -> list[str]:\n        \"\"\"Scenes to play from file.\"\"\"\n        return self._d[\"scene_names\"]\n\n    @scene_names.setter\n    def scene_names(self, value: list[str]) -> None:\n        self._d.__setitem__(\"scene_names\", value)\n\n    @property\n    def tex_template(self) -> TexTemplate:\n        \"\"\"Template used when rendering Tex.  See :class:`.TexTemplate`.\"\"\"\n        if not hasattr(self, \"_tex_template\") or not self._tex_template:\n            fn = self._d[\"tex_template_file\"]\n            if fn:\n                self._tex_template = TexTemplate.from_file(fn)\n            else:\n                self._tex_template = TexTemplate()\n        return self._tex_template\n\n    @tex_template.setter\n    def tex_template(self, val: TexTemplate) -> None:\n        if isinstance(val, TexTemplate):\n            self._tex_template = val\n\n    @property\n    def tex_template_file(self) -> Path:\n        \"\"\"File to read Tex template from (no flag).  See :class:`.TexTemplate`.\"\"\"\n        return self._d[\"tex_template_file\"]\n\n    @tex_template_file.setter\n    def tex_template_file(self, val: str) -> None:\n        if val:\n            if not os.access(val, os.R_OK):\n                logger.warning(\n                    f\"Custom TeX template {val} not found or not readable.\",\n                )\n            else:\n                self._d[\"tex_template_file\"] = Path(val)\n        else:\n            self._d[\"tex_template_file\"] = val  # actually set the falsy value\n\n    @property\n    def plugins(self) -> list[str]:\n        \"\"\"List of plugins to enable.\"\"\"\n        return self._d[\"plugins\"]\n\n    @plugins.setter\n    def plugins(self, value: list[str]):\n        self._d[\"plugins\"] = value"}, {"name": "ManimDirective", "code": "class ManimDirective(Directive):\n    r\"\"\"The manim directive, rendering videos while building\n    the documentation.\n\n    See the module docstring for documentation.\n    \"\"\"\n\n    has_content = True\n    required_arguments = 1\n    optional_arguments = 0\n    option_spec = {\n        \"hide_source\": bool,\n        \"no_autoplay\": bool,\n        \"quality\": lambda arg: directives.choice(\n            arg,\n            (\"low\", \"medium\", \"high\", \"fourk\"),\n        ),\n        \"save_as_gif\": bool,\n        \"save_last_frame\": bool,\n        \"ref_modules\": lambda arg: process_name_list(arg, \"mod\"),\n        \"ref_classes\": lambda arg: process_name_list(arg, \"class\"),\n        \"ref_functions\": lambda arg: process_name_list(arg, \"func\"),\n        \"ref_methods\": lambda arg: process_name_list(arg, \"meth\"),\n    }\n    final_argument_whitespace = True\n\n    def run(self) -> list[nodes.Element]:\n        # Rendering is skipped if the tag skip-manim is present,\n        # or if we are making the pot-files\n        should_skip = (\n            \"skip-manim\" in self.state.document.settings.env.app.builder.tags\n            or self.state.document.settings.env.app.builder.name == \"gettext\"\n        )\n        if should_skip:\n            clsname = self.arguments[0]\n            node = SkipManimNode()\n            self.state.nested_parse(\n                StringList(\n                    [\n                        f\"Placeholder block for ``{clsname}``.\",\n                        \"\",\n                        \".. code-block:: python\",\n                        \"\",\n                    ]\n                    + [\"    \" + line for line in self.content]\n                    + [\n                        \"\",\n                        \".. raw:: html\",\n                        \"\",\n                        f'    <pre data-manim-binder data-manim-classname=\"{clsname}\">',\n                    ]\n                    + [\"    \" + line for line in self.content]\n                    + [\"    </pre>\"],\n                ),\n                self.content_offset,\n                node,\n            )\n            return [node]\n\n        from manim import config, tempconfig\n\n        global classnamedict\n\n        clsname = self.arguments[0]\n        if clsname not in classnamedict:\n            classnamedict[clsname] = 1\n        else:\n            classnamedict[clsname] += 1\n\n        hide_source = \"hide_source\" in self.options\n        no_autoplay = \"no_autoplay\" in self.options\n        save_as_gif = \"save_as_gif\" in self.options\n        save_last_frame = \"save_last_frame\" in self.options\n        assert not (save_as_gif and save_last_frame)\n\n        ref_content = (\n            self.options.get(\"ref_modules\", [])\n            + self.options.get(\"ref_classes\", [])\n            + self.options.get(\"ref_functions\", [])\n            + self.options.get(\"ref_methods\", [])\n        )\n        ref_block = \"References: \" + \" \".join(ref_content) if ref_content else \"\"\n\n        if \"quality\" in self.options:\n            quality = f\"{self.options['quality']}_quality\"\n        else:\n            quality = \"example_quality\"\n        frame_rate = QUALITIES[quality][\"frame_rate\"]\n        pixel_height = QUALITIES[quality][\"pixel_height\"]\n        pixel_width = QUALITIES[quality][\"pixel_width\"]\n\n        state_machine = self.state_machine\n        document = state_machine.document\n\n        source_file_name = Path(document.attributes[\"source\"])\n        source_rel_name = source_file_name.relative_to(setup.confdir)  # type: ignore[attr-defined]\n        source_rel_dir = source_rel_name.parents[0]\n        dest_dir = Path(setup.app.builder.outdir, source_rel_dir).absolute()  # type: ignore[attr-defined]\n        if not dest_dir.exists():\n            dest_dir.mkdir(parents=True, exist_ok=True)\n\n        source_block_in = [\n            \".. code-block:: python\",\n            \"\",\n            \"    from manim import *\\n\",\n            *(\"    \" + line for line in self.content),\n            \"\",\n            \".. raw:: html\",\n            \"\",\n            f'    <pre data-manim-binder data-manim-classname=\"{clsname}\">',\n            *(\"    \" + line for line in self.content),\n            \"\",\n            \"    </pre>\",\n        ]\n        source_block = \"\\n\".join(source_block_in)\n\n        config.media_dir = (Path(setup.confdir) / \"media\").absolute()  # type: ignore[attr-defined,assignment]\n        config.images_dir = \"{media_dir}/images\"\n        config.video_dir = \"{media_dir}/videos/{quality}\"\n        output_file = f\"{clsname}-{classnamedict[clsname]}\"\n        config.assets_dir = Path(\"_static\")  # type: ignore[assignment]\n        config.progress_bar = \"none\"\n        config.verbosity = \"WARNING\"\n\n        example_config = {\n            \"frame_rate\": frame_rate,\n            \"no_autoplay\": no_autoplay,\n            \"pixel_height\": pixel_height,\n            \"pixel_width\": pixel_width,\n            \"save_last_frame\": save_last_frame,\n            \"write_to_movie\": not save_last_frame,\n            \"output_file\": output_file,\n        }\n        if save_last_frame:\n            example_config[\"format\"] = None\n        if save_as_gif:\n            example_config[\"format\"] = \"gif\"\n\n        user_code = list(self.content)\n        if user_code[0].startswith(\">>> \"):  # check whether block comes from doctest\n            user_code = [\n                line[4:] for line in user_code if line.startswith((\">>> \", \"... \"))\n            ]\n\n        code = [\n            \"from manim import *\",\n            *user_code,\n            f\"{clsname}().render()\",\n        ]\n\n        try:\n            with tempconfig(example_config):\n                run_time = timeit(lambda: exec(\"\\n\".join(code), globals()), number=1)\n                video_dir = config.get_dir(\"video_dir\")\n                images_dir = config.get_dir(\"images_dir\")\n        except Exception as e:\n            raise RuntimeError(f\"Error while rendering example {clsname}\") from e\n\n        _write_rendering_stats(\n            clsname,\n            run_time,\n            self.state.document.settings.env.docname,\n        )\n\n        # copy video file to output directory\n        if not (save_as_gif or save_last_frame):\n            filename = f\"{output_file}.mp4\"\n            filesrc = video_dir / filename\n            destfile = Path(dest_dir, filename)\n            shutil.copyfile(filesrc, destfile)\n        elif save_as_gif:\n            filename = f\"{output_file}.gif\"\n            filesrc = video_dir / filename\n        elif save_last_frame:\n            filename = f\"{output_file}.png\"\n            filesrc = images_dir / filename\n        else:\n            raise ValueError(\"Invalid combination of render flags received.\")\n        rendered_template = jinja2.Template(TEMPLATE).render(\n            clsname=clsname,\n            clsname_lowercase=clsname.lower(),\n            hide_source=hide_source,\n            filesrc_rel=Path(filesrc).relative_to(setup.confdir).as_posix(),  # type: ignore[attr-defined]\n            no_autoplay=no_autoplay,\n            output_file=output_file,\n            save_last_frame=save_last_frame,\n            save_as_gif=save_as_gif,\n            source_block=source_block,\n            ref_block=ref_block,\n        )\n        state_machine.insert_input(\n            rendered_template.split(\"\\n\"),\n            source=document.attributes[\"source\"],\n        )\n\n        return []"}, {"name": "ManimFrame", "code": "class ManimFrame(Mapping):\n    _OPTS: ClassVar[set[str]] = {\n        \"pixel_width\",\n        \"pixel_height\",\n        \"aspect_ratio\",\n        \"frame_height\",\n        \"frame_width\",\n        \"frame_y_radius\",\n        \"frame_x_radius\",\n        \"top\",\n        \"bottom\",\n        \"left_side\",\n        \"right_side\",\n    }\n    _CONSTANTS: ClassVar[dict[str, Vector3D]] = {\n        \"UP\": np.array((0.0, 1.0, 0.0)),\n        \"DOWN\": np.array((0.0, -1.0, 0.0)),\n        \"RIGHT\": np.array((1.0, 0.0, 0.0)),\n        \"LEFT\": np.array((-1.0, 0.0, 0.0)),\n        \"IN\": np.array((0.0, 0.0, -1.0)),\n        \"OUT\": np.array((0.0, 0.0, 1.0)),\n        \"ORIGIN\": np.array((0.0, 0.0, 0.0)),\n        \"X_AXIS\": np.array((1.0, 0.0, 0.0)),\n        \"Y_AXIS\": np.array((0.0, 1.0, 0.0)),\n        \"Z_AXIS\": np.array((0.0, 0.0, 1.0)),\n        \"UL\": np.array((-1.0, 1.0, 0.0)),\n        \"UR\": np.array((1.0, 1.0, 0.0)),\n        \"DL\": np.array((-1.0, -1.0, 0.0)),\n        \"DR\": np.array((1.0, -1.0, 0.0)),\n    }\n\n    _c: ManimConfig\n\n    def __init__(self, c: ManimConfig) -> None:\n        if not isinstance(c, ManimConfig):\n            raise TypeError(\"argument must be instance of 'ManimConfig'\")\n        # need to use __dict__ directly because setting attributes is not\n        # allowed (see __setattr__)\n        self.__dict__[\"_c\"] = c\n\n    # there are required by parent class Mapping to behave like a dict\n    def __getitem__(self, key: str | int) -> Any:\n        if key in self._OPTS:\n            return self._c[key]\n        elif key in self._CONSTANTS:\n            return self._CONSTANTS[key]\n        else:\n            raise KeyError(key)\n\n    def __iter__(self) -> Iterable[str]:\n        return iter(list(self._OPTS) + list(self._CONSTANTS))\n\n    def __len__(self) -> int:\n        return len(self._OPTS)\n\n    # make this truly immutable\n    def __setattr__(self, attr: Any, val: Any) -> NoReturn:\n        raise TypeError(\"'ManimFrame' object does not support item assignment\")\n\n    def __setitem__(self, key: Any, val: Any) -> NoReturn:\n        raise TypeError(\"'ManimFrame' object does not support item assignment\")\n\n    def __delitem__(self, key: Any) -> NoReturn:\n        raise TypeError(\"'ManimFrame' object does not support item deletion\")"}, {"name": "MappingCamera", "code": "class MappingCamera(Camera):\n    \"\"\"Camera object that allows mapping\n    between objects.\n    \"\"\"\n\n    def __init__(\n        self,\n        mapping_func=lambda p: p,\n        min_num_curves=50,\n        allow_object_intrusion=False,\n        **kwargs,\n    ):\n        self.mapping_func = mapping_func\n        self.min_num_curves = min_num_curves\n        self.allow_object_intrusion = allow_object_intrusion\n        super().__init__(**kwargs)\n\n    def points_to_pixel_coords(self, mobject, points):\n        return super().points_to_pixel_coords(\n            mobject,\n            np.apply_along_axis(self.mapping_func, 1, points),\n        )\n\n    def capture_mobjects(self, mobjects, **kwargs):\n        mobjects = self.get_mobjects_to_display(mobjects, **kwargs)\n        if self.allow_object_intrusion:\n            mobject_copies = mobjects\n        else:\n            mobject_copies = [mobject.copy() for mobject in mobjects]\n        for mobject in mobject_copies:\n            if (\n                isinstance(mobject, VMobject)\n                and 0 < mobject.get_num_curves() < self.min_num_curves\n            ):\n                mobject.insert_n_curves(self.min_num_curves)\n        super().capture_mobjects(\n            mobject_copies,\n            include_submobjects=False,\n            excluded_mobjects=None,\n        )"}, {"name": "MarkupText", "code": "class MarkupText(SVGMobject):\n    r\"\"\"Display (non-LaTeX) text rendered using `Pango <https://pango.org/>`_.\n\n    Text objects behave like a :class:`.VGroup`-like iterable of all characters\n    in the given text. In particular, slicing is possible.\n\n    **What is PangoMarkup?**\n\n    PangoMarkup is a small markup language like html and it helps you avoid using\n    \"range of characters\" while coloring or styling a piece a Text. You can use\n    this language with :class:`~.MarkupText`.\n\n    A simple example of a marked-up string might be::\n\n        <span foreground=\"blue\" size=\"x-large\">Blue text</span> is <i>cool</i>!\"\n\n    and it can be used with :class:`~.MarkupText` as\n\n    .. manim:: MarkupExample\n        :save_last_frame:\n\n        class MarkupExample(Scene):\n            def construct(self):\n                text = MarkupText('<span foreground=\"blue\" size=\"x-large\">Blue text</span> is <i>cool</i>!\"')\n                self.add(text)\n\n    A more elaborate example would be:\n\n    .. manim:: MarkupElaborateExample\n        :save_last_frame:\n\n        class MarkupElaborateExample(Scene):\n            def construct(self):\n                text = MarkupText(\n                    '<span foreground=\"purple\">\u0627</span><span foreground=\"red\">\u064e</span>'\n                    '\u0644<span foreground=\"blue\">\u0652</span>\u0639<span foreground=\"red\">\u064e</span>\u0631'\n                    '<span foreground=\"red\">\u064e</span>\u0628<span foreground=\"red\">\u0650</span>\u064a'\n                    '<span foreground=\"green\">\u0651</span><span foreground=\"red\">\u064e</span>\u0629'\n                    '<span foreground=\"blue\">\u064f</span>'\n                )\n                self.add(text)\n\n    PangoMarkup can also contain XML features such as numeric character\n    entities such as ``&#169;`` for \u00a9 can be used too.\n\n    The most general markup tag is ``<span>``, then there are some\n    convenience tags.\n\n    Here is a list of supported tags:\n\n    - ``<b>bold</b>``, ``<i>italic</i>`` and ``<b><i>bold+italic</i></b>``\n    - ``<u>underline</u>`` and ``<s>strike through</s>``\n    - ``<tt>typewriter font</tt>``\n    - ``<big>bigger font</big>`` and ``<small>smaller font</small>``\n    - ``<sup>superscript</sup>`` and ``<sub>subscript</sub>``\n    - ``<span underline=\"double\" underline_color=\"green\">double underline</span>``\n    - ``<span underline=\"error\">error underline</span>``\n    - ``<span overline=\"single\" overline_color=\"green\">overline</span>``\n    - ``<span strikethrough=\"true\" strikethrough_color=\"red\">strikethrough</span>``\n    - ``<span font_family=\"sans\">temporary change of font</span>``\n    - ``<span foreground=\"red\">temporary change of color</span>``\n    - ``<span fgcolor=\"red\">temporary change of color</span>``\n    - ``<gradient from=\"YELLOW\" to=\"RED\">temporary gradient</gradient>``\n\n    For ``<span>`` markup, colors can be specified either as\n    hex triples like ``#aabbcc`` or as named CSS colors like\n    ``AliceBlue``.\n    The ``<gradient>`` tag is handled by Manim rather than\n    Pango, and supports hex triplets or Manim constants like\n    ``RED`` or ``RED_A``.\n    If you want to use Manim constants like ``RED_A`` together\n    with ``<span>``, you will need to use Python's f-String\n    syntax as follows::\n\n        MarkupText(f'<span foreground=\"{RED_A}\">here you go</span>')\n\n    If your text contains ligatures, the :class:`MarkupText` class may\n    incorrectly determine the first and last letter when creating the\n    gradient. This is due to the fact that ``fl`` are two separate characters,\n    but might be set as one single glyph - a ligature. If your language\n    does not depend on ligatures, consider setting ``disable_ligatures``\n    to ``True``. If you must use ligatures, the ``gradient`` tag supports an optional\n    attribute ``offset`` which can be used to compensate for that error.\n\n    For example:\n\n    - ``<gradient from=\"RED\" to=\"YELLOW\" offset=\"1\">example</gradient>`` to *start* the gradient one letter earlier\n    - ``<gradient from=\"RED\" to=\"YELLOW\" offset=\",1\">example</gradient>`` to *end* the gradient one letter earlier\n    - ``<gradient from=\"RED\" to=\"YELLOW\" offset=\"2,1\">example</gradient>`` to *start* the gradient two letters earlier and *end* it one letter earlier\n\n    Specifying a second offset may be necessary if the text to be colored does\n    itself contain ligatures. The same can happen when using HTML entities for\n    special chars.\n\n    When using ``underline``, ``overline`` or ``strikethrough`` together with\n    ``<gradient>`` tags, you will also need to use the offset, because\n    underlines are additional paths in the final :class:`SVGMobject`.\n    Check out the following example.\n\n    Escaping of special characters: ``>`` **should** be written as ``&gt;``\n    whereas ``<`` and ``&`` *must* be written as ``&lt;`` and\n    ``&amp;``.\n\n    You can find more information about Pango markup formatting at the\n    corresponding documentation page:\n    `Pango Markup <https://docs.gtk.org/Pango/pango_markup.html>`_.\n    Please be aware that not all features are supported by this class and that\n    the ``<gradient>`` tag mentioned above is not supported by Pango.\n\n    Parameters\n    ----------\n\n    text\n        The text that needs to be created as mobject.\n    fill_opacity\n        The fill opacity, with 1 meaning opaque and 0 meaning transparent.\n    stroke_width\n        Stroke width.\n    font_size\n        Font size.\n    line_spacing\n        Line spacing.\n    font\n        Global font setting for the entire text. Local overrides are possible.\n    slant\n        Global slant setting, e.g. `NORMAL` or `ITALIC`. Local overrides are possible.\n    weight\n        Global weight setting, e.g. `NORMAL` or `BOLD`. Local overrides are possible.\n    gradient\n        Global gradient setting. Local overrides are possible.\n    warn_missing_font\n        If True (default), Manim will issue a warning if the font does not exist in the\n        (case-sensitive) list of fonts returned from `manimpango.list_fonts()`.\n\n    Returns\n    -------\n    :class:`MarkupText`\n        The text displayed in form of a :class:`.VGroup`-like mobject.\n\n    Examples\n    ---------\n\n    .. manim:: BasicMarkupExample\n        :save_last_frame:\n\n        class BasicMarkupExample(Scene):\n            def construct(self):\n                text1 = MarkupText(\"<b>foo</b> <i>bar</i> <b><i>foobar</i></b>\")\n                text2 = MarkupText(\"<s>foo</s> <u>bar</u> <big>big</big> <small>small</small>\")\n                text3 = MarkupText(\"H<sub>2</sub>O and H<sub>3</sub>O<sup>+</sup>\")\n                text4 = MarkupText(\"type <tt>help</tt> for help\")\n                text5 = MarkupText(\n                    '<span underline=\"double\">foo</span> <span underline=\"error\">bar</span>'\n                )\n                group = VGroup(text1, text2, text3, text4, text5).arrange(DOWN)\n                self.add(group)\n\n    .. manim:: ColorExample\n        :save_last_frame:\n\n        class ColorExample(Scene):\n            def construct(self):\n                text1 = MarkupText(\n                    f'all in red <span fgcolor=\"{YELLOW}\">except this</span>', color=RED\n                )\n                text2 = MarkupText(\"nice gradient\", gradient=(BLUE, GREEN))\n                text3 = MarkupText(\n                    'nice <gradient from=\"RED\" to=\"YELLOW\">intermediate</gradient> gradient',\n                    gradient=(BLUE, GREEN),\n                )\n                text4 = MarkupText(\n                    'fl ligature <gradient from=\"RED\" to=\"YELLOW\">causing trouble</gradient> here'\n                )\n                text5 = MarkupText(\n                    'fl ligature <gradient from=\"RED\" to=\"YELLOW\" offset=\"1\">defeated</gradient> with offset'\n                )\n                text6 = MarkupText(\n                    'fl ligature <gradient from=\"RED\" to=\"YELLOW\" offset=\"1\">floating</gradient> inside'\n                )\n                text7 = MarkupText(\n                    'fl ligature <gradient from=\"RED\" to=\"YELLOW\" offset=\"1,1\">floating</gradient> inside'\n                )\n                group = VGroup(text1, text2, text3, text4, text5, text6, text7).arrange(DOWN)\n                self.add(group)\n\n    .. manim:: UnderlineExample\n        :save_last_frame:\n\n        class UnderlineExample(Scene):\n            def construct(self):\n                text1 = MarkupText(\n                    '<span underline=\"double\" underline_color=\"green\">bla</span>'\n                )\n                text2 = MarkupText(\n                    '<span underline=\"single\" underline_color=\"green\">xxx</span><gradient from=\"#ffff00\" to=\"RED\">aabb</gradient>y'\n                )\n                text3 = MarkupText(\n                    '<span underline=\"single\" underline_color=\"green\">xxx</span><gradient from=\"#ffff00\" to=\"RED\" offset=\"-1\">aabb</gradient>y'\n                )\n                text4 = MarkupText(\n                    '<span underline=\"double\" underline_color=\"green\">xxx</span><gradient from=\"#ffff00\" to=\"RED\">aabb</gradient>y'\n                )\n                text5 = MarkupText(\n                    '<span underline=\"double\" underline_color=\"green\">xxx</span><gradient from=\"#ffff00\" to=\"RED\" offset=\"-2\">aabb</gradient>y'\n                )\n                group = VGroup(text1, text2, text3, text4, text5).arrange(DOWN)\n                self.add(group)\n\n    .. manim:: FontExample\n        :save_last_frame:\n\n        class FontExample(Scene):\n            def construct(self):\n                text1 = MarkupText(\n                    'all in sans <span font_family=\"serif\">except this</span>', font=\"sans\"\n                )\n                text2 = MarkupText(\n                    '<span font_family=\"serif\">mixing</span> <span font_family=\"sans\">fonts</span> <span font_family=\"monospace\">is ugly</span>'\n                )\n                text3 = MarkupText(\"special char > or &gt;\")\n                text4 = MarkupText(\"special char &lt; and &amp;\")\n                group = VGroup(text1, text2, text3, text4).arrange(DOWN)\n                self.add(group)\n\n    .. manim:: NewlineExample\n        :save_last_frame:\n\n        class NewlineExample(Scene):\n            def construct(self):\n                text = MarkupText('foooo<span foreground=\"red\">oo\\nbaa</span>aar')\n                self.add(text)\n\n    .. manim:: NoLigaturesExample\n        :save_last_frame:\n\n        class NoLigaturesExample(Scene):\n            def construct(self):\n                text1 = MarkupText('fl<gradient from=\"RED\" to=\"GREEN\">oat</gradient>ing')\n                text2 = MarkupText('fl<gradient from=\"RED\" to=\"GREEN\">oat</gradient>ing', disable_ligatures=True)\n                group = VGroup(text1, text2).arrange(DOWN)\n                self.add(group)\n\n\n    As :class:`MarkupText` uses Pango to render text, rendering non-English\n    characters is easily possible:\n\n    .. manim:: MultiLanguage\n        :save_last_frame:\n\n        class MultiLanguage(Scene):\n            def construct(self):\n                morning = MarkupText(\"\u0bb5\u0ba3\u0b95\u0bcd\u0b95\u0bae\u0bcd\", font=\"sans-serif\")\n                japanese = MarkupText(\n                    '<span fgcolor=\"blue\">\u65e5\u672c</span>\u3078\u3088\u3046\u3053\u305d'\n                )  # works as in ``Text``.\n                mess = MarkupText(\"Multi-Language\", weight=BOLD)\n                russ = MarkupText(\"\u0417\u0434\u0440\u0430\u0432\u0441\u0442\u0432\u0443\u0439\u0442\u0435 \u092e\u0938 \u0928\u092e \u092e \", font=\"sans-serif\")\n                hin = MarkupText(\"\u0928\u092e\u0938\u094d\u0924\u0947\", font=\"sans-serif\")\n                chinese = MarkupText(\"\u81c2\u733f\u300c\u9edb\u6bd4\u300d\u5e36\u8457\u5b69\u5b50\", font=\"sans-serif\")\n                group = VGroup(morning, japanese, mess, russ, hin, chinese).arrange(DOWN)\n                self.add(group)\n\n    You can justify the text by passing :attr:`justify` parameter.\n\n    .. manim:: JustifyText\n\n        class JustifyText(Scene):\n            def construct(self):\n                ipsum_text = (\n                    \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\"\n                    \"Praesent feugiat metus sit amet iaculis pulvinar. Nulla posuere \"\n                    \"quam a ex aliquam, eleifend consectetur tellus viverra. Aliquam \"\n                    \"fermentum interdum justo, nec rutrum elit pretium ac. Nam quis \"\n                    \"leo pulvinar, dignissim est at, venenatis nisi.\"\n                )\n                justified_text = MarkupText(ipsum_text, justify=True).scale(0.4)\n                not_justified_text = MarkupText(ipsum_text, justify=False).scale(0.4)\n                just_title = Title(\"Justified\")\n                njust_title = Title(\"Not Justified\")\n                self.add(njust_title, not_justified_text)\n                self.play(\n                    FadeOut(not_justified_text),\n                    FadeIn(justified_text),\n                    FadeOut(njust_title),\n                    FadeIn(just_title),\n                )\n                self.wait(1)\n\n    Tests\n    -----\n\n    Check that the creation of :class:`~.MarkupText` works::\n\n        >>> MarkupText('The horse does not eat cucumber salad.')\n        MarkupText('The horse does not eat cucumber salad.')\n\n    \"\"\"\n\n    @staticmethod\n    @functools.cache\n    def font_list() -> list[str]:\n        return manimpango.list_fonts()\n\n    def __init__(\n        self,\n        text: str,\n        fill_opacity: float = 1,\n        stroke_width: float = 0,\n        color: ParsableManimColor | None = None,\n        font_size: float = DEFAULT_FONT_SIZE,\n        line_spacing: int = -1,\n        font: str = \"\",\n        slant: str = NORMAL,\n        weight: str = NORMAL,\n        justify: bool = False,\n        gradient: tuple = None,\n        tab_width: int = 4,\n        height: int = None,\n        width: int = None,\n        should_center: bool = True,\n        disable_ligatures: bool = False,\n        warn_missing_font: bool = True,\n        **kwargs,\n    ) -> None:\n        self.text = text\n        self.line_spacing = line_spacing\n        if font and warn_missing_font:\n            fonts_list = Text.font_list()\n            # handle special case of sans/sans-serif\n            if font.lower() == \"sans-serif\":\n                font = \"sans\"\n            if font not in fonts_list:\n                # check if the capitalized version is in the supported fonts\n                if font.capitalize() in fonts_list:\n                    font = font.capitalize()\n                elif font.lower() in fonts_list:\n                    font = font.lower()\n                elif font.title() in fonts_list:\n                    font = font.title()\n                else:\n                    logger.warning(f\"Font {font} not in {fonts_list}.\")\n        self.font = font\n        self._font_size = float(font_size)\n        self.slant = slant\n        self.weight = weight\n        self.gradient = gradient\n        self.tab_width = tab_width\n        self.justify = justify\n\n        self.original_text = text\n        self.disable_ligatures = disable_ligatures\n        text_without_tabs = text\n        if \"\\t\" in text:\n            text_without_tabs = text.replace(\"\\t\", \" \" * self.tab_width)\n\n        colormap = self._extract_color_tags()\n        if len(colormap) > 0:\n            logger.warning(\n                'Using <color> tags in MarkupText is deprecated. Please use <span foreground=\"...\"> instead.',\n            )\n        gradientmap = self._extract_gradient_tags()\n        validate_error = MarkupUtils.validate(self.text)\n        if validate_error:\n            raise ValueError(validate_error)\n\n        if self.line_spacing == -1:\n            self.line_spacing = (\n                self._font_size + self._font_size * DEFAULT_LINE_SPACING_SCALE\n            )\n        else:\n            self.line_spacing = self._font_size + self._font_size * self.line_spacing\n\n        color: ManimColor = ManimColor(color) if color else VMobject().color\n        file_name = self._text2svg(color)\n\n        PangoUtils.remove_last_M(file_name)\n        super().__init__(\n            file_name,\n            fill_opacity=fill_opacity,\n            stroke_width=stroke_width,\n            height=height,\n            width=width,\n            should_center=should_center,\n            **kwargs,\n        )\n\n        self.chars = self.get_group_class()(*self.submobjects)\n        self.text = text_without_tabs.replace(\" \", \"\").replace(\"\\n\", \"\")\n\n        nppc = self.n_points_per_curve\n        for each in self:\n            if len(each.points) == 0:\n                continue\n            points = each.points\n            curve_start = points[0]\n            assert len(curve_start) == self.dim, curve_start\n            # Some of the glyphs in this text might not be closed,\n            # so we close them by identifying when one curve ends\n            # but it is not where the next curve starts.\n            # It is more efficient to temporarily create a list\n            # of points and add them one at a time, then turn them\n            # into a numpy array at the end, rather than creating\n            # new numpy arrays every time a point or fixing line\n            # is added (which is O(n^2) for numpy arrays).\n            closed_curve_points = []\n            # OpenGL has points be part of quadratic Bezier curves;\n            # Cairo uses cubic Bezier curves.\n            if nppc == 3:  # RendererType.OPENGL\n\n                def add_line_to(end):\n                    nonlocal closed_curve_points\n                    start = closed_curve_points[-1]\n                    closed_curve_points += [\n                        start,\n                        (start + end) / 2,\n                        end,\n                    ]\n\n            else:  # RendererType.CAIRO\n\n                def add_line_to(end):\n                    nonlocal closed_curve_points\n                    start = closed_curve_points[-1]\n                    closed_curve_points += [\n                        start,\n                        (start + start + end) / 3,\n                        (start + end + end) / 3,\n                        end,\n                    ]\n\n            for index, point in enumerate(points):\n                closed_curve_points.append(point)\n                if (\n                    index != len(points) - 1\n                    and (index + 1) % nppc == 0\n                    and any(point != points[index + 1])\n                ):\n                    # Add straight line from last point on this curve to the\n                    # start point on the next curve.\n                    add_line_to(curve_start)\n                    curve_start = points[index + 1]\n            # Make sure last curve is closed\n            add_line_to(curve_start)\n            each.points = np.array(closed_curve_points, ndmin=2)\n\n        if self.gradient:\n            self.set_color_by_gradient(*self.gradient)\n        for col in colormap:\n            self.chars[\n                col[\"start\"] - col[\"start_offset\"] : col[\"end\"]\n                - col[\"start_offset\"]\n                - col[\"end_offset\"]\n            ].set_color(self._parse_color(col[\"color\"]))\n        for grad in gradientmap:\n            self.chars[\n                grad[\"start\"] - grad[\"start_offset\"] : grad[\"end\"]\n                - grad[\"start_offset\"]\n                - grad[\"end_offset\"]\n            ].set_color_by_gradient(\n                *(self._parse_color(grad[\"from\"]), self._parse_color(grad[\"to\"]))\n            )\n        # anti-aliasing\n        if height is None and width is None:\n            self.scale(TEXT_MOB_SCALE_FACTOR)\n\n        self.initial_height = self.height\n\n    @property\n    def font_size(self):\n        return (\n            self.height\n            / self.initial_height\n            / TEXT_MOB_SCALE_FACTOR\n            * 2.4\n            * self._font_size\n            / DEFAULT_FONT_SIZE\n        )\n\n    @font_size.setter\n    def font_size(self, font_val):\n        # TODO: use pango's font size scaling.\n        if font_val <= 0:\n            raise ValueError(\"font_size must be greater than 0.\")\n        else:\n            self.scale(font_val / self.font_size)\n\n    def _text2hash(self, color: ParsableManimColor):\n        \"\"\"Generates ``sha256`` hash for file name.\"\"\"\n        settings = (\n            \"MARKUPPANGO\"\n            + self.font\n            + self.slant\n            + self.weight\n            + ManimColor(color).to_hex().lower()\n        )  # to differentiate from classical Pango Text\n        settings += str(self.line_spacing) + str(self._font_size)\n        settings += str(self.disable_ligatures)\n        settings += str(self.justify)\n        id_str = self.text + settings\n        hasher = hashlib.sha256()\n        hasher.update(id_str.encode())\n        return hasher.hexdigest()[:16]\n\n    def _text2svg(self, color: ParsableManimColor | None):\n        \"\"\"Convert the text to SVG using Pango.\"\"\"\n        color = ManimColor(color)\n        size = self._font_size\n        line_spacing = self.line_spacing\n        size /= TEXT2SVG_ADJUSTMENT_FACTOR\n        line_spacing /= TEXT2SVG_ADJUSTMENT_FACTOR\n\n        dir_name = config.get_dir(\"text_dir\")\n        if not dir_name.is_dir():\n            dir_name.mkdir(parents=True)\n        hash_name = self._text2hash(color)\n        file_name = dir_name / (hash_name + \".svg\")\n\n        if file_name.exists():\n            svg_file = str(file_name.resolve())\n        else:\n            final_text = (\n                f'<span foreground=\"{color.to_hex()}\">{self.text}</span>'\n                if color is not None\n                else self.text\n            )\n            logger.debug(f\"Setting Text {self.text}\")\n            svg_file = MarkupUtils.text2svg(\n                final_text,\n                self.font,\n                self.slant,\n                self.weight,\n                size,\n                line_spacing,\n                self.disable_ligatures,\n                str(file_name.resolve()),\n                START_X,\n                START_Y,\n                600,  # width\n                400,  # height\n                justify=self.justify,\n                pango_width=500,\n            )\n        return svg_file\n\n    def _count_real_chars(self, s):\n        \"\"\"Counts characters that will be displayed.\n\n        This is needed for partial coloring or gradients, because space\n        counts to the text's `len`, but has no corresponding character.\n        \"\"\"\n        count = 0\n        level = 0\n        # temporarily replace HTML entities by single char\n        s = re.sub(\"&[^;]+;\", \"x\", s)\n        for c in s:\n            if c == \"<\":\n                level += 1\n            if c == \">\" and level > 0:\n                level -= 1\n            elif c != \" \" and c != \"\\t\" and level == 0:\n                count += 1\n        return count\n\n    def _extract_gradient_tags(self):\n        \"\"\"Used to determine which parts (if any) of the string should be formatted\n        with a gradient.\n\n        Removes the ``<gradient>`` tag, as it is not part of Pango's markup and would cause an error.\n        \"\"\"\n        tags = re.finditer(\n            r'<gradient\\s+from=\"([^\"]+)\"\\s+to=\"([^\"]+)\"(\\s+offset=\"([^\"]+)\")?>(.+?)</gradient>',\n            self.original_text,\n            re.S,\n        )\n        gradientmap = []\n        for tag in tags:\n            start = self._count_real_chars(self.original_text[: tag.start(0)])\n            end = start + self._count_real_chars(tag.group(5))\n            offsets = tag.group(4).split(\",\") if tag.group(4) else [0]\n            start_offset = int(offsets[0]) if offsets[0] else 0\n            end_offset = int(offsets[1]) if len(offsets) == 2 and offsets[1] else 0\n\n            gradientmap.append(\n                {\n                    \"start\": start,\n                    \"end\": end,\n                    \"from\": tag.group(1),\n                    \"to\": tag.group(2),\n                    \"start_offset\": start_offset,\n                    \"end_offset\": end_offset,\n                },\n            )\n        self.text = re.sub(\n            \"<gradient[^>]+>(.+?)</gradient>\", r\"\\1\", self.text, count=0, flags=re.S\n        )\n        return gradientmap\n\n    def _parse_color(self, col):\n        \"\"\"Parse color given in ``<color>`` or ``<gradient>`` tags.\"\"\"\n        if re.match(\"#[0-9a-f]{6}\", col):\n            return col\n        else:\n            return ManimColor(col).to_hex()\n\n    def _extract_color_tags(self):\n        \"\"\"Used to determine which parts (if any) of the string should be formatted\n        with a custom color.\n\n        Removes the ``<color>`` tag, as it is not part of Pango's markup and would cause an error.\n\n        Note: Using the ``<color>`` tags is deprecated. As soon as the legacy syntax is gone, this function\n        will be removed.\n        \"\"\"\n        tags = re.finditer(\n            r'<color\\s+col=\"([^\"]+)\"(\\s+offset=\"([^\"]+)\")?>(.+?)</color>',\n            self.original_text,\n            re.S,\n        )\n\n        colormap = []\n        for tag in tags:\n            start = self._count_real_chars(self.original_text[: tag.start(0)])\n            end = start + self._count_real_chars(tag.group(4))\n            offsets = tag.group(3).split(\",\") if tag.group(3) else [0]\n            start_offset = int(offsets[0]) if offsets[0] else 0\n            end_offset = int(offsets[1]) if len(offsets) == 2 and offsets[1] else 0\n\n            colormap.append(\n                {\n                    \"start\": start,\n                    \"end\": end,\n                    \"color\": tag.group(1),\n                    \"start_offset\": start_offset,\n                    \"end_offset\": end_offset,\n                },\n            )\n        self.text = re.sub(\n            \"<color[^>]+>(.+?)</color>\", r\"\\1\", self.text, count=0, flags=re.S\n        )\n        return colormap\n\n    def __repr__(self):\n        return f\"MarkupText({repr(self.original_text)})\""}, {"name": "match_interpolate", "code": "def match_interpolate(\n    new_start: float,\n    new_end: float,\n    old_start: float,\n    old_end: float,\n    old_value: float | Point3D,\n) -> float | Point3D:\n    \"\"\"Interpolate a value from an old range to a new range.\n\n    Parameters\n    ----------\n    new_start\n        The start of the new range.\n    new_end\n        The end of the new range.\n    old_start\n        The start of the old range.\n    old_end\n        The end of the old range.\n    old_value\n        The value within the old range whose corresponding\n        value in the new range (with the same alpha value)\n        is desired.\n\n    Returns\n    -------\n        The interpolated value within the new range.\n\n    Examples\n    --------\n    >>> match_interpolate(0, 100, 10, 20, 15)\n    np.float64(50.0)\n    \"\"\"\n    old_alpha = inverse_interpolate(old_start, old_end, old_value)\n    return interpolate(\n        new_start,\n        new_end,\n        old_alpha,\n    )"}, {"name": "MathTable", "code": "class MathTable(Table):\n    \"\"\"A specialized :class:`~.Table` mobject for use with LaTeX.\n\n    Examples\n    --------\n\n    .. manim:: MathTableExample\n        :save_last_frame:\n\n        class MathTableExample(Scene):\n            def construct(self):\n                t0 = MathTable(\n                    [[\"+\", 0, 5, 10],\n                    [0, 0, 5, 10],\n                    [2, 2, 7, 12],\n                    [4, 4, 9, 14]],\n                    include_outer_lines=True)\n                self.add(t0)\n    \"\"\"\n\n    def __init__(\n        self,\n        table: Iterable[Iterable[float | str]],\n        element_to_mobject: Callable[[float | str], VMobject] = MathTex,\n        **kwargs,\n    ):\n        \"\"\"\n        Special case of :class:`~.Table` with `element_to_mobject` set to :class:`~.MathTex`.\n        Every entry in `table` is set in a Latex `align` environment.\n\n        Parameters\n        ----------\n        table\n            A 2d array or list of lists. Content of the table have to be valid input\n            for :class:`~.MathTex`.\n        element_to_mobject\n            The :class:`~.Mobject` class applied to the table entries. Set as :class:`~.MathTex`.\n        kwargs\n            Additional arguments to be passed to :class:`~.Table`.\n        \"\"\"\n        super().__init__(\n            table,\n            element_to_mobject=element_to_mobject,\n            **kwargs,\n        )"}, {"name": "MathTex", "code": "class MathTex(SingleStringMathTex):\n    r\"\"\"A string compiled with LaTeX in math mode.\n\n    Examples\n    --------\n    .. manim:: Formula\n        :save_last_frame:\n\n        class Formula(Scene):\n            def construct(self):\n                t = MathTex(r\"\\int_a^b f'(x) dx = f(b)- f(a)\")\n                self.add(t)\n\n    Tests\n    -----\n    Check that creating a :class:`~.MathTex` works::\n\n        >>> MathTex('a^2 + b^2 = c^2') # doctest: +SKIP\n        MathTex('a^2 + b^2 = c^2')\n\n    Check that double brace group splitting works correctly::\n\n        >>> t1 = MathTex('{{ a }} + {{ b }} = {{ c }}') # doctest: +SKIP\n        >>> len(t1.submobjects) # doctest: +SKIP\n        5\n        >>> t2 = MathTex(r\"\\frac{1}{a+b\\sqrt{2}}\") # doctest: +SKIP\n        >>> len(t2.submobjects) # doctest: +SKIP\n        1\n\n    \"\"\"\n\n    def __init__(\n        self,\n        *tex_strings,\n        arg_separator: str = \" \",\n        substrings_to_isolate: Iterable[str] | None = None,\n        tex_to_color_map: dict[str, ManimColor] = None,\n        tex_environment: str = \"align*\",\n        **kwargs,\n    ):\n        self.tex_template = kwargs.pop(\"tex_template\", config[\"tex_template\"])\n        self.arg_separator = arg_separator\n        self.substrings_to_isolate = (\n            [] if substrings_to_isolate is None else substrings_to_isolate\n        )\n        self.tex_to_color_map = tex_to_color_map\n        if self.tex_to_color_map is None:\n            self.tex_to_color_map = {}\n        self.tex_environment = tex_environment\n        self.brace_notation_split_occurred = False\n        self.tex_strings = self._break_up_tex_strings(tex_strings)\n        try:\n            super().__init__(\n                self.arg_separator.join(self.tex_strings),\n                tex_environment=self.tex_environment,\n                tex_template=self.tex_template,\n                **kwargs,\n            )\n            self._break_up_by_substrings()\n        except ValueError as compilation_error:\n            if self.brace_notation_split_occurred:\n                logger.error(\n                    dedent(\n                        \"\"\"\\\n                        A group of double braces, {{ ... }}, was detected in\n                        your string. Manim splits TeX strings at the double\n                        braces, which might have caused the current\n                        compilation error. If you didn't use the double brace\n                        split intentionally, add spaces between the braces to\n                        avoid the automatic splitting: {{ ... }} --> { { ... } }.\n                        \"\"\",\n                    ),\n                )\n            raise compilation_error\n        self.set_color_by_tex_to_color_map(self.tex_to_color_map)\n\n        if self.organize_left_to_right:\n            self._organize_submobjects_left_to_right()\n\n    def _break_up_tex_strings(self, tex_strings):\n        # Separate out anything surrounded in double braces\n        pre_split_length = len(tex_strings)\n        tex_strings = [re.split(\"{{(.*?)}}\", str(t)) for t in tex_strings]\n        tex_strings = sum(tex_strings, [])\n        if len(tex_strings) > pre_split_length:\n            self.brace_notation_split_occurred = True\n\n        # Separate out any strings specified in the isolate\n        # or tex_to_color_map lists.\n        patterns = []\n        patterns.extend(\n            [\n                f\"({re.escape(ss)})\"\n                for ss in it.chain(\n                    self.substrings_to_isolate,\n                    self.tex_to_color_map.keys(),\n                )\n            ],\n        )\n        pattern = \"|\".join(patterns)\n        if pattern:\n            pieces = []\n            for s in tex_strings:\n                pieces.extend(re.split(pattern, s))\n        else:\n            pieces = tex_strings\n        return [p for p in pieces if p]\n\n    def _break_up_by_substrings(self):\n        \"\"\"\n        Reorganize existing submobjects one layer\n        deeper based on the structure of tex_strings (as a list\n        of tex_strings)\n        \"\"\"\n        new_submobjects = []\n        curr_index = 0\n        for tex_string in self.tex_strings:\n            sub_tex_mob = SingleStringMathTex(\n                tex_string,\n                tex_environment=self.tex_environment,\n                tex_template=self.tex_template,\n            )\n            num_submobs = len(sub_tex_mob.submobjects)\n            new_index = (\n                curr_index + num_submobs + len(\"\".join(self.arg_separator.split()))\n            )\n            if num_submobs == 0:\n                last_submob_index = min(curr_index, len(self.submobjects) - 1)\n                sub_tex_mob.move_to(self.submobjects[last_submob_index], RIGHT)\n            else:\n                sub_tex_mob.submobjects = self.submobjects[curr_index:new_index]\n            new_submobjects.append(sub_tex_mob)\n            curr_index = new_index\n        self.submobjects = new_submobjects\n        return self\n\n    def get_parts_by_tex(self, tex, substring=True, case_sensitive=True):\n        def test(tex1, tex2):\n            if not case_sensitive:\n                tex1 = tex1.lower()\n                tex2 = tex2.lower()\n            if substring:\n                return tex1 in tex2\n            else:\n                return tex1 == tex2\n\n        return VGroup(*(m for m in self.submobjects if test(tex, m.get_tex_string())))\n\n    def get_part_by_tex(self, tex, **kwargs):\n        all_parts = self.get_parts_by_tex(tex, **kwargs)\n        return all_parts[0] if all_parts else None\n\n    def set_color_by_tex(self, tex, color, **kwargs):\n        parts_to_color = self.get_parts_by_tex(tex, **kwargs)\n        for part in parts_to_color:\n            part.set_color(color)\n        return self\n\n    def set_opacity_by_tex(\n        self, tex: str, opacity: float = 0.5, remaining_opacity: float = None, **kwargs\n    ):\n        \"\"\"\n        Sets the opacity of the tex specified. If 'remaining_opacity' is specified,\n        then the remaining tex will be set to that opacity.\n\n        Parameters\n        ----------\n        tex\n            The tex to set the opacity of.\n        opacity\n            Default 0.5. The opacity to set the tex to\n        remaining_opacity\n            Default None. The opacity to set the remaining tex to.\n            If None, then the remaining tex will not be changed\n        \"\"\"\n        if remaining_opacity is not None:\n            self.set_opacity(opacity=remaining_opacity)\n        for part in self.get_parts_by_tex(tex):\n            part.set_opacity(opacity)\n        return self\n\n    def set_color_by_tex_to_color_map(self, texs_to_color_map, **kwargs):\n        for texs, color in list(texs_to_color_map.items()):\n            try:\n                # If the given key behaves like tex_strings\n                texs + \"\"\n                self.set_color_by_tex(texs, color, **kwargs)\n            except TypeError:\n                # If the given key is a tuple\n                for tex in texs:\n                    self.set_color_by_tex(tex, color, **kwargs)\n        return self\n\n    def index_of_part(self, part):\n        split_self = self.split()\n        if part not in split_self:\n            raise ValueError(\"Trying to get index of part not in MathTex\")\n        return split_self.index(part)\n\n    def index_of_part_by_tex(self, tex, **kwargs):\n        part = self.get_part_by_tex(tex, **kwargs)\n        return self.index_of_part(part)\n\n    def sort_alphabetically(self):\n        self.submobjects.sort(key=lambda m: m.get_tex_string())"}, {"name": "Matrix", "code": "class Matrix(VMobject, metaclass=ConvertToOpenGL):\n    r\"\"\"A mobject that displays a matrix on the screen.\n\n    Parameters\n    ----------\n    matrix\n        A numpy 2d array or list of lists.\n    v_buff\n        Vertical distance between elements, by default 0.8.\n    h_buff\n        Horizontal distance between elements, by default 1.3.\n    bracket_h_buff\n        Distance of the brackets from the matrix, by default ``MED_SMALL_BUFF``.\n    bracket_v_buff\n        Height of the brackets, by default ``MED_SMALL_BUFF``.\n    add_background_rectangles_to_entries\n        ``True`` if should add backgraound rectangles to entries, by default ``False``.\n    include_background_rectangle\n        ``True`` if should include background rectangle, by default ``False``.\n    element_to_mobject\n        The mobject class used to construct the elements, by default :class:`~.MathTex`.\n    element_to_mobject_config\n        Additional arguments to be passed to the constructor in ``element_to_mobject``,\n        by default ``{}``.\n    element_alignment_corner\n        The corner to which elements are aligned, by default ``DR``.\n    left_bracket\n        The left bracket type, by default ``\"[\"``.\n    right_bracket\n        The right bracket type, by default ``\"]\"``.\n    stretch_brackets\n        ``True`` if should stretch the brackets to fit the height of matrix contents, by default ``True``.\n    bracket_config\n        Additional arguments to be passed to :class:`~.MathTex` when constructing\n        the brackets.\n\n    Examples\n    --------\n    The first example shows a variety of uses of this module while the second example\n    exlpains the use of the options `add_background_rectangles_to_entries` and\n    `include_background_rectangle`.\n\n    .. manim:: MatrixExamples\n        :save_last_frame:\n\n        class MatrixExamples(Scene):\n            def construct(self):\n                m0 = Matrix([[2, r\"\\pi\"], [-1, 1]])\n                m1 = Matrix([[2, 0, 4], [-1, 1, 5]],\n                    v_buff=1.3,\n                    h_buff=0.8,\n                    bracket_h_buff=SMALL_BUFF,\n                    bracket_v_buff=SMALL_BUFF,\n                    left_bracket=r\"\\{\",\n                    right_bracket=r\"\\}\")\n                m1.add(SurroundingRectangle(m1.get_columns()[1]))\n                m2 = Matrix([[2, 1], [-1, 3]],\n                    element_alignment_corner=UL,\n                    left_bracket=\"(\",\n                    right_bracket=\")\")\n                m3 = Matrix([[2, 1], [-1, 3]],\n                    left_bracket=r\"\\langle\",\n                    right_bracket=r\"\\rangle\")\n                m4 = Matrix([[2, 1], [-1, 3]],\n                ).set_column_colors(RED, GREEN)\n                m5 = Matrix([[2, 1], [-1, 3]],\n                ).set_row_colors(RED, GREEN)\n                g = Group(\n                    m0,m1,m2,m3,m4,m5\n                ).arrange_in_grid(buff=2)\n                self.add(g)\n\n    .. manim:: BackgroundRectanglesExample\n        :save_last_frame:\n\n        class BackgroundRectanglesExample(Scene):\n            def construct(self):\n                background= Rectangle().scale(3.2)\n                background.set_fill(opacity=.5)\n                background.set_color([TEAL, RED, YELLOW])\n                self.add(background)\n                m0 = Matrix([[12, -30], [-1, 15]],\n                    add_background_rectangles_to_entries=True)\n                m1 = Matrix([[2, 0], [-1, 1]],\n                    include_background_rectangle=True)\n                m2 = Matrix([[12, -30], [-1, 15]])\n                g = Group(m0, m1, m2).arrange(buff=2)\n                self.add(g)\n    \"\"\"\n\n    def __init__(\n        self,\n        matrix: Iterable,\n        v_buff: float = 0.8,\n        h_buff: float = 1.3,\n        bracket_h_buff: float = MED_SMALL_BUFF,\n        bracket_v_buff: float = MED_SMALL_BUFF,\n        add_background_rectangles_to_entries: bool = False,\n        include_background_rectangle: bool = False,\n        element_to_mobject: type[MathTex] = MathTex,\n        element_to_mobject_config: dict = {},\n        element_alignment_corner: Sequence[float] = DR,\n        left_bracket: str = \"[\",\n        right_bracket: str = \"]\",\n        stretch_brackets: bool = True,\n        bracket_config: dict = {},\n        **kwargs,\n    ):\n        self.v_buff = v_buff\n        self.h_buff = h_buff\n        self.bracket_h_buff = bracket_h_buff\n        self.bracket_v_buff = bracket_v_buff\n        self.add_background_rectangles_to_entries = add_background_rectangles_to_entries\n        self.include_background_rectangle = include_background_rectangle\n        self.element_to_mobject = element_to_mobject\n        self.element_to_mobject_config = element_to_mobject_config\n        self.element_alignment_corner = element_alignment_corner\n        self.left_bracket = left_bracket\n        self.right_bracket = right_bracket\n        self.stretch_brackets = stretch_brackets\n        super().__init__(**kwargs)\n        mob_matrix = self._matrix_to_mob_matrix(matrix)\n        self._organize_mob_matrix(mob_matrix)\n        self.elements = VGroup(*it.chain(*mob_matrix))\n        self.add(self.elements)\n        self._add_brackets(self.left_bracket, self.right_bracket, **bracket_config)\n        self.center()\n        self.mob_matrix = mob_matrix\n        if self.add_background_rectangles_to_entries:\n            for mob in self.elements:\n                mob.add_background_rectangle()\n        if self.include_background_rectangle:\n            self.add_background_rectangle()\n\n    def _matrix_to_mob_matrix(self, matrix):\n        return [\n            [\n                self.element_to_mobject(item, **self.element_to_mobject_config)\n                for item in row\n            ]\n            for row in matrix\n        ]\n\n    def _organize_mob_matrix(self, matrix):\n        for i, row in enumerate(matrix):\n            for j, _ in enumerate(row):\n                mob = matrix[i][j]\n                mob.move_to(\n                    i * self.v_buff * DOWN + j * self.h_buff * RIGHT,\n                    self.element_alignment_corner,\n                )\n        return self\n\n    def _add_brackets(self, left: str = \"[\", right: str = \"]\", **kwargs):\n        \"\"\"Adds the brackets to the Matrix mobject.\n\n        See Latex document for various bracket types.\n\n        Parameters\n        ----------\n        left\n            the left bracket, by default \"[\"\n        right\n            the right bracket, by default \"]\"\n\n        Returns\n        -------\n        :class:`Matrix`\n            The current matrix object (self).\n        \"\"\"\n        # Height per row of LaTeX array with default settings\n        BRACKET_HEIGHT = 0.5977\n\n        n = int((self.height) / BRACKET_HEIGHT) + 1\n        empty_tex_array = \"\".join(\n            [\n                r\"\\begin{array}{c}\",\n                *n * [r\"\\quad \\\\\"],\n                r\"\\end{array}\",\n            ]\n        )\n        tex_left = \"\".join(\n            [\n                r\"\\left\" + left,\n                empty_tex_array,\n                r\"\\right.\",\n            ]\n        )\n        tex_right = \"\".join(\n            [\n                r\"\\left.\",\n                empty_tex_array,\n                r\"\\right\" + right,\n            ]\n        )\n        l_bracket = MathTex(tex_left, **kwargs)\n        r_bracket = MathTex(tex_right, **kwargs)\n\n        bracket_pair = VGroup(l_bracket, r_bracket)\n        if self.stretch_brackets:\n            bracket_pair.stretch_to_fit_height(self.height + 2 * self.bracket_v_buff)\n        l_bracket.next_to(self, LEFT, self.bracket_h_buff)\n        r_bracket.next_to(self, RIGHT, self.bracket_h_buff)\n        self.brackets = bracket_pair\n        self.add(l_bracket, r_bracket)\n        return self\n\n    def get_columns(self):\n        r\"\"\"Return columns of the matrix as VGroups.\n\n        Returns\n        --------\n        List[:class:`~.VGroup`]\n            Each VGroup contains a column of the matrix.\n\n        Examples\n        --------\n\n        .. manim:: GetColumnsExample\n            :save_last_frame:\n\n            class GetColumnsExample(Scene):\n                def construct(self):\n                    m0 = Matrix([[r\"\\pi\", 3], [1, 5]])\n                    m0.add(SurroundingRectangle(m0.get_columns()[1]))\n                    self.add(m0)\n        \"\"\"\n        return VGroup(\n            *(\n                VGroup(*(row[i] for row in self.mob_matrix))\n                for i in range(len(self.mob_matrix[0]))\n            )\n        )\n\n    def set_column_colors(self, *colors: str):\n        r\"\"\"Set individual colors for each columns of the matrix.\n\n        Parameters\n        ----------\n        colors\n            The list of colors; each color specified corresponds to a column.\n\n        Returns\n        -------\n        :class:`Matrix`\n            The current matrix object (self).\n\n        Examples\n        --------\n\n        .. manim:: SetColumnColorsExample\n            :save_last_frame:\n\n            class SetColumnColorsExample(Scene):\n                def construct(self):\n                    m0 = Matrix([[\"\\\\pi\", 1], [-1, 3]],\n                    ).set_column_colors([RED,BLUE], GREEN)\n                    self.add(m0)\n        \"\"\"\n        columns = self.get_columns()\n        for color, column in zip(colors, columns):\n            column.set_color(color)\n        return self\n\n    def get_rows(self):\n        r\"\"\"Return rows of the matrix as VGroups.\n\n        Returns\n        --------\n        List[:class:`~.VGroup`]\n            Each VGroup contains a row of the matrix.\n\n        Examples\n        --------\n\n        .. manim:: GetRowsExample\n            :save_last_frame:\n\n            class GetRowsExample(Scene):\n                def construct(self):\n                    m0 = Matrix([[\"\\\\pi\", 3], [1, 5]])\n                    m0.add(SurroundingRectangle(m0.get_rows()[1]))\n                    self.add(m0)\n        \"\"\"\n        return VGroup(*(VGroup(*row) for row in self.mob_matrix))\n\n    def set_row_colors(self, *colors: str):\n        r\"\"\"Set individual colors for each row of the matrix.\n\n        Parameters\n        ----------\n        colors\n            The list of colors; each color specified corresponds to a row.\n\n        Returns\n        -------\n        :class:`Matrix`\n            The current matrix object (self).\n\n        Examples\n        --------\n\n        .. manim:: SetRowColorsExample\n            :save_last_frame:\n\n            class SetRowColorsExample(Scene):\n                def construct(self):\n                    m0 = Matrix([[\"\\\\pi\", 1], [-1, 3]],\n                    ).set_row_colors([RED,BLUE], GREEN)\n                    self.add(m0)\n        \"\"\"\n        rows = self.get_rows()\n        for color, row in zip(colors, rows):\n            row.set_color(color)\n        return self\n\n    def add_background_to_entries(self):\n        \"\"\"Add a black background rectangle to the matrix,\n        see above for an example.\n\n        Returns\n        -------\n        :class:`Matrix`\n            The current matrix object (self).\n        \"\"\"\n        for mob in self.get_entries():\n            mob.add_background_rectangle()\n        return self\n\n    def get_mob_matrix(self):\n        \"\"\"Return the underlying mob matrix mobjects.\n\n        Returns\n        --------\n        List[:class:`~.VGroup`]\n            Each VGroup contains a row of the matrix.\n        \"\"\"\n        return self.mob_matrix\n\n    def get_entries(self):\n        \"\"\"Return the individual entries of the matrix.\n\n        Returns\n        --------\n        :class:`~.VGroup`\n            VGroup containing entries of the matrix.\n\n        Examples\n        --------\n\n        .. manim:: GetEntriesExample\n            :save_last_frame:\n\n            class GetEntriesExample(Scene):\n                def construct(self):\n                    m0 = Matrix([[2, 3], [1, 5]])\n                    ent = m0.get_entries()\n                    colors = [BLUE, GREEN, YELLOW, RED]\n                    for k in range(len(colors)):\n                        ent[k].set_color(colors[k])\n                    self.add(m0)\n        \"\"\"\n        return self.elements\n\n    def get_brackets(self):\n        r\"\"\"Return the bracket mobjects.\n\n        Returns\n        --------\n        List[:class:`~.VGroup`]\n            Each VGroup contains a bracket\n\n        Examples\n        --------\n\n        .. manim:: GetBracketsExample\n            :save_last_frame:\n\n            class GetBracketsExample(Scene):\n                def construct(self):\n                    m0 = Matrix([[\"\\\\pi\", 3], [1, 5]])\n                    bra = m0.get_brackets()\n                    colors = [BLUE, GREEN]\n                    for k in range(len(colors)):\n                        bra[k].set_color(colors[k])\n                    self.add(m0)\n        \"\"\"\n        return self.brackets"}, {"name": "matrix_to_mobject", "code": "def matrix_to_mobject(matrix):\n    return MathTex(matrix_to_tex_string(matrix))"}, {"name": "matrix_to_shader_input", "code": "def matrix_to_shader_input(matrix: MatrixMN) -> FlattenedMatrix4x4:\n    return tuple(matrix.T.ravel())"}, {"name": "matrix_to_tex_string", "code": "def matrix_to_tex_string(matrix):\n    matrix = np.array(matrix).astype(\"str\")\n    if matrix.ndim == 1:\n        matrix = matrix.reshape((matrix.size, 1))\n    n_rows, n_cols = matrix.shape\n    prefix = \"\\\\left[ \\\\begin{array}{%s}\" % (\"c\" * n_cols)\n    suffix = \"\\\\end{array} \\\\right]\"\n    rows = [\" & \".join(row) for row in matrix]\n    return prefix + \" \\\\\\\\ \".join(rows) + suffix"}, {"name": "merge_dicts_recursively", "code": "def merge_dicts_recursively(*dicts: dict[Any, Any]) -> dict[Any, Any]:\n    \"\"\"\n    Creates a dict whose keyset is the union of all the\n    input dictionaries.  The value for each key is based\n    on the first dict in the list with that key.\n\n    dicts later in the list have higher priority\n\n    When values are dictionaries, it is applied recursively\n    \"\"\"\n    result: dict = {}\n    all_items = it.chain(*(d.items() for d in dicts))\n    for key, value in all_items:\n        if key in result and isinstance(result[key], dict) and isinstance(value, dict):\n            result[key] = merge_dicts_recursively(result[key], value)\n        else:\n            result[key] = value\n    return result"}, {"name": "Mesh", "code": "class Mesh(Object3D):\n    def __init__(\n        self,\n        shader=None,\n        attributes=None,\n        geometry=None,\n        material=None,\n        indices=None,\n        use_depth_test=True,\n        primitive=moderngl.TRIANGLES,\n    ):\n        super().__init__()\n        if shader is not None and attributes is not None:\n            self.shader = shader\n            self.attributes = attributes\n            self.indices = indices\n        elif geometry is not None and material is not None:\n            self.shader = material\n            self.attributes = geometry.attributes\n            self.indices = geometry.index\n        else:\n            raise Exception(\n                \"Mesh requires either attributes and a Shader or a Geometry and a \"\n                \"Material\",\n            )\n        self.use_depth_test = use_depth_test\n        self.primitive = primitive\n        self.skip_render = False\n        self.init_updaters()\n\n    def single_copy(self):\n        copy = Mesh(\n            attributes=self.attributes.copy(),\n            shader=self.shader,\n            indices=self.indices.copy() if self.indices is not None else None,\n            use_depth_test=self.use_depth_test,\n            primitive=self.primitive,\n        )\n        copy.skip_render = self.skip_render\n        copy.model_matrix = self.model_matrix.copy()\n        copy.normal_matrix = self.normal_matrix.copy()\n        # TODO: Copy updaters?\n        return copy\n\n    def set_uniforms(self, renderer):\n        self.shader.set_uniform(\n            \"u_model_matrix\",\n            opengl.matrix_to_shader_input(self.model_matrix),\n        )\n        self.shader.set_uniform(\"u_view_matrix\", renderer.camera.formatted_view_matrix)\n        self.shader.set_uniform(\n            \"u_projection_matrix\",\n            renderer.camera.projection_matrix,\n        )\n\n    def render(self):\n        if self.skip_render:\n            return\n\n        if self.use_depth_test:\n            self.shader.context.enable(moderngl.DEPTH_TEST)\n        else:\n            self.shader.context.disable(moderngl.DEPTH_TEST)\n\n        from moderngl import Attribute\n\n        shader_attributes = []\n        for k, v in self.shader.shader_program._members.items():\n            if isinstance(v, Attribute):\n                shader_attributes.append(k)\n        shader_attributes = filter_attributes(self.attributes, shader_attributes)\n\n        vertex_buffer_object = self.shader.context.buffer(shader_attributes.tobytes())\n        if self.indices is None:\n            index_buffer_object = None\n        else:\n            vert_index_data = self.indices.astype(\"i4\").tobytes()\n            if vert_index_data:\n                index_buffer_object = self.shader.context.buffer(vert_index_data)\n            else:\n                index_buffer_object = None\n        vertex_array_object = self.shader.context.simple_vertex_array(\n            self.shader.shader_program,\n            vertex_buffer_object,\n            *shader_attributes.dtype.names,\n            index_buffer=index_buffer_object,\n        )\n        vertex_array_object.render(self.primitive)\n        vertex_buffer_object.release()\n        vertex_array_object.release()\n        if index_buffer_object is not None:\n            index_buffer_object.release()"}, {"name": "mid", "code": "def mid(start: float | Point3D, end: float | Point3D) -> float | Point3D:\n    \"\"\"Returns the midpoint between two values.\n\n    Parameters\n    ----------\n    start\n        The first value\n    end\n        The second value\n\n    Returns\n    -------\n        The midpoint between the two values\n    \"\"\"\n    return (start + end) / 2.0"}, {"name": "midpoint", "code": "def midpoint(\n    point1: Sequence[float],\n    point2: Sequence[float],\n) -> float | np.ndarray:\n    \"\"\"Gets the midpoint of two points.\n\n    Parameters\n    ----------\n    point1\n        The first point.\n    point2\n        The second point.\n\n    Returns\n    -------\n    Union[float, np.ndarray]\n        The midpoint of the points\n    \"\"\"\n    return center_of_mass([point1, point2])"}, {"name": "Mobject", "code": "class Mobject:\n    \"\"\"Mathematical Object: base class for objects that can be displayed on screen.\n\n    There is a compatibility layer that allows for\n    getting and setting generic attributes with ``get_*``\n    and ``set_*`` methods. See :meth:`set` for more details.\n\n    Attributes\n    ----------\n    submobjects : List[:class:`Mobject`]\n        The contained objects.\n    points : :class:`numpy.ndarray`\n        The points of the objects.\n\n        .. seealso::\n\n            :class:`~.VMobject`\n\n    \"\"\"\n\n    animation_overrides = {}\n\n    @classmethod\n    def __init_subclass__(cls, **kwargs) -> None:\n        super().__init_subclass__(**kwargs)\n\n        cls.animation_overrides: dict[\n            type[Animation],\n            FunctionOverride,\n        ] = {}\n        cls._add_intrinsic_animation_overrides()\n        cls._original__init__ = cls.__init__\n\n    def __init__(\n        self,\n        color: ParsableManimColor | list[ParsableManimColor] = WHITE,\n        name: str | None = None,\n        dim: int = 3,\n        target=None,\n        z_index: float = 0,\n    ) -> None:\n        self.name = self.__class__.__name__ if name is None else name\n        self.dim = dim\n        self.target = target\n        self.z_index = z_index\n        self.point_hash = None\n        self.submobjects = []\n        self.updaters: list[Updater] = []\n        self.updating_suspended = False\n        self.color = ManimColor.parse(color)\n\n        self.reset_points()\n        self.generate_points()\n        self.init_colors()\n\n    def _assert_valid_submobjects(self, submobjects: Iterable[Mobject]) -> Self:\n        \"\"\"Check that all submobjects are actually instances of\n        :class:`Mobject`, and that none of them is ``self`` (a\n        :class:`Mobject` cannot contain itself).\n\n        This is an auxiliary function called when adding Mobjects to the\n        :attr:`submobjects` list.\n\n        This function is intended to be overridden by subclasses such as\n        :class:`VMobject`, which should assert that only other VMobjects\n        may be added into it.\n\n        Parameters\n        ----------\n        submobjects\n            The list containing values to validate.\n\n        Returns\n        -------\n        :class:`Mobject`\n            The Mobject itself.\n\n        Raises\n        ------\n        TypeError\n            If any of the values in `submobjects` is not a :class:`Mobject`.\n        ValueError\n            If there was an attempt to add a :class:`Mobject` as its own\n            submobject.\n        \"\"\"\n        return self._assert_valid_submobjects_internal(submobjects, Mobject)\n\n    def _assert_valid_submobjects_internal(\n        self, submobjects: list[Mobject], mob_class: type[Mobject]\n    ) -> Self:\n        for i, submob in enumerate(submobjects):\n            if not isinstance(submob, mob_class):\n                error_message = (\n                    f\"Only values of type {mob_class.__name__} can be added \"\n                    f\"as submobjects of {type(self).__name__}, but the value \"\n                    f\"{submob} (at index {i}) is of type \"\n                    f\"{type(submob).__name__}.\"\n                )\n                # Intended for subclasses such as VMobject, which\n                # cannot have regular Mobjects as submobjects\n                if isinstance(submob, Mobject):\n                    error_message += (\n                        \" You can try adding this value into a Group instead.\"\n                    )\n                raise TypeError(error_message)\n            if submob is self:\n                raise ValueError(\n                    f\"Cannot add {type(self).__name__} as a submobject of \"\n                    f\"itself (at index {i}).\"\n                )\n        return self\n\n    @classmethod\n    def animation_override_for(\n        cls,\n        animation_class: type[Animation],\n    ) -> FunctionOverride | None:\n        \"\"\"Returns the function defining a specific animation override for this class.\n\n        Parameters\n        ----------\n        animation_class\n            The animation class for which the override function should be returned.\n\n        Returns\n        -------\n        Optional[Callable[[Mobject, ...], Animation]]\n            The function returning the override animation or ``None`` if no such animation\n            override is defined.\n        \"\"\"\n        if animation_class in cls.animation_overrides:\n            return cls.animation_overrides[animation_class]\n\n        return None\n\n    @classmethod\n    def _add_intrinsic_animation_overrides(cls) -> None:\n        \"\"\"Initializes animation overrides marked with the :func:`~.override_animation`\n        decorator.\n        \"\"\"\n        for method_name in dir(cls):\n            # Ignore dunder methods\n            if method_name.startswith(\"__\"):\n                continue\n\n            method = getattr(cls, method_name)\n            if hasattr(method, \"_override_animation\"):\n                animation_class = method._override_animation\n                cls.add_animation_override(animation_class, method)\n\n    @classmethod\n    def add_animation_override(\n        cls,\n        animation_class: type[Animation],\n        override_func: FunctionOverride,\n    ) -> None:\n        \"\"\"Add an animation override.\n\n        This does not apply to subclasses.\n\n        Parameters\n        ----------\n        animation_class\n            The animation type to be overridden\n        override_func\n            The function returning an animation replacing the default animation. It gets\n            passed the parameters given to the animation constructor.\n\n        Raises\n        ------\n        MultiAnimationOverrideException\n            If the overridden animation was already overridden.\n        \"\"\"\n        if animation_class not in cls.animation_overrides:\n            cls.animation_overrides[animation_class] = override_func\n        else:\n            raise MultiAnimationOverrideException(\n                f\"The animation {animation_class.__name__} for \"\n                f\"{cls.__name__} is overridden by more than one method: \"\n                f\"{cls.animation_overrides[animation_class].__qualname__} and \"\n                f\"{override_func.__qualname__}.\",\n            )\n\n    @classmethod\n    def set_default(cls, **kwargs) -> None:\n        \"\"\"Sets the default values of keyword arguments.\n\n        If this method is called without any additional keyword\n        arguments, the original default values of the initialization\n        method of this class are restored.\n\n        Parameters\n        ----------\n\n        kwargs\n            Passing any keyword argument will update the default\n            values of the keyword arguments of the initialization\n            function of this class.\n\n        Examples\n        --------\n\n        ::\n\n            >>> from manim import Square, GREEN\n            >>> Square.set_default(color=GREEN, fill_opacity=0.25)\n            >>> s = Square(); s.color, s.fill_opacity\n            (ManimColor('#83C167'), 0.25)\n            >>> Square.set_default()\n            >>> s = Square(); s.color, s.fill_opacity\n            (ManimColor('#FFFFFF'), 0.0)\n\n        .. manim:: ChangedDefaultTextcolor\n            :save_last_frame:\n\n            config.background_color = WHITE\n\n            class ChangedDefaultTextcolor(Scene):\n                def construct(self):\n                    Text.set_default(color=BLACK)\n                    self.add(Text(\"Changing default values is easy!\"))\n\n                    # we revert the colour back to the default to prevent a bug in the docs.\n                    Text.set_default(color=WHITE)\n\n        \"\"\"\n        if kwargs:\n            cls.__init__ = partialmethod(cls.__init__, **kwargs)\n        else:\n            cls.__init__ = cls._original__init__\n\n    @property\n    def animate(self) -> _AnimationBuilder | Self:\n        \"\"\"Used to animate the application of any method of :code:`self`.\n\n        Any method called on :code:`animate` is converted to an animation of applying\n        that method on the mobject itself.\n\n        For example, :code:`square.set_fill(WHITE)` sets the fill color of a square,\n        while :code:`square.animate.set_fill(WHITE)` animates this action.\n\n        Multiple methods can be put in a single animation once via chaining:\n\n        ::\n\n            self.play(my_mobject.animate.shift(RIGHT).rotate(PI))\n\n        .. warning::\n\n            Passing multiple animations for the same :class:`Mobject` in one\n            call to :meth:`~.Scene.play` is discouraged and will most likely\n            not work properly. Instead of writing an animation like\n\n            ::\n\n                self.play(\n                    my_mobject.animate.shift(RIGHT), my_mobject.animate.rotate(PI)\n                )\n\n            make use of method chaining.\n\n        Keyword arguments that can be passed to :meth:`.Scene.play` can be passed\n        directly after accessing ``.animate``, like so::\n\n            self.play(my_mobject.animate(rate_func=linear).shift(RIGHT))\n\n        This is especially useful when animating simultaneous ``.animate`` calls that\n        you want to behave differently::\n\n            self.play(\n                mobject1.animate(run_time=2).rotate(PI),\n                mobject2.animate(rate_func=there_and_back).shift(RIGHT),\n            )\n\n        .. seealso::\n\n            :func:`override_animate`\n\n\n        Examples\n        --------\n\n        .. manim:: AnimateExample\n\n            class AnimateExample(Scene):\n                def construct(self):\n                    s = Square()\n                    self.play(Create(s))\n                    self.play(s.animate.shift(RIGHT))\n                    self.play(s.animate.scale(2))\n                    self.play(s.animate.rotate(PI / 2))\n                    self.play(Uncreate(s))\n\n\n        .. manim:: AnimateChainExample\n\n            class AnimateChainExample(Scene):\n                def construct(self):\n                    s = Square()\n                    self.play(Create(s))\n                    self.play(s.animate.shift(RIGHT).scale(2).rotate(PI / 2))\n                    self.play(Uncreate(s))\n\n        .. manim:: AnimateWithArgsExample\n\n            class AnimateWithArgsExample(Scene):\n                def construct(self):\n                    s = Square()\n                    c = Circle()\n\n                    VGroup(s, c).arrange(RIGHT, buff=2)\n                    self.add(s, c)\n\n                    self.play(\n                        s.animate(run_time=2).rotate(PI / 2),\n                        c.animate(rate_func=there_and_back).shift(RIGHT),\n                    )\n\n        .. warning::\n\n            ``.animate``\n             will interpolate the :class:`~.Mobject` between its points prior to\n             ``.animate`` and its points after applying ``.animate`` to it. This may\n             result in unexpected behavior when attempting to interpolate along paths,\n             or rotations (see :meth:`.rotate`).\n             If you want animations to consider the points between, consider using\n             :class:`~.ValueTracker` with updaters instead (see :meth:`.add_updater`).\n\n        \"\"\"\n        return _AnimationBuilder(self)\n\n    def __deepcopy__(self, clone_from_id) -> Self:\n        cls = self.__class__\n        result = cls.__new__(cls)\n        clone_from_id[id(self)] = result\n        for k, v in self.__dict__.items():\n            setattr(result, k, copy.deepcopy(v, clone_from_id))\n        result.original_id = str(id(self))\n        return result\n\n    def __repr__(self) -> str:\n        return str(self.name)\n\n    def reset_points(self) -> None:\n        \"\"\"Sets :attr:`points` to be an empty array.\"\"\"\n        self.points = np.zeros((0, self.dim))\n\n    def init_colors(self) -> object:\n        \"\"\"Initializes the colors.\n\n        Gets called upon creation. This is an empty method that can be implemented by\n        subclasses.\n        \"\"\"\n\n    def generate_points(self) -> object:\n        \"\"\"Initializes :attr:`points` and therefore the shape.\n\n        Gets called upon creation. This is an empty method that can be implemented by\n        subclasses.\n        \"\"\"\n\n    def add(self, *mobjects: Mobject) -> Self:\n        \"\"\"Add mobjects as submobjects.\n\n        The mobjects are added to :attr:`submobjects`.\n\n        Subclasses of mobject may implement ``+`` and ``+=`` dunder methods.\n\n        Parameters\n        ----------\n        mobjects\n            The mobjects to add.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        Raises\n        ------\n        :class:`ValueError`\n            When a mobject tries to add itself.\n        :class:`TypeError`\n            When trying to add an object that is not an instance of :class:`Mobject`.\n\n\n        Notes\n        -----\n        A mobject cannot contain itself, and it cannot contain a submobject\n        more than once.  If the parent mobject is displayed, the newly-added\n        submobjects will also be displayed (i.e. they are automatically added\n        to the parent Scene).\n\n        See Also\n        --------\n        :meth:`remove`\n        :meth:`add_to_back`\n\n        Examples\n        --------\n        ::\n\n            >>> outer = Mobject()\n            >>> inner = Mobject()\n            >>> outer = outer.add(inner)\n\n        Duplicates are not added again::\n\n            >>> outer = outer.add(inner)\n            >>> len(outer.submobjects)\n            1\n\n        Only Mobjects can be added::\n\n            >>> outer.add(3)\n            Traceback (most recent call last):\n            ...\n            TypeError: Only values of type Mobject can be added as submobjects of Mobject, but the value 3 (at index 0) is of type int.\n\n        Adding an object to itself raises an error::\n\n            >>> outer.add(outer)\n            Traceback (most recent call last):\n            ...\n            ValueError: Cannot add Mobject as a submobject of itself (at index 0).\n\n        A given mobject cannot be added as a submobject\n        twice to some parent::\n\n            >>> parent = Mobject(name=\"parent\")\n            >>> child = Mobject(name=\"child\")\n            >>> parent.add(child, child)\n            [...] WARNING  ...\n            parent\n            >>> parent.submobjects\n            [child]\n\n        \"\"\"\n        self._assert_valid_submobjects(mobjects)\n        unique_mobjects = remove_list_redundancies(mobjects)\n        if len(mobjects) != len(unique_mobjects):\n            logger.warning(\n                \"Attempted adding some Mobject as a child more than once, \"\n                \"this is not possible. Repetitions are ignored.\",\n            )\n\n        self.submobjects = list_update(self.submobjects, unique_mobjects)\n        return self\n\n    def insert(self, index: int, mobject: Mobject) -> None:\n        \"\"\"Inserts a mobject at a specific position into self.submobjects\n\n        Effectively just calls  ``self.submobjects.insert(index, mobject)``,\n        where ``self.submobjects`` is a list.\n\n        Highly adapted from ``Mobject.add``.\n\n        Parameters\n        ----------\n        index\n            The index at which\n        mobject\n            The mobject to be inserted.\n        \"\"\"\n        self._assert_valid_submobjects([mobject])\n        self.submobjects.insert(index, mobject)\n\n    def __add__(self, mobject: Mobject):\n        raise NotImplementedError\n\n    def __iadd__(self, mobject: Mobject):\n        raise NotImplementedError\n\n    def add_to_back(self, *mobjects: Mobject) -> Self:\n        \"\"\"Add all passed mobjects to the back of the submobjects.\n\n        If :attr:`submobjects` already contains the given mobjects, they just get moved\n        to the back instead.\n\n        Parameters\n        ----------\n        mobjects\n            The mobjects to add.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n\n        .. note::\n\n            Technically, this is done by adding (or moving) the mobjects to\n            the head of :attr:`submobjects`. The head of this list is rendered\n            first, which places the corresponding mobjects behind the\n            subsequent list members.\n\n        Raises\n        ------\n        :class:`ValueError`\n            When a mobject tries to add itself.\n        :class:`TypeError`\n            When trying to add an object that is not an instance of :class:`Mobject`.\n\n        Notes\n        -----\n        A mobject cannot contain itself, and it cannot contain a submobject\n        more than once.  If the parent mobject is displayed, the newly-added\n        submobjects will also be displayed (i.e. they are automatically added\n        to the parent Scene).\n\n        See Also\n        --------\n        :meth:`remove`\n        :meth:`add`\n\n        \"\"\"\n        self._assert_valid_submobjects(mobjects)\n        self.remove(*mobjects)\n        # dict.fromkeys() removes duplicates while maintaining order\n        self.submobjects = list(dict.fromkeys(mobjects)) + self.submobjects\n        return self\n\n    def remove(self, *mobjects: Mobject) -> Self:\n        \"\"\"Remove :attr:`submobjects`.\n\n        The mobjects are removed from :attr:`submobjects`, if they exist.\n\n        Subclasses of mobject may implement ``-`` and ``-=`` dunder methods.\n\n        Parameters\n        ----------\n        mobjects\n            The mobjects to remove.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        See Also\n        --------\n        :meth:`add`\n\n        \"\"\"\n        for mobject in mobjects:\n            if mobject in self.submobjects:\n                self.submobjects.remove(mobject)\n        return self\n\n    def __sub__(self, other):\n        raise NotImplementedError\n\n    def __isub__(self, other):\n        raise NotImplementedError\n\n    def set(self, **kwargs) -> Self:\n        \"\"\"Sets attributes.\n\n        I.e. ``my_mobject.set(foo=1)`` applies ``my_mobject.foo = 1``.\n\n        This is a convenience to be used along with :attr:`animate` to\n        animate setting attributes.\n\n        In addition to this method, there is a compatibility\n        layer that allows ``get_*`` and ``set_*`` methods to\n        get and set generic attributes. For instance::\n\n            >>> mob = Mobject()\n            >>> mob.set_foo(0)\n            Mobject\n            >>> mob.get_foo()\n            0\n            >>> mob.foo\n            0\n\n        This compatibility layer does not interfere with any\n        ``get_*`` or ``set_*`` methods that are explicitly\n        defined.\n\n        .. warning::\n\n            This compatibility layer is for backwards compatibility\n            and is not guaranteed to stay around. Where applicable,\n            please prefer getting/setting attributes normally or with\n            the :meth:`set` method.\n\n        Parameters\n        ----------\n        **kwargs\n            The attributes and corresponding values to set.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        Examples\n        --------\n        ::\n\n            >>> mob = Mobject()\n            >>> mob.set(foo=0)\n            Mobject\n            >>> mob.foo\n            0\n        \"\"\"\n        for attr, value in kwargs.items():\n            setattr(self, attr, value)\n\n        return self\n\n    def __getattr__(self, attr: str) -> types.MethodType:\n        # Add automatic compatibility layer\n        # between properties and get_* and set_*\n        # methods.\n        #\n        # In python 3.9+ we could change this\n        # logic to use str.remove_prefix instead.\n\n        if attr.startswith(\"get_\"):\n            # Remove the \"get_\" prefix\n            to_get = attr[4:]\n\n            def getter(self):\n                warnings.warn(\n                    \"This method is not guaranteed to stay around. Please prefer \"\n                    \"getting the attribute normally.\",\n                    DeprecationWarning,\n                    stacklevel=2,\n                )\n\n                return getattr(self, to_get)\n\n            # Return a bound method\n            return types.MethodType(getter, self)\n\n        if attr.startswith(\"set_\"):\n            # Remove the \"set_\" prefix\n            to_set = attr[4:]\n\n            def setter(self, value):\n                warnings.warn(\n                    \"This method is not guaranteed to stay around. Please prefer \"\n                    \"setting the attribute normally or with Mobject.set().\",\n                    DeprecationWarning,\n                    stacklevel=2,\n                )\n\n                setattr(self, to_set, value)\n\n                return self\n\n            # Return a bound method\n            return types.MethodType(setter, self)\n\n        # Unhandled attribute, therefore error\n        raise AttributeError(f\"{type(self).__name__} object has no attribute '{attr}'\")\n\n    @property\n    def width(self) -> float:\n        \"\"\"The width of the mobject.\n\n        Returns\n        -------\n        :class:`float`\n\n        Examples\n        --------\n        .. manim:: WidthExample\n\n            class WidthExample(Scene):\n                def construct(self):\n                    decimal = DecimalNumber().to_edge(UP)\n                    rect = Rectangle(color=BLUE)\n                    rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)\n\n                    decimal.add_updater(lambda d: d.set_value(rect.width))\n\n                    self.add(rect_copy, rect, decimal)\n                    self.play(rect.animate.set(width=7))\n                    self.wait()\n\n        See also\n        --------\n        :meth:`length_over_dim`\n\n        \"\"\"\n        # Get the length across the X dimension\n        return self.length_over_dim(0)\n\n    @width.setter\n    def width(self, value: float):\n        self.scale_to_fit_width(value)\n\n    @property\n    def height(self) -> float:\n        \"\"\"The height of the mobject.\n\n        Returns\n        -------\n        :class:`float`\n\n        Examples\n        --------\n        .. manim:: HeightExample\n\n            class HeightExample(Scene):\n                def construct(self):\n                    decimal = DecimalNumber().to_edge(UP)\n                    rect = Rectangle(color=BLUE)\n                    rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)\n\n                    decimal.add_updater(lambda d: d.set_value(rect.height))\n\n                    self.add(rect_copy, rect, decimal)\n                    self.play(rect.animate.set(height=5))\n                    self.wait()\n\n        See also\n        --------\n        :meth:`length_over_dim`\n\n        \"\"\"\n        # Get the length across the Y dimension\n        return self.length_over_dim(1)\n\n    @height.setter\n    def height(self, value: float):\n        self.scale_to_fit_height(value)\n\n    @property\n    def depth(self) -> float:\n        \"\"\"The depth of the mobject.\n\n        Returns\n        -------\n        :class:`float`\n\n        See also\n        --------\n        :meth:`length_over_dim`\n\n        \"\"\"\n        # Get the length across the Z dimension\n        return self.length_over_dim(2)\n\n    @depth.setter\n    def depth(self, value: float):\n        self.scale_to_fit_depth(value)\n\n    # Can't be staticmethod because of point_cloud_mobject.py\n    def get_array_attrs(self) -> list[Literal[\"points\"]]:\n        return [\"points\"]\n\n    def apply_over_attr_arrays(self, func: MultiMappingFunction) -> Self:\n        for attr in self.get_array_attrs():\n            setattr(self, attr, func(getattr(self, attr)))\n        return self\n\n    # Displaying\n\n    def get_image(self, camera=None) -> PixelArray:\n        if camera is None:\n            from ..camera.camera import Camera\n\n            camera = Camera()\n        camera.capture_mobject(self)\n        return camera.get_image()\n\n    def show(self, camera=None) -> None:\n        self.get_image(camera=camera).show()\n\n    def save_image(self, name: str | None = None) -> None:\n        \"\"\"Saves an image of only this :class:`Mobject` at its position to a png\n        file.\n        \"\"\"\n        self.get_image().save(\n            Path(config.get_dir(\"video_dir\")).joinpath((name or str(self)) + \".png\"),\n        )\n\n    def copy(self) -> Self:\n        \"\"\"Create and return an identical copy of the :class:`Mobject` including all\n        :attr:`submobjects`.\n\n        Returns\n        -------\n        :class:`Mobject`\n            The copy.\n\n        Note\n        ----\n        The clone is initially not visible in the Scene, even if the original was.\n        \"\"\"\n        return copy.deepcopy(self)\n\n    def generate_target(self, use_deepcopy: bool = False) -> Self:\n        self.target = None  # Prevent unbounded linear recursion\n        if use_deepcopy:\n            self.target = copy.deepcopy(self)\n        else:\n            self.target = self.copy()\n        return self.target\n\n    # Updating\n\n    def update(self, dt: float = 0, recursive: bool = True) -> Self:\n        \"\"\"Apply all updaters.\n\n        Does nothing if updating is suspended.\n\n        Parameters\n        ----------\n        dt\n            The parameter ``dt`` to pass to the update functions. Usually this is the\n            time in seconds since the last call of ``update``.\n        recursive\n            Whether to recursively update all submobjects.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        See Also\n        --------\n        :meth:`add_updater`\n        :meth:`get_updaters`\n\n        \"\"\"\n        if self.updating_suspended:\n            return self\n        for updater in self.updaters:\n            if \"dt\" in inspect.signature(updater).parameters:\n                updater(self, dt)\n            else:\n                updater(self)\n        if recursive:\n            for submob in self.submobjects:\n                submob.update(dt, recursive)\n        return self\n\n    def get_time_based_updaters(self) -> list[TimeBasedUpdater]:\n        \"\"\"Return all updaters using the ``dt`` parameter.\n\n        The updaters use this parameter as the input for difference in time.\n\n        Returns\n        -------\n        List[:class:`Callable`]\n            The list of time based updaters.\n\n        See Also\n        --------\n        :meth:`get_updaters`\n        :meth:`has_time_based_updater`\n\n        \"\"\"\n        return [\n            updater\n            for updater in self.updaters\n            if \"dt\" in inspect.signature(updater).parameters\n        ]\n\n    def has_time_based_updater(self) -> bool:\n        \"\"\"Test if ``self`` has a time based updater.\n\n        Returns\n        -------\n        :class:`bool`\n            ``True`` if at least one updater uses the ``dt`` parameter, ``False``\n            otherwise.\n\n        See Also\n        --------\n        :meth:`get_time_based_updaters`\n\n        \"\"\"\n        return any(\n            \"dt\" in inspect.signature(updater).parameters for updater in self.updaters\n        )\n\n    def get_updaters(self) -> list[Updater]:\n        \"\"\"Return all updaters.\n\n        Returns\n        -------\n        List[:class:`Callable`]\n            The list of updaters.\n\n        See Also\n        --------\n        :meth:`add_updater`\n        :meth:`get_time_based_updaters`\n\n        \"\"\"\n        return self.updaters\n\n    def get_family_updaters(self) -> list[Updater]:\n        return list(it.chain(*(sm.get_updaters() for sm in self.get_family())))\n\n    def add_updater(\n        self,\n        update_function: Updater,\n        index: int | None = None,\n        call_updater: bool = False,\n    ) -> Self:\n        \"\"\"Add an update function to this mobject.\n\n        Update functions, or updaters in short, are functions that are applied to the\n        Mobject in every frame.\n\n        Parameters\n        ----------\n        update_function\n            The update function to be added.\n            Whenever :meth:`update` is called, this update function gets called using\n            ``self`` as the first parameter.\n            The updater can have a second parameter ``dt``. If it uses this parameter,\n            it gets called using a second value ``dt``, usually representing the time\n            in seconds since the last call of :meth:`update`.\n        index\n            The index at which the new updater should be added in ``self.updaters``.\n            In case ``index`` is ``None`` the updater will be added at the end.\n        call_updater\n            Whether or not to call the updater initially. If ``True``, the updater will\n            be called using ``dt=0``.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        Examples\n        --------\n        .. manim:: NextToUpdater\n\n            class NextToUpdater(Scene):\n                def construct(self):\n                    def update_label(mobject):\n                        mobject.set_value(dot.get_center()[0])\n                        mobject.next_to(dot)\n\n                    dot = Dot(RIGHT*3)\n                    label = DecimalNumber()\n                    label.add_updater(update_label)\n                    self.add(dot, label)\n\n                    self.play(Rotating(dot, angle=TAU, about_point=ORIGIN, run_time=TAU, rate_func=linear))\n\n        .. manim:: DtUpdater\n\n            class DtUpdater(Scene):\n                def construct(self):\n                    square = Square()\n\n                    #Let the square rotate 90\u00b0 per second\n                    square.add_updater(lambda mobject, dt: mobject.rotate(dt*90*DEGREES))\n                    self.add(square)\n                    self.wait(2)\n\n        See also\n        --------\n        :meth:`get_updaters`\n        :meth:`remove_updater`\n        :class:`~.UpdateFromFunc`\n        :class:`~.Rotating`\n        :meth:`rotate`\n        :attr:`~.Mobject.animate`\n        \"\"\"\n        if index is None:\n            self.updaters.append(update_function)\n        else:\n            self.updaters.insert(index, update_function)\n        if call_updater:\n            parameters = inspect.signature(update_function).parameters\n            if \"dt\" in parameters:\n                update_function(self, 0)\n            else:\n                update_function(self)\n        return self\n\n    def remove_updater(self, update_function: Updater) -> Self:\n        \"\"\"Remove an updater.\n\n        If the same updater is applied multiple times, every instance gets removed.\n\n        Parameters\n        ----------\n        update_function\n            The update function to be removed.\n\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        See also\n        --------\n        :meth:`clear_updaters`\n        :meth:`add_updater`\n        :meth:`get_updaters`\n\n        \"\"\"\n        while update_function in self.updaters:\n            self.updaters.remove(update_function)\n        return self\n\n    def clear_updaters(self, recursive: bool = True) -> Self:\n        \"\"\"Remove every updater.\n\n        Parameters\n        ----------\n        recursive\n            Whether to recursively call ``clear_updaters`` on all submobjects.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        See also\n        --------\n        :meth:`remove_updater`\n        :meth:`add_updater`\n        :meth:`get_updaters`\n\n        \"\"\"\n        self.updaters = []\n        if recursive:\n            for submob in self.submobjects:\n                submob.clear_updaters()\n        return self\n\n    def match_updaters(self, mobject: Mobject) -> Self:\n        \"\"\"Match the updaters of the given mobject.\n\n        Parameters\n        ----------\n        mobject\n            The mobject whose updaters get matched.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        Note\n        ----\n        All updaters from submobjects are removed, but only updaters of the given\n        mobject are matched, not those of it's submobjects.\n\n        See also\n        --------\n        :meth:`add_updater`\n        :meth:`clear_updaters`\n\n        \"\"\"\n        self.clear_updaters()\n        for updater in mobject.get_updaters():\n            self.add_updater(updater)\n        return self\n\n    def suspend_updating(self, recursive: bool = True) -> Self:\n        \"\"\"Disable updating from updaters and animations.\n\n\n        Parameters\n        ----------\n        recursive\n            Whether to recursively suspend updating on all submobjects.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        See also\n        --------\n        :meth:`resume_updating`\n        :meth:`add_updater`\n\n        \"\"\"\n        self.updating_suspended = True\n        if recursive:\n            for submob in self.submobjects:\n                submob.suspend_updating(recursive)\n        return self\n\n    def resume_updating(self, recursive: bool = True) -> Self:\n        \"\"\"Enable updating from updaters and animations.\n\n        Parameters\n        ----------\n        recursive\n            Whether to recursively enable updating on all submobjects.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        See also\n        --------\n        :meth:`suspend_updating`\n        :meth:`add_updater`\n\n        \"\"\"\n        self.updating_suspended = False\n        if recursive:\n            for submob in self.submobjects:\n                submob.resume_updating(recursive)\n        self.update(dt=0, recursive=recursive)\n        return self\n\n    # Transforming operations\n\n    def apply_to_family(self, func: Callable[[Mobject], None]) -> None:\n        \"\"\"Apply a function to ``self`` and every submobject with points recursively.\n\n        Parameters\n        ----------\n        func\n            The function to apply to each mobject. ``func`` gets passed the respective\n            (sub)mobject as parameter.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        See also\n        --------\n        :meth:`family_members_with_points`\n\n        \"\"\"\n        for mob in self.family_members_with_points():\n            func(mob)\n\n    def shift(self, *vectors: Vector3D) -> Self:\n        \"\"\"Shift by the given vectors.\n\n        Parameters\n        ----------\n        vectors\n            Vectors to shift by. If multiple vectors are given, they are added\n            together.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        See also\n        --------\n        :meth:`move_to`\n        \"\"\"\n        total_vector = reduce(op.add, vectors)\n        for mob in self.family_members_with_points():\n            mob.points = mob.points.astype(\"float\")\n            mob.points += total_vector\n\n        return self\n\n    def scale(self, scale_factor: float, **kwargs) -> Self:\n        r\"\"\"Scale the size by a factor.\n\n        Default behavior is to scale about the center of the mobject.\n\n        Parameters\n        ----------\n        scale_factor\n            The scaling factor :math:`\\alpha`. If :math:`0 < |\\alpha|\u00a0< 1`, the mobject\n            will shrink, and for :math:`|\\alpha| > 1` it will grow. Furthermore,\n            if :math:`\\alpha < 0`, the mobject is also flipped.\n        kwargs\n            Additional keyword arguments passed to\n            :meth:`apply_points_function_about_point`.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        Examples\n        --------\n\n        .. manim:: MobjectScaleExample\n            :save_last_frame:\n\n            class MobjectScaleExample(Scene):\n                def construct(self):\n                    f1 = Text(\"F\")\n                    f2 = Text(\"F\").scale(2)\n                    f3 = Text(\"F\").scale(0.5)\n                    f4 = Text(\"F\").scale(-1)\n\n                    vgroup = VGroup(f1, f2, f3, f4).arrange(6 * RIGHT)\n                    self.add(vgroup)\n\n        See also\n        --------\n        :meth:`move_to`\n\n        \"\"\"\n        self.apply_points_function_about_point(\n            lambda points: scale_factor * points, **kwargs\n        )\n        return self\n\n    def rotate_about_origin(self, angle: float, axis: Vector3D = OUT, axes=[]) -> Self:\n        \"\"\"Rotates the :class:`~.Mobject` about the ORIGIN, which is at [0,0,0].\"\"\"\n        return self.rotate(angle, axis, about_point=ORIGIN)\n\n    def rotate(\n        self,\n        angle: float,\n        axis: Vector3D = OUT,\n        about_point: Point3DLike | None = None,\n        **kwargs,\n    ) -> Self:\n        \"\"\"Rotates the :class:`~.Mobject` around a specified axis and point.\n\n        Parameters\n        ----------\n        angle\n            The angle of rotation in radians. Predefined constants such as ``DEGREES``\n            can also be used to specify the angle in degrees.\n        axis\n            The rotation axis (see :class:`~.Rotating` for more).\n        about_point\n            The point about which the mobject rotates. If ``None``, rotation occurs around\n            the center of the mobject.\n        **kwargs\n            Additional keyword arguments passed to :meth:`apply_points_function_about_point`,\n            such as ``about_edge``.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self`` (for method chaining)\n\n\n        .. note::\n            To animate a rotation, use :class:`~.Rotating` or :class:`~.Rotate`\n            instead of ``.animate.rotate(...)``.\n            The ``.animate.rotate(...)`` syntax only applies a transformation\n            from the initial state to the final rotated state\n            (interpolation between the two states), without showing proper rotational motion\n            based on the angle (from 0 to the given angle).\n\n        Examples\n        --------\n\n        .. manim:: RotateMethodExample\n            :save_last_frame:\n\n            class RotateMethodExample(Scene):\n                def construct(self):\n                    circle = Circle(radius=1, color=BLUE)\n                    line = Line(start=ORIGIN, end=RIGHT)\n                    arrow1 = Arrow(start=ORIGIN, end=RIGHT, buff=0, color=GOLD)\n                    group1 = VGroup(circle, line, arrow1)\n\n                    group2 = group1.copy()\n                    arrow2 = group2[2]\n                    arrow2.rotate(angle=PI / 4, about_point=arrow2.get_start())\n\n                    group3 = group1.copy()\n                    arrow3 = group3[2]\n                    arrow3.rotate(angle=120 * DEGREES, about_point=arrow3.get_start())\n\n                    self.add(VGroup(group1, group2, group3).arrange(RIGHT, buff=1))\n\n        See also\n        --------\n        :class:`~.Rotating`, :class:`~.Rotate`, :attr:`~.Mobject.animate`, :meth:`apply_points_function_about_point`\n\n        \"\"\"\n        rot_matrix = rotation_matrix(angle, axis)\n        self.apply_points_function_about_point(\n            lambda points: np.dot(points, rot_matrix.T), about_point, **kwargs\n        )\n        return self\n\n    def flip(self, axis: Vector3D = UP, **kwargs) -> Self:\n        \"\"\"Flips/Mirrors an mobject about its center.\n\n        Examples\n        --------\n\n        .. manim:: FlipExample\n            :save_last_frame:\n\n            class FlipExample(Scene):\n                def construct(self):\n                    s= Line(LEFT, RIGHT+UP).shift(4*LEFT)\n                    self.add(s)\n                    s2= s.copy().flip()\n                    self.add(s2)\n\n        \"\"\"\n        return self.rotate(TAU / 2, axis, **kwargs)\n\n    def stretch(self, factor: float, dim: int, **kwargs) -> Self:\n        def func(points: Point3D_Array) -> Point3D_Array:\n            points[:, dim] *= factor\n            return points\n\n        self.apply_points_function_about_point(func, **kwargs)\n        return self\n\n    def apply_function(self, function: MappingFunction, **kwargs) -> Self:\n        # Default to applying matrix about the origin, not mobjects center\n        if len(kwargs) == 0:\n            kwargs[\"about_point\"] = ORIGIN\n\n        def multi_mapping_function(points: Point3D_Array) -> Point3D_Array:\n            result: Point3D_Array = np.apply_along_axis(function, 1, points)\n            return result\n\n        self.apply_points_function_about_point(multi_mapping_function, **kwargs)\n        return self\n\n    def apply_function_to_position(self, function: MappingFunction) -> Self:\n        self.move_to(function(self.get_center()))\n        return self\n\n    def apply_function_to_submobject_positions(self, function: MappingFunction) -> Self:\n        for submob in self.submobjects:\n            submob.apply_function_to_position(function)\n        return self\n\n    def apply_matrix(self, matrix, **kwargs) -> Self:\n        # Default to applying matrix about the origin, not mobjects center\n        if (\"about_point\" not in kwargs) and (\"about_edge\" not in kwargs):\n            kwargs[\"about_point\"] = ORIGIN\n        full_matrix = np.identity(self.dim)\n        matrix = np.array(matrix)\n        full_matrix[: matrix.shape[0], : matrix.shape[1]] = matrix\n        self.apply_points_function_about_point(\n            lambda points: np.dot(points, full_matrix.T), **kwargs\n        )\n        return self\n\n    def apply_complex_function(\n        self, function: Callable[[complex], complex], **kwargs\n    ) -> Self:\n        \"\"\"Applies a complex function to a :class:`Mobject`.\n        The x and y Point3Ds correspond to the real and imaginary parts respectively.\n\n        Example\n        -------\n\n        .. manim:: ApplyFuncExample\n\n            class ApplyFuncExample(Scene):\n                def construct(self):\n                    circ = Circle().scale(1.5)\n                    circ_ref = circ.copy()\n                    circ.apply_complex_function(\n                        lambda x: np.exp(x*1j)\n                    )\n                    t = ValueTracker(0)\n                    circ.add_updater(\n                        lambda x: x.become(circ_ref.copy().apply_complex_function(\n                            lambda x: np.exp(x+t.get_value()*1j)\n                        )).set_color(BLUE)\n                    )\n                    self.add(circ_ref)\n                    self.play(TransformFromCopy(circ_ref, circ))\n                    self.play(t.animate.set_value(TAU), run_time=3)\n        \"\"\"\n\n        def R3_func(point):\n            x, y, z = point\n            xy_complex = function(complex(x, y))\n            return [xy_complex.real, xy_complex.imag, z]\n\n        return self.apply_function(R3_func)\n\n    def reverse_points(self) -> Self:\n        for mob in self.family_members_with_points():\n            mob.apply_over_attr_arrays(lambda arr: np.array(list(reversed(arr))))\n        return self\n\n    def repeat(self, count: int) -> Self:\n        \"\"\"This can make transition animations nicer\"\"\"\n\n        def repeat_array(array):\n            return reduce(lambda a1, a2: np.append(a1, a2, axis=0), [array] * count)\n\n        for mob in self.family_members_with_points():\n            mob.apply_over_attr_arrays(repeat_array)\n        return self\n\n    # In place operations.\n    # Note, much of these are now redundant with default behavior of\n    # above methods\n\n    # TODO: name is inconsistent with OpenGLMobject.apply_points_function()\n    def apply_points_function_about_point(\n        self,\n        func: MultiMappingFunction,\n        about_point: Point3DLike | None = None,\n        about_edge: Vector3D | None = None,\n    ) -> Self:\n        if about_point is None:\n            if about_edge is None:\n                about_edge = ORIGIN\n            about_point = self.get_critical_point(about_edge)\n        for mob in self.family_members_with_points():\n            mob.points -= about_point\n            mob.points = func(mob.points)\n            mob.points += about_point\n        return self\n\n    def pose_at_angle(self, **kwargs):\n        self.rotate(TAU / 14, RIGHT + UP, **kwargs)\n        return self\n\n    # Positioning methods\n\n    def center(self) -> Self:\n        \"\"\"Moves the center of the mobject to the center of the scene.\n\n        Returns\n        -------\n        :class:`.Mobject`\n            The centered mobject.\n        \"\"\"\n        self.shift(-self.get_center())\n        return self\n\n    def align_on_border(\n        self, direction: Vector3D, buff: float = DEFAULT_MOBJECT_TO_EDGE_BUFFER\n    ) -> Self:\n        \"\"\"Direction just needs to be a vector pointing towards side or\n        corner in the 2d plane.\n        \"\"\"\n        target_point = np.sign(direction) * (\n            config[\"frame_x_radius\"],\n            config[\"frame_y_radius\"],\n            0,\n        )\n        point_to_align = self.get_critical_point(direction)\n        shift_val = target_point - point_to_align - buff * np.array(direction)\n        shift_val = shift_val * abs(np.sign(direction))\n        self.shift(shift_val)\n        return self\n\n    def to_corner(\n        self, corner: Vector3D = DL, buff: float = DEFAULT_MOBJECT_TO_EDGE_BUFFER\n    ) -> Self:\n        \"\"\"Moves this :class:`~.Mobject` to the given corner of the screen.\n\n        Returns\n        -------\n        :class:`.Mobject`\n            The newly positioned mobject.\n\n        Examples\n        --------\n\n        .. manim:: ToCornerExample\n            :save_last_frame:\n\n            class ToCornerExample(Scene):\n                def construct(self):\n                    c = Circle()\n                    c.to_corner(UR)\n                    t = Tex(\"To the corner!\")\n                    t2 = MathTex(\"x^3\").shift(DOWN)\n                    self.add(c,t,t2)\n                    t.to_corner(DL, buff=0)\n                    t2.to_corner(UL, buff=1.5)\n        \"\"\"\n        return self.align_on_border(corner, buff)\n\n    def to_edge(\n        self, edge: Vector3D = LEFT, buff: float = DEFAULT_MOBJECT_TO_EDGE_BUFFER\n    ) -> Self:\n        \"\"\"Moves this :class:`~.Mobject` to the given edge of the screen,\n        without affecting its position in the other dimension.\n\n        Returns\n        -------\n        :class:`.Mobject`\n            The newly positioned mobject.\n\n        Examples\n        --------\n\n        .. manim:: ToEdgeExample\n            :save_last_frame:\n\n            class ToEdgeExample(Scene):\n                def construct(self):\n                    tex_top = Tex(\"I am at the top!\")\n                    tex_top.to_edge(UP)\n                    tex_side = Tex(\"I am moving to the side!\")\n                    c = Circle().shift(2*DOWN)\n                    self.add(tex_top, tex_side, c)\n                    tex_side.to_edge(LEFT)\n                    c.to_edge(RIGHT, buff=0)\n\n        \"\"\"\n        return self.align_on_border(edge, buff)\n\n    def next_to(\n        self,\n        mobject_or_point: Mobject | Point3DLike,\n        direction: Vector3D = RIGHT,\n        buff: float = DEFAULT_MOBJECT_TO_MOBJECT_BUFFER,\n        aligned_edge: Vector3D = ORIGIN,\n        submobject_to_align: Mobject | None = None,\n        index_of_submobject_to_align: int | None = None,\n        coor_mask: Vector3D = np.array([1, 1, 1]),\n    ) -> Self:\n        \"\"\"Move this :class:`~.Mobject` next to another's :class:`~.Mobject` or Point3D.\n\n        Examples\n        --------\n\n        .. manim:: GeometricShapes\n            :save_last_frame:\n\n            class GeometricShapes(Scene):\n                def construct(self):\n                    d = Dot()\n                    c = Circle()\n                    s = Square()\n                    t = Triangle()\n                    d.next_to(c, RIGHT)\n                    s.next_to(c, LEFT)\n                    t.next_to(c, DOWN)\n                    self.add(d, c, s, t)\n\n        \"\"\"\n        if isinstance(mobject_or_point, Mobject):\n            mob = mobject_or_point\n            if index_of_submobject_to_align is not None:\n                target_aligner = mob[index_of_submobject_to_align]\n            else:\n                target_aligner = mob\n            target_point = target_aligner.get_critical_point(aligned_edge + direction)\n        else:\n            target_point = mobject_or_point\n        if submobject_to_align is not None:\n            aligner = submobject_to_align\n        elif index_of_submobject_to_align is not None:\n            aligner = self[index_of_submobject_to_align]\n        else:\n            aligner = self\n        point_to_align = aligner.get_critical_point(aligned_edge - direction)\n        self.shift((target_point - point_to_align + buff * direction) * coor_mask)\n        return self\n\n    def shift_onto_screen(self, **kwargs) -> Self:\n        space_lengths = [config[\"frame_x_radius\"], config[\"frame_y_radius\"]]\n        for vect in UP, DOWN, LEFT, RIGHT:\n            dim = np.argmax(np.abs(vect))\n            buff = kwargs.get(\"buff\", DEFAULT_MOBJECT_TO_EDGE_BUFFER)\n            max_val = space_lengths[dim] - buff\n            edge_center = self.get_edge_center(vect)\n            if np.dot(edge_center, vect) > max_val:\n                self.to_edge(vect, **kwargs)\n        return self\n\n    def is_off_screen(self):\n        if self.get_left()[0] > config[\"frame_x_radius\"]:\n            return True\n        if self.get_right()[0] < -config[\"frame_x_radius\"]:\n            return True\n        if self.get_bottom()[1] > config[\"frame_y_radius\"]:\n            return True\n        return self.get_top()[1] < -config[\"frame_y_radius\"]\n\n    def stretch_about_point(self, factor: float, dim: int, point: Point3DLike) -> Self:\n        return self.stretch(factor, dim, about_point=point)\n\n    def rescale_to_fit(\n        self, length: float, dim: int, stretch: bool = False, **kwargs\n    ) -> Self:\n        old_length = self.length_over_dim(dim)\n        if old_length == 0:\n            return self\n        if stretch:\n            self.stretch(length / old_length, dim, **kwargs)\n        else:\n            self.scale(length / old_length, **kwargs)\n        return self\n\n    def scale_to_fit_width(self, width: float, **kwargs) -> Self:\n        \"\"\"Scales the :class:`~.Mobject` to fit a width while keeping height/depth proportional.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        Examples\n        --------\n        ::\n\n            >>> from manim import *\n            >>> sq = Square()\n            >>> sq.height\n            np.float64(2.0)\n            >>> sq.scale_to_fit_width(5)\n            Square\n            >>> sq.width\n            np.float64(5.0)\n            >>> sq.height\n            np.float64(5.0)\n        \"\"\"\n        return self.rescale_to_fit(width, 0, stretch=False, **kwargs)\n\n    def stretch_to_fit_width(self, width: float, **kwargs) -> Self:\n        \"\"\"Stretches the :class:`~.Mobject` to fit a width, not keeping height/depth proportional.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        Examples\n        --------\n        ::\n\n            >>> from manim import *\n            >>> sq = Square()\n            >>> sq.height\n            np.float64(2.0)\n            >>> sq.stretch_to_fit_width(5)\n            Square\n            >>> sq.width\n            np.float64(5.0)\n            >>> sq.height\n            np.float64(2.0)\n        \"\"\"\n        return self.rescale_to_fit(width, 0, stretch=True, **kwargs)\n\n    def scale_to_fit_height(self, height: float, **kwargs) -> Self:\n        \"\"\"Scales the :class:`~.Mobject` to fit a height while keeping width/depth proportional.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        Examples\n        --------\n        ::\n\n            >>> from manim import *\n            >>> sq = Square()\n            >>> sq.width\n            np.float64(2.0)\n            >>> sq.scale_to_fit_height(5)\n            Square\n            >>> sq.height\n            np.float64(5.0)\n            >>> sq.width\n            np.float64(5.0)\n        \"\"\"\n        return self.rescale_to_fit(height, 1, stretch=False, **kwargs)\n\n    def stretch_to_fit_height(self, height: float, **kwargs) -> Self:\n        \"\"\"Stretches the :class:`~.Mobject` to fit a height, not keeping width/depth proportional.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        Examples\n        --------\n        ::\n\n            >>> from manim import *\n            >>> sq = Square()\n            >>> sq.width\n            np.float64(2.0)\n            >>> sq.stretch_to_fit_height(5)\n            Square\n            >>> sq.height\n            np.float64(5.0)\n            >>> sq.width\n            np.float64(2.0)\n        \"\"\"\n        return self.rescale_to_fit(height, 1, stretch=True, **kwargs)\n\n    def scale_to_fit_depth(self, depth: float, **kwargs) -> Self:\n        \"\"\"Scales the :class:`~.Mobject` to fit a depth while keeping width/height proportional.\"\"\"\n        return self.rescale_to_fit(depth, 2, stretch=False, **kwargs)\n\n    def stretch_to_fit_depth(self, depth: float, **kwargs) -> Self:\n        \"\"\"Stretches the :class:`~.Mobject` to fit a depth, not keeping width/height proportional.\"\"\"\n        return self.rescale_to_fit(depth, 2, stretch=True, **kwargs)\n\n    def set_coord(self, value, dim: int, direction: Vector3D = ORIGIN) -> Self:\n        curr = self.get_coord(dim, direction)\n        shift_vect = np.zeros(self.dim)\n        shift_vect[dim] = value - curr\n        self.shift(shift_vect)\n        return self\n\n    def set_x(self, x: float, direction: Vector3D = ORIGIN) -> Self:\n        \"\"\"Set x value of the center of the :class:`~.Mobject` (``int`` or ``float``)\"\"\"\n        return self.set_coord(x, 0, direction)\n\n    def set_y(self, y: float, direction: Vector3D = ORIGIN) -> Self:\n        \"\"\"Set y value of the center of the :class:`~.Mobject` (``int`` or ``float``)\"\"\"\n        return self.set_coord(y, 1, direction)\n\n    def set_z(self, z: float, direction: Vector3D = ORIGIN) -> Self:\n        \"\"\"Set z value of the center of the :class:`~.Mobject` (``int`` or ``float``)\"\"\"\n        return self.set_coord(z, 2, direction)\n\n    def space_out_submobjects(self, factor: float = 1.5, **kwargs) -> Self:\n        self.scale(factor, **kwargs)\n        for submob in self.submobjects:\n            submob.scale(1.0 / factor)\n        return self\n\n    def move_to(\n        self,\n        point_or_mobject: Point3DLike | Mobject,\n        aligned_edge: Vector3D = ORIGIN,\n        coor_mask: Vector3D = np.array([1, 1, 1]),\n    ) -> Self:\n        \"\"\"Move center of the :class:`~.Mobject` to certain Point3D.\"\"\"\n        if isinstance(point_or_mobject, Mobject):\n            target = point_or_mobject.get_critical_point(aligned_edge)\n        else:\n            target = point_or_mobject\n        point_to_align = self.get_critical_point(aligned_edge)\n        self.shift((target - point_to_align) * coor_mask)\n        return self\n\n    def replace(\n        self, mobject: Mobject, dim_to_match: int = 0, stretch: bool = False\n    ) -> Self:\n        if not mobject.get_num_points() and not mobject.submobjects:\n            raise Warning(\"Attempting to replace mobject with no points\")\n        if stretch:\n            self.stretch_to_fit_width(mobject.width)\n            self.stretch_to_fit_height(mobject.height)\n        else:\n            self.rescale_to_fit(\n                mobject.length_over_dim(dim_to_match),\n                dim_to_match,\n                stretch=False,\n            )\n        self.shift(mobject.get_center() - self.get_center())\n        return self\n\n    def surround(\n        self,\n        mobject: Mobject,\n        dim_to_match: int = 0,\n        stretch: bool = False,\n        buff: float = MED_SMALL_BUFF,\n    ) -> Self:\n        self.replace(mobject, dim_to_match, stretch)\n        length = mobject.length_over_dim(dim_to_match)\n        self.scale((length + buff) / length)\n        return self\n\n    def put_start_and_end_on(self, start: Point3DLike, end: Point3DLike) -> Self:\n        curr_start, curr_end = self.get_start_and_end()\n        curr_vect = curr_end - curr_start\n        if np.all(curr_vect == 0):\n            # TODO: this looks broken. It makes self.points a Point3D instead\n            # of a Point3D_Array. However, modifying this breaks some tests\n            # where this is currently expected.\n            self.points = np.array(start)\n            return self\n        target_vect = np.asarray(end) - np.asarray(start)\n        axis = (\n            normalize(np.cross(curr_vect, target_vect))\n            if np.linalg.norm(np.cross(curr_vect, target_vect)) != 0\n            else OUT\n        )\n        self.scale(\n            np.linalg.norm(target_vect) / np.linalg.norm(curr_vect),\n            about_point=curr_start,\n        )\n        self.rotate(\n            angle_between_vectors(curr_vect, target_vect),\n            about_point=curr_start,\n            axis=axis,\n        )\n        self.shift(start - curr_start)\n        return self\n\n    # Background rectangle\n    def add_background_rectangle(\n        self, color: ParsableManimColor | None = None, opacity: float = 0.75, **kwargs\n    ) -> Self:\n        \"\"\"Add a BackgroundRectangle as submobject.\n\n        The BackgroundRectangle is added behind other submobjects.\n\n        This can be used to increase the mobjects visibility in front of a noisy background.\n\n        Parameters\n        ----------\n        color\n            The color of the BackgroundRectangle\n        opacity\n            The opacity of the BackgroundRectangle\n        kwargs\n            Additional keyword arguments passed to the BackgroundRectangle constructor\n\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        See Also\n        --------\n        :meth:`add_to_back`\n        :class:`~.BackgroundRectangle`\n\n        \"\"\"\n        # TODO, this does not behave well when the mobject has points,\n        # since it gets displayed on top\n        from manim.mobject.geometry.shape_matchers import BackgroundRectangle\n\n        self.background_rectangle = BackgroundRectangle(\n            self, color=color, fill_opacity=opacity, **kwargs\n        )\n        self.add_to_back(self.background_rectangle)\n        return self\n\n    def add_background_rectangle_to_submobjects(self, **kwargs) -> Self:\n        for submobject in self.submobjects:\n            submobject.add_background_rectangle(**kwargs)\n        return self\n\n    def add_background_rectangle_to_family_members_with_points(self, **kwargs) -> Self:\n        for mob in self.family_members_with_points():\n            mob.add_background_rectangle(**kwargs)\n        return self\n\n    # Color functions\n\n    def set_color(\n        self, color: ParsableManimColor = YELLOW_C, family: bool = True\n    ) -> Self:\n        \"\"\"Condition is function which takes in one arguments, (x, y, z).\n        Here it just recurses to submobjects, but in subclasses this\n        should be further implemented based on the the inner workings\n        of color\n        \"\"\"\n        if family:\n            for submob in self.submobjects:\n                submob.set_color(color, family=family)\n\n        self.color = ManimColor.parse(color)\n        return self\n\n    def set_color_by_gradient(self, *colors: ParsableManimColor) -> Self:\n        \"\"\"\n        Parameters\n        ----------\n        colors\n            The colors to use for the gradient. Use like `set_color_by_gradient(RED, BLUE, GREEN)`.\n\n        self.color = ManimColor.parse(color)\n        return self\n        \"\"\"\n        self.set_submobject_colors_by_gradient(*colors)\n        return self\n\n    def set_colors_by_radial_gradient(\n        self,\n        center: Point3DLike | None = None,\n        radius: float = 1,\n        inner_color: ParsableManimColor = WHITE,\n        outer_color: ParsableManimColor = BLACK,\n    ) -> Self:\n        self.set_submobject_colors_by_radial_gradient(\n            center,\n            radius,\n            inner_color,\n            outer_color,\n        )\n        return self\n\n    def set_submobject_colors_by_gradient(self, *colors: Iterable[ParsableManimColor]):\n        if len(colors) == 0:\n            raise ValueError(\"Need at least one color\")\n        elif len(colors) == 1:\n            return self.set_color(*colors)\n\n        mobs = self.family_members_with_points()\n        new_colors = color_gradient(colors, len(mobs))\n\n        for mob, color in zip(mobs, new_colors):\n            mob.set_color(color, family=False)\n        return self\n\n    def set_submobject_colors_by_radial_gradient(\n        self,\n        center: Point3DLike | None = None,\n        radius: float = 1,\n        inner_color: ParsableManimColor = WHITE,\n        outer_color: ParsableManimColor = BLACK,\n    ) -> Self:\n        if center is None:\n            center = self.get_center()\n\n        for mob in self.family_members_with_points():\n            t = np.linalg.norm(mob.get_center() - center) / radius\n            t = min(t, 1)\n            mob_color = interpolate_color(inner_color, outer_color, t)\n            mob.set_color(mob_color, family=False)\n\n        return self\n\n    def to_original_color(self) -> Self:\n        self.set_color(self.color)\n        return self\n\n    def fade_to(\n        self, color: ParsableManimColor, alpha: float, family: bool = True\n    ) -> Self:\n        if self.get_num_points() > 0:\n            new_color = interpolate_color(self.get_color(), color, alpha)\n            self.set_color(new_color, family=False)\n        if family:\n            for submob in self.submobjects:\n                submob.fade_to(color, alpha)\n        return self\n\n    def fade(self, darkness: float = 0.5, family: bool = True) -> Self:\n        if family:\n            for submob in self.submobjects:\n                submob.fade(darkness, family)\n        return self\n\n    def get_color(self) -> ManimColor:\n        \"\"\"Returns the color of the :class:`~.Mobject`\n\n        Examples\n        --------\n        ::\n\n            >>> from manim import Square, RED\n            >>> Square(color=RED).get_color() == RED\n            True\n\n        \"\"\"\n        return self.color\n\n    ##\n\n    def save_state(self) -> Self:\n        \"\"\"Save the current state (position, color & size). Can be restored with :meth:`~.Mobject.restore`.\"\"\"\n        if hasattr(self, \"saved_state\"):\n            # Prevent exponential growth of data\n            self.saved_state = None\n        self.saved_state = self.copy()\n\n        return self\n\n    def restore(self) -> Self:\n        \"\"\"Restores the state that was previously saved with :meth:`~.Mobject.save_state`.\"\"\"\n        if not hasattr(self, \"saved_state\") or self.save_state is None:\n            raise Exception(\"Trying to restore without having saved\")\n        self.become(self.saved_state)\n        return self\n\n    def reduce_across_dimension(self, reduce_func: Callable, dim: int):\n        \"\"\"Find the min or max value from a dimension across all points in this and submobjects.\"\"\"\n        assert dim >= 0\n        assert dim <= 2\n        if len(self.submobjects) == 0 and len(self.points) == 0:\n            # If we have no points and no submobjects, return 0 (e.g. center)\n            return 0\n\n        # If we do not have points (but do have submobjects)\n        # use only the points from those.\n        if len(self.points) == 0:  # noqa: SIM108\n            rv = None\n        else:\n            # Otherwise, be sure to include our own points\n            rv = reduce_func(self.points[:, dim])\n        # Recursively ask submobjects (if any) for the biggest/\n        # smallest dimension they have and compare it to the return value.\n        for mobj in self.submobjects:\n            value = mobj.reduce_across_dimension(reduce_func, dim)\n            rv = value if rv is None else reduce_func([value, rv])\n        return rv\n\n    def nonempty_submobjects(self) -> list[Self]:\n        return [\n            submob\n            for submob in self.submobjects\n            if len(submob.submobjects) != 0 or len(submob.points) != 0\n        ]\n\n    def get_merged_array(self, array_attr: str) -> np.ndarray:\n        \"\"\"Return all of a given attribute from this mobject and all submobjects.\n\n        May contain duplicates; the order is in a depth-first (pre-order)\n        traversal of the submobjects.\n        \"\"\"\n        result = getattr(self, array_attr)\n        for submob in self.submobjects:\n            result = np.append(result, submob.get_merged_array(array_attr), axis=0)\n        return result\n\n    def get_all_points(self) -> Point3D_Array:\n        \"\"\"Return all points from this mobject and all submobjects.\n\n        May contain duplicates; the order is in a depth-first (pre-order)\n        traversal of the submobjects.\n        \"\"\"\n        return self.get_merged_array(\"points\")\n\n    # Getters\n\n    def get_points_defining_boundary(self) -> Point3D_Array:\n        return self.get_all_points()\n\n    def get_num_points(self) -> int:\n        return len(self.points)\n\n    def get_extremum_along_dim(\n        self, points: Point3DLike_Array | None = None, dim: int = 0, key: int = 0\n    ) -> float:\n        np_points: Point3D_Array = (\n            self.get_points_defining_boundary()\n            if points is None\n            else np.asarray(points)\n        )\n        values = np_points[:, dim]\n        if key < 0:\n            return np.min(values)\n        elif key == 0:\n            return (np.min(values) + np.max(values)) / 2\n        else:\n            return np.max(values)\n\n    def get_critical_point(self, direction: Vector3D) -> Point3D:\n        \"\"\"Picture a box bounding the :class:`~.Mobject`.  Such a box has\n        9 'critical points': 4 corners, 4 edge center, the\n        center. This returns one of them, along the given direction.\n\n        ::\n\n            sample = Arc(start_angle=PI / 7, angle=PI / 5)\n\n            # These are all equivalent\n            max_y_1 = sample.get_top()[1]\n            max_y_2 = sample.get_critical_point(UP)[1]\n            max_y_3 = sample.get_extremum_along_dim(dim=1, key=1)\n\n        \"\"\"\n        result = np.zeros(self.dim)\n        all_points = self.get_points_defining_boundary()\n        if len(all_points) == 0:\n            return result\n        for dim in range(self.dim):\n            result[dim] = self.get_extremum_along_dim(\n                all_points,\n                dim=dim,\n                key=direction[dim],\n            )\n        return result\n\n    # Pseudonyms for more general get_critical_point method\n\n    def get_edge_center(self, direction: Vector3D) -> Point3D:\n        \"\"\"Get edge Point3Ds for certain direction.\"\"\"\n        return self.get_critical_point(direction)\n\n    def get_corner(self, direction: Vector3D) -> Point3D:\n        \"\"\"Get corner Point3Ds for certain direction.\"\"\"\n        return self.get_critical_point(direction)\n\n    def get_center(self) -> Point3D:\n        \"\"\"Get center Point3Ds\"\"\"\n        return self.get_critical_point(np.zeros(self.dim))\n\n    def get_center_of_mass(self) -> Point3D:\n        return np.apply_along_axis(np.mean, 0, self.get_all_points())\n\n    def get_boundary_point(self, direction: Vector3D) -> Point3D:\n        all_points = self.get_points_defining_boundary()\n        index = np.argmax(np.dot(all_points, np.array(direction).T))\n        return all_points[index]\n\n    def get_midpoint(self) -> Point3D:\n        \"\"\"Get Point3Ds of the middle of the path that forms the  :class:`~.Mobject`.\n\n        Examples\n        --------\n\n        .. manim:: AngleMidPoint\n            :save_last_frame:\n\n            class AngleMidPoint(Scene):\n                def construct(self):\n                    line1 = Line(ORIGIN, 2*RIGHT)\n                    line2 = Line(ORIGIN, 2*RIGHT).rotate_about_origin(80*DEGREES)\n\n                    a = Angle(line1, line2, radius=1.5, other_angle=False)\n                    d = Dot(a.get_midpoint()).set_color(RED)\n\n                    self.add(line1, line2, a, d)\n                    self.wait()\n\n        \"\"\"\n        return self.point_from_proportion(0.5)\n\n    def get_top(self) -> Point3D:\n        \"\"\"Get top Point3Ds of a box bounding the :class:`~.Mobject`\"\"\"\n        return self.get_edge_center(UP)\n\n    def get_bottom(self) -> Point3D:\n        \"\"\"Get bottom Point3Ds of a box bounding the :class:`~.Mobject`\"\"\"\n        return self.get_edge_center(DOWN)\n\n    def get_right(self) -> Point3D:\n        \"\"\"Get right Point3Ds of a box bounding the :class:`~.Mobject`\"\"\"\n        return self.get_edge_center(RIGHT)\n\n    def get_left(self) -> Point3D:\n        \"\"\"Get left Point3Ds of a box bounding the :class:`~.Mobject`\"\"\"\n        return self.get_edge_center(LEFT)\n\n    def get_zenith(self) -> Point3D:\n        \"\"\"Get zenith Point3Ds of a box bounding a 3D :class:`~.Mobject`.\"\"\"\n        return self.get_edge_center(OUT)\n\n    def get_nadir(self) -> Point3D:\n        \"\"\"Get nadir (opposite the zenith) Point3Ds of a box bounding a 3D :class:`~.Mobject`.\"\"\"\n        return self.get_edge_center(IN)\n\n    def length_over_dim(self, dim: int) -> float:\n        \"\"\"Measure the length of an :class:`~.Mobject` in a certain direction.\"\"\"\n        return self.reduce_across_dimension(\n            max,\n            dim,\n        ) - self.reduce_across_dimension(min, dim)\n\n    def get_coord(self, dim: int, direction: Vector3D = ORIGIN):\n        \"\"\"Meant to generalize ``get_x``, ``get_y`` and ``get_z``\"\"\"\n        return self.get_extremum_along_dim(dim=dim, key=direction[dim])\n\n    def get_x(self, direction: Vector3D = ORIGIN) -> float:\n        \"\"\"Returns x Point3D of the center of the :class:`~.Mobject` as ``float``\"\"\"\n        return self.get_coord(0, direction)\n\n    def get_y(self, direction: Vector3D = ORIGIN) -> float:\n        \"\"\"Returns y Point3D of the center of the :class:`~.Mobject` as ``float``\"\"\"\n        return self.get_coord(1, direction)\n\n    def get_z(self, direction: Vector3D = ORIGIN) -> float:\n        \"\"\"Returns z Point3D of the center of the :class:`~.Mobject` as ``float``\"\"\"\n        return self.get_coord(2, direction)\n\n    def get_start(self) -> Point3D:\n        \"\"\"Returns the point, where the stroke that surrounds the :class:`~.Mobject` starts.\"\"\"\n        self.throw_error_if_no_points()\n        return np.array(self.points[0])\n\n    def get_end(self) -> Point3D:\n        \"\"\"Returns the point, where the stroke that surrounds the :class:`~.Mobject` ends.\"\"\"\n        self.throw_error_if_no_points()\n        return np.array(self.points[-1])\n\n    def get_start_and_end(self) -> tuple[Point3D, Point3D]:\n        \"\"\"Returns starting and ending point of a stroke as a ``tuple``.\"\"\"\n        return self.get_start(), self.get_end()\n\n    def point_from_proportion(self, alpha: float) -> Point3D:\n        raise NotImplementedError(\"Please override in a child class.\")\n\n    def proportion_from_point(self, point: Point3DLike) -> float:\n        raise NotImplementedError(\"Please override in a child class.\")\n\n    def get_pieces(self, n_pieces: float) -> Group:\n        template = self.copy()\n        template.submobjects = []\n        alphas = np.linspace(0, 1, n_pieces + 1)\n        return Group(\n            *(\n                template.copy().pointwise_become_partial(self, a1, a2)\n                for a1, a2 in zip(alphas[:-1], alphas[1:])\n            )\n        )\n\n    def get_z_index_reference_point(self) -> Point3D:\n        # TODO, better place to define default z_index_group?\n        z_index_group = getattr(self, \"z_index_group\", self)\n        return z_index_group.get_center()\n\n    def has_points(self) -> bool:\n        \"\"\"Check if :class:`~.Mobject` contains points.\"\"\"\n        return len(self.points) > 0\n\n    def has_no_points(self) -> bool:\n        \"\"\"Check if :class:`~.Mobject` *does not* contains points.\"\"\"\n        return not self.has_points()\n\n    # Match other mobject properties\n\n    def match_color(self, mobject: Mobject) -> Self:\n        \"\"\"Match the color with the color of another :class:`~.Mobject`.\"\"\"\n        return self.set_color(mobject.get_color())\n\n    def match_dim_size(self, mobject: Mobject, dim: int, **kwargs) -> Self:\n        \"\"\"Match the specified dimension with the dimension of another :class:`~.Mobject`.\"\"\"\n        return self.rescale_to_fit(mobject.length_over_dim(dim), dim, **kwargs)\n\n    def match_width(self, mobject: Mobject, **kwargs) -> Self:\n        \"\"\"Match the width with the width of another :class:`~.Mobject`.\"\"\"\n        return self.match_dim_size(mobject, 0, **kwargs)\n\n    def match_height(self, mobject: Mobject, **kwargs) -> Self:\n        \"\"\"Match the height with the height of another :class:`~.Mobject`.\"\"\"\n        return self.match_dim_size(mobject, 1, **kwargs)\n\n    def match_depth(self, mobject: Mobject, **kwargs) -> Self:\n        \"\"\"Match the depth with the depth of another :class:`~.Mobject`.\"\"\"\n        return self.match_dim_size(mobject, 2, **kwargs)\n\n    def match_coord(\n        self, mobject: Mobject, dim: int, direction: Vector3D = ORIGIN\n    ) -> Self:\n        \"\"\"Match the Point3Ds with the Point3Ds of another :class:`~.Mobject`.\"\"\"\n        return self.set_coord(\n            mobject.get_coord(dim, direction),\n            dim=dim,\n            direction=direction,\n        )\n\n    def match_x(self, mobject: Mobject, direction=ORIGIN) -> Self:\n        \"\"\"Match x coord. to the x coord. of another :class:`~.Mobject`.\"\"\"\n        return self.match_coord(mobject, 0, direction)\n\n    def match_y(self, mobject: Mobject, direction=ORIGIN) -> Self:\n        \"\"\"Match y coord. to the x coord. of another :class:`~.Mobject`.\"\"\"\n        return self.match_coord(mobject, 1, direction)\n\n    def match_z(self, mobject: Mobject, direction=ORIGIN) -> Self:\n        \"\"\"Match z coord. to the x coord. of another :class:`~.Mobject`.\"\"\"\n        return self.match_coord(mobject, 2, direction)\n\n    def align_to(\n        self,\n        mobject_or_point: Mobject | Point3DLike,\n        direction: Vector3D = ORIGIN,\n    ) -> Self:\n        \"\"\"Aligns mobject to another :class:`~.Mobject` in a certain direction.\n\n        Examples:\n        mob1.align_to(mob2, UP) moves mob1 vertically so that its\n        top edge lines ups with mob2's top edge.\n        \"\"\"\n        if isinstance(mobject_or_point, Mobject):\n            point = mobject_or_point.get_critical_point(direction)\n        else:\n            point = mobject_or_point\n\n        for dim in range(self.dim):\n            if direction[dim] != 0:\n                self.set_coord(point[dim], dim, direction)\n        return self\n\n    # Family matters\n\n    def __getitem__(self, value):\n        self_list = self.split()\n        if isinstance(value, slice):\n            GroupClass = self.get_group_class()\n            return GroupClass(*self_list.__getitem__(value))\n        return self_list.__getitem__(value)\n\n    def __iter__(self):\n        return iter(self.split())\n\n    def __len__(self):\n        return len(self.split())\n\n    def get_group_class(self) -> type[Group]:\n        return Group\n\n    @staticmethod\n    def get_mobject_type_class() -> type[Mobject]:\n        \"\"\"Return the base class of this mobject type.\"\"\"\n        return Mobject\n\n    def split(self) -> list[Self]:\n        result = [self] if len(self.points) > 0 else []\n        return result + self.submobjects\n\n    def get_family(self, recurse: bool = True) -> list[Self]:\n        \"\"\"Lists all mobjects in the hierarchy (family) of the given mobject,\n        including the mobject itself and all its submobjects recursively.\n\n        Parameters\n        ----------\n        recurse\n            Just for consistency with get_family method in OpenGLMobject.\n\n        Returns\n        -------\n        list[Mobject]\n            A list of mobjects in the family of the given mobject.\n\n        Examples\n        --------\n        ::\n\n            >>> from manim import Square, Rectangle, VGroup, Group, Mobject, VMobject\n            >>> s, r, m, v = Square(), Rectangle(), Mobject(), VMobject()\n            >>> vg = VGroup(s, r)\n            >>> gr = Group(vg, m, v)\n            >>> gr.get_family()\n            [Group, VGroup(Square, Rectangle), Square, Rectangle, Mobject, VMobject]\n\n        See also\n        --------\n        :meth:`~.Mobject.family_members_with_points`, :meth:`~.Mobject.align_data`\n\n        \"\"\"\n        sub_families = [x.get_family() for x in self.submobjects]\n        all_mobjects = [self] + list(it.chain(*sub_families))\n        return remove_list_redundancies(all_mobjects)\n\n    def family_members_with_points(self) -> list[Self]:\n        \"\"\"Filters the list of family members (generated by :meth:`.get_family`) to include only mobjects with points.\n\n        Returns\n        -------\n        list[Mobject]\n            A list of mobjects that have points.\n\n        Examples\n        --------\n        ::\n\n            >>> from manim import Square, Rectangle, VGroup, Group, Mobject, VMobject\n            >>> s, r, m, v = Square(), Rectangle(), Mobject(), VMobject()\n            >>> vg = VGroup(s, r)\n            >>> gr = Group(vg, m, v)\n            >>> gr.family_members_with_points()\n            [Square, Rectangle]\n\n        See also\n        --------\n        :meth:`~.Mobject.get_family`\n\n        \"\"\"\n        return [m for m in self.get_family() if m.get_num_points() > 0]\n\n    def arrange(\n        self,\n        direction: Vector3D = RIGHT,\n        buff: float = DEFAULT_MOBJECT_TO_MOBJECT_BUFFER,\n        center: bool = True,\n        **kwargs,\n    ) -> Self:\n        \"\"\"Sorts :class:`~.Mobject` next to each other on screen.\n\n        Examples\n        --------\n\n        .. manim:: Example\n            :save_last_frame:\n\n            class Example(Scene):\n                def construct(self):\n                    s1 = Square()\n                    s2 = Square()\n                    s3 = Square()\n                    s4 = Square()\n                    x = VGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.0)\n                    self.add(x)\n        \"\"\"\n        for m1, m2 in zip(self.submobjects, self.submobjects[1:]):\n            m2.next_to(m1, direction, buff, **kwargs)\n        if center:\n            self.center()\n        return self\n\n    def arrange_in_grid(\n        self,\n        rows: int | None = None,\n        cols: int | None = None,\n        buff: float | tuple[float, float] = MED_SMALL_BUFF,\n        cell_alignment: Vector3D = ORIGIN,\n        row_alignments: str | None = None,  # \"ucd\"\n        col_alignments: str | None = None,  # \"lcr\"\n        row_heights: Iterable[float | None] | None = None,\n        col_widths: Iterable[float | None] | None = None,\n        flow_order: str = \"rd\",\n        **kwargs,\n    ) -> Self:\n        \"\"\"Arrange submobjects in a grid.\n\n        Parameters\n        ----------\n        rows\n            The number of rows in the grid.\n        cols\n            The number of columns in the grid.\n        buff\n            The gap between grid cells. To specify a different buffer in the horizontal and\n            vertical directions, a tuple of two values can be given - ``(row, col)``.\n        cell_alignment\n            The way each submobject is aligned in its grid cell.\n        row_alignments\n            The vertical alignment for each row (top to bottom). Accepts the following characters: ``\"u\"`` -\n            up, ``\"c\"`` - center, ``\"d\"`` - down.\n        col_alignments\n            The horizontal alignment for each column (left to right). Accepts the following characters ``\"l\"`` - left,\n            ``\"c\"`` - center, ``\"r\"`` - right.\n        row_heights\n            Defines a list of heights for certain rows (top to bottom). If the list contains\n            ``None``, the corresponding row will fit its height automatically based\n            on the highest element in that row.\n        col_widths\n            Defines a list of widths for certain columns (left to right). If the list contains ``None``, the\n            corresponding column will fit its width automatically based on the widest element in that column.\n        flow_order\n            The order in which submobjects fill the grid. Can be one of the following values:\n            \"rd\", \"dr\", \"ld\", \"dl\", \"ru\", \"ur\", \"lu\", \"ul\". (\"rd\" -> fill rightwards then downwards)\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n        Raises\n        ------\n        ValueError\n            If ``rows`` and ``cols`` are too small to fit all submobjects.\n        ValueError\n            If :code:`cols`, :code:`col_alignments` and :code:`col_widths` or :code:`rows`,\n            :code:`row_alignments` and :code:`row_heights` have mismatching sizes.\n\n        Notes\n        -----\n        If only one of ``cols`` and ``rows`` is set implicitly, the other one will be chosen big\n        enough to fit all submobjects. If neither is set, they will be chosen to be about the same,\n        tending towards ``cols`` > ``rows`` (simply because videos are wider than they are high).\n\n        If both ``cell_alignment`` and ``row_alignments`` / ``col_alignments`` are\n        defined, the latter has higher priority.\n\n        Examples\n        --------\n        .. manim:: ExampleBoxes\n            :save_last_frame:\n\n            class ExampleBoxes(Scene):\n                def construct(self):\n                    boxes=VGroup(*[Square() for s in range(0,6)])\n                    boxes.arrange_in_grid(rows=2, buff=0.1)\n                    self.add(boxes)\n\n\n        .. manim:: ArrangeInGrid\n            :save_last_frame:\n\n            class ArrangeInGrid(Scene):\n                def construct(self):\n                    boxes = VGroup(*[\n                        Rectangle(WHITE, 0.5, 0.5).add(Text(str(i+1)).scale(0.5))\n                        for i in range(24)\n                    ])\n                    self.add(boxes)\n\n                    boxes.arrange_in_grid(\n                        buff=(0.25,0.5),\n                        col_alignments=\"lccccr\",\n                        row_alignments=\"uccd\",\n                        col_widths=[1, *[None]*4, 1],\n                        row_heights=[1, None, None, 1],\n                        flow_order=\"dr\"\n                    )\n\n\n        \"\"\"\n        from manim.mobject.geometry.line import Line\n\n        mobs = self.submobjects.copy()\n        start_pos = self.get_center()\n\n        # get cols / rows values if given (implicitly)\n        def init_size(num, alignments, sizes):\n            if num is not None:\n                return num\n            if alignments is not None:\n                return len(alignments)\n            if sizes is not None:\n                return len(sizes)\n\n        cols = init_size(cols, col_alignments, col_widths)\n        rows = init_size(rows, row_alignments, row_heights)\n\n        # calculate rows cols\n        if rows is None and cols is None:\n            cols = math.ceil(math.sqrt(len(mobs)))\n            # make the grid as close to quadratic as possible.\n            # choosing cols first can results in cols>rows.\n            # This is favored over rows>cols since in general\n            # the sceene is wider than high.\n        if rows is None:\n            rows = math.ceil(len(mobs) / cols)\n        if cols is None:\n            cols = math.ceil(len(mobs) / rows)\n        if rows * cols < len(mobs):\n            raise ValueError(\"Too few rows and columns to fit all submobjetcs.\")\n        # rows and cols are now finally valid.\n\n        if isinstance(buff, tuple):\n            buff_x = buff[0]\n            buff_y = buff[1]\n        else:\n            buff_x = buff_y = buff\n\n        # Initialize alignments correctly\n        def init_alignments(alignments, num, mapping, name, dir_):\n            if alignments is None:\n                # Use cell_alignment as fallback\n                return [cell_alignment * dir_] * num\n            if len(alignments) != num:\n                raise ValueError(f\"{name}_alignments has a mismatching size.\")\n            alignments = list(alignments)\n            for i in range(num):\n                alignments[i] = mapping[alignments[i]]\n            return alignments\n\n        row_alignments = init_alignments(\n            row_alignments,\n            rows,\n            {\"u\": UP, \"c\": ORIGIN, \"d\": DOWN},\n            \"row\",\n            RIGHT,\n        )\n        col_alignments = init_alignments(\n            col_alignments,\n            cols,\n            {\"l\": LEFT, \"c\": ORIGIN, \"r\": RIGHT},\n            \"col\",\n            UP,\n        )\n        # Now row_alignment[r] + col_alignment[c] is the alignment in cell [r][c]\n\n        mapper = {\n            \"dr\": lambda r, c: (rows - r - 1) + c * rows,\n            \"dl\": lambda r, c: (rows - r - 1) + (cols - c - 1) * rows,\n            \"ur\": lambda r, c: r + c * rows,\n            \"ul\": lambda r, c: r + (cols - c - 1) * rows,\n            \"rd\": lambda r, c: (rows - r - 1) * cols + c,\n            \"ld\": lambda r, c: (rows - r - 1) * cols + (cols - c - 1),\n            \"ru\": lambda r, c: r * cols + c,\n            \"lu\": lambda r, c: r * cols + (cols - c - 1),\n        }\n        if flow_order not in mapper:\n            raise ValueError(\n                'flow_order must be one of the following values: \"dr\", \"rd\", \"ld\" \"dl\", \"ru\", \"ur\", \"lu\", \"ul\".',\n            )\n        flow_order = mapper[flow_order]\n\n        # Reverse row_alignments and row_heights. Necessary since the\n        # grid filling is handled bottom up for simplicity reasons.\n        def reverse(maybe_list):\n            if maybe_list is not None:\n                maybe_list = list(maybe_list)\n                maybe_list.reverse()\n                return maybe_list\n\n        row_alignments = reverse(row_alignments)\n        row_heights = reverse(row_heights)\n\n        placeholder = Mobject()\n        # Used to fill up the grid temporarily, doesn't get added to the scene.\n        # In this case a Mobject is better than None since it has width and height\n        # properties of 0.\n\n        mobs.extend([placeholder] * (rows * cols - len(mobs)))\n        grid = [[mobs[flow_order(r, c)] for c in range(cols)] for r in range(rows)]\n\n        measured_heigths = [\n            max(grid[r][c].height for c in range(cols)) for r in range(rows)\n        ]\n        measured_widths = [\n            max(grid[r][c].width for r in range(rows)) for c in range(cols)\n        ]\n\n        # Initialize row_heights / col_widths correctly using measurements as fallback\n        def init_sizes(sizes, num, measures, name):\n            if sizes is None:\n                sizes = [None] * num\n            if len(sizes) != num:\n                raise ValueError(f\"{name} has a mismatching size.\")\n            return [\n                sizes[i] if sizes[i] is not None else measures[i] for i in range(num)\n            ]\n\n        heights = init_sizes(row_heights, rows, measured_heigths, \"row_heights\")\n        widths = init_sizes(col_widths, cols, measured_widths, \"col_widths\")\n\n        x, y = 0, 0\n        for r in range(rows):\n            x = 0\n            for c in range(cols):\n                if grid[r][c] is not placeholder:\n                    alignment = row_alignments[r] + col_alignments[c]\n                    line = Line(\n                        x * RIGHT + y * UP,\n                        (x + widths[c]) * RIGHT + (y + heights[r]) * UP,\n                    )\n                    # Use a mobject to avoid rewriting align inside\n                    # box code that Mobject.move_to(Mobject) already\n                    # includes.\n\n                    grid[r][c].move_to(line, alignment)\n                x += widths[c] + buff_x\n            y += heights[r] + buff_y\n\n        self.move_to(start_pos)\n        return self\n\n    def sort(\n        self,\n        point_to_num_func: Callable[[Point3DLike], float] = lambda p: p[0],\n        submob_func: Callable[[Mobject], Any] | None = None,\n    ) -> Self:\n        \"\"\"Sorts the list of :attr:`submobjects` by a function defined by ``submob_func``.\"\"\"\n        if submob_func is None:\n\n            def submob_func(m: Mobject) -> float:\n                return point_to_num_func(m.get_center())\n\n        self.submobjects.sort(key=submob_func)\n        return self\n\n    def shuffle(self, recursive: bool = False) -> None:\n        \"\"\"Shuffles the list of :attr:`submobjects`.\"\"\"\n        if recursive:\n            for submob in self.submobjects:\n                submob.shuffle(recursive=True)\n        random.shuffle(self.submobjects)\n\n    def invert(self, recursive: bool = False) -> None:\n        \"\"\"Inverts the list of :attr:`submobjects`.\n\n        Parameters\n        ----------\n        recursive\n            If ``True``, all submobject lists of this mobject's family are inverted.\n\n        Examples\n        --------\n\n        .. manim:: InvertSumobjectsExample\n\n            class InvertSumobjectsExample(Scene):\n                def construct(self):\n                    s = VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])\n                    s2 = s.copy()\n                    s2.invert()\n                    s2.shift(DOWN)\n                    self.play(Write(s), Write(s2))\n        \"\"\"\n        if recursive:\n            for submob in self.submobjects:\n                submob.invert(recursive=True)\n        self.submobjects.reverse()\n\n    # Just here to keep from breaking old scenes.\n    def arrange_submobjects(self, *args, **kwargs) -> Self:\n        \"\"\"Arrange the position of :attr:`submobjects` with a small buffer.\n\n        Examples\n        --------\n\n        .. manim:: ArrangeSumobjectsExample\n            :save_last_frame:\n\n            class ArrangeSumobjectsExample(Scene):\n                def construct(self):\n                    s= VGroup(*[Dot().shift(i*0.1*RIGHT*np.random.uniform(-1,1)+UP*np.random.uniform(-1,1)) for i in range(0,15)])\n                    s.shift(UP).set_color(BLUE)\n                    s2= s.copy().set_color(RED)\n                    s2.arrange_submobjects()\n                    s2.shift(DOWN)\n                    self.add(s,s2)\n\n        \"\"\"\n        return self.arrange(*args, **kwargs)\n\n    def sort_submobjects(self, *args, **kwargs) -> Self:\n        \"\"\"Sort the :attr:`submobjects`\"\"\"\n        return self.sort(*args, **kwargs)\n\n    def shuffle_submobjects(self, *args, **kwargs) -> None:\n        \"\"\"Shuffles the order of :attr:`submobjects`\n\n        Examples\n        --------\n\n        .. manim:: ShuffleSubmobjectsExample\n\n            class ShuffleSubmobjectsExample(Scene):\n                def construct(self):\n                    s= VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])\n                    s2= s.copy()\n                    s2.shuffle_submobjects()\n                    s2.shift(DOWN)\n                    self.play(Write(s), Write(s2))\n        \"\"\"\n        return self.shuffle(*args, **kwargs)\n\n    # Alignment\n    def align_data(self, mobject: Mobject, skip_point_alignment: bool = False) -> None:\n        \"\"\"Aligns the family structure and data of this mobject with another mobject.\n\n        Afterwards, the two mobjects will have the same number of submobjects\n        (see :meth:`.align_submobjects`) and the same parent structure (see\n        :meth:`.null_point_align`). If ``skip_point_alignment`` is ``False``,\n        they will also have the same number of points (see :meth:`.align_points`).\n\n        Parameters\n        ----------\n        mobject\n            The other mobject this mobject should be aligned to.\n        skip_point_alignment\n            Controls whether or not the computationally expensive\n            point alignment is skipped (default: ``False``).\n\n\n        .. note::\n\n            This method is primarily used internally by :meth:`.become` and the\n            :class:`~.Transform` animation to ensure that mobjects are structurally\n            compatible before transformation.\n\n        Examples\n        --------\n        ::\n\n            >>> from manim import Rectangle, Line, ORIGIN, RIGHT\n            >>> rect = Rectangle(width=4.0, height=2.0, grid_xstep=1.0, grid_ystep=0.5)\n            >>> line = Line(start=ORIGIN,end=RIGHT)\n            >>> line.align_data(rect)\n            >>> len(line.get_family()) == len(rect.get_family())\n            True\n            >>> line.get_num_points() == rect.get_num_points()\n            True\n\n        See also\n        --------\n        :class:`~.Transform`, :meth:`~.Mobject.become`, :meth:`~.VMobject.align_points`, :meth:`~.Mobject.get_family`\n\n        \"\"\"\n        self.null_point_align(mobject)\n        self.align_submobjects(mobject)\n        if not skip_point_alignment:\n            self.align_points(mobject)\n        # Recurse\n        for m1, m2 in zip(self.submobjects, mobject.submobjects):\n            m1.align_data(m2)\n\n    def get_point_mobject(self, center=None):\n        \"\"\"The simplest :class:`~.Mobject` to be transformed to or from self.\n        Should by a point of the appropriate type\n        \"\"\"\n        msg = f\"get_point_mobject not implemented for {self.__class__.__name__}\"\n        raise NotImplementedError(msg)\n\n    def align_points(self, mobject: Mobject) -> Self:\n        count1 = self.get_num_points()\n        count2 = mobject.get_num_points()\n        if count1 < count2:\n            self.align_points_with_larger(mobject)\n        elif count2 < count1:\n            mobject.align_points_with_larger(self)\n        return self\n\n    def align_points_with_larger(self, larger_mobject: Mobject):\n        raise NotImplementedError(\"Please override in a child class.\")\n\n    def align_submobjects(self, mobject: Mobject) -> Self:\n        mob1 = self\n        mob2 = mobject\n        n1 = len(mob1.submobjects)\n        n2 = len(mob2.submobjects)\n        mob1.add_n_more_submobjects(max(0, n2 - n1))\n        mob2.add_n_more_submobjects(max(0, n1 - n2))\n        return self\n\n    def null_point_align(self, mobject: Mobject):\n        \"\"\"If a :class:`~.Mobject` with points is being aligned to\n        one without, treat both as groups, and push\n        the one with points into its own submobjects\n        list.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n        \"\"\"\n        for m1, m2 in (self, mobject), (mobject, self):\n            if m1.has_no_points() and m2.has_points():\n                m2.push_self_into_submobjects()\n        return self\n\n    def push_self_into_submobjects(self) -> Self:\n        copy = self.copy()\n        copy.submobjects = []\n        self.reset_points()\n        self.add(copy)\n        return self\n\n    def add_n_more_submobjects(self, n: int) -> Self | None:\n        if n == 0:\n            return None\n\n        curr = len(self.submobjects)\n        if curr == 0:\n            # If empty, simply add n point mobjects\n            self.submobjects = [self.get_point_mobject() for k in range(n)]\n            return None\n\n        target = curr + n\n        # TODO, factor this out to utils so as to reuse\n        # with VMobject.insert_n_curves\n        repeat_indices = (np.arange(target) * curr) // target\n        split_factors = [sum(repeat_indices == i) for i in range(curr)]\n        new_submobs = []\n        for submob, sf in zip(self.submobjects, split_factors):\n            new_submobs.append(submob)\n            for _ in range(1, sf):\n                new_submobs.append(submob.copy().fade(1))\n        self.submobjects = new_submobs\n        return self\n\n    def repeat_submobject(self, submob: Mobject) -> Self:\n        return submob.copy()\n\n    def interpolate(\n        self,\n        mobject1: Mobject,\n        mobject2: Mobject,\n        alpha: float,\n        path_func: PathFuncType = straight_path(),\n    ) -> Self:\n        \"\"\"Turns this :class:`~.Mobject` into an interpolation between ``mobject1``\n        and ``mobject2``.\n\n        The interpolation is applied to the points and color of the mobject.\n\n        Parameters\n        ----------\n        mobject1\n            The starting Mobject.\n        mobject2\n            The target Mobject.\n        alpha\n            Interpolation factor between 0 (at ``mobject1``) and 1 (at ``mobject2``).\n        path_func\n            The function defining the interpolation path. Defaults to a straight path.\n\n        Returns\n        -------\n        :class:`Mobject`\n            ``self``\n\n\n        .. note::\n\n            - Both mobjects must have the same number of points. If not, this will raise an error.\n              Use :meth:`~.VMobject.align_points` to match point counts beforehand if needed.\n            - This method is used internally by the :class:`~.Transform` animation\n              to interpolate between two mobjects during a transformation.\n\n        Examples\n        --------\n\n        .. manim:: InterpolateExample\n            :save_last_frame:\n\n            class InterpolateExample(Scene):\n                def construct(self):\n                    # No need for point alignment:\n                    dotL = Dot(color=DARK_GREY).to_edge(LEFT)\n                    dotR = Dot(color=YELLOW).scale(10).to_edge(RIGHT)\n                    dotMid1 = VMobject().interpolate(dotL, dotR, alpha=0.1)\n                    dotMid2 = VMobject().interpolate(dotL, dotR, alpha=0.25)\n                    dotMid3 = VMobject().interpolate(dotL, dotR, alpha=0.5)\n                    dotMid4 = VMobject().interpolate(dotL, dotR, alpha=0.75)\n                    dots = VGroup(dotL, dotR, dotMid1, dotMid2, dotMid3, dotMid4)\n\n                    # Needs point alignment:\n                    line = Line(ORIGIN, UP).to_edge(LEFT)\n                    sq = Square(color=RED, fill_opacity=1, stroke_color=BLUE).to_edge(RIGHT)\n                    line.align_points(sq)\n                    mid1 = VMobject().interpolate(line, sq, alpha=0.1)\n                    mid2 = VMobject().interpolate(line, sq, alpha=0.25)\n                    mid3 = VMobject().interpolate(line, sq, alpha=0.5)\n                    mid4 = VMobject().interpolate(line, sq, alpha=0.75)\n                    linesquares = VGroup(line, sq, mid1, mid2, mid3, mid4)\n\n                    self.add(VGroup(dots, linesquares).arrange(DOWN, buff=1))\n        See also\n        --------\n        :class:`~.Transform`, :meth:`~.VMobject.align_points`, :meth:`~.VMobject.interpolate_color`\n\n        \"\"\"\n        self.points = path_func(mobject1.points, mobject2.points, alpha)\n        self.interpolate_color(mobject1, mobject2, alpha)\n        return self\n\n    def interpolate_color(self, mobject1: Mobject, mobject2: Mobject, alpha: float):\n        raise NotImplementedError(\"Please override in a child class.\")\n\n    def become(\n        self,\n        mobject: Mobject,\n        match_height: bool = False,\n        match_width: bool = False,\n        match_depth: bool = False,\n        match_center: bool = False,\n        stretch: bool = False,\n    ) -> Self:\n        \"\"\"Edit points, colors and submobjects to be identical\n        to another :class:`~.Mobject`\n\n        .. note::\n\n            If both match_height and match_width are ``True`` then the transformed :class:`~.Mobject`\n            will match the height first and then the width.\n\n        Parameters\n        ----------\n        match_height\n            Whether or not to preserve the height of the original\n            :class:`~.Mobject`.\n        match_width\n            Whether or not to preserve the width of the original\n            :class:`~.Mobject`.\n        match_depth\n            Whether or not to preserve the depth of the original\n            :class:`~.Mobject`.\n        match_center\n            Whether or not to preserve the center of the original\n            :class:`~.Mobject`.\n        stretch\n            Whether or not to stretch the target mobject to match the\n            the proportions of the original :class:`~.Mobject`.\n\n        Examples\n        --------\n        .. manim:: BecomeScene\n\n            class BecomeScene(Scene):\n                def construct(self):\n                    circ = Circle(fill_color=RED, fill_opacity=0.8)\n                    square = Square(fill_color=BLUE, fill_opacity=0.2)\n                    self.add(circ)\n                    self.wait(0.5)\n                    circ.become(square)\n                    self.wait(0.5)\n\n\n        The following examples illustrate how mobject measurements\n        change when using the ``match_...`` and ``stretch`` arguments.\n        We start with a rectangle that is 2 units high and 4 units wide,\n        which we want to turn into a circle of radius 3::\n\n            >>> from manim import Rectangle, Circle\n            >>> import numpy as np\n            >>> rect = Rectangle(height=2, width=4)\n            >>> circ = Circle(radius=3)\n\n        With ``stretch=True``, the target circle is deformed to match\n        the proportions of the rectangle, which results in the target\n        mobject being an ellipse with height 2 and width 4. We can\n        check that the resulting points satisfy the ellipse equation\n        :math:`x^2/a^2 + y^2/b^2 = 1` with :math:`a = 4/2` and :math:`b = 2/2`\n        being the semi-axes::\n\n            >>> result = rect.copy().become(circ, stretch=True)\n            >>> result.height, result.width\n            (np.float64(2.0), np.float64(4.0))\n            >>> ellipse_points = np.array(result.get_anchors())\n            >>> ellipse_eq = np.sum(ellipse_points**2 * [1/4, 1, 0], axis=1)\n            >>> np.allclose(ellipse_eq, 1)\n            True\n\n        With ``match_height=True`` and ``match_width=True`` the circle is\n        scaled such that the height or the width of the rectangle will\n        be preserved, respectively.\n        The points of the resulting mobject satisfy the circle equation\n        :math:`x^2 + y^2 = r^2` for the corresponding radius :math:`r`::\n\n            >>> result = rect.copy().become(circ, match_height=True)\n            >>> result.height, result.width\n            (np.float64(2.0), np.float64(2.0))\n            >>> circle_points = np.array(result.get_anchors())\n            >>> circle_eq = np.sum(circle_points**2, axis=1)\n            >>> np.allclose(circle_eq, 1)\n            True\n            >>> result = rect.copy().become(circ, match_width=True)\n            >>> result.height, result.width\n            (np.float64(4.0), np.float64(4.0))\n            >>> circle_points = np.array(result.get_anchors())\n            >>> circle_eq = np.sum(circle_points**2, axis=1)\n            >>> np.allclose(circle_eq, 2**2)\n            True\n\n        With ``match_center=True``, the resulting mobject is moved such that\n        its center is the same as the center of the original mobject::\n\n            >>> rect = rect.shift(np.array([0, 1, 0]))\n            >>> np.allclose(rect.get_center(), circ.get_center())\n            False\n            >>> result = rect.copy().become(circ, match_center=True)\n            >>> np.allclose(rect.get_center(), result.get_center())\n            True\n\n        See also\n        --------\n        :meth:`~.Mobject.align_data`, :meth:`~.VMobject.interpolate_color`\n        \"\"\"\n        mobject = mobject.copy()\n        if stretch:\n            mobject.stretch_to_fit_height(self.height)\n            mobject.stretch_to_fit_width(self.width)\n            mobject.stretch_to_fit_depth(self.depth)\n        else:\n            if match_height:\n                mobject.match_height(self)\n            if match_width:\n                mobject.match_width(self)\n            if match_depth:\n                mobject.match_depth(self)\n\n        if match_center:\n            mobject.move_to(self.get_center())\n\n        self.align_data(mobject, skip_point_alignment=True)\n        for sm1, sm2 in zip(self.get_family(), mobject.get_family()):\n            sm1.points = np.array(sm2.points)\n            sm1.interpolate_color(sm1, sm2, 1)\n        return self\n\n    def match_points(self, mobject: Mobject, copy_submobjects: bool = True) -> Self:\n        \"\"\"Edit points, positions, and submobjects to be identical\n        to another :class:`~.Mobject`, while keeping the style unchanged.\n\n        Examples\n        --------\n        .. manim:: MatchPointsScene\n\n            class MatchPointsScene(Scene):\n                def construct(self):\n                    circ = Circle(fill_color=RED, fill_opacity=0.8)\n                    square = Square(fill_color=BLUE, fill_opacity=0.2)\n                    self.add(circ)\n                    self.wait(0.5)\n                    self.play(circ.animate.match_points(square))\n                    self.wait(0.5)\n        \"\"\"\n        for sm1, sm2 in zip(self.get_family(), mobject.get_family()):\n            sm1.points = np.array(sm2.points)\n        return self\n\n    # Errors\n    def throw_error_if_no_points(self) -> None:\n        if self.has_no_points():\n            caller_name = sys._getframe(1).f_code.co_name\n            raise Exception(\n                f\"Cannot call Mobject.{caller_name} for a Mobject with no points\",\n            )\n\n    # About z-index\n    def set_z_index(\n        self,\n        z_index_value: float,\n        family: bool = True,\n    ) -> Self:\n        \"\"\"Sets the :class:`~.Mobject`'s :attr:`z_index` to the value specified in `z_index_value`.\n\n        Parameters\n        ----------\n        z_index_value\n            The new value of :attr:`z_index` set.\n        family\n            If ``True``, the :attr:`z_index` value of all submobjects is also set.\n\n        Returns\n        -------\n        :class:`Mobject`\n            The Mobject itself, after :attr:`z_index` is set. For chaining purposes. (Returns `self`.)\n\n        Examples\n        --------\n        .. manim:: SetZIndex\n            :save_last_frame:\n\n            class SetZIndex(Scene):\n                def construct(self):\n                    text = Text('z_index = 3', color = PURE_RED).shift(UP).set_z_index(3)\n                    square = Square(2, fill_opacity=1).set_z_index(2)\n                    tex = Tex(r'zIndex = 1', color = PURE_BLUE).shift(DOWN).set_z_index(1)\n                    circle = Circle(radius = 1.7, color = GREEN, fill_opacity = 1) # z_index = 0\n\n                    # Displaying order is now defined by z_index values\n                    self.add(text)\n                    self.add(square)\n                    self.add(tex)\n                    self.add(circle)\n        \"\"\"\n        if family:\n            for submob in self.submobjects:\n                submob.set_z_index(z_index_value, family=family)\n        self.z_index = z_index_value\n        return self\n\n    def set_z_index_by_z_Point3D(self) -> Self:\n        \"\"\"Sets the :class:`~.Mobject`'s z Point3D to the value of :attr:`z_index`.\n\n        Returns\n        -------\n        :class:`Mobject`\n            The Mobject itself, after :attr:`z_index` is set. (Returns `self`.)\n        \"\"\"\n        z_coord = self.get_center()[-1]\n        self.set_z_index(z_coord)\n        return self"}, {"name": "Mobject1D", "code": "class Mobject1D(PMobject, metaclass=ConvertToOpenGL):\n    def __init__(self, density: int = DEFAULT_POINT_DENSITY_1D, **kwargs: Any) -> None:\n        self.density = density\n        self.epsilon = 1.0 / self.density\n        super().__init__(**kwargs)\n\n    def add_line(\n        self,\n        start: npt.NDArray,\n        end: npt.NDArray,\n        color: ParsableManimColor | None = None,\n    ) -> None:\n        start, end = list(map(np.array, [start, end]))\n        length = np.linalg.norm(end - start)\n        if length == 0:\n            points = np.array([start])\n        else:\n            epsilon = self.epsilon / length\n            points = np.array(\n                [interpolate(start, end, t) for t in np.arange(0, 1, epsilon)]\n            )\n        self.add_points(points, color=color)"}, {"name": "Mobject2D", "code": "class Mobject2D(PMobject, metaclass=ConvertToOpenGL):\n    def __init__(self, density: int = DEFAULT_POINT_DENSITY_2D, **kwargs: Any) -> None:\n        self.density = density\n        self.epsilon = 1.0 / self.density\n        super().__init__(**kwargs)"}, {"name": "MobjectMatrix", "code": "class MobjectMatrix(Matrix):\n    r\"\"\"A mobject that displays a matrix of mobject entries on the screen.\n\n    Examples\n    --------\n\n    .. manim:: MobjectMatrixExample\n        :save_last_frame:\n\n        class MobjectMatrixExample(Scene):\n            def construct(self):\n                a = Circle().scale(0.3)\n                b = Square().scale(0.3)\n                c = MathTex(\"\\\\pi\").scale(2)\n                d = Star().scale(0.3)\n                m0 = MobjectMatrix([[a, b], [c, d]])\n                self.add(m0)\n    \"\"\"\n\n    def __init__(self, matrix, element_to_mobject=lambda m: m, **kwargs):\n        super().__init__(matrix, element_to_mobject=element_to_mobject, **kwargs)"}, {"name": "MobjectTable", "code": "class MobjectTable(Table):\n    \"\"\"A specialized :class:`~.Table` mobject for use with :class:`~.Mobject`.\n\n    Examples\n    --------\n\n    .. manim:: MobjectTableExample\n        :save_last_frame:\n\n        class MobjectTableExample(Scene):\n            def construct(self):\n                cross = VGroup(\n                    Line(UP + LEFT, DOWN + RIGHT),\n                    Line(UP + RIGHT, DOWN + LEFT),\n                )\n                a = Circle().set_color(RED).scale(0.5)\n                b = cross.set_color(BLUE).scale(0.5)\n                t0 = MobjectTable(\n                    [[a.copy(),b.copy(),a.copy()],\n                    [b.copy(),a.copy(),a.copy()],\n                    [a.copy(),b.copy(),b.copy()]]\n                )\n                line = Line(\n                    t0.get_corner(DL), t0.get_corner(UR)\n                ).set_color(RED)\n                self.add(t0, line)\n    \"\"\"\n\n    def __init__(\n        self,\n        table: Iterable[Iterable[VMobject]],\n        element_to_mobject: Callable[[VMobject], VMobject] = lambda m: m,\n        **kwargs,\n    ):\n        \"\"\"\n        Special case of :class:`~.Table` with ``element_to_mobject`` set to an identity function.\n        Here, every item in ``table`` must already be of type :class:`~.Mobject`.\n\n        Parameters\n        ----------\n        table\n            A 2D array or list of lists. Content of the table must be of type :class:`~.Mobject`.\n        element_to_mobject\n            The :class:`~.Mobject` class applied to the table entries. Set as ``lambda m : m`` to return itself.\n        kwargs\n            Additional arguments to be passed to :class:`~.Table`.\n        \"\"\"\n        super().__init__(table, element_to_mobject=element_to_mobject, **kwargs)"}, {"name": "modify_atime", "code": "def modify_atime(file_path: str) -> None:\n    \"\"\"Will manually change the accessed time (called `atime`) of the file, as on a lot of OS the accessed time refresh is disabled by default.\n\n    Parameters\n    ----------\n    file_path\n        The path of the file.\n    \"\"\"\n    os.utime(file_path, times=(time.time(), Path(file_path).stat().st_mtime))"}, {"name": "MoveAlongPath", "code": "class MoveAlongPath(Animation):\n    \"\"\"Make one mobject move along the path of another mobject.\n\n    .. manim:: MoveAlongPathExample\n\n        class MoveAlongPathExample(Scene):\n            def construct(self):\n                d1 = Dot().set_color(ORANGE)\n                l1 = Line(LEFT, RIGHT)\n                l2 = VMobject()\n                self.add(d1, l1, l2)\n                l2.add_updater(lambda x: x.become(Line(LEFT, d1.get_center()).set_color(ORANGE)))\n                self.play(MoveAlongPath(d1, l1), rate_func=linear)\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        path: VMobject,\n        suspend_mobject_updating: bool | None = False,\n        **kwargs,\n    ) -> None:\n        self.path = path\n        super().__init__(\n            mobject, suspend_mobject_updating=suspend_mobject_updating, **kwargs\n        )\n\n    def interpolate_mobject(self, alpha: float) -> None:\n        point = self.path.point_from_proportion(self.rate_func(alpha))\n        self.mobject.move_to(point)"}, {"name": "MoveToTarget", "code": "class MoveToTarget(Transform):\n    \"\"\"Transforms a mobject to the mobject stored in its ``target`` attribute.\n\n    After calling the :meth:`~.Mobject.generate_target` method, the :attr:`target`\n    attribute of the mobject is populated with a copy of it. After modifying the attribute,\n    playing the :class:`.MoveToTarget` animation transforms the original mobject\n    into the modified one stored in the :attr:`target` attribute.\n\n    Examples\n    --------\n\n    .. manim:: MoveToTargetExample\n\n        class MoveToTargetExample(Scene):\n            def construct(self):\n                c = Circle()\n\n                c.generate_target()\n                c.target.set_fill(color=GREEN, opacity=0.5)\n                c.target.shift(2*RIGHT + UP).scale(0.5)\n\n                self.add(c)\n                self.play(MoveToTarget(c))\n\n    \"\"\"\n\n    def __init__(self, mobject: Mobject, **kwargs) -> None:\n        self.check_validity_of_input(mobject)\n        super().__init__(mobject, mobject.target, **kwargs)\n\n    def check_validity_of_input(self, mobject: Mobject) -> None:\n        if not hasattr(mobject, \"target\"):\n            raise ValueError(\n                \"MoveToTarget called on mobjectwithout attribute 'target'\",\n            )"}, {"name": "MovingCamera", "code": "class MovingCamera(Camera):\n    \"\"\"\n    Stays in line with the height, width and position of it's 'frame', which is a Rectangle\n\n    .. SEEALSO::\n\n        :class:`.MovingCameraScene`\n\n    \"\"\"\n\n    def __init__(\n        self,\n        frame=None,\n        fixed_dimension=0,  # width\n        default_frame_stroke_color=WHITE,\n        default_frame_stroke_width=0,\n        **kwargs,\n    ):\n        \"\"\"\n        Frame is a Mobject, (should almost certainly be a rectangle)\n        determining which region of space the camera displays\n        \"\"\"\n        self.fixed_dimension = fixed_dimension\n        self.default_frame_stroke_color = default_frame_stroke_color\n        self.default_frame_stroke_width = default_frame_stroke_width\n        if frame is None:\n            frame = ScreenRectangle(height=config[\"frame_height\"])\n            frame.set_stroke(\n                self.default_frame_stroke_color,\n                self.default_frame_stroke_width,\n            )\n        self.frame = frame\n        super().__init__(**kwargs)\n\n    # TODO, make these work for a rotated frame\n    @property\n    def frame_height(self):\n        \"\"\"Returns the height of the frame.\n\n        Returns\n        -------\n        float\n            The height of the frame.\n        \"\"\"\n        return self.frame.height\n\n    @property\n    def frame_width(self):\n        \"\"\"Returns the width of the frame\n\n        Returns\n        -------\n        float\n            The width of the frame.\n        \"\"\"\n        return self.frame.width\n\n    @property\n    def frame_center(self):\n        \"\"\"Returns the centerpoint of the frame in cartesian coordinates.\n\n        Returns\n        -------\n        np.array\n            The cartesian coordinates of the center of the frame.\n        \"\"\"\n        return self.frame.get_center()\n\n    @frame_height.setter\n    def frame_height(self, frame_height: float):\n        \"\"\"Sets the height of the frame in MUnits.\n\n        Parameters\n        ----------\n        frame_height\n            The new frame_height.\n        \"\"\"\n        self.frame.stretch_to_fit_height(frame_height)\n\n    @frame_width.setter\n    def frame_width(self, frame_width: float):\n        \"\"\"Sets the width of the frame in MUnits.\n\n        Parameters\n        ----------\n        frame_width\n            The new frame_width.\n        \"\"\"\n        self.frame.stretch_to_fit_width(frame_width)\n\n    @frame_center.setter\n    def frame_center(self, frame_center: np.ndarray | list | tuple | Mobject):\n        \"\"\"Sets the centerpoint of the frame.\n\n        Parameters\n        ----------\n        frame_center\n            The point to which the frame must be moved.\n            If is of type mobject, the frame will be moved to\n            the center of that mobject.\n        \"\"\"\n        self.frame.move_to(frame_center)\n\n    def capture_mobjects(self, mobjects, **kwargs):\n        # self.reset_frame_center()\n        # self.realign_frame_shape()\n        super().capture_mobjects(mobjects, **kwargs)\n\n    # Since the frame can be moving around, the cairo\n    # context used for updating should be regenerated\n    # at each frame.  So no caching.\n    def get_cached_cairo_context(self, pixel_array):\n        \"\"\"\n        Since the frame can be moving around, the cairo\n        context used for updating should be regenerated\n        at each frame.  So no caching.\n        \"\"\"\n        return None\n\n    def cache_cairo_context(self, pixel_array, ctx):\n        \"\"\"\n        Since the frame can be moving around, the cairo\n        context used for updating should be regenerated\n        at each frame.  So no caching.\n        \"\"\"\n        pass\n\n    # def reset_frame_center(self):\n    #     self.frame_center = self.frame.get_center()\n\n    # def realign_frame_shape(self):\n    #     height, width = self.frame_shape\n    #     if self.fixed_dimension == 0:\n    #         self.frame_shape = (height, self.frame.width\n    #     else:\n    #         self.frame_shape = (self.frame.height, width)\n    #     self.resize_frame_shape(fixed_dimension=self.fixed_dimension)\n\n    def get_mobjects_indicating_movement(self):\n        \"\"\"\n        Returns all mobjects whose movement implies that the camera\n        should think of all other mobjects on the screen as moving\n\n        Returns\n        -------\n        list\n        \"\"\"\n        return [self.frame]\n\n    def auto_zoom(\n        self,\n        mobjects: list[Mobject],\n        margin: float = 0,\n        only_mobjects_in_frame: bool = False,\n        animate: bool = True,\n    ):\n        \"\"\"Zooms on to a given array of mobjects (or a singular mobject)\n        and automatically resizes to frame all the mobjects.\n\n        .. NOTE::\n\n            This method only works when 2D-objects in the XY-plane are considered, it\n            will not work correctly when the camera has been rotated.\n\n        Parameters\n        ----------\n        mobjects\n            The mobject or array of mobjects that the camera will focus on.\n\n        margin\n            The width of the margin that is added to the frame (optional, 0 by default).\n\n        only_mobjects_in_frame\n            If set to ``True``, only allows focusing on mobjects that are already in frame.\n\n        animate\n            If set to ``False``, applies the changes instead of returning the corresponding animation\n\n        Returns\n        -------\n        Union[_AnimationBuilder, ScreenRectangle]\n            _AnimationBuilder that zooms the camera view to a given list of mobjects\n            or ScreenRectangle with position and size updated to zoomed position.\n\n        \"\"\"\n        scene_critical_x_left = None\n        scene_critical_x_right = None\n        scene_critical_y_up = None\n        scene_critical_y_down = None\n\n        for m in mobjects:\n            if (m == self.frame) or (\n                only_mobjects_in_frame and not self.is_in_frame(m)\n            ):\n                # detected camera frame, should not be used to calculate final position of camera\n                continue\n\n            # initialize scene critical points with first mobjects critical points\n            if scene_critical_x_left is None:\n                scene_critical_x_left = m.get_critical_point(LEFT)[0]\n                scene_critical_x_right = m.get_critical_point(RIGHT)[0]\n                scene_critical_y_up = m.get_critical_point(UP)[1]\n                scene_critical_y_down = m.get_critical_point(DOWN)[1]\n\n            else:\n                if m.get_critical_point(LEFT)[0] < scene_critical_x_left:\n                    scene_critical_x_left = m.get_critical_point(LEFT)[0]\n\n                if m.get_critical_point(RIGHT)[0] > scene_critical_x_right:\n                    scene_critical_x_right = m.get_critical_point(RIGHT)[0]\n\n                if m.get_critical_point(UP)[1] > scene_critical_y_up:\n                    scene_critical_y_up = m.get_critical_point(UP)[1]\n\n                if m.get_critical_point(DOWN)[1] < scene_critical_y_down:\n                    scene_critical_y_down = m.get_critical_point(DOWN)[1]\n\n        # calculate center x and y\n        x = (scene_critical_x_left + scene_critical_x_right) / 2\n        y = (scene_critical_y_up + scene_critical_y_down) / 2\n\n        # calculate proposed width and height of zoomed scene\n        new_width = abs(scene_critical_x_left - scene_critical_x_right)\n        new_height = abs(scene_critical_y_up - scene_critical_y_down)\n\n        m_target = self.frame.animate if animate else self.frame\n        # zoom to fit all mobjects along the side that has the largest size\n        if new_width / self.frame.width > new_height / self.frame.height:\n            return m_target.set_x(x).set_y(y).set(width=new_width + margin)\n        else:\n            return m_target.set_x(x).set_y(y).set(height=new_height + margin)"}, {"name": "MovingCameraScene", "code": "class MovingCameraScene(Scene):\n    \"\"\"\n    This is a Scene, with special configurations and properties that\n    make it suitable for cases where the camera must be moved around.\n\n    Note: Examples are included in the moving_camera_scene module\n    documentation, see below in the 'see also' section.\n\n    .. SEEALSO::\n\n        :mod:`.moving_camera_scene`\n        :class:`.MovingCamera`\n    \"\"\"\n\n    def __init__(self, camera_class=MovingCamera, **kwargs):\n        super().__init__(camera_class=camera_class, **kwargs)\n\n    def get_moving_mobjects(self, *animations: Animation):\n        \"\"\"\n        This method returns a list of all of the Mobjects in the Scene that\n        are moving, that are also in the animations passed.\n\n        Parameters\n        ----------\n        *animations\n            The Animations whose mobjects will be checked.\n        \"\"\"\n        moving_mobjects = super().get_moving_mobjects(*animations)\n        all_moving_mobjects = extract_mobject_family_members(moving_mobjects)\n        movement_indicators = self.renderer.camera.get_mobjects_indicating_movement()\n        for movement_indicator in movement_indicators:\n            if movement_indicator in all_moving_mobjects:\n                # When one of these is moving, the camera should\n                # consider all mobjects to be moving\n                return list_update(self.mobjects, moving_mobjects)\n        return moving_mobjects"}, {"name": "MultiAnimationOverrideException", "code": "class MultiAnimationOverrideException(Exception):\n    pass"}, {"name": "MultiCamera", "code": "class MultiCamera(MovingCamera):\n    \"\"\"Camera Object that allows for multiple perspectives.\"\"\"\n\n    def __init__(\n        self,\n        image_mobjects_from_cameras: ImageMobject | None = None,\n        allow_cameras_to_capture_their_own_display=False,\n        **kwargs,\n    ):\n        \"\"\"Initialises the MultiCamera\n\n        Parameters\n        ----------\n        image_mobjects_from_cameras\n\n        kwargs\n            Any valid keyword arguments of MovingCamera.\n        \"\"\"\n        self.image_mobjects_from_cameras = []\n        if image_mobjects_from_cameras is not None:\n            for imfc in image_mobjects_from_cameras:\n                self.add_image_mobject_from_camera(imfc)\n        self.allow_cameras_to_capture_their_own_display = (\n            allow_cameras_to_capture_their_own_display\n        )\n        super().__init__(**kwargs)\n\n    def add_image_mobject_from_camera(self, image_mobject_from_camera: ImageMobject):\n        \"\"\"Adds an ImageMobject that's been obtained from the camera\n        into the list ``self.image_mobject_from_cameras``\n\n        Parameters\n        ----------\n        image_mobject_from_camera\n            The ImageMobject to add to self.image_mobject_from_cameras\n        \"\"\"\n        # A silly method to have right now, but maybe there are things\n        # we want to guarantee about any imfc's added later.\n        imfc = image_mobject_from_camera\n        assert isinstance(imfc.camera, MovingCamera)\n        self.image_mobjects_from_cameras.append(imfc)\n\n    def update_sub_cameras(self):\n        \"\"\"Reshape sub_camera pixel_arrays\"\"\"\n        for imfc in self.image_mobjects_from_cameras:\n            pixel_height, pixel_width = self.pixel_array.shape[:2]\n            imfc.camera.frame_shape = (\n                imfc.camera.frame.height,\n                imfc.camera.frame.width,\n            )\n            imfc.camera.reset_pixel_shape(\n                int(pixel_height * imfc.height / self.frame_height),\n                int(pixel_width * imfc.width / self.frame_width),\n            )\n\n    def reset(self):\n        \"\"\"Resets the MultiCamera.\n\n        Returns\n        -------\n        MultiCamera\n            The reset MultiCamera\n        \"\"\"\n        for imfc in self.image_mobjects_from_cameras:\n            imfc.camera.reset()\n        super().reset()\n        return self\n\n    def capture_mobjects(self, mobjects, **kwargs):\n        self.update_sub_cameras()\n        for imfc in self.image_mobjects_from_cameras:\n            to_add = list(mobjects)\n            if not self.allow_cameras_to_capture_their_own_display:\n                to_add = list_difference_update(to_add, imfc.get_family())\n            imfc.camera.capture_mobjects(to_add, **kwargs)\n        super().capture_mobjects(mobjects, **kwargs)\n\n    def get_mobjects_indicating_movement(self):\n        \"\"\"Returns all mobjects whose movement implies that the camera\n        should think of all other mobjects on the screen as moving\n\n        Returns\n        -------\n        list\n        \"\"\"\n        return [self.frame] + [\n            imfc.camera.frame for imfc in self.image_mobjects_from_cameras\n        ]"}, {"name": "norm_squared", "code": "def norm_squared(v: float) -> float:\n    val: float = np.dot(v, v)\n    return val"}, {"name": "normalize", "code": "def normalize(\n    vect: np.ndarray | tuple[float], fall_back: np.ndarray | None = None\n) -> np.ndarray:\n    norm = np.linalg.norm(vect)\n    if norm > 0:\n        return np.array(vect) / norm\n    else:\n        return fall_back or np.zeros(len(vect))"}, {"name": "normalize_along_axis", "code": "def normalize_along_axis(array: np.ndarray, axis: np.ndarray) -> np.ndarray:\n    \"\"\"Normalizes an array with the provided axis.\n\n    Parameters\n    ----------\n    array\n        The array which has to be normalized.\n    axis\n        The axis to be normalized to.\n\n    Returns\n    -------\n    np.ndarray\n        Array which has been normalized according to the axis.\n    \"\"\"\n    norms = np.sqrt((array * array).sum(axis))\n    norms[norms == 0] = 1\n    buffed_norms = np.repeat(norms, array.shape[axis]).reshape(array.shape)\n    array /= buffed_norms\n    return array"}, {"name": "not_quite_there", "code": "def not_quite_there(\n    func: RateFunction = smooth,\n    proportion: float = 0.7,\n) -> RateFunction:\n    def result(t: float, *args: Any, **kwargs: Any) -> float:\n        return proportion * func(t, *args, **kwargs)\n\n    return result"}, {"name": "NumberLine", "code": "class NumberLine(Line):\n    \"\"\"Creates a number line with tick marks.\n\n    Parameters\n    ----------\n    x_range\n        The ``[x_min, x_max, x_step]`` values to create the line.\n    length\n        The length of the number line.\n    unit_size\n        The distance between each tick of the line. Overwritten by :attr:`length`, if specified.\n    include_ticks\n        Whether to include ticks on the number line.\n    tick_size\n        The length of each tick mark.\n    numbers_with_elongated_ticks\n        An iterable of specific values with elongated ticks.\n    longer_tick_multiple\n        Influences how many times larger elongated ticks are than regular ticks (2 = 2x).\n    rotation\n        The angle (in radians) at which the line is rotated.\n    stroke_width\n        The thickness of the line.\n    include_tip\n        Whether to add a tip to the end of the line.\n    tip_width\n        The width of the tip.\n    tip_height\n        The height of the tip.\n    tip_shape\n        The mobject class used to construct the tip, or ``None`` (the\n        default) for the default arrow tip. Passed classes have to inherit\n        from :class:`.ArrowTip`.\n    include_numbers\n        Whether to add numbers to the tick marks. The number of decimal places is determined\n        by the step size, this default can be overridden by ``decimal_number_config``.\n    scaling\n        The way the ``x_range`` is value is scaled, i.e. :class:`~.LogBase` for a logarithmic numberline. Defaults to :class:`~.LinearBase`.\n    font_size\n        The size of the label mobjects. Defaults to 36.\n    label_direction\n        The specific position to which label mobjects are added on the line.\n    label_constructor\n        Determines the mobject class that will be used to construct the labels of the number line.\n    line_to_number_buff\n        The distance between the line and the label mobject.\n    decimal_number_config\n        Arguments that can be passed to :class:`~.numbers.DecimalNumber` to influence number mobjects.\n    numbers_to_exclude\n        An explicit iterable of numbers to not be added to the number line.\n    numbers_to_include\n        An explicit iterable of numbers to add to the number line\n    kwargs\n        Additional arguments to be passed to :class:`~.Line`.\n\n\n    .. note::\n\n        Number ranges that include both negative and positive values will be generated\n        from the 0 point, and may not include a tick at the min / max\n        values as the tick locations are dependent on the step size.\n\n    Examples\n    --------\n    .. manim:: NumberLineExample\n        :save_last_frame:\n\n        class NumberLineExample(Scene):\n            def construct(self):\n                l0 = NumberLine(\n                    x_range=[-10, 10, 2],\n                    length=10,\n                    color=BLUE,\n                    include_numbers=True,\n                    label_direction=UP,\n                )\n\n                l1 = NumberLine(\n                    x_range=[-10, 10, 2],\n                    unit_size=0.5,\n                    numbers_with_elongated_ticks=[-2, 4],\n                    include_numbers=True,\n                    font_size=24,\n                )\n                num6 = l1.numbers[8]\n                num6.set_color(RED)\n\n                l2 = NumberLine(\n                    x_range=[-2.5, 2.5 + 0.5, 0.5],\n                    length=12,\n                    decimal_number_config={\"num_decimal_places\": 2},\n                    include_numbers=True,\n                )\n\n                l3 = NumberLine(\n                    x_range=[-5, 5 + 1, 1],\n                    length=6,\n                    include_tip=True,\n                    include_numbers=True,\n                    rotation=10 * DEGREES,\n                )\n\n                line_group = VGroup(l0, l1, l2, l3).arrange(DOWN, buff=1)\n                self.add(line_group)\n    \"\"\"\n\n    def __init__(\n        self,\n        x_range: Sequence[float] | None = None,  # must be first\n        length: float | None = None,\n        unit_size: float = 1,\n        # ticks\n        include_ticks: bool = True,\n        tick_size: float = 0.1,\n        numbers_with_elongated_ticks: Iterable[float] | None = None,\n        longer_tick_multiple: int = 2,\n        exclude_origin_tick: bool = False,\n        # visuals\n        rotation: float = 0,\n        stroke_width: float = 2.0,\n        # tip\n        include_tip: bool = False,\n        tip_width: float = DEFAULT_ARROW_TIP_LENGTH,\n        tip_height: float = DEFAULT_ARROW_TIP_LENGTH,\n        tip_shape: type[ArrowTip] | None = None,\n        # numbers/labels\n        include_numbers: bool = False,\n        font_size: float = 36,\n        label_direction: Sequence[float] = DOWN,\n        label_constructor: VMobject = MathTex,\n        scaling: _ScaleBase = LinearBase(),\n        line_to_number_buff: float = MED_SMALL_BUFF,\n        decimal_number_config: dict | None = None,\n        numbers_to_exclude: Iterable[float] | None = None,\n        numbers_to_include: Iterable[float] | None = None,\n        **kwargs,\n    ):\n        # avoid mutable arguments in defaults\n        if numbers_to_exclude is None:\n            numbers_to_exclude = []\n        if numbers_with_elongated_ticks is None:\n            numbers_with_elongated_ticks = []\n\n        if x_range is None:\n            x_range = [\n                round(-config[\"frame_x_radius\"]),\n                round(config[\"frame_x_radius\"]),\n                1,\n            ]\n        elif len(x_range) == 2:\n            # adds x_step if not specified. not sure how to feel about this. a user can't know default without peeking at source code\n            x_range = [*x_range, 1]\n\n        if decimal_number_config is None:\n            decimal_number_config = {\n                \"num_decimal_places\": self._decimal_places_from_step(x_range[2]),\n            }\n\n        # turn into a NumPy array to scale by just applying the function\n        self.x_range = np.array(x_range, dtype=float)\n        self.x_min, self.x_max, self.x_step = scaling.function(self.x_range)\n        self.length = length\n        self.unit_size = unit_size\n        # ticks\n        self.include_ticks = include_ticks\n        self.tick_size = tick_size\n        self.numbers_with_elongated_ticks = numbers_with_elongated_ticks\n        self.longer_tick_multiple = longer_tick_multiple\n        self.exclude_origin_tick = exclude_origin_tick\n        # visuals\n        self.rotation = rotation\n        # tip\n        self.include_tip = include_tip\n        self.tip_width = tip_width\n        self.tip_height = tip_height\n        # numbers\n        self.font_size = font_size\n        self.include_numbers = include_numbers\n        self.label_direction = label_direction\n        self.label_constructor = label_constructor\n        self.line_to_number_buff = line_to_number_buff\n        self.decimal_number_config = decimal_number_config\n        self.numbers_to_exclude = numbers_to_exclude\n        self.numbers_to_include = numbers_to_include\n\n        self.scaling = scaling\n        super().__init__(\n            self.x_range[0] * RIGHT,\n            self.x_range[1] * RIGHT,\n            stroke_width=stroke_width,\n            **kwargs,\n        )\n\n        if self.length:\n            self.set_length(self.length)\n            self.unit_size = self.get_unit_size()\n        else:\n            self.scale(self.unit_size)\n\n        self.center()\n\n        if self.include_tip:\n            self.add_tip(\n                tip_length=self.tip_height,\n                tip_width=self.tip_width,\n                tip_shape=tip_shape,\n            )\n            self.tip.set_stroke(self.stroke_color, self.stroke_width)\n\n        if self.include_ticks:\n            self.add_ticks()\n\n        self.rotate(self.rotation)\n        if self.include_numbers or self.numbers_to_include is not None:\n            if self.scaling.custom_labels:\n                tick_range = self.get_tick_range()\n\n                self.add_labels(\n                    dict(\n                        zip(\n                            tick_range,\n                            self.scaling.get_custom_labels(\n                                tick_range,\n                                unit_decimal_places=decimal_number_config[\n                                    \"num_decimal_places\"\n                                ],\n                            ),\n                        )\n                    ),\n                )\n\n            else:\n                self.add_numbers(\n                    x_values=self.numbers_to_include,\n                    excluding=self.numbers_to_exclude,\n                    font_size=self.font_size,\n                )\n\n    def rotate_about_zero(self, angle: float, axis: Sequence[float] = OUT, **kwargs):\n        return self.rotate_about_number(0, angle, axis, **kwargs)\n\n    def rotate_about_number(\n        self, number: float, angle: float, axis: Sequence[float] = OUT, **kwargs\n    ):\n        return self.rotate(angle, axis, about_point=self.n2p(number), **kwargs)\n\n    def add_ticks(self):\n        \"\"\"Adds ticks to the number line. Ticks can be accessed after creation\n        via ``self.ticks``.\n        \"\"\"\n        ticks = VGroup()\n        elongated_tick_size = self.tick_size * self.longer_tick_multiple\n        elongated_tick_offsets = self.numbers_with_elongated_ticks - self.x_min\n        for x in self.get_tick_range():\n            size = self.tick_size\n            if np.any(np.isclose(x - self.x_min, elongated_tick_offsets)):\n                size = elongated_tick_size\n            ticks.add(self.get_tick(x, size))\n        self.add(ticks)\n        self.ticks = ticks\n\n    def get_tick(self, x: float, size: float | None = None) -> Line:\n        \"\"\"Generates a tick and positions it along the number line.\n\n        Parameters\n        ----------\n        x\n            The position of the tick.\n        size\n            The factor by which the tick is scaled.\n\n        Returns\n        -------\n        :class:`~.Line`\n            A positioned tick.\n        \"\"\"\n        if size is None:\n            size = self.tick_size\n        result = Line(size * DOWN, size * UP)\n        result.rotate(self.get_angle())\n        result.move_to(self.number_to_point(x))\n        result.match_style(self)\n        return result\n\n    def get_tick_marks(self) -> VGroup:\n        return self.ticks\n\n    def get_tick_range(self) -> np.ndarray:\n        \"\"\"Generates the range of values on which labels are plotted based on the\n        ``x_range`` attribute of the number line.\n\n        Returns\n        -------\n        np.ndarray\n            A numpy array of floats represnting values along the number line.\n        \"\"\"\n        x_min, x_max, x_step = self.x_range\n        if not self.include_tip:\n            x_max += 1e-6\n\n        # Handle cases where min and max are both positive or both negative\n        if x_min < x_max < 0 or x_max > x_min > 0:\n            tick_range = np.arange(x_min, x_max, x_step)\n        else:\n            start_point = 0\n            if self.exclude_origin_tick:\n                start_point += x_step\n\n            x_min_segment = np.arange(start_point, np.abs(x_min) + 1e-6, x_step) * -1\n            x_max_segment = np.arange(start_point, x_max, x_step)\n\n            tick_range = np.unique(np.concatenate((x_min_segment, x_max_segment)))\n\n        return self.scaling.function(tick_range)\n\n    def number_to_point(self, number: float | np.ndarray) -> np.ndarray:\n        \"\"\"Accepts a value along the number line and returns a point with\n        respect to the scene.\n        Equivalent to `NumberLine @ number`\n\n        Parameters\n        ----------\n        number\n            The value to be transformed into a coordinate. Or a list of values.\n\n        Returns\n        -------\n        np.ndarray\n            A point with respect to the scene's coordinate system. Or a list of points.\n\n        Examples\n        --------\n\n            >>> from manim import NumberLine\n            >>> number_line = NumberLine()\n            >>> number_line.number_to_point(0)\n            array([0., 0., 0.])\n            >>> number_line.number_to_point(1)\n            array([1., 0., 0.])\n            >>> number_line @ 1\n            array([1., 0., 0.])\n            >>> number_line.number_to_point([1, 2, 3])\n            array([[1., 0., 0.],\n                   [2., 0., 0.],\n                   [3., 0., 0.]])\n        \"\"\"\n        number = np.asarray(number)\n        scalar = number.ndim == 0\n        number = self.scaling.inverse_function(number)\n        alphas = (number - self.x_range[0]) / (self.x_range[1] - self.x_range[0])\n        alphas = float(alphas) if scalar else np.vstack(alphas)\n        val = interpolate(self.get_start(), self.get_end(), alphas)\n        return val\n\n    def point_to_number(self, point: Sequence[float]) -> float:\n        \"\"\"Accepts a point with respect to the scene and returns\n        a float along the number line.\n\n        Parameters\n        ----------\n        point\n            A sequence of values consisting of ``(x_coord, y_coord, z_coord)``.\n\n        Returns\n        -------\n        float\n            A float representing a value along the number line.\n\n        Examples\n        --------\n\n            >>> from manim import NumberLine\n            >>> number_line = NumberLine()\n            >>> number_line.point_to_number((0, 0, 0))\n            np.float64(0.0)\n            >>> number_line.point_to_number((1, 0, 0))\n            np.float64(1.0)\n            >>> number_line.point_to_number([[0.5, 0, 0], [1, 0, 0], [1.5, 0, 0]])\n            array([0.5, 1. , 1.5])\n\n        \"\"\"\n        point = np.asarray(point)\n        start, end = self.get_start_and_end()\n        unit_vect = normalize(end - start)\n        proportion = np.dot(point - start, unit_vect) / np.dot(end - start, unit_vect)\n        return interpolate(self.x_min, self.x_max, proportion)\n\n    def n2p(self, number: float | np.ndarray) -> np.ndarray:\n        \"\"\"Abbreviation for :meth:`~.NumberLine.number_to_point`.\"\"\"\n        return self.number_to_point(number)\n\n    def p2n(self, point: Sequence[float]) -> float:\n        \"\"\"Abbreviation for :meth:`~.NumberLine.point_to_number`.\"\"\"\n        return self.point_to_number(point)\n\n    def get_unit_size(self) -> float:\n        return self.get_length() / (self.x_range[1] - self.x_range[0])\n\n    def get_unit_vector(self) -> np.ndarray:\n        return super().get_unit_vector() * self.unit_size\n\n    def get_number_mobject(\n        self,\n        x: float,\n        direction: Sequence[float] | None = None,\n        buff: float | None = None,\n        font_size: float | None = None,\n        label_constructor: VMobject | None = None,\n        **number_config,\n    ) -> VMobject:\n        \"\"\"Generates a positioned :class:`~.DecimalNumber` mobject\n        generated according to ``label_constructor``.\n\n        Parameters\n        ----------\n        x\n            The x-value at which the mobject should be positioned.\n        direction\n            Determines the direction at which the label is positioned next to the line.\n        buff\n            The distance of the label from the line.\n        font_size\n            The font size of the label mobject.\n        label_constructor\n            The :class:`~.VMobject` class that will be used to construct the label.\n            Defaults to the ``label_constructor`` attribute of the number line\n            if not specified.\n\n        Returns\n        -------\n        :class:`~.DecimalNumber`\n            The positioned mobject.\n        \"\"\"\n        number_config = merge_dicts_recursively(\n            self.decimal_number_config,\n            number_config,\n        )\n        if direction is None:\n            direction = self.label_direction\n        if buff is None:\n            buff = self.line_to_number_buff\n        if font_size is None:\n            font_size = self.font_size\n        if label_constructor is None:\n            label_constructor = self.label_constructor\n\n        num_mob = DecimalNumber(\n            x, font_size=font_size, mob_class=label_constructor, **number_config\n        )\n\n        num_mob.next_to(self.number_to_point(x), direction=direction, buff=buff)\n        if x < 0 and self.label_direction[0] == 0:\n            # Align without the minus sign\n            num_mob.shift(num_mob[0].width * LEFT / 2)\n        return num_mob\n\n    def get_number_mobjects(self, *numbers, **kwargs) -> VGroup:\n        if len(numbers) == 0:\n            numbers = self.default_numbers_to_display()\n        return VGroup([self.get_number_mobject(number, **kwargs) for number in numbers])\n\n    def get_labels(self) -> VGroup:\n        return self.get_number_mobjects()\n\n    def add_numbers(\n        self,\n        x_values: Iterable[float] | None = None,\n        excluding: Iterable[float] | None = None,\n        font_size: float | None = None,\n        label_constructor: VMobject | None = None,\n        **kwargs,\n    ):\n        \"\"\"Adds :class:`~.DecimalNumber` mobjects representing their position\n        at each tick of the number line. The numbers can be accessed after creation\n        via ``self.numbers``.\n\n        Parameters\n        ----------\n        x_values\n            An iterable of the values used to position and create the labels.\n            Defaults to the output produced by :meth:`~.NumberLine.get_tick_range`\n        excluding\n            A list of values to exclude from :attr:`x_values`.\n        font_size\n            The font size of the labels. Defaults to the ``font_size`` attribute\n            of the number line.\n        label_constructor\n            The :class:`~.VMobject` class that will be used to construct the label.\n            Defaults to the ``label_constructor`` attribute of the number line\n            if not specified.\n        \"\"\"\n        if x_values is None:\n            x_values = self.get_tick_range()\n\n        if excluding is None:\n            excluding = self.numbers_to_exclude\n\n        if font_size is None:\n            font_size = self.font_size\n\n        if label_constructor is None:\n            label_constructor = self.label_constructor\n\n        numbers = VGroup()\n        for x in x_values:\n            if x in excluding:\n                continue\n            numbers.add(\n                self.get_number_mobject(\n                    x,\n                    font_size=font_size,\n                    label_constructor=label_constructor,\n                    **kwargs,\n                )\n            )\n        self.add(numbers)\n        self.numbers = numbers\n        return self\n\n    def add_labels(\n        self,\n        dict_values: dict[float, str | float | VMobject],\n        direction: Sequence[float] = None,\n        buff: float | None = None,\n        font_size: float | None = None,\n        label_constructor: VMobject | None = None,\n    ):\n        \"\"\"Adds specifically positioned labels to the :class:`~.NumberLine` using a ``dict``.\n        The labels can be accessed after creation via ``self.labels``.\n\n        Parameters\n        ----------\n        dict_values\n            A dictionary consisting of the position along the number line and the mobject to be added:\n            ``{1: Tex(\"Monday\"), 3: Tex(\"Tuesday\")}``. :attr:`label_constructor` will be used\n            to construct the labels if the value is not a mobject (``str`` or ``float``).\n        direction\n            Determines the direction at which the label is positioned next to the line.\n        buff\n            The distance of the label from the line.\n        font_size\n            The font size of the mobject to be positioned.\n        label_constructor\n            The :class:`~.VMobject` class that will be used to construct the label.\n            Defaults to the ``label_constructor`` attribute of the number line\n            if not specified.\n\n        Raises\n        ------\n        AttributeError\n            If the label does not have a ``font_size`` attribute, an ``AttributeError`` is raised.\n        \"\"\"\n        direction = self.label_direction if direction is None else direction\n        buff = self.line_to_number_buff if buff is None else buff\n        font_size = self.font_size if font_size is None else font_size\n        if label_constructor is None:\n            label_constructor = self.label_constructor\n\n        labels = VGroup()\n        for x, label in dict_values.items():\n            # TODO: remove this check and ability to call\n            # this method via CoordinateSystem.add_coordinates()\n            # must be explicitly called\n            if isinstance(label, str) and label_constructor is MathTex:\n                label = Tex(label)\n            else:\n                label = self._create_label_tex(label, label_constructor)\n\n            if hasattr(label, \"font_size\"):\n                label.font_size = font_size\n            else:\n                raise AttributeError(f\"{label} is not compatible with add_labels.\")\n            label.next_to(self.number_to_point(x), direction=direction, buff=buff)\n            labels.add(label)\n\n        self.labels = labels\n        self.add(labels)\n        return self\n\n    def _create_label_tex(\n        self,\n        label_tex: str | float | VMobject,\n        label_constructor: Callable | None = None,\n        **kwargs,\n    ) -> VMobject:\n        \"\"\"Checks if the label is a :class:`~.VMobject`, otherwise, creates a\n        label by passing ``label_tex`` to ``label_constructor``.\n\n        Parameters\n        ----------\n        label_tex\n            The label for which a mobject should be created. If the label already\n            is a mobject, no new mobject is created.\n        label_constructor\n            Optional. A class or function returning a mobject when\n            passing ``label_tex`` as an argument. If ``None`` is passed\n            (the default), the label constructor from the :attr:`.label_constructor`\n            attribute is used.\n\n        Returns\n        -------\n        :class:`~.VMobject`\n            The label.\n        \"\"\"\n        if label_constructor is None:\n            label_constructor = self.label_constructor\n        if isinstance(label_tex, (VMobject, OpenGLVMobject)):\n            return label_tex\n        else:\n            return label_constructor(label_tex, **kwargs)\n\n    @staticmethod\n    def _decimal_places_from_step(step) -> int:\n        step = str(step)\n        if \".\" not in step:\n            return 0\n        return len(step.split(\".\")[-1])\n\n    def __matmul__(self, other: float):\n        return self.n2p(other)\n\n    def __rmatmul__(self, other: Point3DLike | Mobject):\n        if isinstance(other, Mobject):\n            other = other.get_center()\n        return self.p2n(other)"}, {"name": "NumberPlane", "code": "class NumberPlane(Axes):\n    \"\"\"Creates a cartesian plane with background lines.\n\n    Parameters\n    ----------\n    x_range\n        The ``[x_min, x_max, x_step]`` values of the plane in the horizontal direction.\n    y_range\n        The ``[y_min, y_max, y_step]`` values of the plane in the vertical direction.\n    x_length\n        The width of the plane.\n    y_length\n        The height of the plane.\n    background_line_style\n        Arguments that influence the construction of the background lines of the plane.\n    faded_line_style\n        Similar to :attr:`background_line_style`, affects the construction of the scene's background lines.\n    faded_line_ratio\n        Determines the number of boxes within the background lines: :code:`2` = 4 boxes, :code:`3` = 9 boxes.\n    make_smooth_after_applying_functions\n        Currently non-functional.\n    kwargs\n        Additional arguments to be passed to :class:`Axes`.\n\n\n    .. note::\n        If :attr:`x_length` or :attr:`y_length` are not defined, they are automatically calculated such that\n        one unit on each axis is one Manim unit long.\n\n    Examples\n    --------\n    .. manim:: NumberPlaneExample\n        :save_last_frame:\n\n        class NumberPlaneExample(Scene):\n            def construct(self):\n                number_plane = NumberPlane(\n                    background_line_style={\n                        \"stroke_color\": TEAL,\n                        \"stroke_width\": 4,\n                        \"stroke_opacity\": 0.6\n                    }\n                )\n                self.add(number_plane)\n\n    .. manim:: NumberPlaneScaled\n        :save_last_frame:\n\n        class NumberPlaneScaled(Scene):\n            def construct(self):\n                number_plane = NumberPlane(\n                    x_range=(-4, 11, 1),\n                    y_range=(-3, 3, 1),\n                    x_length=5,\n                    y_length=2,\n                ).move_to(LEFT*3)\n\n                number_plane_scaled_y = NumberPlane(\n                    x_range=(-4, 11, 1),\n                    x_length=5,\n                    y_length=4,\n                ).move_to(RIGHT*3)\n\n                self.add(number_plane)\n                self.add(number_plane_scaled_y)\n    \"\"\"\n\n    def __init__(\n        self,\n        x_range: Sequence[float] | None = (\n            -config[\"frame_x_radius\"],\n            config[\"frame_x_radius\"],\n            1,\n        ),\n        y_range: Sequence[float] | None = (\n            -config[\"frame_y_radius\"],\n            config[\"frame_y_radius\"],\n            1,\n        ),\n        x_length: float | None = None,\n        y_length: float | None = None,\n        background_line_style: dict[str, Any] | None = None,\n        faded_line_style: dict[str, Any] | None = None,\n        faded_line_ratio: int = 1,\n        make_smooth_after_applying_functions: bool = True,\n        **kwargs: dict[str, Any],\n    ):\n        # configs\n        self.axis_config = {\n            \"stroke_width\": 2,\n            \"include_ticks\": False,\n            \"include_tip\": False,\n            \"line_to_number_buff\": SMALL_BUFF,\n            \"label_direction\": DR,\n            \"font_size\": 24,\n        }\n        self.y_axis_config = {\"label_direction\": DR}\n        self.background_line_style = {\n            \"stroke_color\": BLUE_D,\n            \"stroke_width\": 2,\n            \"stroke_opacity\": 1,\n        }\n\n        self._update_default_configs(\n            (self.axis_config, self.y_axis_config, self.background_line_style),\n            (\n                kwargs.pop(\"axis_config\", None),\n                kwargs.pop(\"y_axis_config\", None),\n                background_line_style,\n            ),\n        )\n\n        # Defaults to a faded version of line_config\n        self.faded_line_style = faded_line_style\n        self.faded_line_ratio = faded_line_ratio\n        self.make_smooth_after_applying_functions = make_smooth_after_applying_functions\n\n        # init\n        super().__init__(\n            x_range=x_range,\n            y_range=y_range,\n            x_length=x_length,\n            y_length=y_length,\n            axis_config=self.axis_config,\n            y_axis_config=self.y_axis_config,\n            **kwargs,\n        )\n\n        self._init_background_lines()\n\n    def _init_background_lines(self) -> None:\n        \"\"\"Will init all the lines of NumberPlanes (faded or not)\"\"\"\n        if self.faded_line_style is None:\n            style = dict(self.background_line_style)\n            # For anything numerical, like stroke_width\n            # and stroke_opacity, chop it in half\n            for key in style:\n                if isinstance(style[key], numbers.Number):\n                    style[key] *= 0.5\n            self.faded_line_style = style\n\n        self.background_lines, self.faded_lines = self._get_lines()\n\n        self.background_lines.set_style(\n            **self.background_line_style,\n        )\n        self.faded_lines.set_style(\n            **self.faded_line_style,\n        )\n        self.add_to_back(\n            self.faded_lines,\n            self.background_lines,\n        )\n\n    def _get_lines(self) -> tuple[VGroup, VGroup]:\n        \"\"\"Generate all the lines, faded and not faded.\n         Two sets of lines are generated: one parallel to the X-axis, and parallel to the Y-axis.\n\n        Returns\n        -------\n        Tuple[:class:`~.VGroup`, :class:`~.VGroup`]\n            The first (i.e the non faded lines) and second (i.e the faded lines) sets of lines, respectively.\n        \"\"\"\n        x_axis = self.get_x_axis()\n        y_axis = self.get_y_axis()\n\n        x_lines1, x_lines2 = self._get_lines_parallel_to_axis(\n            x_axis,\n            y_axis,\n            self.y_axis.x_range[2],\n            self.faded_line_ratio,\n        )\n\n        y_lines1, y_lines2 = self._get_lines_parallel_to_axis(\n            y_axis,\n            x_axis,\n            self.x_axis.x_range[2],\n            self.faded_line_ratio,\n        )\n\n        # TODO this was added so that we can run tests on NumberPlane\n        # In the future these attributes will be tacked onto self.background_lines\n        self.x_lines = x_lines1\n        self.y_lines = y_lines1\n        lines1 = VGroup(*x_lines1, *y_lines1)\n        lines2 = VGroup(*x_lines2, *y_lines2)\n\n        return lines1, lines2\n\n    def _get_lines_parallel_to_axis(\n        self,\n        axis_parallel_to: NumberLine,\n        axis_perpendicular_to: NumberLine,\n        freq: float,\n        ratio_faded_lines: int,\n    ) -> tuple[VGroup, VGroup]:\n        \"\"\"Generate a set of lines parallel to an axis.\n\n        Parameters\n        ----------\n        axis_parallel_to\n            The axis with which the lines will be parallel.\n        axis_perpendicular_to\n            The axis with which the lines will be perpendicular.\n        ratio_faded_lines\n            The ratio between the space between faded lines and the space between non-faded lines.\n        freq\n            Frequency of non-faded lines (number of non-faded lines per graph unit).\n\n        Returns\n        -------\n        Tuple[:class:`~.VGroup`, :class:`~.VGroup`]\n            The first (i.e the non-faded lines parallel to `axis_parallel_to`) and second\n             (i.e the faded lines parallel to `axis_parallel_to`) sets of lines, respectively.\n        \"\"\"\n        line = Line(axis_parallel_to.get_start(), axis_parallel_to.get_end())\n        if ratio_faded_lines == 0:  # don't show faded lines\n            ratio_faded_lines = 1  # i.e. set ratio to 1\n        step = (1 / ratio_faded_lines) * freq\n        lines1 = VGroup()\n        lines2 = VGroup()\n        unit_vector_axis_perp_to = axis_perpendicular_to.get_unit_vector()\n\n        # need to unpack all three values\n        x_min, x_max, _ = axis_perpendicular_to.x_range\n\n        # account for different axis scalings (logarithmic), where\n        # negative values do not exist and [-2 , 4] should output lines\n        # similar to [0, 6]\n        if axis_perpendicular_to.x_min > 0 and x_min < 0:\n            x_min, x_max = (0, np.abs(x_min) + np.abs(x_max))\n\n        # min/max used in case range does not include 0. i.e. if (2,6):\n        # the range becomes (0,4), not (0,6).\n        ranges = (\n            [0],\n            np.arange(step, min(x_max - x_min, x_max), step),\n            np.arange(-step, max(x_min - x_max, x_min), -step),\n        )\n\n        for inputs in ranges:\n            for k, x in enumerate(inputs):\n                new_line = line.copy()\n                new_line.shift(unit_vector_axis_perp_to * x)\n                if (k + 1) % ratio_faded_lines == 0:\n                    lines1.add(new_line)\n                else:\n                    lines2.add(new_line)\n        return lines1, lines2\n\n    def get_vector(self, coords: Sequence[ManimFloat], **kwargs: Any) -> Arrow:\n        kwargs[\"buff\"] = 0\n        return Arrow(\n            self.coords_to_point(0, 0), self.coords_to_point(*coords), **kwargs\n        )\n\n    def prepare_for_nonlinear_transform(self, num_inserted_curves: int = 50) -> Self:\n        for mob in self.family_members_with_points():\n            num_curves = mob.get_num_curves()\n            if num_inserted_curves > num_curves:\n                mob.insert_n_curves(num_inserted_curves - num_curves)\n        return self"}, {"name": "Object3D", "code": "class Object3D:\n    def __init__(self, *children):\n        self.model_matrix = np.eye(4)\n        self.normal_matrix = np.eye(4)\n        self.children = []\n        self.parent = None\n        self.add(*children)\n        self.init_updaters()\n\n    # TODO: Use path_func.\n    def interpolate(self, start, end, alpha, _):\n        self.model_matrix = (1 - alpha) * start.model_matrix + alpha * end.model_matrix\n        self.normal_matrix = (\n            1 - alpha\n        ) * start.normal_matrix + alpha * end.normal_matrix\n\n    def single_copy(self):\n        copy = Object3D()\n        copy.model_matrix = self.model_matrix.copy()\n        copy.normal_matrix = self.normal_matrix.copy()\n        return copy\n\n    def copy(self):\n        node_to_copy = {}\n\n        bfs = [self]\n        while bfs:\n            node = bfs.pop(0)\n            bfs.extend(node.children)\n\n            node_copy = node.single_copy()\n            node_to_copy[node] = node_copy\n\n            # Add the copy to the copy of the parent.\n            if node.parent is not None and node is not self:\n                node_to_copy[node.parent].add(node_copy)\n        return node_to_copy[self]\n\n    def add(self, *children):\n        for child in children:\n            if child.parent is not None:\n                raise Exception(\n                    \"Attempt to add child that's already added to another Object3D\",\n                )\n        self.remove(*children, current_children_only=False)\n        self.children.extend(children)\n        for child in children:\n            child.parent = self\n\n    def remove(self, *children, current_children_only=True):\n        if current_children_only:\n            for child in children:\n                if child.parent != self:\n                    raise Exception(\n                        \"Attempt to remove child that isn't added to this Object3D\",\n                    )\n        self.children = list(filter(lambda child: child not in children, self.children))\n        for child in children:\n            child.parent = None\n\n    def get_position(self):\n        return self.model_matrix[:, 3][:3]\n\n    def set_position(self, position):\n        self.model_matrix[:, 3][:3] = position\n        return self\n\n    def get_meshes(self):\n        dfs = [self]\n        while dfs:\n            parent = dfs.pop()\n            if isinstance(parent, Mesh):\n                yield parent\n            dfs.extend(parent.children)\n\n    def get_family(self):\n        dfs = [self]\n        while dfs:\n            parent = dfs.pop()\n            yield parent\n            dfs.extend(parent.children)\n\n    def align_data_and_family(self, _):\n        pass\n\n    def hierarchical_model_matrix(self):\n        if self.parent is None:\n            return self.model_matrix\n\n        model_matrices = [self.model_matrix]\n        current_object = self\n        while current_object.parent is not None:\n            model_matrices.append(current_object.parent.model_matrix)\n            current_object = current_object.parent\n        return np.linalg.multi_dot(list(reversed(model_matrices)))\n\n    def hierarchical_normal_matrix(self):\n        if self.parent is None:\n            return self.normal_matrix[:3, :3]\n\n        normal_matrices = [self.normal_matrix]\n        current_object = self\n        while current_object.parent is not None:\n            normal_matrices.append(current_object.parent.model_matrix)\n            current_object = current_object.parent\n        return np.linalg.multi_dot(list(reversed(normal_matrices)))[:3, :3]\n\n    def init_updaters(self):\n        self.time_based_updaters = []\n        self.non_time_updaters = []\n        self.has_updaters = False\n        self.updating_suspended = False\n\n    def update(self, dt=0):\n        if not self.has_updaters or self.updating_suspended:\n            return self\n        for updater in self.time_based_updaters:\n            updater(self, dt)\n        for updater in self.non_time_updaters:\n            updater(self)\n        return self\n\n    def get_time_based_updaters(self):\n        return self.time_based_updaters\n\n    def has_time_based_updater(self):\n        return len(self.time_based_updaters) > 0\n\n    def get_updaters(self):\n        return self.time_based_updaters + self.non_time_updaters\n\n    def add_updater(self, update_function, index=None, call_updater=True):\n        if \"dt\" in inspect.signature(update_function).parameters:\n            updater_list = self.time_based_updaters\n        else:\n            updater_list = self.non_time_updaters\n\n        if index is None:\n            updater_list.append(update_function)\n        else:\n            updater_list.insert(index, update_function)\n\n        self.refresh_has_updater_status()\n        if call_updater:\n            self.update()\n        return self\n\n    def remove_updater(self, update_function):\n        for updater_list in [self.time_based_updaters, self.non_time_updaters]:\n            while update_function in updater_list:\n                updater_list.remove(update_function)\n        self.refresh_has_updater_status()\n        return self\n\n    def clear_updaters(self):\n        self.time_based_updaters = []\n        self.non_time_updaters = []\n        self.refresh_has_updater_status()\n        return self\n\n    def match_updaters(self, mobject):\n        self.clear_updaters()\n        for updater in mobject.get_updaters():\n            self.add_updater(updater)\n        return self\n\n    def suspend_updating(self):\n        self.updating_suspended = True\n        return self\n\n    def resume_updating(self, call_updater=True):\n        self.updating_suspended = False\n        if call_updater:\n            self.update(dt=0)\n        return self\n\n    def refresh_has_updater_status(self):\n        self.has_updaters = len(self.get_updaters()) > 0\n        return self"}, {"name": "Octahedron", "code": "class Octahedron(Polyhedron):\n    \"\"\"An octahedron, one of the five platonic solids. It has 8 faces, 12 edges and 6 vertices.\n\n    Parameters\n    ----------\n    edge_length\n        The length of an edge between any two vertices.\n\n    Examples\n    --------\n\n    .. manim:: OctahedronScene\n        :save_last_frame:\n\n        class OctahedronScene(ThreeDScene):\n            def construct(self):\n                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n                obj = Octahedron()\n                self.add(obj)\n    \"\"\"\n\n    def __init__(self, edge_length: float = 1, **kwargs):\n        unit = edge_length * np.sqrt(2) / 2\n        super().__init__(\n            vertex_coords=[\n                np.array([unit, 0, 0]),\n                np.array([-unit, 0, 0]),\n                np.array([0, unit, 0]),\n                np.array([0, -unit, 0]),\n                np.array([0, 0, unit]),\n                np.array([0, 0, -unit]),\n            ],\n            faces_list=[\n                [2, 4, 1],\n                [0, 4, 2],\n                [4, 3, 0],\n                [1, 3, 4],\n                [3, 5, 0],\n                [1, 5, 3],\n                [2, 5, 1],\n                [0, 5, 2],\n            ],\n            **kwargs,\n        )"}, {"name": "OldMultiCamera", "code": "class OldMultiCamera(Camera):\n    def __init__(self, *cameras_with_start_positions, **kwargs):\n        self.shifted_cameras = [\n            DictAsObject(\n                {\n                    \"camera\": camera_with_start_positions[0],\n                    \"start_x\": camera_with_start_positions[1][1],\n                    \"start_y\": camera_with_start_positions[1][0],\n                    \"end_x\": camera_with_start_positions[1][1]\n                    + camera_with_start_positions[0].pixel_width,\n                    \"end_y\": camera_with_start_positions[1][0]\n                    + camera_with_start_positions[0].pixel_height,\n                },\n            )\n            for camera_with_start_positions in cameras_with_start_positions\n        ]\n        super().__init__(**kwargs)\n\n    def capture_mobjects(self, mobjects, **kwargs):\n        for shifted_camera in self.shifted_cameras:\n            shifted_camera.camera.capture_mobjects(mobjects, **kwargs)\n\n            self.pixel_array[\n                shifted_camera.start_y : shifted_camera.end_y,\n                shifted_camera.start_x : shifted_camera.end_x,\n            ] = shifted_camera.camera.pixel_array\n\n    def set_background(self, pixel_array, **kwargs):\n        for shifted_camera in self.shifted_cameras:\n            shifted_camera.camera.set_background(\n                pixel_array[\n                    shifted_camera.start_y : shifted_camera.end_y,\n                    shifted_camera.start_x : shifted_camera.end_x,\n                ],\n                **kwargs,\n            )\n\n    def set_pixel_array(self, pixel_array, **kwargs):\n        super().set_pixel_array(pixel_array, **kwargs)\n        for shifted_camera in self.shifted_cameras:\n            shifted_camera.camera.set_pixel_array(\n                pixel_array[\n                    shifted_camera.start_y : shifted_camera.end_y,\n                    shifted_camera.start_x : shifted_camera.end_x,\n                ],\n                **kwargs,\n            )\n\n    def init_background(self):\n        super().init_background()\n        for shifted_camera in self.shifted_cameras:\n            shifted_camera.camera.init_background()"}, {"name": "open_file", "code": "def open_file(file_path: Path, in_browser: bool = False) -> None:\n    current_os = platform.system()\n    if current_os == \"Windows\":\n        # The method os.startfile is only available in Windows,\n        # ignoring type error caused by this.\n        os.startfile(file_path if not in_browser else file_path.parent)  # type: ignore[attr-defined]\n    else:\n        if current_os == \"Linux\":\n            commands = [\"xdg-open\"]\n            file_path = file_path if not in_browser else file_path.parent\n        elif current_os.startswith(\"CYGWIN\"):\n            commands = [\"cygstart\"]\n            file_path = file_path if not in_browser else file_path.parent\n        elif current_os == \"Darwin\":\n            commands = [\"open\"] if not in_browser else [\"open\", \"-R\"]\n        else:\n            raise OSError(\"Unable to identify your operating system...\")\n\n        # check after so that file path is set correctly\n        if config.preview_command:\n            commands = [config.preview_command]\n        commands.append(str(file_path))\n        sp.run(commands)"}, {"name": "open_media_file", "code": "def open_media_file(file_writer: SceneFileWriter) -> None:\n    file_paths = []\n\n    if config[\"save_last_frame\"]:\n        file_paths.append(file_writer.image_file_path)\n    if write_to_movie() and not is_gif_format():\n        file_paths.append(file_writer.movie_file_path)\n    if write_to_movie() and is_gif_format():\n        file_paths.append(file_writer.gif_file_path)\n\n    for file_path in file_paths:\n        if config[\"show_in_file_browser\"]:\n            open_file(file_path, True)\n        if config[\"preview\"]:\n            open_file(file_path, False)\n\n            logger.info(f\"Previewed File at: '{file_path}'\")"}, {"name": "OpenGLAnnularSector", "code": "class OpenGLAnnularSector(OpenGLArc):\n    def __init__(\n        self,\n        inner_radius=1,\n        outer_radius=2,\n        angle=TAU / 4,\n        start_angle=0,\n        fill_opacity=1,\n        stroke_width=0,\n        color=WHITE,\n        **kwargs,\n    ):\n        self.inner_radius = inner_radius\n        self.outer_radius = outer_radius\n        super().__init__(\n            start_angle=start_angle,\n            angle=angle,\n            fill_opacity=fill_opacity,\n            stroke_width=stroke_width,\n            color=color,\n            **kwargs,\n        )\n\n    def init_points(self):\n        inner_arc, outer_arc = (\n            OpenGLArc(\n                start_angle=self.start_angle,\n                angle=self.angle,\n                radius=radius,\n                arc_center=self.arc_center,\n            )\n            for radius in (self.inner_radius, self.outer_radius)\n        )\n        outer_arc.reverse_points()\n        self.append_points(inner_arc.points)\n        self.add_line_to(outer_arc.points[0])\n        self.append_points(outer_arc.points)\n        self.add_line_to(inner_arc.points[0])"}, {"name": "OpenGLAnnulus", "code": "class OpenGLAnnulus(OpenGLCircle):\n    def __init__(\n        self,\n        inner_radius=1,\n        outer_radius=2,\n        fill_opacity=1,\n        stroke_width=0,\n        color=WHITE,\n        mark_paths_closed=False,\n        **kwargs,\n    ):\n        self.mark_paths_closed = mark_paths_closed  # is this even used?\n        self.inner_radius = inner_radius\n        self.outer_radius = outer_radius\n        super().__init__(\n            fill_opacity=fill_opacity, stroke_width=stroke_width, color=color, **kwargs\n        )\n\n    def init_points(self):\n        self.radius = self.outer_radius\n        outer_circle = OpenGLCircle(radius=self.outer_radius)\n        inner_circle = OpenGLCircle(radius=self.inner_radius)\n        inner_circle.reverse_points()\n        self.append_points(outer_circle.points)\n        self.append_points(inner_circle.points)\n        self.shift(self.arc_center)"}, {"name": "OpenGLArc", "code": "class OpenGLArc(OpenGLTipableVMobject):\n    def __init__(\n        self,\n        start_angle=0,\n        angle=TAU / 4,\n        radius=1.0,\n        n_components=8,\n        arc_center=ORIGIN,\n        **kwargs,\n    ):\n        self.start_angle = start_angle\n        self.angle = angle\n        self.radius = radius\n        self.n_components = n_components\n        self.arc_center = arc_center\n        super().__init__(self, **kwargs)\n        self.orientation = -1\n\n    def init_points(self):\n        self.set_points(\n            OpenGLArc.create_quadratic_bezier_points(\n                angle=self.angle,\n                start_angle=self.start_angle,\n                n_components=self.n_components,\n            ),\n        )\n        # To maintain proper orientation for fill shaders.\n        self.scale(self.radius, about_point=ORIGIN)\n        self.shift(self.arc_center)\n\n    @staticmethod\n    def create_quadratic_bezier_points(angle, start_angle=0, n_components=8):\n        samples = np.array(\n            [\n                [np.cos(a), np.sin(a), 0]\n                for a in np.linspace(\n                    start_angle,\n                    start_angle + angle,\n                    2 * n_components + 1,\n                )\n            ],\n        )\n        theta = angle / n_components\n        samples[1::2] /= np.cos(theta / 2)\n\n        points = np.zeros((3 * n_components, 3))\n        points[0::3] = samples[0:-1:2]\n        points[1::3] = samples[1::2]\n        points[2::3] = samples[2::2]\n        return points\n\n    def get_arc_center(self):\n        \"\"\"\n        Looks at the normals to the first two\n        anchors, and finds their intersection points\n        \"\"\"\n        # First two anchors and handles\n        a1, h, a2 = self.points[:3]\n        # Tangent vectors\n        t1 = h - a1\n        t2 = h - a2\n        # Normals\n        n1 = rotate_vector(t1, TAU / 4)\n        n2 = rotate_vector(t2, TAU / 4)\n        return find_intersection(a1, n1, a2, n2)\n\n    def get_start_angle(self):\n        angle = angle_of_vector(self.get_start() - self.get_arc_center())\n        return angle % TAU\n\n    def get_stop_angle(self):\n        angle = angle_of_vector(self.get_end() - self.get_arc_center())\n        return angle % TAU\n\n    def move_arc_center_to(self, point):\n        self.shift(point - self.get_arc_center())\n        return self"}, {"name": "OpenGLArcBetweenPoints", "code": "class OpenGLArcBetweenPoints(OpenGLArc):\n    def __init__(self, start, end, angle=TAU / 4, **kwargs):\n        super().__init__(angle=angle, **kwargs)\n        if angle == 0:\n            self.set_points_as_corners([LEFT, RIGHT])\n        self.put_start_and_end_on(start, end)"}, {"name": "OpenGLArrow", "code": "class OpenGLArrow(OpenGLLine):\n    def __init__(\n        self,\n        start=LEFT,\n        end=RIGHT,\n        path_arc=0,\n        fill_color=GREY_A,\n        fill_opacity=1,\n        stroke_width=0,\n        buff=MED_SMALL_BUFF,\n        thickness=0.05,\n        tip_width_ratio=5,\n        tip_angle=PI / 3,\n        max_tip_length_to_length_ratio=0.5,\n        max_width_to_length_ratio=0.1,\n        **kwargs,\n    ):\n        self.thickness = thickness\n        self.tip_width_ratio = tip_width_ratio\n        self.tip_angle = tip_angle\n        self.max_tip_length_to_length_ratio = max_tip_length_to_length_ratio\n        self.max_width_to_length_ratio = max_width_to_length_ratio\n        super().__init__(\n            start=start,\n            end=end,\n            buff=buff,\n            path_arc=path_arc,\n            fill_color=fill_color,\n            fill_opacity=fill_opacity,\n            stroke_width=stroke_width,\n            **kwargs,\n        )\n\n    def set_points_by_ends(self, start, end, buff=0, path_arc=0):\n        # Find the right tip length and thickness\n        vect = end - start\n        length = max(np.linalg.norm(vect), 1e-8)\n        thickness = self.thickness\n        w_ratio = self.max_width_to_length_ratio / (thickness / length)\n        if w_ratio < 1:\n            thickness *= w_ratio\n\n        tip_width = self.tip_width_ratio * thickness\n        tip_length = tip_width / (2 * np.tan(self.tip_angle / 2))\n        t_ratio = self.max_tip_length_to_length_ratio / (tip_length / length)\n        if t_ratio < 1:\n            tip_length *= t_ratio\n            tip_width *= t_ratio\n\n        # Find points for the stem\n        if path_arc == 0:\n            points1 = (length - tip_length) * np.array([RIGHT, 0.5 * RIGHT, ORIGIN])\n            points1 += thickness * UP / 2\n            points2 = points1[::-1] + thickness * DOWN\n        else:\n            # Solve for radius so that the tip-to-tail length matches |end - start|\n            a = 2 * (1 - np.cos(path_arc))\n            b = -2 * tip_length * np.sin(path_arc)\n            c = tip_length**2 - length**2\n            R = (-b + np.sqrt(b**2 - 4 * a * c)) / (2 * a)\n\n            # Find arc points\n            points1 = OpenGLArc.create_quadratic_bezier_points(path_arc)\n            points2 = np.array(points1[::-1])\n            points1 *= R + thickness / 2\n            points2 *= R - thickness / 2\n            if path_arc < 0:\n                tip_length *= -1\n            rot_T = rotation_matrix_transpose(PI / 2 - path_arc, OUT)\n            for points in points1, points2:\n                points[:] = np.dot(points, rot_T)\n                points += R * DOWN\n\n        self.set_points(points1)\n        # Tip\n        self.add_line_to(tip_width * UP / 2)\n        self.add_line_to(tip_length * LEFT)\n        self.tip_index = len(self.points) - 1\n        self.add_line_to(tip_width * DOWN / 2)\n        self.add_line_to(points2[0])\n        # Close it out\n        self.append_points(points2)\n        self.add_line_to(points1[0])\n\n        if length > 0:\n            # Final correction\n            super().scale(length / self.get_length())\n\n        self.rotate(angle_of_vector(vect) - self.get_angle())\n        self.rotate(\n            PI / 2 - np.arccos(normalize(vect)[2]),\n            axis=rotate_vector(self.get_unit_vector(), -PI / 2),\n        )\n        self.shift(start - self.get_start())\n        self.refresh_triangulation()\n\n    def reset_points_around_ends(self):\n        self.set_points_by_ends(\n            self.get_start(),\n            self.get_end(),\n            path_arc=self.path_arc,\n        )\n        return self\n\n    def get_start(self):\n        nppc = self.n_points_per_curve\n        points = self.points\n        return (points[0] + points[-nppc]) / 2\n\n    def get_end(self):\n        return self.points[self.tip_index]\n\n    def put_start_and_end_on(self, start, end):\n        self.set_points_by_ends(start, end, buff=0, path_arc=self.path_arc)\n        return self\n\n    def scale(self, *args, **kwargs):\n        super().scale(*args, **kwargs)\n        self.reset_points_around_ends()\n        return self\n\n    def set_thickness(self, thickness):\n        self.thickness = thickness\n        self.reset_points_around_ends()\n        return self\n\n    def set_path_arc(self, path_arc):\n        self.path_arc = path_arc\n        self.reset_points_around_ends()\n        return self"}, {"name": "OpenGLArrowTip", "code": "class OpenGLArrowTip(OpenGLTriangle):\n    def __init__(\n        self,\n        fill_opacity=1,\n        fill_color=WHITE,\n        stroke_width=0,\n        width=DEFAULT_ARROW_TIP_WIDTH,\n        length=DEFAULT_ARROW_TIP_LENGTH,\n        angle=0,\n        **kwargs,\n    ):\n        super().__init__(\n            start_angle=0,\n            fill_opacity=fill_opacity,\n            fill_color=fill_color,\n            stroke_width=stroke_width,\n            **kwargs,\n        )\n        self.set_width(width, stretch=True)\n        self.set_height(length, stretch=True)\n\n    def get_base(self):\n        return self.point_from_proportion(0.5)\n\n    def get_tip_point(self):\n        return self.points[0]\n\n    def get_vector(self):\n        return self.get_tip_point() - self.get_base()\n\n    def get_angle(self):\n        return angle_of_vector(self.get_vector())\n\n    def get_length(self):\n        return np.linalg.norm(self.get_vector())"}, {"name": "OpenGLCamera", "code": "class OpenGLCamera(OpenGLMobject):\n    euler_angles = _Data()\n\n    def __init__(\n        self,\n        frame_shape=None,\n        center_point=None,\n        # Theta, phi, gamma\n        euler_angles=[0, 0, 0],\n        focal_distance=2,\n        light_source_position=[-10, 10, 10],\n        orthographic=False,\n        minimum_polar_angle=-PI / 2,\n        maximum_polar_angle=PI / 2,\n        model_matrix=None,\n        **kwargs,\n    ):\n        self.use_z_index = True\n        self.frame_rate = 60\n        self.orthographic = orthographic\n        self.minimum_polar_angle = minimum_polar_angle\n        self.maximum_polar_angle = maximum_polar_angle\n        if self.orthographic:\n            self.projection_matrix = opengl.orthographic_projection_matrix()\n            self.unformatted_projection_matrix = opengl.orthographic_projection_matrix(\n                format_=False,\n            )\n        else:\n            self.projection_matrix = opengl.perspective_projection_matrix()\n            self.unformatted_projection_matrix = opengl.perspective_projection_matrix(\n                format_=False,\n            )\n\n        if frame_shape is None:\n            self.frame_shape = (config[\"frame_width\"], config[\"frame_height\"])\n        else:\n            self.frame_shape = frame_shape\n\n        if center_point is None:\n            self.center_point = ORIGIN\n        else:\n            self.center_point = center_point\n\n        if model_matrix is None:\n            model_matrix = opengl.translation_matrix(0, 0, 11)\n\n        self.focal_distance = focal_distance\n\n        if light_source_position is None:\n            self.light_source_position = [-10, 10, 10]\n        else:\n            self.light_source_position = light_source_position\n        self.light_source = OpenGLPoint(self.light_source_position)\n\n        self.default_model_matrix = model_matrix\n        super().__init__(model_matrix=model_matrix, should_render=False, **kwargs)\n\n        if euler_angles is None:\n            euler_angles = [0, 0, 0]\n        euler_angles = np.array(euler_angles, dtype=float)\n\n        self.euler_angles = euler_angles\n        self.refresh_rotation_matrix()\n\n    def get_position(self):\n        return self.model_matrix[:, 3][:3]\n\n    def set_position(self, position):\n        self.model_matrix[:, 3][:3] = position\n        return self\n\n    @cached_property\n    def formatted_view_matrix(self):\n        return opengl.matrix_to_shader_input(np.linalg.inv(self.model_matrix))\n\n    @cached_property\n    def unformatted_view_matrix(self):\n        return np.linalg.inv(self.model_matrix)\n\n    def init_points(self):\n        self.set_points([ORIGIN, LEFT, RIGHT, DOWN, UP])\n        self.set_width(self.frame_shape[0], stretch=True)\n        self.set_height(self.frame_shape[1], stretch=True)\n        self.move_to(self.center_point)\n\n    def to_default_state(self):\n        self.center()\n        self.set_height(config[\"frame_height\"])\n        self.set_width(config[\"frame_width\"])\n        self.set_euler_angles(0, 0, 0)\n        self.model_matrix = self.default_model_matrix\n        return self\n\n    def refresh_rotation_matrix(self):\n        # Rotate based on camera orientation\n        theta, phi, gamma = self.euler_angles\n        quat = quaternion_mult(\n            quaternion_from_angle_axis(theta, OUT, axis_normalized=True),\n            quaternion_from_angle_axis(phi, RIGHT, axis_normalized=True),\n            quaternion_from_angle_axis(gamma, OUT, axis_normalized=True),\n        )\n        self.inverse_rotation_matrix = rotation_matrix_transpose_from_quaternion(quat)\n\n    def rotate(self, angle, axis=OUT, **kwargs):\n        curr_rot_T = self.inverse_rotation_matrix\n        added_rot_T = rotation_matrix_transpose(angle, axis)\n        new_rot_T = np.dot(curr_rot_T, added_rot_T)\n        Fz = new_rot_T[2]\n        phi = np.arccos(Fz[2])\n        theta = angle_of_vector(Fz[:2]) + PI / 2\n        partial_rot_T = np.dot(\n            rotation_matrix_transpose(phi, RIGHT),\n            rotation_matrix_transpose(theta, OUT),\n        )\n        gamma = angle_of_vector(np.dot(partial_rot_T, new_rot_T.T)[:, 0])\n        self.set_euler_angles(theta, phi, gamma)\n        return self\n\n    def set_euler_angles(self, theta=None, phi=None, gamma=None):\n        if theta is not None:\n            self.euler_angles[0] = theta\n        if phi is not None:\n            self.euler_angles[1] = phi\n        if gamma is not None:\n            self.euler_angles[2] = gamma\n        self.refresh_rotation_matrix()\n        return self\n\n    def set_theta(self, theta):\n        return self.set_euler_angles(theta=theta)\n\n    def set_phi(self, phi):\n        return self.set_euler_angles(phi=phi)\n\n    def set_gamma(self, gamma):\n        return self.set_euler_angles(gamma=gamma)\n\n    def increment_theta(self, dtheta):\n        self.euler_angles[0] += dtheta\n        self.refresh_rotation_matrix()\n        return self\n\n    def increment_phi(self, dphi):\n        phi = self.euler_angles[1]\n        new_phi = clip(phi + dphi, -PI / 2, PI / 2)\n        self.euler_angles[1] = new_phi\n        self.refresh_rotation_matrix()\n        return self\n\n    def increment_gamma(self, dgamma):\n        self.euler_angles[2] += dgamma\n        self.refresh_rotation_matrix()\n        return self\n\n    def get_shape(self):\n        return (self.get_width(), self.get_height())\n\n    def get_center(self):\n        # Assumes first point is at the center\n        return self.points[0]\n\n    def get_width(self):\n        points = self.points\n        return points[2, 0] - points[1, 0]\n\n    def get_height(self):\n        points = self.points\n        return points[4, 1] - points[3, 1]\n\n    def get_focal_distance(self):\n        return self.focal_distance * self.get_height()\n\n    def interpolate(self, *args, **kwargs):\n        super().interpolate(*args, **kwargs)\n        self.refresh_rotation_matrix()"}, {"name": "OpenGLCircle", "code": "class OpenGLCircle(OpenGLArc):\n    def __init__(self, color=RED, **kwargs):\n        super().__init__(0, TAU, color=color, **kwargs)\n\n    def surround(self, mobject, dim_to_match=0, stretch=False, buff=MED_SMALL_BUFF):\n        # Ignores dim_to_match and stretch; result will always be a circle\n        # TODO: Perhaps create an ellipse class to handle singele-dimension stretching\n\n        self.replace(mobject, dim_to_match, stretch)\n        self.stretch((self.get_width() + 2 * buff) / self.get_width(), 0)\n        self.stretch((self.get_height() + 2 * buff) / self.get_height(), 1)\n\n    def point_at_angle(self, angle):\n        start_angle = self.get_start_angle()\n        return self.point_from_proportion((angle - start_angle) / TAU)"}, {"name": "OpenGLCubicBezier", "code": "class OpenGLCubicBezier(OpenGLVMobject):\n    def __init__(self, a0, h0, h1, a1, **kwargs):\n        super().__init__(**kwargs)\n        self.add_cubic_bezier_curve(a0, h0, h1, a1)"}, {"name": "OpenGLCurvedArrow", "code": "class OpenGLCurvedArrow(OpenGLArcBetweenPoints):\n    def __init__(self, start_point, end_point, **kwargs):\n        super().__init__(start_point, end_point, **kwargs)\n        self.add_tip()"}, {"name": "OpenGLCurvedDoubleArrow", "code": "class OpenGLCurvedDoubleArrow(OpenGLCurvedArrow):\n    def __init__(self, start_point, end_point, **kwargs):\n        super().__init__(start_point, end_point, **kwargs)\n        self.add_tip(at_start=True)"}, {"name": "OpenGLCurvesAsSubmobjects", "code": "class OpenGLCurvesAsSubmobjects(OpenGLVGroup):\n    \"\"\"Convert a curve's elements to submobjects.\n\n    Examples\n    --------\n    .. manim:: LineGradientExample\n        :save_last_frame:\n\n        class LineGradientExample(Scene):\n            def construct(self):\n                curve = ParametricFunction(lambda t: [t, np.sin(t), 0], t_range=[-PI, PI, 0.01], stroke_width=10)\n                new_curve = CurvesAsSubmobjects(curve)\n                new_curve.set_color_by_gradient(BLUE, RED)\n                self.add(new_curve.shift(UP), curve)\n\n    \"\"\"\n\n    def __init__(self, vmobject, **kwargs):\n        super().__init__(**kwargs)\n        for tup in vmobject.get_bezier_tuples():\n            part = OpenGLVMobject()\n            part.set_points(tup)\n            part.match_style(vmobject)\n            self.add(part)"}, {"name": "OpenGLDashedLine", "code": "class OpenGLDashedLine(OpenGLLine):\n    def __init__(\n        self, *args, dash_length=DEFAULT_DASH_LENGTH, dashed_ratio=0.5, **kwargs\n    ):\n        self.dashed_ratio = dashed_ratio\n        self.dash_length = dash_length\n        super().__init__(*args, **kwargs)\n        dashed_ratio = self.dashed_ratio\n        num_dashes = self.calculate_num_dashes(dashed_ratio)\n        dashes = OpenGLDashedVMobject(\n            self,\n            num_dashes=num_dashes,\n            dashed_ratio=dashed_ratio,\n        )\n        self.clear_points()\n        self.add(*dashes)\n\n    def calculate_num_dashes(self, dashed_ratio):\n        return max(\n            2,\n            int(np.ceil((self.get_length() / self.dash_length) * dashed_ratio)),\n        )\n\n    def get_start(self):\n        if len(self.submobjects) > 0:\n            return self.submobjects[0].get_start()\n        else:\n            return super().get_start()\n\n    def get_end(self):\n        if len(self.submobjects) > 0:\n            return self.submobjects[-1].get_end()\n        else:\n            return super().get_end()\n\n    def get_first_handle(self):\n        return self.submobjects[0].points[1]\n\n    def get_last_handle(self):\n        return self.submobjects[-1].points[-2]"}, {"name": "OpenGLDashedVMobject", "code": "class OpenGLDashedVMobject(OpenGLVMobject):\n    \"\"\"A :class:`OpenGLVMobject` composed of dashes instead of lines.\n\n    Examples\n    --------\n    .. manim:: DashedVMobjectExample\n        :save_last_frame:\n\n        class DashedVMobjectExample(Scene):\n            def construct(self):\n                r = 0.5\n\n                top_row = OpenGLVGroup()  # Increasing num_dashes\n                for dashes in range(2, 12):\n                    circ = DashedVMobject(Circle(radius=r, color=WHITE), num_dashes=dashes)\n                    top_row.add(circ)\n\n                middle_row = OpenGLVGroup()  # Increasing dashed_ratio\n                for ratio in np.arange(1 / 11, 1, 1 / 11):\n                    circ = DashedVMobject(\n                        Circle(radius=r, color=WHITE), dashed_ratio=ratio\n                    )\n                    middle_row.add(circ)\n\n                sq = DashedVMobject(Square(1.5, color=RED))\n                penta = DashedVMobject(RegularPolygon(5, color=BLUE))\n                bottom_row = OpenGLVGroup(sq, penta)\n\n                top_row.arrange(buff=0.4)\n                middle_row.arrange()\n                bottom_row.arrange(buff=1)\n                everything = OpenGLVGroup(top_row, middle_row, bottom_row).arrange(DOWN, buff=1)\n                self.add(everything)\n    \"\"\"\n\n    def __init__(\n        self,\n        vmobject: OpenGLVMobject,\n        num_dashes: int = 15,\n        dashed_ratio: float = 0.5,\n        color: ParsableManimColor = WHITE,\n        **kwargs,\n    ):\n        self.dashed_ratio = dashed_ratio\n        self.num_dashes = num_dashes\n        super().__init__(color=color, **kwargs)\n        r = self.dashed_ratio\n        n = self.num_dashes\n        if num_dashes > 0:\n            # Assuming total length is 1\n            dash_len = r / n\n            void_len = (1 - r) / n if vmobject.is_closed() else (1 - r) / (n - 1)\n\n            self.add(\n                *(\n                    vmobject.get_subcurve(\n                        i * (dash_len + void_len),\n                        i * (dash_len + void_len) + dash_len,\n                    )\n                    for i in range(n)\n                )\n            )\n        # Family is already taken care of by get_subcurve\n        # implementation\n        self.match_style(vmobject, recurse=False)"}, {"name": "OpenGLDot", "code": "class OpenGLDot(OpenGLCircle):\n    def __init__(\n        self,\n        point=ORIGIN,\n        radius=DEFAULT_DOT_RADIUS,\n        stroke_width=0,\n        fill_opacity=1.0,\n        color=WHITE,\n        **kwargs,\n    ):\n        super().__init__(\n            arc_center=point,\n            radius=radius,\n            stroke_width=stroke_width,\n            fill_opacity=fill_opacity,\n            color=color,\n            **kwargs,\n        )"}, {"name": "OpenGLDoubleArrow", "code": "class OpenGLDoubleArrow(OpenGLArrow):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.add_tip(at_start=True)"}, {"name": "OpenGLElbow", "code": "class OpenGLElbow(OpenGLVMobject):\n    def __init__(self, width=0.2, angle=0, **kwargs):\n        self.angle = angle\n        super().__init__(self, **kwargs)\n        self.set_points_as_corners([UP, UP + RIGHT, RIGHT])\n        self.set_width(width, about_point=ORIGIN)\n        self.rotate(self.angle, about_point=ORIGIN)"}, {"name": "OpenGLEllipse", "code": "class OpenGLEllipse(OpenGLCircle):\n    def __init__(self, width=2, height=1, **kwargs):\n        super().__init__(**kwargs)\n        self.set_width(width, stretch=True)\n        self.set_height(height, stretch=True)"}, {"name": "OpenGLGroup", "code": "class OpenGLGroup(OpenGLMobject):\n    def __init__(self, *mobjects: OpenGLMobject, **kwargs):\n        super().__init__(**kwargs)\n        self.add(*mobjects)"}, {"name": "OpenGLImageMobject", "code": "class OpenGLImageMobject(OpenGLTexturedSurface):\n    def __init__(\n        self,\n        filename_or_array: str | Path | np.ndarray,\n        width: float = None,\n        height: float = None,\n        image_mode: str = \"RGBA\",\n        resampling_algorithm: int = Resampling.BICUBIC,\n        opacity: float = 1,\n        gloss: float = 0,\n        shadow: float = 0,\n        **kwargs,\n    ):\n        self.image = filename_or_array\n        self.resampling_algorithm = resampling_algorithm\n        if isinstance(filename_or_array, np.ndarray):\n            self.size = self.image.shape[1::-1]\n        elif isinstance(filename_or_array, (str, Path)):\n            path = get_full_raster_image_path(filename_or_array)\n            self.size = Image.open(path).size\n\n        if width is None and height is None:\n            width = 4 * self.size[0] / self.size[1]\n            height = 4\n        if height is None:\n            height = width * self.size[1] / self.size[0]\n        if width is None:\n            width = height * self.size[0] / self.size[1]\n\n        surface = OpenGLSurface(\n            lambda u, v: np.array([u, v, 0]),\n            [-width / 2, width / 2],\n            [-height / 2, height / 2],\n            opacity=opacity,\n            gloss=gloss,\n            shadow=shadow,\n        )\n\n        super().__init__(\n            surface,\n            self.image,\n            image_mode=image_mode,\n            opacity=opacity,\n            gloss=gloss,\n            shadow=shadow,\n            **kwargs,\n        )\n\n    def get_image_from_file(\n        self,\n        image_file: str | Path | np.ndarray,\n        image_mode: str,\n    ):\n        if isinstance(image_file, (str, Path)):\n            return super().get_image_from_file(image_file, image_mode)\n        else:\n            return (\n                Image.fromarray(image_file.astype(\"uint8\"))\n                .convert(image_mode)\n                .resize(\n                    np.array(image_file.shape[:2])\n                    * 200,  # assumption of 200 ppmu (pixels per manim unit) would suffice\n                    resample=self.resampling_algorithm,\n                )\n            )"}, {"name": "OpenGLLine", "code": "class OpenGLLine(OpenGLTipableVMobject):\n    def __init__(self, start=LEFT, end=RIGHT, buff=0, path_arc=0, **kwargs):\n        self.dim = 3\n        self.buff = buff\n        self.path_arc = path_arc\n        self.set_start_and_end_attrs(start, end)\n        super().__init__(**kwargs)\n\n    def init_points(self):\n        self.set_points_by_ends(self.start, self.end, self.buff, self.path_arc)\n\n    def set_points_by_ends(self, start, end, buff=0, path_arc=0):\n        if path_arc:\n            self.set_points(OpenGLArc.create_quadratic_bezier_points(path_arc))\n            self.put_start_and_end_on(start, end)\n        else:\n            self.set_points_as_corners([start, end])\n        self.account_for_buff(self.buff)\n\n    def set_path_arc(self, new_value):\n        self.path_arc = new_value\n        self.init_points()\n\n    def account_for_buff(self, buff):\n        if buff == 0:\n            return\n        #\n        length = self.get_length() if self.path_arc == 0 else self.get_arc_length()\n        #\n        if length < 2 * buff:\n            return\n        buff_prop = buff / length\n        self.pointwise_become_partial(self, buff_prop, 1 - buff_prop)\n        return self\n\n    def set_start_and_end_attrs(self, start, end):\n        # If either start or end are Mobjects, this\n        # gives their centers\n        rough_start = self.pointify(start)\n        rough_end = self.pointify(end)\n        vect = normalize(rough_end - rough_start)\n        # Now that we know the direction between them,\n        # we can find the appropriate boundary point from\n        # start and end, if they're mobjects\n        self.start = self.pointify(start, vect) + self.buff * vect\n        self.end = self.pointify(end, -vect) - self.buff * vect\n\n    def pointify(self, mob_or_point, direction=None):\n        \"\"\"\n        Take an argument passed into Line (or subclass) and turn\n        it into a 3d point.\n        \"\"\"\n        if isinstance(mob_or_point, Mobject):\n            mob = mob_or_point\n            if direction is None:\n                return mob.get_center()\n            else:\n                return mob.get_continuous_bounding_box_point(direction)\n        else:\n            point = mob_or_point\n            result = np.zeros(self.dim)\n            result[: len(point)] = point\n            return result\n\n    def put_start_and_end_on(self, start, end):\n        curr_start, curr_end = self.get_start_and_end()\n        if (curr_start == curr_end).all():\n            self.set_points_by_ends(start, end, self.path_arc)\n        return super().put_start_and_end_on(start, end)\n\n    def get_vector(self):\n        return self.get_end() - self.get_start()\n\n    def get_unit_vector(self):\n        return normalize(self.get_vector())\n\n    def get_angle(self):\n        return angle_of_vector(self.get_vector())\n\n    def get_projection(self, point):\n        \"\"\"Return projection of a point onto the line\"\"\"\n        unit_vect = self.get_unit_vector()\n        start = self.get_start()\n        return start + np.dot(point - start, unit_vect) * unit_vect\n\n    def get_slope(self):\n        return np.tan(self.get_angle())\n\n    def set_angle(self, angle, about_point=None):\n        if about_point is None:\n            about_point = self.get_start()\n        self.rotate(\n            angle - self.get_angle(),\n            about_point=about_point,\n        )\n        return self\n\n    def set_length(self, length):\n        self.scale(length / self.get_length())"}, {"name": "OpenGLMobject", "code": "class OpenGLMobject:\n    \"\"\"Mathematical Object: base class for objects that can be displayed on screen.\n\n    Attributes\n    ----------\n    submobjects : List[:class:`OpenGLMobject`]\n        The contained objects.\n    points : :class:`numpy.ndarray`\n        The points of the objects.\n\n        .. seealso::\n\n            :class:`~.OpenGLVMobject`\n\n    \"\"\"\n\n    shader_dtype = [\n        (\"point\", np.float32, (3,)),\n    ]\n    shader_folder = \"\"\n\n    # _Data and _Uniforms are set as class variables to tell manim how to handle setting/getting these attributes later.\n    points = _Data()\n    bounding_box = _Data()\n    rgbas = _Data()\n\n    is_fixed_in_frame = _Uniforms()\n    is_fixed_orientation = _Uniforms()\n    fixed_orientation_center = _Uniforms()  # for fixed orientation reference\n    gloss = _Uniforms()\n    shadow = _Uniforms()\n\n    def __init__(\n        self,\n        color: ParsableManimColor | Iterable[ParsableManimColor] = WHITE,\n        opacity: float = 1,\n        dim: int = 3,  # TODO, get rid of this\n        # Lighting parameters\n        # Positive gloss up to 1 makes it reflect the light.\n        gloss: float = 0.0,\n        # Positive shadow up to 1 makes a side opposite the light darker\n        shadow: float = 0.0,\n        # For shaders\n        render_primitive: int = moderngl.TRIANGLES,\n        texture_paths: dict[str, str] | None = None,\n        depth_test: bool = False,\n        # If true, the mobject will not get rotated according to camera position\n        is_fixed_in_frame: bool = False,\n        is_fixed_orientation: bool = False,\n        # Must match in attributes of vert shader\n        # Event listener\n        listen_to_events: bool = False,\n        model_matrix: MatrixMN | None = None,\n        should_render: bool = True,\n        name: str | None = None,\n        **kwargs,\n    ):\n        self.name = self.__class__.__name__ if name is None else name\n        # getattr in case data/uniforms are already defined in parent classes.\n        self.data = getattr(self, \"data\", {})\n        self.uniforms = getattr(self, \"uniforms\", {})\n\n        self.opacity = opacity\n        self.dim = dim  # TODO, get rid of this\n        # Lighting parameters\n        # Positive gloss up to 1 makes it reflect the light.\n        self.gloss = gloss\n        # Positive shadow up to 1 makes a side opposite the light darker\n        self.shadow = shadow\n        # For shaders\n        self.render_primitive = render_primitive\n        self.texture_paths = texture_paths\n        self.depth_test = depth_test\n        # If true, the mobject will not get rotated according to camera position\n        self.is_fixed_in_frame = float(is_fixed_in_frame)\n        self.is_fixed_orientation = float(is_fixed_orientation)\n        self.fixed_orientation_center = (0, 0, 0)\n        # Must match in attributes of vert shader\n        # Event listener\n        self.listen_to_events = listen_to_events\n\n        self._submobjects = []\n        self.parents = []\n        self.parent = None\n        self.family = [self]\n        self.locked_data_keys = set()\n        self.needs_new_bounding_box = True\n        if model_matrix is None:\n            self.model_matrix = np.eye(4)\n        else:\n            self.model_matrix = model_matrix\n\n        self.init_data()\n        self.init_updaters()\n        # self.init_event_listners()\n        self.init_points()\n        self.color = ManimColor.parse(color)\n        self.init_colors()\n\n        self.shader_indices = None\n\n        if self.depth_test:\n            self.apply_depth_test()\n\n        self.should_render = should_render\n\n    def _assert_valid_submobjects(self, submobjects: Iterable[OpenGLMobject]) -> Self:\n        \"\"\"Check that all submobjects are actually instances of\n        :class:`OpenGLMobject`, and that none of them is\n        ``self`` (an :class:`OpenGLMobject` cannot contain itself).\n\n        This is an auxiliary function called when adding OpenGLMobjects to the\n        :attr:`submobjects` list.\n\n        This function is intended to be overridden by subclasses such as\n        :class:`OpenGLVMobject`, which should assert that only other\n        OpenGLVMobjects may be added into it.\n\n        Parameters\n        ----------\n        submobjects\n            The list containing values to validate.\n\n        Returns\n        -------\n        :class:`OpenGLMobject`\n            The OpenGLMobject itself.\n\n        Raises\n        ------\n        TypeError\n            If any of the values in `submobjects` is not an\n            :class:`OpenGLMobject`.\n        ValueError\n            If there was an attempt to add an :class:`OpenGLMobject` as its own\n            submobject.\n        \"\"\"\n        return self._assert_valid_submobjects_internal(submobjects, OpenGLMobject)\n\n    def _assert_valid_submobjects_internal(\n        self, submobjects: Iterable[OpenGLMobject], mob_class: type[OpenGLMobject]\n    ) -> Self:\n        for i, submob in enumerate(submobjects):\n            if not isinstance(submob, mob_class):\n                error_message = (\n                    f\"Only values of type {mob_class.__name__} can be added \"\n                    f\"as submobjects of {type(self).__name__}, but the value \"\n                    f\"{submob} (at index {i}) is of type \"\n                    f\"{type(submob).__name__}.\"\n                )\n                # Intended for subclasses such as OpenGLVMobject, which\n                # cannot have regular OpenGLMobjects as submobjects\n                if isinstance(submob, OpenGLMobject):\n                    error_message += (\n                        \" You can try adding this value into a Group instead.\"\n                    )\n                raise TypeError(error_message)\n            if submob is self:\n                raise ValueError(\n                    f\"Cannot add {type(self).__name__} as a submobject of \"\n                    f\"itself (at index {i}).\"\n                )\n        return self\n\n    @classmethod\n    def __init_subclass__(cls, **kwargs) -> None:\n        super().__init_subclass__(**kwargs)\n        cls._original__init__ = cls.__init__\n\n    def __str__(self) -> str:\n        return self.__class__.__name__\n\n    def __repr__(self) -> str:\n        return str(self.name)\n\n    def __sub__(self, other):\n        return NotImplemented\n\n    def __isub__(self, other):\n        return NotImplemented\n\n    def __add__(self, mobject):\n        return NotImplemented\n\n    def __iadd__(self, mobject):\n        return NotImplemented\n\n    @classmethod\n    def set_default(cls, **kwargs) -> None:\n        \"\"\"Sets the default values of keyword arguments.\n\n        If this method is called without any additional keyword\n        arguments, the original default values of the initialization\n        method of this class are restored.\n\n        Parameters\n        ----------\n\n        kwargs\n            Passing any keyword argument will update the default\n            values of the keyword arguments of the initialization\n            function of this class.\n\n        Examples\n        --------\n\n        ::\n\n            >>> from manim import Square, GREEN\n            >>> Square.set_default(color=GREEN, fill_opacity=0.25)\n            >>> s = Square(); s.color, s.fill_opacity\n            (ManimColor('#83C167'), 0.25)\n            >>> Square.set_default()\n            >>> s = Square(); s.color, s.fill_opacity\n            (ManimColor('#FFFFFF'), 0.0)\n\n        .. manim:: ChangedDefaultTextcolor\n            :save_last_frame:\n\n            config.background_color = WHITE\n\n            class ChangedDefaultTextcolor(Scene):\n                def construct(self):\n                    Text.set_default(color=BLACK)\n                    self.add(Text(\"Changing default values is easy!\"))\n\n                    # we revert the colour back to the default to prevent a bug in the docs.\n                    Text.set_default(color=WHITE)\n\n        \"\"\"\n        if kwargs:\n            cls.__init__ = partialmethod(cls.__init__, **kwargs)\n        else:\n            cls.__init__ = cls._original__init__\n\n    def init_data(self) -> None:\n        \"\"\"Initializes the ``points``, ``bounding_box`` and ``rgbas`` attributes and groups them into self.data.\n        Subclasses can inherit and overwrite this method to extend `self.data`.\n        \"\"\"\n        self.points = np.zeros((0, 3))\n        self.bounding_box = np.zeros((3, 3))\n        self.rgbas = np.zeros((1, 4))\n\n    def init_colors(self) -> object:\n        \"\"\"Initializes the colors.\n\n        Gets called upon creation\n        \"\"\"\n        self.set_color(self.color, self.opacity)\n\n    def init_points(self) -> object:\n        \"\"\"Initializes :attr:`points` and therefore the shape.\n\n        Gets called upon creation. This is an empty method that can be implemented by\n        subclasses.\n        \"\"\"\n        # Typically implemented in subclass, unless purposefully left blank\n        pass\n\n    def set(self, **kwargs) -> Self:\n        \"\"\"Sets attributes.\n\n        Mainly to be used along with :attr:`animate` to\n        animate setting attributes.\n\n        Examples\n        --------\n        ::\n\n            >>> mob = OpenGLMobject()\n            >>> mob.set(foo=0)\n            OpenGLMobject\n            >>> mob.foo\n            0\n\n        Parameters\n        ----------\n        **kwargs\n            The attributes and corresponding values to set.\n\n        Returns\n        -------\n        :class:`OpenGLMobject`\n            ``self``\n\n\n        \"\"\"\n        for attr, value in kwargs.items():\n            setattr(self, attr, value)\n\n        return self\n\n    def set_data(self, data: dict[str, Any]) -> Self:\n        for key in data:\n            self.data[key] = data[key].copy()\n        return self\n\n    def set_uniforms(self, uniforms: dict[str, Any]) -> Self:\n        for key in uniforms:\n            self.uniforms[key] = uniforms[key]  # Copy?\n        return self\n\n    @property\n    def animate(self) -> _AnimationBuilder | Self:\n        \"\"\"Used to animate the application of a method.\n\n        .. warning::\n\n            Passing multiple animations for the same :class:`OpenGLMobject` in one\n            call to :meth:`~.Scene.play` is discouraged and will most likely\n            not work properly. Instead of writing an animation like\n\n            ::\n\n                self.play(\n                    my_mobject.animate.shift(RIGHT), my_mobject.animate.rotate(PI)\n                )\n\n            make use of method chaining for ``animate``, meaning::\n\n                self.play(my_mobject.animate.shift(RIGHT).rotate(PI))\n\n        Keyword arguments that can be passed to :meth:`.Scene.play` can be passed\n        directly after accessing ``.animate``, like so::\n\n            self.play(my_mobject.animate(rate_func=linear).shift(RIGHT))\n\n        This is especially useful when animating simultaneous ``.animate`` calls that\n        you want to behave differently::\n\n            self.play(\n                mobject1.animate(run_time=2).rotate(PI),\n                mobject2.animate(rate_func=there_and_back).shift(RIGHT),\n            )\n\n        .. seealso::\n\n            :func:`override_animate`\n\n\n        Examples\n        --------\n\n        .. manim:: AnimateExample\n\n            class AnimateExample(Scene):\n                def construct(self):\n                    s = Square()\n                    self.play(Create(s))\n                    self.play(s.animate.shift(RIGHT))\n                    self.play(s.animate.scale(2))\n                    self.play(s.animate.rotate(PI / 2))\n                    self.play(Uncreate(s))\n\n\n        .. manim:: AnimateChainExample\n\n            class AnimateChainExample(Scene):\n                def construct(self):\n                    s = Square()\n                    self.play(Create(s))\n                    self.play(s.animate.shift(RIGHT).scale(2).rotate(PI / 2))\n                    self.play(Uncreate(s))\n\n        .. manim:: AnimateWithArgsExample\n\n            class AnimateWithArgsExample(Scene):\n                def construct(self):\n                    s = Square()\n                    c = Circle()\n\n                    VGroup(s, c).arrange(RIGHT, buff=2)\n                    self.add(s, c)\n\n                    self.play(\n                        s.animate(run_time=2).rotate(PI / 2),\n                        c.animate(rate_func=there_and_back).shift(RIGHT),\n                    )\n\n        .. warning::\n\n            ``.animate``\n             will interpolate the :class:`~.OpenGLMobject` between its points prior to\n             ``.animate`` and its points after applying ``.animate`` to it. This may\n             result in unexpected behavior when attempting to interpolate along paths,\n             or rotations.\n             If you want animations to consider the points between, consider using\n             :class:`~.ValueTracker` with updaters instead.\n\n        \"\"\"\n        return _AnimationBuilder(self)\n\n    @property\n    def width(self) -> float:\n        \"\"\"The width of the mobject.\n\n        Returns\n        -------\n        :class:`float`\n\n        Examples\n        --------\n        .. manim:: WidthExample\n\n            class WidthExample(Scene):\n                def construct(self):\n                    decimal = DecimalNumber().to_edge(UP)\n                    rect = Rectangle(color=BLUE)\n                    rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)\n\n                    decimal.add_updater(lambda d: d.set_value(rect.width))\n\n                    self.add(rect_copy, rect, decimal)\n                    self.play(rect.animate.set(width=7))\n                    self.wait()\n\n        See also\n        --------\n        :meth:`length_over_dim`\n\n        \"\"\"\n        # Get the length across the X dimension\n        return self.length_over_dim(0)\n\n    # Only these methods should directly affect points\n    @width.setter\n    def width(self, value: float) -> None:\n        self.rescale_to_fit(value, 0, stretch=False)\n\n    @property\n    def height(self) -> float:\n        \"\"\"The height of the mobject.\n\n        Returns\n        -------\n        :class:`float`\n\n        Examples\n        --------\n        .. manim:: HeightExample\n\n            class HeightExample(Scene):\n                def construct(self):\n                    decimal = DecimalNumber().to_edge(UP)\n                    rect = Rectangle(color=BLUE)\n                    rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)\n\n                    decimal.add_updater(lambda d: d.set_value(rect.height))\n\n                    self.add(rect_copy, rect, decimal)\n                    self.play(rect.animate.set(height=5))\n                    self.wait()\n\n        See also\n        --------\n        :meth:`length_over_dim`\n\n        \"\"\"\n        # Get the length across the Y dimension\n        return self.length_over_dim(1)\n\n    @height.setter\n    def height(self, value: float) -> None:\n        self.rescale_to_fit(value, 1, stretch=False)\n\n    @property\n    def depth(self) -> float:\n        \"\"\"The depth of the mobject.\n\n        Returns\n        -------\n        :class:`float`\n\n        See also\n        --------\n        :meth:`length_over_dim`\n\n        \"\"\"\n        # Get the length across the Z dimension\n        return self.length_over_dim(2)\n\n    @depth.setter\n    def depth(self, value: float) -> None:\n        self.rescale_to_fit(value, 2, stretch=False)\n\n    def resize_points(self, new_length, resize_func=resize_array):\n        if new_length != len(self.points):\n            self.points = resize_func(self.points, new_length)\n        self.refresh_bounding_box()\n        return self\n\n    def set_points(self, points: Point3DLike_Array) -> Self:\n        if len(points) == len(self.points):\n            self.points[:] = points\n        elif isinstance(points, np.ndarray):\n            self.points = points.copy()\n        else:\n            self.points = np.array(points)\n        self.refresh_bounding_box()\n        return self\n\n    def apply_over_attr_arrays(\n        self, func: Callable[[npt.NDArray[T]], npt.NDArray[T]]\n    ) -> Self:\n        # TODO: OpenGLMobject.get_array_attrs() doesn't even exist!\n        for attr in self.get_array_attrs():\n            setattr(self, attr, func(getattr(self, attr)))\n        return self\n\n    def append_points(self, new_points: Point3DLike_Array) -> Self:\n        self.points = np.vstack([self.points, new_points])\n        self.refresh_bounding_box()\n        return self\n\n    def reverse_points(self) -> Self:\n        for mob in self.get_family():\n            for key in mob.data:\n                mob.data[key] = mob.data[key][::-1]\n        return self\n\n    def get_midpoint(self) -> Point3D:\n        \"\"\"Get coordinates of the middle of the path that forms the  :class:`~.OpenGLMobject`.\n\n        Examples\n        --------\n\n        .. manim:: AngleMidPoint\n            :save_last_frame:\n\n            class AngleMidPoint(Scene):\n                def construct(self):\n                    line1 = Line(ORIGIN, 2*RIGHT)\n                    line2 = Line(ORIGIN, 2*RIGHT).rotate_about_origin(80*DEGREES)\n\n                    a = Angle(line1, line2, radius=1.5, other_angle=False)\n                    d = Dot(a.get_midpoint()).set_color(RED)\n\n                    self.add(line1, line2, a, d)\n                    self.wait()\n\n        \"\"\"\n        return self.point_from_proportion(0.5)\n\n    # TODO: name is inconsistent with Mobject.apply_points_function_about_point()\n    def apply_points_function(\n        self,\n        func: MultiMappingFunction,\n        about_point: Point3DLike | None = None,\n        about_edge: Vector3D | None = ORIGIN,\n        works_on_bounding_box: bool = False,\n    ) -> Self:\n        if about_point is None and about_edge is not None:\n            about_point = self.get_bounding_box_point(about_edge)\n\n        for mob in self.get_family():\n            arrs = []\n            if mob.has_points():\n                arrs.append(mob.points)\n            if works_on_bounding_box:\n                arrs.append(mob.get_bounding_box())\n\n            for arr in arrs:\n                if about_point is None:\n                    arr[:] = func(arr)\n                else:\n                    arr[:] = func(arr - about_point) + about_point\n\n        if not works_on_bounding_box:\n            self.refresh_bounding_box(recurse_down=True)\n        else:\n            for parent in self.parents:\n                parent.refresh_bounding_box()\n        return self\n\n    # Others related to points\n\n    def match_points(self, mobject: OpenGLMobject) -> Self:\n        \"\"\"Edit points, positions, and submobjects to be identical\n        to another :class:`~.OpenGLMobject`, while keeping the style unchanged.\n\n        Examples\n        --------\n        .. manim:: MatchPointsScene\n\n            class MatchPointsScene(Scene):\n                def construct(self):\n                    circ = Circle(fill_color=RED, fill_opacity=0.8)\n                    square = Square(fill_color=BLUE, fill_opacity=0.2)\n                    self.add(circ)\n                    self.wait(0.5)\n                    self.play(circ.animate.match_points(square))\n                    self.wait(0.5)\n        \"\"\"\n        self.set_points(mobject.points)\n        return self\n\n    def clear_points(self) -> Self:\n        self.points = np.empty((0, 3))\n        return self\n\n    def get_num_points(self) -> int:\n        return len(self.points)\n\n    def get_all_points(self) -> Point3D_Array:\n        if self.submobjects:\n            return np.vstack([sm.points for sm in self.get_family()])\n        else:\n            return self.points\n\n    def has_points(self) -> bool:\n        return self.get_num_points() > 0\n\n    def get_bounding_box(self) -> npt.NDArray[float]:\n        if self.needs_new_bounding_box:\n            self.bounding_box = self.compute_bounding_box()\n            self.needs_new_bounding_box = False\n        return self.bounding_box\n\n    def compute_bounding_box(self) -> npt.NDArray[float]:\n        all_points = np.vstack(\n            [\n                self.points,\n                *(\n                    mob.get_bounding_box()\n                    for mob in self.get_family()[1:]\n                    if mob.has_points()\n                ),\n            ],\n        )\n        if len(all_points) == 0:\n            return np.zeros((3, self.dim))\n        else:\n            # Lower left and upper right corners\n            mins = all_points.min(0)\n            maxs = all_points.max(0)\n            mids = (mins + maxs) / 2\n            return np.array([mins, mids, maxs])\n\n    def refresh_bounding_box(\n        self, recurse_down: bool = False, recurse_up: bool = True\n    ) -> Self:\n        for mob in self.get_family(recurse_down):\n            mob.needs_new_bounding_box = True\n        if recurse_up:\n            for parent in self.parents:\n                parent.refresh_bounding_box()\n        return self\n\n    def is_point_touching(\n        self, point: Point3DLike, buff: float = MED_SMALL_BUFF\n    ) -> bool:\n        bb = self.get_bounding_box()\n        mins = bb[0] - buff\n        maxs = bb[2] + buff\n        return (point >= mins).all() and (point <= maxs).all()\n\n    # Family matters\n\n    def __getitem__(self, value: int | slice) -> OpenGLMobject:\n        if isinstance(value, slice):\n            GroupClass = self.get_group_class()\n            return GroupClass(*self.split().__getitem__(value))\n        return self.split().__getitem__(value)\n\n    def __iter__(self) -> Iterator[OpenGLMobject]:\n        return iter(self.split())\n\n    def __len__(self) -> int:\n        return len(self.split())\n\n    def split(self) -> Sequence[OpenGLMobject]:\n        return self.submobjects\n\n    def assemble_family(self) -> Self:\n        sub_families = (sm.get_family() for sm in self.submobjects)\n        self.family = [self, *uniq_chain(*sub_families)]\n        self.refresh_has_updater_status()\n        self.refresh_bounding_box()\n        for parent in self.parents:\n            parent.assemble_family()\n        return self\n\n    def get_family(self, recurse: bool = True) -> Sequence[OpenGLMobject]:\n        if recurse and hasattr(self, \"family\"):\n            return self.family\n        else:\n            return [self]\n\n    def family_members_with_points(self) -> Sequence[OpenGLMobject]:\n        return [m for m in self.get_family() if m.has_points()]\n\n    def add(self, *mobjects: OpenGLMobject, update_parent: bool = False) -> Self:\n        \"\"\"Add mobjects as submobjects.\n\n        The mobjects are added to :attr:`submobjects`.\n\n        Subclasses of mobject may implement ``+`` and ``+=`` dunder methods.\n\n        Parameters\n        ----------\n        mobjects\n            The mobjects to add.\n\n        Returns\n        -------\n        :class:`OpenGLMobject`\n            ``self``\n\n        Raises\n        ------\n        :class:`ValueError`\n            When a mobject tries to add itself.\n        :class:`TypeError`\n            When trying to add an object that is not an instance of :class:`OpenGLMobject`.\n\n\n        Notes\n        -----\n        A mobject cannot contain itself, and it cannot contain a submobject\n        more than once.  If the parent mobject is displayed, the newly-added\n        submobjects will also be displayed (i.e. they are automatically added\n        to the parent Scene).\n\n        See Also\n        --------\n        :meth:`remove`\n        :meth:`add_to_back`\n\n        Examples\n        --------\n        ::\n\n            >>> outer = OpenGLMobject()\n            >>> inner = OpenGLMobject()\n            >>> outer = outer.add(inner)\n\n        Duplicates are not added again::\n\n            >>> outer = outer.add(inner)\n            >>> len(outer.submobjects)\n            1\n\n        Only OpenGLMobjects can be added::\n\n            >>> outer.add(3)\n            Traceback (most recent call last):\n            ...\n            TypeError: Only values of type OpenGLMobject can be added as submobjects of OpenGLMobject, but the value 3 (at index 0) is of type int.\n\n        Adding an object to itself raises an error::\n\n            >>> outer.add(outer)\n            Traceback (most recent call last):\n            ...\n            ValueError: Cannot add OpenGLMobject as a submobject of itself (at index 0).\n\n        \"\"\"\n        if update_parent:\n            assert len(mobjects) == 1, \"Can't set multiple parents.\"\n            mobjects[0].parent = self\n\n        self._assert_valid_submobjects(mobjects)\n\n        if any(mobjects.count(elem) > 1 for elem in mobjects):\n            logger.warning(\n                \"Attempted adding some Mobject as a child more than once, \"\n                \"this is not possible. Repetitions are ignored.\",\n            )\n        for mobject in mobjects:\n            if mobject not in self.submobjects:\n                self.submobjects.append(mobject)\n            if self not in mobject.parents:\n                mobject.parents.append(self)\n        self.assemble_family()\n        return self\n\n    def insert(\n        self, index: int, mobject: OpenGLMobject, update_parent: bool = False\n    ) -> Self:\n        \"\"\"Inserts a mobject at a specific position into self.submobjects\n\n        Effectively just calls  ``self.submobjects.insert(index, mobject)``,\n        where ``self.submobjects`` is a list.\n\n        Highly adapted from ``OpenGLMobject.add``.\n\n        Parameters\n        ----------\n        index\n            The index at which\n        mobject\n            The mobject to be inserted.\n        update_parent\n            Whether or not to set ``mobject.parent`` to ``self``.\n        \"\"\"\n        if update_parent:\n            mobject.parent = self\n\n        self._assert_valid_submobjects([mobject])\n\n        if mobject not in self.submobjects:\n            self.submobjects.insert(index, mobject)\n\n        if self not in mobject.parents:\n            mobject.parents.append(self)\n\n        self.assemble_family()\n        return self\n\n    def remove(self, *mobjects: OpenGLMobject, update_parent: bool = False) -> Self:\n        \"\"\"Remove :attr:`submobjects`.\n\n        The mobjects are removed from :attr:`submobjects`, if they exist.\n\n        Subclasses of mobject may implement ``-`` and ``-=`` dunder methods.\n\n        Parameters\n        ----------\n        mobjects\n            The mobjects to remove.\n\n        Returns\n        -------\n        :class:`OpenGLMobject`\n            ``self``\n\n        See Also\n        --------\n        :meth:`add`\n\n        \"\"\"\n        if update_parent:\n            assert len(mobjects) == 1, \"Can't remove multiple parents.\"\n            mobjects[0].parent = None\n\n        for mobject in mobjects:\n            if mobject in self.submobjects:\n                self.submobjects.remove(mobject)\n            if self in mobject.parents:\n                mobject.parents.remove(self)\n        self.assemble_family()\n        return self\n\n    def add_to_back(self, *mobjects: OpenGLMobject) -> Self:\n        # NOTE: is the note true OpenGLMobjects?\n        \"\"\"Add all passed mobjects to the back of the submobjects.\n\n        If :attr:`submobjects` already contains the given mobjects, they just get moved\n        to the back instead.\n\n        Parameters\n        ----------\n        mobjects\n            The mobjects to add.\n\n        Returns\n        -------\n        :class:`OpenGLMobject`\n            ``self``\n\n\n        .. note::\n\n            Technically, this is done by adding (or moving) the mobjects to\n            the head of :attr:`submobjects`. The head of this list is rendered\n            first, which places the corresponding mobjects behind the\n            subsequent list members.\n\n        Raises\n        ------\n        :class:`ValueError`\n            When a mobject tries to add itself.\n        :class:`TypeError`\n            When trying to add an object that is not an instance of :class:`OpenGLMobject`.\n\n        Notes\n        -----\n        A mobject cannot contain itself, and it cannot contain a submobject\n        more than once.  If the parent mobject is displayed, the newly-added\n        submobjects will also be displayed (i.e. they are automatically added\n        to the parent Scene).\n\n        See Also\n        --------\n        :meth:`remove`\n        :meth:`add`\n\n        \"\"\"\n        self._assert_valid_submobjects(mobjects)\n        self.submobjects = list_update(mobjects, self.submobjects)\n        return self\n\n    def replace_submobject(self, index: int, new_submob: OpenGLMobject) -> Self:\n        self._assert_valid_submobjects([new_submob])\n        old_submob = self.submobjects[index]\n        if self in old_submob.parents:\n            old_submob.parents.remove(self)\n        self.submobjects[index] = new_submob\n        self.assemble_family()\n        return self\n\n    # Submobject organization\n\n    def arrange(\n        self, direction: Vector3D = RIGHT, center: bool = True, **kwargs\n    ) -> Self:\n        \"\"\"Sorts :class:`~.OpenGLMobject` next to each other on screen.\n\n        Examples\n        --------\n\n        .. manim:: Example\n            :save_last_frame:\n\n            class Example(Scene):\n                def construct(self):\n                    s1 = Square()\n                    s2 = Square()\n                    s3 = Square()\n                    s4 = Square()\n                    x = OpenGLVGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.0)\n                    self.add(x)\n        \"\"\"\n        for m1, m2 in zip(self.submobjects, self.submobjects[1:]):\n            m2.next_to(m1, direction, **kwargs)\n        if center:\n            self.center()\n        return self\n\n    def arrange_in_grid(\n        self,\n        rows: int | None = None,\n        cols: int | None = None,\n        buff: float | tuple[float, float] = MED_SMALL_BUFF,\n        cell_alignment: Vector3D = ORIGIN,\n        row_alignments: str | None = None,  # \"ucd\"\n        col_alignments: str | None = None,  # \"lcr\"\n        row_heights: Sequence[float | None] | None = None,\n        col_widths: Sequence[float | None] | None = None,\n        flow_order: str = \"rd\",\n        **kwargs,\n    ) -> Self:\n        \"\"\"Arrange submobjects in a grid.\n\n        Parameters\n        ----------\n        rows\n            The number of rows in the grid.\n        cols\n            The number of columns in the grid.\n        buff\n            The gap between grid cells. To specify a different buffer in the horizontal and\n            vertical directions, a tuple of two values can be given - ``(row, col)``.\n        cell_alignment\n            The way each submobject is aligned in its grid cell.\n        row_alignments\n            The vertical alignment for each row (top to bottom). Accepts the following characters: ``\"u\"`` -\n            up, ``\"c\"`` - center, ``\"d\"`` - down.\n        col_alignments\n            The horizontal alignment for each column (left to right). Accepts the following characters ``\"l\"`` - left,\n            ``\"c\"`` - center, ``\"r\"`` - right.\n        row_heights\n            Defines a list of heights for certain rows (top to bottom). If the list contains\n            ``None``, the corresponding row will fit its height automatically based\n            on the highest element in that row.\n        col_widths\n            Defines a list of widths for certain columns (left to right). If the list contains ``None``, the\n            corresponding column will fit its width automatically based on the widest element in that column.\n        flow_order\n            The order in which submobjects fill the grid. Can be one of the following values:\n            \"rd\", \"dr\", \"ld\", \"dl\", \"ru\", \"ur\", \"lu\", \"ul\". (\"rd\" -> fill rightwards then downwards)\n\n        Returns\n        -------\n        OpenGLMobject\n            The mobject.\n\n        NOTES\n        -----\n\n        If only one of ``cols`` and ``rows`` is set implicitly, the other one will be chosen big\n        enough to fit all submobjects. If neither is set, they will be chosen to be about the same,\n        tending towards ``cols`` > ``rows`` (simply because videos are wider than they are high).\n\n        If both ``cell_alignment`` and ``row_alignments`` / ``col_alignments`` are\n        defined, the latter has higher priority.\n\n\n        Raises\n        ------\n        ValueError\n            If ``rows`` and ``cols`` are too small to fit all submobjects.\n        ValueError\n            If :code:`cols`, :code:`col_alignments` and :code:`col_widths` or :code:`rows`,\n            :code:`row_alignments` and :code:`row_heights` have mismatching sizes.\n\n        Examples\n        --------\n        .. manim:: ExampleBoxes\n            :save_last_frame:\n\n            class ExampleBoxes(Scene):\n                def construct(self):\n                    boxes=VGroup(*[Square() for s in range(0,6)])\n                    boxes.arrange_in_grid(rows=2, buff=0.1)\n                    self.add(boxes)\n\n\n        .. manim:: ArrangeInGrid\n            :save_last_frame:\n\n            class ArrangeInGrid(Scene):\n                def construct(self):\n                    #Add some numbered boxes:\n                    np.random.seed(3)\n                    boxes = VGroup(*[\n                        Rectangle(WHITE, np.random.random()+.5, np.random.random()+.5).add(Text(str(i+1)).scale(0.5))\n                        for i in range(22)\n                    ])\n                    self.add(boxes)\n\n                    boxes.arrange_in_grid(\n                        buff=(0.25,0.5),\n                        col_alignments=\"lccccr\",\n                        row_alignments=\"uccd\",\n                        col_widths=[2, *[None]*4, 2],\n                        flow_order=\"dr\"\n                    )\n\n\n        \"\"\"\n        from manim.mobject.geometry.line import Line\n\n        mobs = self.submobjects.copy()\n        start_pos = self.get_center()\n\n        # get cols / rows values if given (implicitly)\n        def init_size(\n            num: int | None,\n            alignments: str | None,\n            sizes: Sequence[float | None] | None,\n            name: str,\n        ) -> int:\n            if num is not None:\n                return num\n            if alignments is not None:\n                return len(alignments)\n            if sizes is not None:\n                return len(sizes)\n            raise ValueError(\n                f\"At least one of the following parameters: '{name}s', \"\n                f\"'{name}_alignments' or \"\n                f\"'{name}_{'widths' if name == 'col' else 'heights'}', \"\n                \"must not be None\"\n            )\n\n        cols = init_size(cols, col_alignments, col_widths, \"col\")\n        rows = init_size(rows, row_alignments, row_heights, \"row\")\n\n        # calculate rows cols\n        if rows is None and cols is None:\n            cols = ceil(np.sqrt(len(mobs)))\n            # make the grid as close to quadratic as possible.\n            # choosing cols first can results in cols>rows.\n            # This is favored over rows>cols since in general\n            # the sceene is wider than high.\n        if rows is None:\n            rows = ceil(len(mobs) / cols)\n        if cols is None:\n            cols = ceil(len(mobs) / rows)\n        if rows * cols < len(mobs):\n            raise ValueError(\"Too few rows and columns to fit all submobjetcs.\")\n        # rows and cols are now finally valid.\n\n        if isinstance(buff, tuple):\n            buff_x = buff[0]\n            buff_y = buff[1]\n        else:\n            buff_x = buff_y = buff\n\n        # Initialize alignments correctly\n        def init_alignments(\n            str_alignments: str | None,\n            num: int,\n            mapping: dict[str, Vector3D],\n            name: str,\n            direction: Vector3D,\n        ) -> Sequence[Vector3D]:\n            if str_alignments is None:\n                # Use cell_alignment as fallback\n                return [cell_alignment * direction] * num\n            if len(str_alignments) != num:\n                raise ValueError(f\"{name}_alignments has a mismatching size.\")\n            return [mapping[letter] for letter in str_alignments]\n\n        row_alignments = init_alignments(\n            row_alignments,\n            rows,\n            {\"u\": UP, \"c\": ORIGIN, \"d\": DOWN},\n            \"row\",\n            RIGHT,\n        )\n        col_alignments = init_alignments(\n            col_alignments,\n            cols,\n            {\"l\": LEFT, \"c\": ORIGIN, \"r\": RIGHT},\n            \"col\",\n            UP,\n        )\n        # Now row_alignment[r] + col_alignment[c] is the alignment in cell [r][c]\n\n        mapper = {\n            \"dr\": lambda r, c: (rows - r - 1) + c * rows,\n            \"dl\": lambda r, c: (rows - r - 1) + (cols - c - 1) * rows,\n            \"ur\": lambda r, c: r + c * rows,\n            \"ul\": lambda r, c: r + (cols - c - 1) * rows,\n            \"rd\": lambda r, c: (rows - r - 1) * cols + c,\n            \"ld\": lambda r, c: (rows - r - 1) * cols + (cols - c - 1),\n            \"ru\": lambda r, c: r * cols + c,\n            \"lu\": lambda r, c: r * cols + (cols - c - 1),\n        }\n        if flow_order not in mapper:\n            raise ValueError(\n                'flow_order must be one of the following values: \"dr\", \"rd\", \"ld\" \"dl\", \"ru\", \"ur\", \"lu\", \"ul\".',\n            )\n        flow_order = mapper[flow_order]\n\n        # Reverse row_alignments and row_heights. Necessary since the\n        # grid filling is handled bottom up for simplicity reasons.\n        def reverse(maybe_list: Sequence[Any] | None) -> Sequence[Any] | None:\n            if maybe_list is not None:\n                maybe_list = list(maybe_list)\n                maybe_list.reverse()\n                return maybe_list\n            return None\n\n        row_alignments = reverse(row_alignments)\n        row_heights = reverse(row_heights)\n\n        placeholder = OpenGLMobject()\n        # Used to fill up the grid temporarily, doesn't get added to the scene.\n        # In this case a Mobject is better than None since it has width and height\n        # properties of 0.\n\n        mobs.extend([placeholder] * (rows * cols - len(mobs)))\n        grid = [[mobs[flow_order(r, c)] for c in range(cols)] for r in range(rows)]\n\n        measured_heigths = [\n            max(grid[r][c].height for c in range(cols)) for r in range(rows)\n        ]\n        measured_widths = [\n            max(grid[r][c].width for r in range(rows)) for c in range(cols)\n        ]\n\n        # Initialize row_heights / col_widths correctly using measurements as fallback\n        def init_sizes(\n            sizes: Sequence[float | None] | None,\n            num: int,\n            measures: Sequence[float],\n            name: str,\n        ) -> Sequence[float]:\n            if sizes is None:\n                sizes = [None] * num\n            if len(sizes) != num:\n                raise ValueError(f\"{name} has a mismatching size.\")\n            return [\n                sizes[i] if sizes[i] is not None else measures[i] for i in range(num)\n            ]\n\n        heights = init_sizes(row_heights, rows, measured_heigths, \"row_heights\")\n        widths = init_sizes(col_widths, cols, measured_widths, \"col_widths\")\n\n        x, y = 0, 0\n        for r in range(rows):\n            x = 0\n            for c in range(cols):\n                if grid[r][c] is not placeholder:\n                    alignment = row_alignments[r] + col_alignments[c]\n                    line = Line(\n                        x * RIGHT + y * UP,\n                        (x + widths[c]) * RIGHT + (y + heights[r]) * UP,\n                    )\n                    # Use a mobject to avoid rewriting align inside\n                    # box code that Mobject.move_to(Mobject) already\n                    # includes.\n\n                    grid[r][c].move_to(line, alignment)\n                x += widths[c] + buff_x\n            y += heights[r] + buff_y\n\n        self.move_to(start_pos)\n        return self\n\n    def get_grid(\n        self, n_rows: int, n_cols: int, height: float | None = None, **kwargs\n    ) -> OpenGLGroup:\n        \"\"\"\n        Returns a new mobject containing multiple copies of this one\n        arranged in a grid\n        \"\"\"\n        grid = self.duplicate(n_rows * n_cols)\n        grid.arrange_in_grid(n_rows, n_cols, **kwargs)\n        if height is not None:\n            grid.set_height(height)\n        return grid\n\n    def duplicate(self, n: int) -> OpenGLGroup:\n        \"\"\"Returns an :class:`~.OpenGLGroup` containing ``n`` copies of the mobject.\"\"\"\n        return self.get_group_class()(*[self.copy() for _ in range(n)])\n\n    def sort(\n        self,\n        point_to_num_func: Callable[[Point3DLike], float] = lambda p: p[0],\n        submob_func: Callable[[OpenGLMobject], Any] | None = None,\n    ) -> Self:\n        \"\"\"Sorts the list of :attr:`submobjects` by a function defined by ``submob_func``.\"\"\"\n        if submob_func is not None:\n            self.submobjects.sort(key=submob_func)\n        else:\n            self.submobjects.sort(key=lambda m: point_to_num_func(m.get_center()))\n        return self\n\n    def shuffle(self, recurse: bool = False) -> Self:\n        \"\"\"Shuffles the order of :attr:`submobjects`\n\n        Examples\n        --------\n\n        .. manim:: ShuffleSubmobjectsExample\n\n            class ShuffleSubmobjectsExample(Scene):\n                def construct(self):\n                    s= OpenGLVGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])\n                    s2= s.copy()\n                    s2.shuffle()\n                    s2.shift(DOWN)\n                    self.play(Write(s), Write(s2))\n        \"\"\"\n        if recurse:\n            for submob in self.submobjects:\n                submob.shuffle(recurse=True)\n        random.shuffle(self.submobjects)\n        self.assemble_family()\n        return self\n\n    def invert(self, recursive: bool = False) -> Self:\n        \"\"\"Inverts the list of :attr:`submobjects`.\n\n        Parameters\n        ----------\n        recursive\n            If ``True``, all submobject lists of this mobject's family are inverted.\n\n        Examples\n        --------\n\n        .. manim:: InvertSumobjectsExample\n\n            class InvertSumobjectsExample(Scene):\n                def construct(self):\n                    s = VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])\n                    s2 = s.copy()\n                    s2.invert()\n                    s2.shift(DOWN)\n                    self.play(Write(s), Write(s2))\n        \"\"\"\n        if recursive:\n            for submob in self.submobjects:\n                submob.invert(recursive=True)\n        self.submobjects.reverse()\n        self.assemble_family()\n        return self\n\n    # Copying\n\n    def copy(self, shallow: bool = False) -> OpenGLMobject:\n        \"\"\"Create and return an identical copy of the :class:`OpenGLMobject` including all\n        :attr:`submobjects`.\n\n        Returns\n        -------\n        :class:`OpenGLMobject`\n            The copy.\n\n        Parameters\n        ----------\n        shallow\n            Controls whether a shallow copy is returned.\n\n        Note\n        ----\n        The clone is initially not visible in the Scene, even if the original was.\n        \"\"\"\n        if not shallow:\n            return self.deepcopy()\n\n        # TODO, either justify reason for shallow copy, or\n        # remove this redundancy everywhere\n        # return self.deepcopy()\n\n        parents = self.parents\n        self.parents = []\n        copy_mobject = copy.copy(self)\n        self.parents = parents\n\n        copy_mobject.data = dict(self.data)\n        for key in self.data:\n            copy_mobject.data[key] = self.data[key].copy()\n\n        # TODO, are uniforms ever numpy arrays?\n        copy_mobject.uniforms = dict(self.uniforms)\n\n        copy_mobject.submobjects = []\n        copy_mobject.add(*(sm.copy() for sm in self.submobjects))\n        copy_mobject.match_updaters(self)\n\n        copy_mobject.needs_new_bounding_box = self.needs_new_bounding_box\n\n        # Make sure any mobject or numpy array attributes are copied\n        family = self.get_family()\n        for attr, value in list(self.__dict__.items()):\n            if (\n                isinstance(value, OpenGLMobject)\n                and value in family\n                and value is not self\n            ):\n                setattr(copy_mobject, attr, value.copy())\n            if isinstance(value, np.ndarray):\n                setattr(copy_mobject, attr, value.copy())\n            # if isinstance(value, ShaderWrapper):\n            #     setattr(copy_mobject, attr, value.copy())\n        return copy_mobject\n\n    def deepcopy(self) -> OpenGLMobject:\n        parents = self.parents\n        self.parents = []\n        result = copy.deepcopy(self)\n        self.parents = parents\n        return result\n\n    def generate_target(self, use_deepcopy: bool = False) -> OpenGLMobject:\n        self.target = None  # Prevent exponential explosion\n        if use_deepcopy:\n            self.target = self.deepcopy()\n        else:\n            self.target = self.copy()\n        return self.target\n\n    def save_state(self, use_deepcopy: bool = False) -> Self:\n        \"\"\"Save the current state (position, color & size). Can be restored with :meth:`~.OpenGLMobject.restore`.\"\"\"\n        if hasattr(self, \"saved_state\"):\n            # Prevent exponential growth of data\n            self.saved_state = None\n        if use_deepcopy:\n            self.saved_state = self.deepcopy()\n        else:\n            self.saved_state = self.copy()\n        return self\n\n    def restore(self) -> Self:\n        \"\"\"Restores the state that was previously saved with :meth:`~.OpenGLMobject.save_state`.\"\"\"\n        if not hasattr(self, \"saved_state\") or self.save_state is None:\n            raise Exception(\"Trying to restore without having saved\")\n        self.become(self.saved_state)\n        return self\n\n    # Updating\n\n    def init_updaters(self) -> None:\n        self.time_based_updaters = []\n        self.non_time_updaters = []\n        self.has_updaters = False\n        self.updating_suspended = False\n\n    def update(self, dt: float = 0, recurse: bool = True) -> Self:\n        if not self.has_updaters or self.updating_suspended:\n            return self\n        for updater in self.time_based_updaters:\n            updater(self, dt)\n        for updater in self.non_time_updaters:\n            updater(self)\n        if recurse:\n            for submob in self.submobjects:\n                submob.update(dt, recurse)\n        return self\n\n    def get_time_based_updaters(self) -> Sequence[TimeBasedUpdater]:\n        return self.time_based_updaters\n\n    def has_time_based_updater(self) -> bool:\n        return len(self.time_based_updaters) > 0\n\n    def get_updaters(self) -> Sequence[Updater]:\n        return self.time_based_updaters + self.non_time_updaters\n\n    def get_family_updaters(self) -> Sequence[Updater]:\n        return list(it.chain(*(sm.get_updaters() for sm in self.get_family())))\n\n    def add_updater(\n        self,\n        update_function: Updater,\n        index: int | None = None,\n        call_updater: bool = False,\n    ) -> Self:\n        if \"dt\" in inspect.signature(update_function).parameters:\n            updater_list = self.time_based_updaters\n        else:\n            updater_list = self.non_time_updaters\n\n        if index is None:\n            updater_list.append(update_function)\n        else:\n            updater_list.insert(index, update_function)\n\n        self.refresh_has_updater_status()\n        if call_updater:\n            self.update()\n        return self\n\n    def remove_updater(self, update_function: Updater) -> Self:\n        for updater_list in [self.time_based_updaters, self.non_time_updaters]:\n            while update_function in updater_list:\n                updater_list.remove(update_function)\n        self.refresh_has_updater_status()\n        return self\n\n    def clear_updaters(self, recurse: bool = True) -> Self:\n        self.time_based_updaters = []\n        self.non_time_updaters = []\n        self.refresh_has_updater_status()\n        if recurse:\n            for submob in self.submobjects:\n                submob.clear_updaters()\n        return self\n\n    def match_updaters(self, mobject: OpenGLMobject) -> Self:\n        self.clear_updaters()\n        for updater in mobject.get_updaters():\n            self.add_updater(updater)\n        return self\n\n    def suspend_updating(self, recurse: bool = True) -> Self:\n        self.updating_suspended = True\n        if recurse:\n            for submob in self.submobjects:\n                submob.suspend_updating(recurse)\n        return self\n\n    def resume_updating(self, recurse: bool = True, call_updater: bool = True) -> Self:\n        self.updating_suspended = False\n        if recurse:\n            for submob in self.submobjects:\n                submob.resume_updating(recurse)\n        for parent in self.parents:\n            parent.resume_updating(recurse=False, call_updater=False)\n        if call_updater:\n            self.update(dt=0, recurse=recurse)\n        return self\n\n    def refresh_has_updater_status(self) -> Self:\n        self.has_updaters = any(mob.get_updaters() for mob in self.get_family())\n        return self\n\n    # Transforming operations\n\n    def shift(self, vector: Vector3D) -> Self:\n        self.apply_points_function(\n            lambda points: points + vector,\n            about_edge=None,\n            works_on_bounding_box=True,\n        )\n        return self\n\n    def scale(\n        self,\n        scale_factor: float,\n        about_point: Sequence[float] | None = None,\n        about_edge: Sequence[float] = ORIGIN,\n        **kwargs,\n    ) -> Self:\n        r\"\"\"Scale the size by a factor.\n\n        Default behavior is to scale about the center of the mobject.\n        The argument about_edge can be a vector, indicating which side of\n        the mobject to scale about, e.g., mob.scale(about_edge = RIGHT)\n        scales about mob.get_right().\n\n        Otherwise, if about_point is given a value, scaling is done with\n        respect to that point.\n\n        Parameters\n        ----------\n        scale_factor\n            The scaling factor :math:`\\alpha`. If :math:`0 < |\\alpha|\u00a0< 1`, the mobject\n            will shrink, and for :math:`|\\alpha| > 1` it will grow. Furthermore,\n            if :math:`\\alpha < 0`, the mobject is also flipped.\n        kwargs\n            Additional keyword arguments passed to\n            :meth:`apply_points_function`.\n\n        Returns\n        -------\n        OpenGLMobject\n            The scaled mobject.\n\n        Examples\n        --------\n\n        .. manim:: MobjectScaleExample\n            :save_last_frame:\n\n            class MobjectScaleExample(Scene):\n                def construct(self):\n                    f1 = Text(\"F\")\n                    f2 = Text(\"F\").scale(2)\n                    f3 = Text(\"F\").scale(0.5)\n                    f4 = Text(\"F\").scale(-1)\n\n                    vgroup = VGroup(f1, f2, f3, f4).arrange(6 * RIGHT)\n                    self.add(vgroup)\n\n        See also\n        --------\n        :meth:`move_to`\n\n        \"\"\"\n        self.apply_points_function(\n            lambda points: scale_factor * points,\n            about_point=about_point,\n            about_edge=about_edge,\n            works_on_bounding_box=True,\n            **kwargs,\n        )\n        return self\n\n    def stretch(self, factor: float, dim: int, **kwargs) -> Self:\n        def func(points: Point3D_Array) -> Point3D_Array:\n            points[:, dim] *= factor\n            return points\n\n        self.apply_points_function(func, works_on_bounding_box=True, **kwargs)\n        return self\n\n    def rotate_about_origin(self, angle: float, axis: Vector3D = OUT) -> Self:\n        return self.rotate(angle, axis, about_point=ORIGIN)\n\n    def rotate(\n        self,\n        angle: float,\n        axis: Vector3D = OUT,\n        about_point: Sequence[float] | None = None,\n        **kwargs,\n    ) -> Self:\n        \"\"\"Rotates the :class:`~.OpenGLMobject` about a certain point.\"\"\"\n        rot_matrix_T = rotation_matrix_transpose(angle, axis)\n        self.apply_points_function(\n            lambda points: np.dot(points, rot_matrix_T),\n            about_point=about_point,\n            **kwargs,\n        )\n        return self\n\n    def flip(self, axis: Vector3D = UP, **kwargs) -> Self:\n        \"\"\"Flips/Mirrors an mobject about its center.\n\n        Examples\n        --------\n\n        .. manim:: FlipExample\n            :save_last_frame:\n\n            class FlipExample(Scene):\n                def construct(self):\n                    s= Line(LEFT, RIGHT+UP).shift(4*LEFT)\n                    self.add(s)\n                    s2= s.copy().flip()\n                    self.add(s2)\n\n        \"\"\"\n        return self.rotate(TAU / 2, axis, **kwargs)\n\n    def apply_function(self, function: MappingFunction, **kwargs) -> Self:\n        # Default to applying matrix about the origin, not mobjects center\n        if len(kwargs) == 0:\n            kwargs[\"about_point\"] = ORIGIN\n\n        def multi_mapping_function(points: Point3D_Array) -> Point3D_Array:\n            result: Point3D_Array = np.apply_along_axis(function, 1, points)\n            return result\n\n        self.apply_points_function(multi_mapping_function, **kwargs)\n        return self\n\n    def apply_function_to_position(self, function: MappingFunction) -> Self:\n        self.move_to(function(self.get_center()))\n        return self\n\n    def apply_function_to_submobject_positions(self, function: MappingFunction) -> Self:\n        for submob in self.submobjects:\n            submob.apply_function_to_position(function)\n        return self\n\n    def apply_matrix(self, matrix: MatrixMN, **kwargs) -> Self:\n        # Default to applying matrix about the origin, not mobjects center\n        if (\"about_point\" not in kwargs) and (\"about_edge\" not in kwargs):\n            kwargs[\"about_point\"] = ORIGIN\n        full_matrix = np.identity(self.dim)\n        matrix = np.array(matrix)\n        full_matrix[: matrix.shape[0], : matrix.shape[1]] = matrix\n        self.apply_points_function(\n            lambda points: np.dot(points, full_matrix.T), **kwargs\n        )\n        return self\n\n    def apply_complex_function(\n        self, function: Callable[[complex], complex], **kwargs\n    ) -> Self:\n        \"\"\"Applies a complex function to a :class:`OpenGLMobject`.\n        The x and y coordinates correspond to the real and imaginary parts respectively.\n\n        Example\n        -------\n\n        .. manim:: ApplyFuncExample\n\n            class ApplyFuncExample(Scene):\n                def construct(self):\n                    circ = Circle().scale(1.5)\n                    circ_ref = circ.copy()\n                    circ.apply_complex_function(\n                        lambda x: np.exp(x*1j)\n                    )\n                    t = ValueTracker(0)\n                    circ.add_updater(\n                        lambda x: x.become(circ_ref.copy().apply_complex_function(\n                            lambda x: np.exp(x+t.get_value()*1j)\n                        )).set_color(BLUE)\n                    )\n                    self.add(circ_ref)\n                    self.play(TransformFromCopy(circ_ref, circ))\n                    self.play(t.animate.set_value(TAU), run_time=3)\n        \"\"\"\n\n        def R3_func(point):\n            x, y, z = point\n            xy_complex = function(complex(x, y))\n            return [xy_complex.real, xy_complex.imag, z]\n\n        return self.apply_function(R3_func)\n\n    def hierarchical_model_matrix(self) -> MatrixMN:\n        if self.parent is None:\n            return self.model_matrix\n\n        model_matrices = [self.model_matrix]\n        current_object = self\n        while current_object.parent is not None:\n            model_matrices.append(current_object.parent.model_matrix)\n            current_object = current_object.parent\n        return np.linalg.multi_dot(list(reversed(model_matrices)))\n\n    def wag(\n        self,\n        direction: Vector3D = RIGHT,\n        axis: Vector3D = DOWN,\n        wag_factor: float = 1.0,\n    ) -> Self:\n        for mob in self.family_members_with_points():\n            alphas = np.dot(mob.points, np.transpose(axis))\n            alphas -= min(alphas)\n            alphas /= max(alphas)\n            alphas = alphas**wag_factor\n            mob.set_points(\n                mob.points\n                + np.dot(\n                    alphas.reshape((len(alphas), 1)),\n                    np.array(direction).reshape((1, mob.dim)),\n                ),\n            )\n        return self\n\n    # Positioning methods\n\n    def center(self) -> Self:\n        \"\"\"Moves the mobject to the center of the Scene.\"\"\"\n        self.shift(-self.get_center())\n        return self\n\n    def align_on_border(\n        self,\n        direction: Vector3D,\n        buff: float = DEFAULT_MOBJECT_TO_EDGE_BUFFER,\n    ) -> Self:\n        \"\"\"\n        Direction just needs to be a vector pointing towards side or\n        corner in the 2d plane.\n        \"\"\"\n        target_point = np.sign(direction) * (\n            config[\"frame_x_radius\"],\n            config[\"frame_y_radius\"],\n            0,\n        )\n        point_to_align = self.get_bounding_box_point(direction)\n        shift_val = target_point - point_to_align - buff * np.array(direction)\n        shift_val = shift_val * abs(np.sign(direction))\n        self.shift(shift_val)\n        return self\n\n    def to_corner(\n        self,\n        corner: Vector3D = LEFT + DOWN,\n        buff: float = DEFAULT_MOBJECT_TO_EDGE_BUFFER,\n    ) -> Self:\n        return self.align_on_border(corner, buff)\n\n    def to_edge(\n        self,\n        edge: Vector3D = LEFT,\n        buff: float = DEFAULT_MOBJECT_TO_EDGE_BUFFER,\n    ) -> Self:\n        return self.align_on_border(edge, buff)\n\n    def next_to(\n        self,\n        mobject_or_point: OpenGLMobject | Point3DLike,\n        direction: Vector3D = RIGHT,\n        buff: float = DEFAULT_MOBJECT_TO_MOBJECT_BUFFER,\n        aligned_edge: Vector3D = ORIGIN,\n        submobject_to_align: OpenGLMobject | None = None,\n        index_of_submobject_to_align: int | None = None,\n        coor_mask: Point3DLike = np.array([1, 1, 1]),\n    ) -> Self:\n        \"\"\"Move this :class:`~.OpenGLMobject` next to another's :class:`~.OpenGLMobject` or coordinate.\n\n        Examples\n        --------\n\n        .. manim:: GeometricShapes\n            :save_last_frame:\n\n            class GeometricShapes(Scene):\n                def construct(self):\n                    d = Dot()\n                    c = Circle()\n                    s = Square()\n                    t = Triangle()\n                    d.next_to(c, RIGHT)\n                    s.next_to(c, LEFT)\n                    t.next_to(c, DOWN)\n                    self.add(d, c, s, t)\n\n        \"\"\"\n        if isinstance(mobject_or_point, OpenGLMobject):\n            mob = mobject_or_point\n            if index_of_submobject_to_align is not None:\n                target_aligner = mob[index_of_submobject_to_align]\n            else:\n                target_aligner = mob\n            target_point = target_aligner.get_bounding_box_point(\n                aligned_edge + direction,\n            )\n        else:\n            target_point = mobject_or_point\n        if submobject_to_align is not None:\n            aligner = submobject_to_align\n        elif index_of_submobject_to_align is not None:\n            aligner = self[index_of_submobject_to_align]\n        else:\n            aligner = self\n        point_to_align = aligner.get_bounding_box_point(aligned_edge - direction)\n        self.shift((target_point - point_to_align + buff * direction) * coor_mask)\n        return self\n\n    def shift_onto_screen(self, **kwargs) -> Self:\n        space_lengths = [config[\"frame_x_radius\"], config[\"frame_y_radius\"]]\n        for vect in UP, DOWN, LEFT, RIGHT:\n            dim = np.argmax(np.abs(vect))\n            buff = kwargs.get(\"buff\", DEFAULT_MOBJECT_TO_EDGE_BUFFER)\n            max_val = space_lengths[dim] - buff\n            edge_center = self.get_edge_center(vect)\n            if np.dot(edge_center, vect) > max_val:\n                self.to_edge(vect, **kwargs)\n        return self\n\n    def is_off_screen(self) -> bool:\n        if self.get_left()[0] > config.frame_x_radius:\n            return True\n        if self.get_right()[0] < config.frame_x_radius:\n            return True\n        if self.get_bottom()[1] > config.frame_y_radius:\n            return True\n        return self.get_top()[1] < -config.frame_y_radius\n\n    def stretch_about_point(self, factor: float, dim: int, point: Point3DLike) -> Self:\n        return self.stretch(factor, dim, about_point=point)\n\n    def rescale_to_fit(\n        self, length: float, dim: int, stretch: bool = False, **kwargs\n    ) -> Self:\n        old_length = self.length_over_dim(dim)\n        if old_length == 0:\n            return self\n        if stretch:\n            self.stretch(length / old_length, dim, **kwargs)\n        else:\n            self.scale(length / old_length, **kwargs)\n        return self\n\n    def stretch_to_fit_width(self, width: float, **kwargs) -> Self:\n        \"\"\"Stretches the :class:`~.OpenGLMobject` to fit a width, not keeping height/depth proportional.\n\n        Returns\n        -------\n        :class:`OpenGLMobject`\n            ``self``\n\n        Examples\n        --------\n        ::\n\n            >>> from manim import *\n            >>> import numpy as np\n            >>> sq = Square()\n            >>> sq.height\n            np.float64(2.0)\n            >>> sq.stretch_to_fit_width(5)\n            Square\n            >>> sq.width\n            np.float64(5.0)\n            >>> sq.height\n            np.float64(2.0)\n        \"\"\"\n        return self.rescale_to_fit(width, 0, stretch=True, **kwargs)\n\n    def stretch_to_fit_height(self, height: float, **kwargs) -> Self:\n        \"\"\"Stretches the :class:`~.OpenGLMobject` to fit a height, not keeping width/height proportional.\"\"\"\n        return self.rescale_to_fit(height, 1, stretch=True, **kwargs)\n\n    def stretch_to_fit_depth(self, depth: float, **kwargs) -> Self:\n        \"\"\"Stretches the :class:`~.OpenGLMobject` to fit a depth, not keeping width/height proportional.\"\"\"\n        return self.rescale_to_fit(depth, 1, stretch=True, **kwargs)\n\n    def set_width(self, width: float, stretch: bool = False, **kwargs) -> Self:\n        \"\"\"Scales the :class:`~.OpenGLMobject` to fit a width while keeping height/depth proportional.\n\n        Returns\n        -------\n        :class:`OpenGLMobject`\n            ``self``\n\n        Examples\n        --------\n        ::\n\n            >>> from manim import *\n            >>> import numpy as np\n            >>> sq = Square()\n            >>> sq.height\n            np.float64(2.0)\n            >>> sq.scale_to_fit_width(5)\n            Square\n            >>> sq.width\n            np.float64(5.0)\n            >>> sq.height\n            np.float64(5.0)\n        \"\"\"\n        return self.rescale_to_fit(width, 0, stretch=stretch, **kwargs)\n\n    scale_to_fit_width = set_width\n\n    def set_height(self, height: float, stretch: bool = False, **kwargs) -> Self:\n        \"\"\"Scales the :class:`~.OpenGLMobject` to fit a height while keeping width/depth proportional.\"\"\"\n        return self.rescale_to_fit(height, 1, stretch=stretch, **kwargs)\n\n    scale_to_fit_height = set_height\n\n    def set_depth(self, depth: float, stretch: bool = False, **kwargs):\n        \"\"\"Scales the :class:`~.OpenGLMobject` to fit a depth while keeping width/height proportional.\"\"\"\n        return self.rescale_to_fit(depth, 2, stretch=stretch, **kwargs)\n\n    scale_to_fit_depth = set_depth\n\n    def set_coord(self, value: float, dim: int, direction: Vector3D = ORIGIN) -> Self:\n        curr = self.get_coord(dim, direction)\n        shift_vect = np.zeros(self.dim)\n        shift_vect[dim] = value - curr\n        self.shift(shift_vect)\n        return self\n\n    def set_x(self, x: float, direction: Vector3D = ORIGIN) -> Self:\n        \"\"\"Set x value of the center of the :class:`~.OpenGLMobject` (``int`` or ``float``)\"\"\"\n        return self.set_coord(x, 0, direction)\n\n    def set_y(self, y: float, direction: Vector3D = ORIGIN) -> Self:\n        \"\"\"Set y value of the center of the :class:`~.OpenGLMobject` (``int`` or ``float``)\"\"\"\n        return self.set_coord(y, 1, direction)\n\n    def set_z(self, z: float, direction: Vector3D = ORIGIN) -> Self:\n        \"\"\"Set z value of the center of the :class:`~.OpenGLMobject` (``int`` or ``float``)\"\"\"\n        return self.set_coord(z, 2, direction)\n\n    def space_out_submobjects(self, factor: float = 1.5, **kwargs) -> Self:\n        self.scale(factor, **kwargs)\n        for submob in self.submobjects:\n            submob.scale(1.0 / factor)\n        return self\n\n    def move_to(\n        self,\n        point_or_mobject: Point3DLike | OpenGLMobject,\n        aligned_edge: Vector3D = ORIGIN,\n        coor_mask: Point3DLike = np.array([1, 1, 1]),\n    ) -> Self:\n        \"\"\"Move center of the :class:`~.OpenGLMobject` to certain coordinate.\"\"\"\n        if isinstance(point_or_mobject, OpenGLMobject):\n            target = point_or_mobject.get_bounding_box_point(aligned_edge)\n        else:\n            target = point_or_mobject\n        point_to_align = self.get_bounding_box_point(aligned_edge)\n        self.shift((target - point_to_align) * coor_mask)\n        return self\n\n    def replace(\n        self,\n        mobject: OpenGLMobject,\n        dim_to_match: int = 0,\n        stretch: bool = False,\n    ) -> Self:\n        if not mobject.get_num_points() and not mobject.submobjects:\n            self.scale(0)\n            return self\n        if stretch:\n            for i in range(self.dim):\n                self.rescale_to_fit(mobject.length_over_dim(i), i, stretch=True)\n        else:\n            self.rescale_to_fit(\n                mobject.length_over_dim(dim_to_match),\n                dim_to_match,\n                stretch=False,\n            )\n        self.shift(mobject.get_center() - self.get_center())\n        return self\n\n    def surround(\n        self,\n        mobject: OpenGLMobject,\n        dim_to_match: int = 0,\n        stretch: bool = False,\n        buff: float = MED_SMALL_BUFF,\n    ) -> Self:\n        self.replace(mobject, dim_to_match, stretch)\n        length = mobject.length_over_dim(dim_to_match)\n        self.scale((length + buff) / length)\n        return self\n\n    def put_start_and_end_on(self, start: Point3DLike, end: Point3DLike) -> Self:\n        curr_start, curr_end = self.get_start_and_end()\n        curr_vect = curr_end - curr_start\n        if np.all(curr_vect == 0):\n            raise Exception(\"Cannot position endpoints of closed loop\")\n        target_vect = np.array(end) - np.array(start)\n        axis = (\n            normalize(np.cross(curr_vect, target_vect))\n            if np.linalg.norm(np.cross(curr_vect, target_vect)) != 0\n            else OUT\n        )\n        self.scale(\n            np.linalg.norm(target_vect) / np.linalg.norm(curr_vect),\n            about_point=curr_start,\n        )\n        self.rotate(\n            angle_between_vectors(curr_vect, target_vect),\n            about_point=curr_start,\n            axis=axis,\n        )\n        self.shift(start - curr_start)\n        return self\n\n    # Color functions\n\n    def set_rgba_array(\n        self,\n        color: ParsableManimColor | Iterable[ParsableManimColor] | None = None,\n        opacity: float | Iterable[float] | None = None,\n        name: str = \"rgbas\",\n        recurse: bool = True,\n    ) -> Self:\n        if color is not None:\n            rgbs = np.array([color_to_rgb(c) for c in listify(color)])\n        if opacity is not None:\n            opacities = listify(opacity)\n\n        # Color only\n        if color is not None and opacity is None:\n            for mob in self.get_family(recurse):\n                mob.data[name] = resize_array(\n                    mob.data[name] if name in mob.data else np.empty((1, 3)), len(rgbs)\n                )\n                mob.data[name][:, :3] = rgbs\n\n        # Opacity only\n        if color is None and opacity is not None:\n            for mob in self.get_family(recurse):\n                mob.data[name] = resize_array(\n                    mob.data[name] if name in mob.data else np.empty((1, 3)),\n                    len(opacities),\n                )\n                mob.data[name][:, 3] = opacities\n\n        # Color and opacity\n        if color is not None and opacity is not None:\n            rgbas = np.array([[*rgb, o] for rgb, o in zip(*make_even(rgbs, opacities))])\n            for mob in self.get_family(recurse):\n                mob.data[name] = rgbas.copy()\n        return self\n\n    def set_rgba_array_direct(\n        self,\n        rgbas: npt.NDArray[RGBA_Array_Float],\n        name: str = \"rgbas\",\n        recurse: bool = True,\n    ) -> Self:\n        \"\"\"Directly set rgba data from `rgbas` and optionally do the same recursively\n        with submobjects. This can be used if the `rgbas` have already been generated\n        with the correct shape and simply need to be set.\n\n        Parameters\n        ----------\n        rgbas\n            the rgba to be set as data\n        name\n            the name of the data attribute to be set\n        recurse\n            set to true to recursively apply this method to submobjects\n        \"\"\"\n        for mob in self.get_family(recurse):\n            mob.data[name] = rgbas.copy()\n\n    def set_color(\n        self,\n        color: ParsableManimColor | Iterable[ParsableManimColor] | None,\n        opacity: float | Iterable[float] | None = None,\n        recurse: bool = True,\n    ) -> Self:\n        self.set_rgba_array(color, opacity, recurse=False)\n        # Recurse to submobjects differently from how set_rgba_array\n        # in case they implement set_color differently\n        if color is not None:\n            self.color: ManimColor = ManimColor.parse(color)\n        if opacity is not None:\n            self.opacity = opacity\n        if recurse:\n            for submob in self.submobjects:\n                submob.set_color(color, recurse=True)\n        return self\n\n    def set_opacity(\n        self, opacity: float | Iterable[float] | None, recurse: bool = True\n    ) -> Self:\n        self.set_rgba_array(color=None, opacity=opacity, recurse=False)\n        if recurse:\n            for submob in self.submobjects:\n                submob.set_opacity(opacity, recurse=True)\n        return self\n\n    def get_color(self) -> str:\n        return rgb_to_hex(self.rgbas[0, :3])\n\n    def get_opacity(self) -> float:\n        return self.rgbas[0, 3]\n\n    def set_color_by_gradient(self, *colors: ParsableManimColor) -> Self:\n        return self.set_submobject_colors_by_gradient(*colors)\n\n    def set_submobject_colors_by_gradient(self, *colors: ParsableManimColor) -> Self:\n        if len(colors) == 0:\n            raise Exception(\"Need at least one color\")\n        elif len(colors) == 1:\n            return self.set_color(*colors)\n\n        # mobs = self.family_members_with_points()\n        mobs = self.submobjects\n        new_colors = color_gradient(colors, len(mobs))\n\n        for mob, color in zip(mobs, new_colors):\n            mob.set_color(color)\n        return self\n\n    def fade(self, darkness: float = 0.5, recurse: bool = True) -> Self:\n        return self.set_opacity(1.0 - darkness, recurse=recurse)\n\n    def get_gloss(self) -> float:\n        return self.gloss\n\n    def set_gloss(self, gloss: float, recurse: bool = True) -> Self:\n        for mob in self.get_family(recurse):\n            mob.gloss = gloss\n        return self\n\n    def get_shadow(self) -> float:\n        return self.shadow\n\n    def set_shadow(self, shadow: float, recurse: bool = True) -> Self:\n        for mob in self.get_family(recurse):\n            mob.shadow = shadow\n        return self\n\n    # Background rectangle\n\n    def add_background_rectangle(\n        self,\n        color: ParsableManimColor | None = None,\n        opacity: float = 0.75,\n        **kwargs,\n    ) -> Self:\n        # TODO, this does not behave well when the mobject has points,\n        # since it gets displayed on top\n        \"\"\"Add a BackgroundRectangle as submobject.\n\n        The BackgroundRectangle is added behind other submobjects.\n\n        This can be used to increase the mobjects visibility in front of a noisy background.\n\n        Parameters\n        ----------\n        color\n            The color of the BackgroundRectangle\n        opacity\n            The opacity of the BackgroundRectangle\n        kwargs\n            Additional keyword arguments passed to the BackgroundRectangle constructor\n\n\n        Returns\n        -------\n        :class:`OpenGLMobject`\n            ``self``\n\n        See Also\n        --------\n        :meth:`add_to_back`\n        :class:`~.BackgroundRectangle`\n\n        \"\"\"\n        from manim.mobject.geometry.shape_matchers import BackgroundRectangle\n\n        self.background_rectangle = BackgroundRectangle(\n            self, color=color, fill_opacity=opacity, **kwargs\n        )\n        self.add_to_back(self.background_rectangle)\n        return self\n\n    def add_background_rectangle_to_submobjects(self, **kwargs) -> Self:\n        for submobject in self.submobjects:\n            submobject.add_background_rectangle(**kwargs)\n        return self\n\n    def add_background_rectangle_to_family_members_with_points(self, **kwargs) -> Self:\n        for mob in self.family_members_with_points():\n            mob.add_background_rectangle(**kwargs)\n        return self\n\n    # Getters\n\n    def get_bounding_box_point(self, direction: Vector3D) -> Point3D:\n        bb = self.get_bounding_box()\n        indices = (np.sign(direction) + 1).astype(int)\n        return np.array([bb[indices[i]][i] for i in range(3)])\n\n    def get_edge_center(self, direction: Vector3D) -> Point3D:\n        \"\"\"Get edge coordinates for certain direction.\"\"\"\n        return self.get_bounding_box_point(direction)\n\n    def get_corner(self, direction: Vector3D) -> Point3D:\n        \"\"\"Get corner coordinates for certain direction.\"\"\"\n        return self.get_bounding_box_point(direction)\n\n    def get_center(self) -> Point3D:\n        \"\"\"Get center coordinates.\"\"\"\n        return self.get_bounding_box()[1]\n\n    def get_center_of_mass(self) -> Point3D:\n        return self.get_all_points().mean(0)\n\n    def get_boundary_point(self, direction: Vector3D) -> Point3D:\n        all_points = self.get_all_points()\n        boundary_directions = all_points - self.get_center()\n        norms = np.linalg.norm(boundary_directions, axis=1)\n        boundary_directions /= np.repeat(norms, 3).reshape((len(norms), 3))\n        index = np.argmax(np.dot(boundary_directions, np.array(direction).T))\n        return all_points[index]\n\n    def get_continuous_bounding_box_point(self, direction: Vector3D) -> Point3D:\n        dl, center, ur = self.get_bounding_box()\n        corner_vect = ur - center\n        return center + direction / np.max(\n            np.abs(\n                np.true_divide(\n                    direction,\n                    corner_vect,\n                    out=np.zeros(len(direction)),\n                    where=((corner_vect) != 0),\n                ),\n            ),\n        )\n\n    def get_top(self) -> Point3D:\n        \"\"\"Get top coordinates of a box bounding the :class:`~.OpenGLMobject`\"\"\"\n        return self.get_edge_center(UP)\n\n    def get_bottom(self) -> Point3D:\n        \"\"\"Get bottom coordinates of a box bounding the :class:`~.OpenGLMobject`\"\"\"\n        return self.get_edge_center(DOWN)\n\n    def get_right(self) -> Point3D:\n        \"\"\"Get right coordinates of a box bounding the :class:`~.OpenGLMobject`\"\"\"\n        return self.get_edge_center(RIGHT)\n\n    def get_left(self) -> Point3D:\n        \"\"\"Get left coordinates of a box bounding the :class:`~.OpenGLMobject`\"\"\"\n        return self.get_edge_center(LEFT)\n\n    def get_zenith(self) -> Point3D:\n        \"\"\"Get zenith coordinates of a box bounding a 3D :class:`~.OpenGLMobject`.\"\"\"\n        return self.get_edge_center(OUT)\n\n    def get_nadir(self) -> Point3D:\n        \"\"\"Get nadir (opposite the zenith) coordinates of a box bounding a 3D :class:`~.OpenGLMobject`.\"\"\"\n        return self.get_edge_center(IN)\n\n    def length_over_dim(self, dim: int) -> float:\n        bb = self.get_bounding_box()\n        return abs((bb[2] - bb[0])[dim])\n\n    def get_width(self) -> float:\n        \"\"\"Returns the width of the mobject.\"\"\"\n        return self.length_over_dim(0)\n\n    def get_height(self) -> float:\n        \"\"\"Returns the height of the mobject.\"\"\"\n        return self.length_over_dim(1)\n\n    def get_depth(self) -> float:\n        \"\"\"Returns the depth of the mobject.\"\"\"\n        return self.length_over_dim(2)\n\n    def get_coord(self, dim: int, direction: Vector3D = ORIGIN) -> ManimFloat:\n        \"\"\"Meant to generalize ``get_x``, ``get_y`` and ``get_z``\"\"\"\n        return self.get_bounding_box_point(direction)[dim]\n\n    def get_x(self, direction: Vector3D = ORIGIN) -> ManimFloat:\n        \"\"\"Returns x coordinate of the center of the :class:`~.OpenGLMobject` as ``float``\"\"\"\n        return self.get_coord(0, direction)\n\n    def get_y(self, direction: Vector3D = ORIGIN) -> ManimFloat:\n        \"\"\"Returns y coordinate of the center of the :class:`~.OpenGLMobject` as ``float``\"\"\"\n        return self.get_coord(1, direction)\n\n    def get_z(self, direction: Vector3D = ORIGIN) -> ManimFloat:\n        \"\"\"Returns z coordinate of the center of the :class:`~.OpenGLMobject` as ``float``\"\"\"\n        return self.get_coord(2, direction)\n\n    def get_start(self) -> Point3D:\n        \"\"\"Returns the point, where the stroke that surrounds the :class:`~.OpenGLMobject` starts.\"\"\"\n        self.throw_error_if_no_points()\n        return np.array(self.points[0])\n\n    def get_end(self) -> Point3D:\n        \"\"\"Returns the point, where the stroke that surrounds the :class:`~.OpenGLMobject` ends.\"\"\"\n        self.throw_error_if_no_points()\n        return np.array(self.points[-1])\n\n    def get_start_and_end(self) -> tuple[Point3D, Point3D]:\n        \"\"\"Returns starting and ending point of a stroke as a ``tuple``.\"\"\"\n        return self.get_start(), self.get_end()\n\n    def point_from_proportion(self, alpha: float) -> Point3D:\n        points = self.points\n        i, subalpha = integer_interpolate(0, len(points) - 1, alpha)\n        return interpolate(points[i], points[i + 1], subalpha)\n\n    def pfp(self, alpha: float) -> Point3D:\n        \"\"\"Abbreviation for point_from_proportion\"\"\"\n        return self.point_from_proportion(alpha)\n\n    def get_pieces(self, n_pieces: int) -> OpenGLMobject:\n        template = self.copy()\n        template.submobjects = []\n        alphas = np.linspace(0, 1, n_pieces + 1)\n        return OpenGLGroup(\n            *(\n                template.copy().pointwise_become_partial(self, a1, a2)\n                for a1, a2 in zip(alphas[:-1], alphas[1:])\n            )\n        )\n\n    def get_z_index_reference_point(self) -> Point3D:\n        # TODO, better place to define default z_index_group?\n        z_index_group = getattr(self, \"z_index_group\", self)\n        return z_index_group.get_center()\n\n    # Match other mobject properties\n\n    def match_color(self, mobject: OpenGLMobject) -> Self:\n        \"\"\"Match the color with the color of another :class:`~.OpenGLMobject`.\"\"\"\n        return self.set_color(mobject.get_color())\n\n    def match_dim_size(self, mobject: OpenGLMobject, dim: int, **kwargs) -> Self:\n        \"\"\"Match the specified dimension with the dimension of another :class:`~.OpenGLMobject`.\"\"\"\n        return self.rescale_to_fit(mobject.length_over_dim(dim), dim, **kwargs)\n\n    def match_width(self, mobject: OpenGLMobject, **kwargs) -> Self:\n        \"\"\"Match the width with the width of another :class:`~.OpenGLMobject`.\"\"\"\n        return self.match_dim_size(mobject, 0, **kwargs)\n\n    def match_height(self, mobject: OpenGLMobject, **kwargs) -> Self:\n        \"\"\"Match the height with the height of another :class:`~.OpenGLMobject`.\"\"\"\n        return self.match_dim_size(mobject, 1, **kwargs)\n\n    def match_depth(self, mobject: OpenGLMobject, **kwargs) -> Self:\n        \"\"\"Match the depth with the depth of another :class:`~.OpenGLMobject`.\"\"\"\n        return self.match_dim_size(mobject, 2, **kwargs)\n\n    def match_coord(\n        self, mobject: OpenGLMobject, dim: int, direction: Vector3D = ORIGIN\n    ) -> Self:\n        \"\"\"Match the coordinates with the coordinates of another :class:`~.OpenGLMobject`.\"\"\"\n        return self.set_coord(\n            mobject.get_coord(dim, direction),\n            dim=dim,\n            direction=direction,\n        )\n\n    def match_x(self, mobject: OpenGLMobject, direction: Vector3D = ORIGIN) -> Self:\n        \"\"\"Match x coord. to the x coord. of another :class:`~.OpenGLMobject`.\"\"\"\n        return self.match_coord(mobject, 0, direction)\n\n    def match_y(self, mobject: OpenGLMobject, direction: Vector3D = ORIGIN) -> Self:\n        \"\"\"Match y coord. to the x coord. of another :class:`~.OpenGLMobject`.\"\"\"\n        return self.match_coord(mobject, 1, direction)\n\n    def match_z(self, mobject: OpenGLMobject, direction: Vector3D = ORIGIN) -> Self:\n        \"\"\"Match z coord. to the x coord. of another :class:`~.OpenGLMobject`.\"\"\"\n        return self.match_coord(mobject, 2, direction)\n\n    def align_to(\n        self,\n        mobject_or_point: OpenGLMobject | Point3DLike,\n        direction: Vector3D = ORIGIN,\n    ) -> Self:\n        \"\"\"\n        Examples:\n        mob1.align_to(mob2, UP) moves mob1 vertically so that its\n        top edge lines ups with mob2's top edge.\n\n        mob1.align_to(mob2, alignment_vect = RIGHT) moves mob1\n        horizontally so that it's center is directly above/below\n        the center of mob2\n        \"\"\"\n        if isinstance(mobject_or_point, OpenGLMobject):\n            point = mobject_or_point.get_bounding_box_point(direction)\n        else:\n            point = mobject_or_point\n\n        for dim in range(self.dim):\n            if direction[dim] != 0:\n                self.set_coord(point[dim], dim, direction)\n        return self\n\n    def get_group_class(self) -> type[OpenGLGroup]:\n        return OpenGLGroup\n\n    @staticmethod\n    def get_mobject_type_class() -> type[OpenGLMobject]:\n        \"\"\"Return the base class of this mobject type.\"\"\"\n        return OpenGLMobject\n\n    # Alignment\n\n    def align_data_and_family(self, mobject: OpenGLMobject) -> Self:\n        self.align_family(mobject)\n        self.align_data(mobject)\n        return self\n\n    def align_data(self, mobject: OpenGLMobject) -> Self:\n        # In case any data arrays get resized when aligned to shader data\n        # self.refresh_shader_data()\n        for mob1, mob2 in zip(self.get_family(), mobject.get_family()):\n            # Separate out how points are treated so that subclasses\n            # can handle that case differently if they choose\n            mob1.align_points(mob2)\n            for key in mob1.data.keys() & mob2.data.keys():\n                if key == \"points\":\n                    continue\n                arr1 = mob1.data[key]\n                arr2 = mob2.data[key]\n                if len(arr2) > len(arr1):\n                    mob1.data[key] = resize_preserving_order(arr1, len(arr2))\n                elif len(arr1) > len(arr2):\n                    mob2.data[key] = resize_preserving_order(arr2, len(arr1))\n        return self\n\n    def align_points(self, mobject: OpenGLMobject) -> Self:\n        max_len = max(self.get_num_points(), mobject.get_num_points())\n        for mob in (self, mobject):\n            mob.resize_points(max_len, resize_func=resize_preserving_order)\n        return self\n\n    def align_family(self, mobject: OpenGLMobject) -> Self:\n        mob1 = self\n        mob2 = mobject\n        n1 = len(mob1)\n        n2 = len(mob2)\n        if n1 != n2:\n            mob1.add_n_more_submobjects(max(0, n2 - n1))\n            mob2.add_n_more_submobjects(max(0, n1 - n2))\n        # Recurse\n        for sm1, sm2 in zip(mob1.submobjects, mob2.submobjects):\n            sm1.align_family(sm2)\n        return self\n\n    def push_self_into_submobjects(self) -> Self:\n        copy = self.deepcopy()\n        copy.submobjects = []\n        self.resize_points(0)\n        self.add(copy)\n        return self\n\n    def add_n_more_submobjects(self, n: int) -> Self:\n        if n == 0:\n            return self\n\n        curr = len(self.submobjects)\n        if curr == 0:\n            # If empty, simply add n point mobjects\n            null_mob = self.copy()\n            null_mob.set_points([self.get_center()])\n            self.submobjects = [null_mob.copy() for k in range(n)]\n            return self\n        target = curr + n\n        repeat_indices = (np.arange(target) * curr) // target\n        split_factors = [(repeat_indices == i).sum() for i in range(curr)]\n        new_submobs = []\n        for submob, sf in zip(self.submobjects, split_factors):\n            new_submobs.append(submob)\n            for _ in range(1, sf):\n                new_submob = submob.copy()\n                # If the submobject is at all transparent, then\n                # make the copy completely transparent\n                if submob.get_opacity() < 1:\n                    new_submob.set_opacity(0)\n                new_submobs.append(new_submob)\n        self.submobjects = new_submobs\n        return self\n\n    # Interpolate\n\n    def interpolate(\n        self,\n        mobject1: OpenGLMobject,\n        mobject2: OpenGLMobject,\n        alpha: float,\n        path_func: PathFuncType = straight_path(),\n    ) -> Self:\n        \"\"\"Turns this :class:`~.OpenGLMobject` into an interpolation between ``mobject1``\n        and ``mobject2``.\n\n        Examples\n        --------\n\n        .. manim:: DotInterpolation\n            :save_last_frame:\n\n            class DotInterpolation(Scene):\n                def construct(self):\n                    dotR = Dot(color=DARK_GREY)\n                    dotR.shift(2 * RIGHT)\n                    dotL = Dot(color=WHITE)\n                    dotL.shift(2 * LEFT)\n\n                    dotMiddle = OpenGLVMobject().interpolate(dotL, dotR, alpha=0.3)\n\n                    self.add(dotL, dotR, dotMiddle)\n        \"\"\"\n        for key in self.data:\n            if key in self.locked_data_keys:\n                continue\n            if len(self.data[key]) == 0:\n                continue\n            if key not in mobject1.data or key not in mobject2.data:\n                continue\n\n            func = path_func if key in (\"points\", \"bounding_box\") else interpolate\n\n            self.data[key][:] = func(mobject1.data[key], mobject2.data[key], alpha)\n\n        for key in self.uniforms:\n            if key != \"fixed_orientation_center\":\n                self.uniforms[key] = interpolate(\n                    mobject1.uniforms[key],\n                    mobject2.uniforms[key],\n                    alpha,\n                )\n            else:\n                self.uniforms[\"fixed_orientation_center\"] = tuple(\n                    interpolate(\n                        np.array(mobject1.uniforms[\"fixed_orientation_center\"]),\n                        np.array(mobject2.uniforms[\"fixed_orientation_center\"]),\n                        alpha,\n                    )\n                )\n        return self\n\n    def pointwise_become_partial(\n        self, mobject: OpenGLMobject, a: float, b: float\n    ) -> None:\n        \"\"\"\n        Set points in such a way as to become only\n        part of mobject.\n        Inputs 0 <= a < b <= 1 determine what portion\n        of mobject to become.\n        \"\"\"\n        pass  # To implement in subclass\n\n    def become(\n        self,\n        mobject: OpenGLMobject,\n        match_height: bool = False,\n        match_width: bool = False,\n        match_depth: bool = False,\n        match_center: bool = False,\n        stretch: bool = False,\n    ) -> Self:\n        \"\"\"Edit all data and submobjects to be identical\n        to another :class:`~.OpenGLMobject`\n\n        .. note::\n\n            If both match_height and match_width are ``True`` then the transformed :class:`~.OpenGLMobject`\n            will match the height first and then the width\n\n        Parameters\n        ----------\n        match_height\n            If ``True``, then the transformed :class:`~.OpenGLMobject` will match the height of the original\n        match_width\n            If ``True``, then the transformed :class:`~.OpenGLMobject` will match the width of the original\n        match_depth\n            If ``True``, then the transformed :class:`~.OpenGLMobject` will match the depth of the original\n        match_center\n            If ``True``, then the transformed :class:`~.OpenGLMobject` will match the center of the original\n        stretch\n            If ``True``, then the transformed :class:`~.OpenGLMobject` will stretch to fit the proportions of the original\n\n        Examples\n        --------\n        .. manim:: BecomeScene\n\n            class BecomeScene(Scene):\n                def construct(self):\n                    circ = Circle(fill_color=RED, fill_opacity=0.8)\n                    square = Square(fill_color=BLUE, fill_opacity=0.2)\n                    self.add(circ)\n                    self.wait(0.5)\n                    circ.become(square)\n                    self.wait(0.5)\n        \"\"\"\n        if stretch:\n            mobject.stretch_to_fit_height(self.height)\n            mobject.stretch_to_fit_width(self.width)\n            mobject.stretch_to_fit_depth(self.depth)\n        else:\n            if match_height:\n                mobject.match_height(self)\n            if match_width:\n                mobject.match_width(self)\n            if match_depth:\n                mobject.match_depth(self)\n\n        if match_center:\n            mobject.move_to(self.get_center())\n\n        self.align_family(mobject)\n        for sm1, sm2 in zip(self.get_family(), mobject.get_family()):\n            sm1.set_data(sm2.data)\n            sm1.set_uniforms(sm2.uniforms)\n        self.refresh_bounding_box(recurse_down=True)\n        return self\n\n    # Locking data\n\n    def lock_data(self, keys: Iterable[str]) -> None:\n        \"\"\"\n        To speed up some animations, particularly transformations,\n        it can be handy to acknowledge which pieces of data\n        won't change during the animation so that calls to\n        interpolate can skip this, and so that it's not\n        read into the shader_wrapper objects needlessly\n        \"\"\"\n        if self.has_updaters:\n            return\n        # Be sure shader data has most up to date information\n        self.refresh_shader_data()\n        self.locked_data_keys = set(keys)\n\n    def lock_matching_data(\n        self, mobject1: OpenGLMobject, mobject2: OpenGLMobject\n    ) -> Self:\n        for sm, sm1, sm2 in zip(\n            self.get_family(),\n            mobject1.get_family(),\n            mobject2.get_family(),\n        ):\n            keys = sm.data.keys() & sm1.data.keys() & sm2.data.keys()\n            sm.lock_data(\n                list(\n                    filter(\n                        lambda key: np.all(sm1.data[key] == sm2.data[key]),\n                        keys,\n                    ),\n                ),\n            )\n        return self\n\n    def unlock_data(self) -> None:\n        for mob in self.get_family():\n            mob.locked_data_keys = set()\n\n    # Operations touching shader uniforms\n\n    @affects_shader_info_id\n    def fix_in_frame(self) -> Self:\n        self.is_fixed_in_frame = 1.0\n        return self\n\n    @affects_shader_info_id\n    def fix_orientation(self) -> Self:\n        self.is_fixed_orientation = 1.0\n        self.fixed_orientation_center = tuple(self.get_center())\n        self.depth_test = True\n        return self\n\n    @affects_shader_info_id\n    def unfix_from_frame(self) -> Self:\n        self.is_fixed_in_frame = 0.0\n        return self\n\n    @affects_shader_info_id\n    def unfix_orientation(self) -> Self:\n        self.is_fixed_orientation = 0.0\n        self.fixed_orientation_center = (0, 0, 0)\n        self.depth_test = False\n        return self\n\n    @affects_shader_info_id\n    def apply_depth_test(self) -> Self:\n        self.depth_test = True\n        return self\n\n    @affects_shader_info_id\n    def deactivate_depth_test(self) -> Self:\n        self.depth_test = False\n        return self\n\n    # Shader code manipulation\n\n    def replace_shader_code(self, old_code: str, new_code: str) -> Self:\n        # TODO, will this work with VMobject structure, given\n        # that it does not simpler return shader_wrappers of\n        # family?\n        for wrapper in self.get_shader_wrapper_list():\n            wrapper.replace_code(old_code, new_code)\n        return self\n\n    def set_color_by_code(self, glsl_code: str) -> Self:\n        \"\"\"\n        Takes a snippet of code and inserts it into a\n        context which has the following variables:\n        vec4 color, vec3 point, vec3 unit_normal.\n        The code should change the color variable\n        \"\"\"\n        self.replace_shader_code(\"///// INSERT COLOR FUNCTION HERE /////\", glsl_code)\n        return self\n\n    def set_color_by_xyz_func(\n        self,\n        glsl_snippet: str,\n        min_value: float = -5.0,\n        max_value: float = 5.0,\n        colormap: str = \"viridis\",\n    ) -> Self:\n        \"\"\"\n        Pass in a glsl expression in terms of x, y and z which returns\n        a float.\n        \"\"\"\n        # TODO, add a version of this which changes the point data instead\n        # of the shader code\n        for char in \"xyz\":\n            glsl_snippet = glsl_snippet.replace(char, \"point.\" + char)\n        rgb_list = get_colormap_list(colormap)\n        self.set_color_by_code(\n            f\"color.rgb = float_to_color({glsl_snippet}, {float(min_value)}, {float(max_value)}, {get_colormap_code(rgb_list)});\",\n        )\n        return self\n\n    # For shader data\n\n    def refresh_shader_wrapper_id(self) -> Self:\n        self.get_shader_wrapper().refresh_id()\n        return self\n\n    def get_shader_wrapper(self) -> ShaderWrapper:\n        from manim.renderer.shader_wrapper import ShaderWrapper\n\n        # if hasattr(self, \"__shader_wrapper\"):\n        # return self.__shader_wrapper\n\n        self.shader_wrapper = ShaderWrapper(\n            vert_data=self.get_shader_data(),\n            vert_indices=self.get_shader_vert_indices(),\n            uniforms=self.get_shader_uniforms(),\n            depth_test=self.depth_test,\n            texture_paths=self.texture_paths,\n            render_primitive=self.render_primitive,\n            shader_folder=self.__class__.shader_folder,\n        )\n        return self.shader_wrapper\n\n    def get_shader_wrapper_list(self) -> Sequence[ShaderWrapper]:\n        shader_wrappers = it.chain(\n            [self.get_shader_wrapper()],\n            *(sm.get_shader_wrapper_list() for sm in self.submobjects),\n        )\n        batches = batch_by_property(shader_wrappers, lambda sw: sw.get_id())\n\n        result = []\n        for wrapper_group, _ in batches:\n            shader_wrapper = wrapper_group[0]\n            if not shader_wrapper.is_valid():\n                continue\n            shader_wrapper.combine_with(*wrapper_group[1:])\n            if len(shader_wrapper.vert_data) > 0:\n                result.append(shader_wrapper)\n        return result\n\n    def check_data_alignment(self, array: npt.NDArray, data_key: str) -> Self:\n        # Makes sure that self.data[key] can be broadcast into\n        # the given array, meaning its length has to be either 1\n        # or the length of the array\n        d_len = len(self.data[data_key])\n        if d_len != 1 and d_len != len(array):\n            self.data[data_key] = resize_with_interpolation(\n                self.data[data_key],\n                len(array),\n            )\n        return self\n\n    def get_resized_shader_data_array(self, length: float) -> npt.NDArray:\n        # If possible, try to populate an existing array, rather\n        # than recreating it each frame\n        points = self.points\n        shader_data = np.zeros(len(points), dtype=self.shader_dtype)\n        return shader_data\n\n    def read_data_to_shader(\n        self,\n        shader_data: npt.NDArray,  # has structured data type, ex. (\"point\", np.float32, (3,))\n        shader_data_key: str,\n        data_key: str,\n    ) -> None:\n        if data_key in self.locked_data_keys:\n            return\n        self.check_data_alignment(shader_data, data_key)\n        shader_data[shader_data_key] = self.data[data_key]\n\n    def get_shader_data(self) -> npt.NDArray:\n        shader_data = self.get_resized_shader_data_array(self.get_num_points())\n        self.read_data_to_shader(shader_data, \"point\", \"points\")\n        return shader_data\n\n    def refresh_shader_data(self) -> None:\n        self.get_shader_data()\n\n    def get_shader_uniforms(self) -> dict[str, Any]:\n        return self.uniforms\n\n    def get_shader_vert_indices(self) -> Sequence[int]:\n        return self.shader_indices\n\n    @property\n    def submobjects(self) -> Sequence[OpenGLMobject]:\n        return self._submobjects if hasattr(self, \"_submobjects\") else []\n\n    @submobjects.setter\n    def submobjects(self, submobject_list: Iterable[OpenGLMobject]) -> None:\n        self.remove(*self.submobjects)\n        self.add(*submobject_list)\n\n    # Errors\n\n    def throw_error_if_no_points(self) -> None:\n        if not self.has_points():\n            message = (\n                \"Cannot call OpenGLMobject.{} \" + \"for a OpenGLMobject with no points\"\n            )\n            caller_name = sys._getframe(1).f_code.co_name\n            raise Exception(message.format(caller_name))"}, {"name": "OpenGLPGroup", "code": "class OpenGLPGroup(OpenGLPMobject):\n    def __init__(self, *pmobs, **kwargs):\n        if not all(isinstance(m, OpenGLPMobject) for m in pmobs):\n            raise Exception(\"All submobjects must be of type OpenglPMObject\")\n        super().__init__(**kwargs)\n        self.add(*pmobs)\n\n    def fade_to(self, color, alpha, family=True):\n        if family:\n            for mob in self.submobjects:\n                mob.fade_to(color, alpha, family)"}, {"name": "OpenGLPMobject", "code": "class OpenGLPMobject(OpenGLMobject):\n    shader_folder = \"true_dot\"\n    # Scale for consistency with cairo units\n    OPENGL_POINT_RADIUS_SCALE_FACTOR = 0.01\n    shader_dtype = [\n        (\"point\", np.float32, (3,)),\n        (\"color\", np.float32, (4,)),\n    ]\n\n    point_radius = _Uniforms()\n\n    def __init__(\n        self, stroke_width=2.0, color=YELLOW, render_primitive=moderngl.POINTS, **kwargs\n    ):\n        self.stroke_width = stroke_width\n        super().__init__(color=color, render_primitive=render_primitive, **kwargs)\n        self.point_radius = (\n            self.stroke_width * OpenGLPMobject.OPENGL_POINT_RADIUS_SCALE_FACTOR\n        )\n\n    def reset_points(self):\n        self.rgbas = np.zeros((1, 4))\n        self.points = np.zeros((0, 3))\n        return self\n\n    def get_array_attrs(self):\n        return [\"points\", \"rgbas\"]\n\n    def add_points(self, points, rgbas=None, color=None, opacity=None):\n        \"\"\"Add points.\n\n        Points must be a Nx3 numpy array.\n        Rgbas must be a Nx4 numpy array if it is not None.\n        \"\"\"\n        if rgbas is None and color is None:\n            color = YELLOW\n        self.append_points(points)\n        # rgbas array will have been resized with points\n        if color is not None:\n            if opacity is None:\n                opacity = self.rgbas[-1, 3]\n            new_rgbas = np.repeat([color_to_rgba(color, opacity)], len(points), axis=0)\n        elif rgbas is not None:\n            new_rgbas = rgbas\n        elif len(rgbas) != len(points):\n            raise ValueError(\"points and rgbas must have same length\")\n        self.rgbas = np.append(self.rgbas, new_rgbas, axis=0)\n        return self\n\n    def thin_out(self, factor=5):\n        \"\"\"Removes all but every nth point for n = factor\"\"\"\n        for mob in self.family_members_with_points():\n            num_points = mob.get_num_points()\n\n            def thin_func(num_points=num_points):\n                return np.arange(0, num_points, factor)\n\n            if len(mob.points) == len(mob.rgbas):\n                mob.set_rgba_array_direct(mob.rgbas[thin_func()])\n            mob.set_points(mob.points[thin_func()])\n\n        return self\n\n    def set_color_by_gradient(self, *colors):\n        self.rgbas = np.array(\n            list(map(color_to_rgba, color_gradient(*colors, self.get_num_points()))),\n        )\n        return self\n\n    def set_colors_by_radial_gradient(\n        self,\n        center=None,\n        radius=1,\n        inner_color=WHITE,\n        outer_color=BLACK,\n    ):\n        start_rgba, end_rgba = list(map(color_to_rgba, [inner_color, outer_color]))\n        if center is None:\n            center = self.get_center()\n        for mob in self.family_members_with_points():\n            distances = np.abs(self.points - center)\n            alphas = np.linalg.norm(distances, axis=1) / radius\n\n            mob.rgbas = np.array(\n                np.array(\n                    [interpolate(start_rgba, end_rgba, alpha) for alpha in alphas],\n                ),\n            )\n        return self\n\n    def match_colors(self, pmobject):\n        self.rgbas[:] = resize_with_interpolation(pmobject.rgbas, self.get_num_points())\n        return self\n\n    def fade_to(self, color, alpha, family=True):\n        rgbas = interpolate(self.rgbas, color_to_rgba(color), alpha)\n        for mob in self.submobjects:\n            mob.fade_to(color, alpha, family)\n        self.set_rgba_array_direct(rgbas)\n        return self\n\n    def filter_out(self, condition):\n        for mob in self.family_members_with_points():\n            to_keep = ~np.apply_along_axis(condition, 1, mob.points)\n            for key in mob.data:\n                mob.data[key] = mob.data[key][to_keep]\n        return self\n\n    def sort_points(self, function=lambda p: p[0]):\n        \"\"\"function is any map from R^3 to R\"\"\"\n        for mob in self.family_members_with_points():\n            indices = np.argsort(np.apply_along_axis(function, 1, mob.points))\n            for key in mob.data:\n                mob.data[key] = mob.data[key][indices]\n        return self\n\n    def ingest_submobjects(self):\n        for key in self.data:\n            self.data[key] = np.vstack([sm.data[key] for sm in self.get_family()])\n        return self\n\n    def point_from_proportion(self, alpha):\n        index = alpha * (self.get_num_points() - 1)\n        return self.points[int(index)]\n\n    def pointwise_become_partial(self, pmobject, a, b):\n        lower_index = int(a * pmobject.get_num_points())\n        upper_index = int(b * pmobject.get_num_points())\n        for key in self.data:\n            self.data[key] = pmobject.data[key][lower_index:upper_index]\n        return self\n\n    def get_shader_data(self):\n        shader_data = np.zeros(len(self.points), dtype=self.shader_dtype)\n        self.read_data_to_shader(shader_data, \"point\", \"points\")\n        self.read_data_to_shader(shader_data, \"color\", \"rgbas\")\n        return shader_data\n\n    @staticmethod\n    def get_mobject_type_class():\n        return OpenGLPMobject"}, {"name": "OpenGLPMPoint", "code": "class OpenGLPMPoint(OpenGLPMobject):\n    def __init__(self, location=ORIGIN, stroke_width=4.0, **kwargs):\n        self.location = location\n        super().__init__(stroke_width=stroke_width, **kwargs)\n\n    def init_points(self):\n        self.points = np.array([self.location], dtype=np.float32)"}, {"name": "OpenGLPoint", "code": "class OpenGLPoint(OpenGLMobject):\n    def __init__(\n        self,\n        location: Point3DLike = ORIGIN,\n        artificial_width: float = 1e-6,\n        artificial_height: float = 1e-6,\n        **kwargs,\n    ):\n        self.artificial_width = artificial_width\n        self.artificial_height = artificial_height\n        super().__init__(**kwargs)\n        self.set_location(location)\n\n    def get_width(self) -> float:\n        return self.artificial_width\n\n    def get_height(self) -> float:\n        return self.artificial_height\n\n    def get_location(self) -> Point3D:\n        return self.points[0].copy()\n\n    def get_bounding_box_point(self, *args, **kwargs) -> Point3D:\n        return self.get_location()\n\n    def set_location(self, new_loc: Point3D) -> None:\n        self.set_points(np.array(new_loc, ndmin=2, dtype=float))"}, {"name": "OpenGLPolygon", "code": "class OpenGLPolygon(OpenGLVMobject):\n    def __init__(self, *vertices, **kwargs):\n        self.vertices = vertices\n        super().__init__(**kwargs)\n\n    def init_points(self):\n        verts = self.vertices\n        self.set_points_as_corners([*verts, verts[0]])\n\n    def get_vertices(self):\n        return self.get_start_anchors()\n\n    def round_corners(self, radius=0.5):\n        vertices = self.get_vertices()\n        arcs = []\n        for v1, v2, v3 in adjacent_n_tuples(vertices, 3):\n            vect1 = v2 - v1\n            vect2 = v3 - v2\n            unit_vect1 = normalize(vect1)\n            unit_vect2 = normalize(vect2)\n            angle = angle_between_vectors(vect1, vect2)\n            # Negative radius gives concave curves\n            angle *= np.sign(radius)\n            # Distance between vertex and start of the arc\n            cut_off_length = radius * np.tan(angle / 2)\n            # Determines counterclockwise vs. clockwise\n            sign = np.sign(np.cross(vect1, vect2)[2])\n            arc = OpenGLArcBetweenPoints(\n                v2 - unit_vect1 * cut_off_length,\n                v2 + unit_vect2 * cut_off_length,\n                angle=sign * angle,\n                n_components=2,\n            )\n            arcs.append(arc)\n\n        self.clear_points()\n        # To ensure that we loop through starting with last\n        arcs = [arcs[-1], *arcs[:-1]]\n        for arc1, arc2 in adjacent_pairs(arcs):\n            self.append_points(arc1.points)\n            line = OpenGLLine(arc1.get_end(), arc2.get_start())\n            # Make sure anchors are evenly distributed\n            len_ratio = line.get_length() / arc1.get_arc_length()\n            line.insert_n_curves(int(arc1.get_num_curves() * len_ratio))\n            self.append_points(line.points)\n        return self"}, {"name": "OpenGLRectangle", "code": "class OpenGLRectangle(OpenGLPolygon):\n    def __init__(self, color=WHITE, width=4.0, height=2.0, **kwargs):\n        super().__init__(UR, UL, DL, DR, color=color, **kwargs)\n\n        self.set_width(width, stretch=True)\n        self.set_height(height, stretch=True)"}, {"name": "OpenGLRegularPolygon", "code": "class OpenGLRegularPolygon(OpenGLPolygon):\n    def __init__(self, n=6, start_angle=None, **kwargs):\n        self.start_angle = start_angle\n        if self.start_angle is None:\n            if n % 2 == 0:\n                self.start_angle = 0\n            else:\n                self.start_angle = 90 * DEGREES\n        start_vect = rotate_vector(RIGHT, self.start_angle)\n        vertices = compass_directions(n, start_vect)\n        super().__init__(*vertices, **kwargs)"}, {"name": "OpenGLRenderer", "code": "class OpenGLRenderer:\n    def __init__(\n        self,\n        file_writer_class: type[SceneFileWriter] = SceneFileWriter,\n        skip_animations: bool = False,\n    ) -> None:\n        # Measured in pixel widths, used for vector graphics\n        self.anti_alias_width = 1.5\n        self._file_writer_class = file_writer_class\n\n        self._original_skipping_status = skip_animations\n        self.skip_animations = skip_animations\n        self.animation_start_time = 0\n        self.animation_elapsed_time = 0\n        self.time = 0\n        self.animations_hashes = []\n        self.num_plays = 0\n\n        self.camera = OpenGLCamera()\n        self.pressed_keys = set()\n\n        # Initialize texture map.\n        self.path_to_texture_id = {}\n\n        self.background_color = config[\"background_color\"]\n\n    def init_scene(self, scene):\n        self.partial_movie_files = []\n        self.file_writer: Any = self._file_writer_class(\n            self,\n            scene.__class__.__name__,\n        )\n        self.scene = scene\n        self.background_color = config[\"background_color\"]\n        if not hasattr(self, \"window\"):\n            if self.should_create_window():\n                from .opengl_renderer_window import Window\n\n                self.window = Window(self)\n                self.context = self.window.ctx\n                self.frame_buffer_object = self.context.detect_framebuffer()\n            else:\n                self.window = None\n                try:\n                    self.context = moderngl.create_context(standalone=True)\n                except Exception:\n                    self.context = moderngl.create_context(\n                        standalone=True,\n                        backend=\"egl\",\n                    )\n                self.frame_buffer_object = self.get_frame_buffer_object(self.context, 0)\n                self.frame_buffer_object.use()\n            self.context.enable(moderngl.BLEND)\n            self.context.wireframe = config[\"enable_wireframe\"]\n            self.context.blend_func = (\n                moderngl.SRC_ALPHA,\n                moderngl.ONE_MINUS_SRC_ALPHA,\n                moderngl.ONE,\n                moderngl.ONE,\n            )\n\n    def should_create_window(self):\n        if config[\"force_window\"]:\n            logger.warning(\n                \"'--force_window' is enabled, this is intended for debugging purposes \"\n                \"and may impact performance if used when outputting files\",\n            )\n            return True\n        return (\n            config[\"preview\"]\n            and not config[\"save_last_frame\"]\n            and not config[\"format\"]\n            and not config[\"write_to_movie\"]\n            and not config[\"dry_run\"]\n        )\n\n    def get_pixel_shape(self):\n        if hasattr(self, \"frame_buffer_object\"):\n            return self.frame_buffer_object.viewport[2:4]\n        else:\n            return None\n\n    def refresh_perspective_uniforms(self, camera):\n        pw, ph = self.get_pixel_shape()\n        fw, fh = camera.get_shape()\n        # TODO, this should probably be a mobject uniform, with\n        # the camera taking care of the conversion factor\n        anti_alias_width = self.anti_alias_width / (ph / fh)\n        # Orient light\n        rotation = camera.inverse_rotation_matrix\n        light_pos = camera.light_source.get_location()\n        light_pos = np.dot(rotation, light_pos)\n\n        self.perspective_uniforms = {\n            \"frame_shape\": camera.get_shape(),\n            \"anti_alias_width\": anti_alias_width,\n            \"camera_center\": tuple(camera.get_center()),\n            \"camera_rotation\": tuple(np.array(rotation).T.flatten()),\n            \"light_source_position\": tuple(light_pos),\n            \"focal_distance\": camera.get_focal_distance(),\n        }\n\n    def render_mobject(self, mobject):\n        if isinstance(mobject, OpenGLVMobject):\n            if config[\"use_projection_fill_shaders\"]:\n                render_opengl_vectorized_mobject_fill(self, mobject)\n\n            if config[\"use_projection_stroke_shaders\"]:\n                render_opengl_vectorized_mobject_stroke(self, mobject)\n\n        shader_wrapper_list = mobject.get_shader_wrapper_list()\n\n        # Convert ShaderWrappers to Meshes.\n        for shader_wrapper in shader_wrapper_list:\n            shader = Shader(self.context, shader_wrapper.shader_folder)\n\n            # Set textures.\n            for name, path in shader_wrapper.texture_paths.items():\n                tid = self.get_texture_id(path)\n                shader.shader_program[name].value = tid\n\n            # Set uniforms.\n            for name, value in it.chain(\n                shader_wrapper.uniforms.items(),\n                self.perspective_uniforms.items(),\n            ):\n                with contextlib.suppress(KeyError):\n                    shader.set_uniform(name, value)\n            try:\n                shader.set_uniform(\n                    \"u_view_matrix\", self.scene.camera.formatted_view_matrix\n                )\n                shader.set_uniform(\n                    \"u_projection_matrix\",\n                    self.scene.camera.projection_matrix,\n                )\n            except KeyError:\n                pass\n\n            # Set depth test.\n            if shader_wrapper.depth_test:\n                self.context.enable(moderngl.DEPTH_TEST)\n            else:\n                self.context.disable(moderngl.DEPTH_TEST)\n\n            # Render.\n            mesh = Mesh(\n                shader,\n                shader_wrapper.vert_data,\n                indices=shader_wrapper.vert_indices,\n                use_depth_test=shader_wrapper.depth_test,\n                primitive=mobject.render_primitive,\n            )\n            mesh.set_uniforms(self)\n            mesh.render()\n\n    def get_texture_id(self, path):\n        if repr(path) not in self.path_to_texture_id:\n            tid = len(self.path_to_texture_id)\n            texture = self.context.texture(\n                size=path.size,\n                components=len(path.getbands()),\n                data=path.tobytes(),\n            )\n            texture.repeat_x = False\n            texture.repeat_y = False\n            texture.filter = (moderngl.NEAREST, moderngl.NEAREST)\n            texture.swizzle = \"RRR1\" if path.mode == \"L\" else \"RGBA\"\n            texture.use(location=tid)\n            self.path_to_texture_id[repr(path)] = tid\n\n        return self.path_to_texture_id[repr(path)]\n\n    def update_skipping_status(self) -> None:\n        \"\"\"\n        This method is used internally to check if the current\n        animation needs to be skipped or not. It also checks if\n        the number of animations that were played correspond to\n        the number of animations that need to be played, and\n        raises an EndSceneEarlyException if they don't correspond.\n        \"\"\"\n        # there is always at least one section -> no out of bounds here\n        if self.file_writer.sections[-1].skip_animations:\n            self.skip_animations = True\n        if (\n            config.from_animation_number > 0\n            and self.num_plays < config.from_animation_number\n        ):\n            self.skip_animations = True\n        if (\n            config.upto_animation_number >= 0\n            and self.num_plays > config.upto_animation_number\n        ):\n            self.skip_animations = True\n            raise EndSceneEarlyException()\n\n    @handle_caching_play\n    def play(self, scene, *args, **kwargs):\n        # TODO: Handle data locking / unlocking.\n        self.animation_start_time = time.time()\n        self.file_writer.begin_animation(not self.skip_animations)\n\n        scene.compile_animation_data(*args, **kwargs)\n        scene.begin_animations()\n        if scene.is_current_animation_frozen_frame():\n            self.update_frame(scene)\n\n            if not self.skip_animations:\n                self.file_writer.write_frame(\n                    self, num_frames=int(config.frame_rate * scene.duration)\n                )\n\n            if self.window is not None:\n                self.window.swap_buffers()\n                while time.time() - self.animation_start_time < scene.duration:\n                    pass\n            self.animation_elapsed_time = scene.duration\n\n        else:\n            scene.play_internal()\n\n        self.file_writer.end_animation(not self.skip_animations)\n        self.time += scene.duration\n        self.num_plays += 1\n\n    def clear_screen(self):\n        self.frame_buffer_object.clear(*self.background_color)\n        self.window.swap_buffers()\n\n    def render(self, scene, frame_offset, moving_mobjects):\n        self.update_frame(scene)\n\n        if self.skip_animations:\n            return\n\n        self.file_writer.write_frame(self)\n\n        if self.window is not None:\n            self.window.swap_buffers()\n            while self.animation_elapsed_time < frame_offset:\n                self.update_frame(scene)\n                self.window.swap_buffers()\n\n    def update_frame(self, scene):\n        self.frame_buffer_object.clear(*self.background_color)\n        self.refresh_perspective_uniforms(scene.camera)\n\n        for mobject in scene.mobjects:\n            if not mobject.should_render:\n                continue\n            self.render_mobject(mobject)\n\n        for obj in scene.meshes:\n            for mesh in obj.get_meshes():\n                mesh.set_uniforms(self)\n                mesh.render()\n\n        self.animation_elapsed_time = time.time() - self.animation_start_time\n\n    def scene_finished(self, scene):\n        # When num_plays is 0, no images have been output, so output a single\n        # image in this case\n        if self.num_plays > 0:\n            self.file_writer.finish()\n        elif self.num_plays == 0 and config.write_to_movie:\n            config.write_to_movie = False\n\n        if self.should_save_last_frame():\n            config.save_last_frame = True\n            self.update_frame(scene)\n            self.file_writer.save_final_image(self.get_image())\n\n    def should_save_last_frame(self):\n        if config[\"save_last_frame\"]:\n            return True\n        if self.scene.interactive_mode:\n            return False\n        return self.num_plays == 0\n\n    def get_image(self) -> Image.Image:\n        \"\"\"Returns an image from the current frame. The first argument passed to image represents\n        the mode RGB with the alpha channel A. The data we read is from the currently bound frame\n        buffer. We pass in 'raw' as the name of the decoder, 0 and -1 args are specifically\n        used for the decoder tand represent the stride and orientation. 0 means there is no\n        padding expected between bytes and -1 represents the orientation and means the first\n        line of the image is the bottom line on the screen.\n\n        Returns\n        -------\n        PIL.Image\n            The PIL image of the array.\n        \"\"\"\n        raw_buffer_data = self.get_raw_frame_buffer_object_data()\n        image = Image.frombytes(\n            \"RGBA\",\n            self.get_pixel_shape(),\n            raw_buffer_data,\n            \"raw\",\n            \"RGBA\",\n            0,\n            -1,\n        )\n        return image\n\n    def save_static_frame_data(self, scene, static_mobjects):\n        pass\n\n    def get_frame_buffer_object(self, context, samples=0):\n        pixel_width = config[\"pixel_width\"]\n        pixel_height = config[\"pixel_height\"]\n        num_channels = 4\n        return context.framebuffer(\n            color_attachments=context.texture(\n                (pixel_width, pixel_height),\n                components=num_channels,\n                samples=samples,\n            ),\n            depth_attachment=context.depth_renderbuffer(\n                (pixel_width, pixel_height),\n                samples=samples,\n            ),\n        )\n\n    def get_raw_frame_buffer_object_data(self, dtype=\"f1\"):\n        # Copy blocks from the fbo_msaa to the drawn fbo using Blit\n        # pw, ph = self.get_pixel_shape()\n        # gl.glBindFramebuffer(gl.GL_READ_FRAMEBUFFER, self.fbo_msaa.glo)\n        # gl.glBindFramebuffer(gl.GL_DRAW_FRAMEBUFFER, self.fbo.glo)\n        # gl.glBlitFramebuffer(\n        #     0, 0, pw, ph, 0, 0, pw, ph, gl.GL_COLOR_BUFFER_BIT, gl.GL_LINEAR\n        # )\n        num_channels = 4\n        ret = self.frame_buffer_object.read(\n            viewport=self.frame_buffer_object.viewport,\n            components=num_channels,\n            dtype=dtype,\n        )\n        return ret\n\n    def get_frame(self):\n        # get current pixel values as numpy data in order to test output\n        raw = self.get_raw_frame_buffer_object_data(dtype=\"f1\")\n        pixel_shape = self.get_pixel_shape()\n        result_dimensions = (pixel_shape[1], pixel_shape[0], 4)\n        np_buf = np.frombuffer(raw, dtype=\"uint8\").reshape(result_dimensions)\n        np_buf = np.flipud(np_buf)\n        return np_buf\n\n    # Returns offset from the bottom left corner in pixels.\n    # top_left flag should be set to True when using a GUI framework\n    # where the (0,0) is at the top left: e.g. PySide6\n    def pixel_coords_to_space_coords(self, px, py, relative=False, top_left=False):\n        pixel_shape = self.get_pixel_shape()\n        if pixel_shape is None:\n            return np.array([0, 0, 0])\n        pw, ph = pixel_shape\n        fh = config[\"frame_height\"]\n        fc = self.camera.get_center()\n        if relative:\n            return 2 * np.array([px / pw, py / ph, 0])\n        else:\n            # Only scale wrt one axis\n            scale = fh / ph\n            return fc + scale * np.array(\n                [(px - pw / 2), (-1 if top_left else 1) * (py - ph / 2), 0]\n            )\n\n    @property\n    def background_color(self):\n        return self._background_color\n\n    @background_color.setter\n    def background_color(self, value):\n        self._background_color = color_to_rgba(value, 1.0)"}, {"name": "OpenGLRoundedRectangle", "code": "class OpenGLRoundedRectangle(OpenGLRectangle):\n    def __init__(self, corner_radius=0.5, **kwargs):\n        self.corner_radius = corner_radius\n        super().__init__(**kwargs)\n        self.round_corners(self.corner_radius)"}, {"name": "OpenGLSector", "code": "class OpenGLSector(OpenGLAnnularSector):\n    def __init__(self, outer_radius=1, inner_radius=0, **kwargs):\n        super().__init__(inner_radius=inner_radius, outer_radius=outer_radius, **kwargs)"}, {"name": "OpenGLSquare", "code": "class OpenGLSquare(OpenGLRectangle):\n    def __init__(self, side_length=2.0, **kwargs):\n        self.side_length = side_length\n\n        super().__init__(height=side_length, width=side_length, **kwargs)"}, {"name": "OpenGLSurface", "code": "class OpenGLSurface(OpenGLMobject):\n    r\"\"\"Creates a Surface.\n\n    Parameters\n    ----------\n    uv_func\n        The function that defines the surface.\n    u_range\n        The range of the ``u`` variable: ``(u_min, u_max)``.\n    v_range\n        The range of the ``v`` variable: ``(v_min, v_max)``.\n    resolution\n        The number of samples taken of the surface.\n    axes\n        Axes on which the surface is to be drawn. Optional\n        parameter used when coloring a surface by z-value.\n    color\n        Color of the surface. Defaults to grey.\n    colorscale\n        Colors of the surface. Optional parameter used when\n        coloring a surface by values. Passing a list of\n        colors and an axes will color the surface by z-value.\n        Passing a list of tuples in the form ``(color, pivot)``\n        allows user-defined pivots where the color transitions.\n    colorscale_axis\n        Defines the axis on which the colorscale is applied\n        (0 = x, 1 = y, 2 = z), default is z-axis (2).\n    opacity\n        Opacity of the surface from 0 being fully transparent\n        to 1 being fully opaque. Defaults to 1.\n    \"\"\"\n\n    shader_dtype = [\n        (\"point\", np.float32, (3,)),\n        (\"du_point\", np.float32, (3,)),\n        (\"dv_point\", np.float32, (3,)),\n        (\"color\", np.float32, (4,)),\n    ]\n    shader_folder = \"surface\"\n\n    def __init__(\n        self,\n        uv_func=None,\n        u_range=None,\n        v_range=None,\n        # Resolution counts number of points sampled, which for\n        # each coordinate is one more than the the number of\n        # rows/columns of approximating squares\n        resolution=None,\n        axes=None,\n        color=GREY,\n        colorscale=None,\n        colorscale_axis=2,\n        opacity=1.0,\n        gloss=0.3,\n        shadow=0.4,\n        prefered_creation_axis=1,\n        # For du and dv steps.  Much smaller and numerical error\n        # can crop up in the shaders.\n        epsilon=1e-5,\n        render_primitive=moderngl.TRIANGLES,\n        depth_test=True,\n        shader_folder=None,\n        **kwargs,\n    ):\n        self.passed_uv_func = uv_func\n        self.u_range = u_range if u_range is not None else (0, 1)\n        self.v_range = v_range if v_range is not None else (0, 1)\n        # Resolution counts number of points sampled, which for\n        # each coordinate is one more than the the number of\n        # rows/columns of approximating squares\n        self.resolution = resolution if resolution is not None else (101, 101)\n        self.axes = axes\n        self.colorscale = colorscale\n        self.colorscale_axis = colorscale_axis\n        self.prefered_creation_axis = prefered_creation_axis\n        # For du and dv steps.  Much smaller and numerical error\n        # can crop up in the shaders.\n        self.epsilon = epsilon\n\n        self.triangle_indices = None\n        super().__init__(\n            color=color,\n            opacity=opacity,\n            gloss=gloss,\n            shadow=shadow,\n            shader_folder=shader_folder if shader_folder is not None else \"surface\",\n            render_primitive=render_primitive,\n            depth_test=depth_test,\n            **kwargs,\n        )\n        self.compute_triangle_indices()\n\n    def uv_func(self, u, v):\n        # To be implemented in subclasses\n        if self.passed_uv_func:\n            return self.passed_uv_func(u, v)\n        return (u, v, 0.0)\n\n    def init_points(self):\n        dim = self.dim\n        nu, nv = self.resolution\n        u_range = np.linspace(*self.u_range, nu)\n        v_range = np.linspace(*self.v_range, nv)\n\n        # Get three lists:\n        # - Points generated by pure uv values\n        # - Those generated by values nudged by du\n        # - Those generated by values nudged by dv\n        point_lists = []\n        for du, dv in [(0, 0), (self.epsilon, 0), (0, self.epsilon)]:\n            uv_grid = np.array([[[u + du, v + dv] for v in v_range] for u in u_range])\n            point_grid = np.apply_along_axis(lambda p: self.uv_func(*p), 2, uv_grid)\n            point_lists.append(point_grid.reshape((nu * nv, dim)))\n        # Rather than tracking normal vectors, the points list will hold on to the\n        # infinitesimal nudged values alongside the original values.  This way, one\n        # can perform all the manipulations they'd like to the surface, and normals\n        # are still easily recoverable.\n        self.set_points(np.vstack(point_lists))\n\n    def compute_triangle_indices(self):\n        # TODO, if there is an event which changes\n        # the resolution of the surface, make sure\n        # this is called.\n        nu, nv = self.resolution\n        if nu == 0 or nv == 0:\n            self.triangle_indices = np.zeros(0, dtype=int)\n            return\n        index_grid = np.arange(nu * nv).reshape((nu, nv))\n        indices = np.zeros(6 * (nu - 1) * (nv - 1), dtype=int)\n        indices[0::6] = index_grid[:-1, :-1].flatten()  # Top left\n        indices[1::6] = index_grid[+1:, :-1].flatten()  # Bottom left\n        indices[2::6] = index_grid[:-1, +1:].flatten()  # Top right\n        indices[3::6] = index_grid[:-1, +1:].flatten()  # Top right\n        indices[4::6] = index_grid[+1:, :-1].flatten()  # Bottom left\n        indices[5::6] = index_grid[+1:, +1:].flatten()  # Bottom right\n        self.triangle_indices = indices\n\n    def get_triangle_indices(self):\n        return self.triangle_indices\n\n    def get_surface_points_and_nudged_points(self):\n        points = self.points\n        k = len(points) // 3\n        return points[:k], points[k : 2 * k], points[2 * k :]\n\n    def get_unit_normals(self):\n        s_points, du_points, dv_points = self.get_surface_points_and_nudged_points()\n        normals = np.cross(\n            (du_points - s_points) / self.epsilon,\n            (dv_points - s_points) / self.epsilon,\n        )\n        return normalize_along_axis(normals, 1)\n\n    def pointwise_become_partial(self, smobject, a, b, axis=None):\n        assert isinstance(smobject, OpenGLSurface)\n        if axis is None:\n            axis = self.prefered_creation_axis\n        if a <= 0 and b >= 1:\n            self.match_points(smobject)\n            return self\n\n        nu, nv = smobject.resolution\n        self.set_points(\n            np.vstack(\n                [\n                    self.get_partial_points_array(\n                        arr.copy(),\n                        a,\n                        b,\n                        (nu, nv, 3),\n                        axis=axis,\n                    )\n                    for arr in smobject.get_surface_points_and_nudged_points()\n                ],\n            ),\n        )\n        return self\n\n    def get_partial_points_array(self, points, a, b, resolution, axis):\n        if len(points) == 0:\n            return points\n        nu, nv = resolution[:2]\n        points = points.reshape(resolution)\n        max_index = resolution[axis] - 1\n        lower_index, lower_residue = integer_interpolate(0, max_index, a)\n        upper_index, upper_residue = integer_interpolate(0, max_index, b)\n        if axis == 0:\n            points[:lower_index] = interpolate(\n                points[lower_index],\n                points[lower_index + 1],\n                lower_residue,\n            )\n            points[upper_index + 1 :] = interpolate(\n                points[upper_index],\n                points[upper_index + 1],\n                upper_residue,\n            )\n        else:\n            shape = (nu, 1, resolution[2])\n            points[:, :lower_index] = interpolate(\n                points[:, lower_index],\n                points[:, lower_index + 1],\n                lower_residue,\n            ).reshape(shape)\n            points[:, upper_index + 1 :] = interpolate(\n                points[:, upper_index],\n                points[:, upper_index + 1],\n                upper_residue,\n            ).reshape(shape)\n        return points.reshape((nu * nv, *resolution[2:]))\n\n    def sort_faces_back_to_front(self, vect=OUT):\n        tri_is = self.triangle_indices\n        indices = list(range(len(tri_is) // 3))\n        points = self.points\n\n        def index_dot(index):\n            return np.dot(points[tri_is[3 * index]], vect)\n\n        indices.sort(key=index_dot)\n        for k in range(3):\n            tri_is[k::3] = tri_is[k::3][indices]\n        return self\n\n    # For shaders\n    def get_shader_data(self):\n        \"\"\"Called by parent Mobject to calculate and return\n        the shader data.\n\n        Returns\n        -------\n        shader_dtype\n            An array containing the shader data (vertices and\n            color of each vertex)\n        \"\"\"\n        s_points, du_points, dv_points = self.get_surface_points_and_nudged_points()\n        shader_data = np.zeros(len(s_points), dtype=self.shader_dtype)\n        if \"points\" not in self.locked_data_keys:\n            shader_data[\"point\"] = s_points\n            shader_data[\"du_point\"] = du_points\n            shader_data[\"dv_point\"] = dv_points\n            if self.colorscale:\n                if not hasattr(self, \"color_by_val\"):\n                    self.color_by_val = self._get_color_by_value(s_points)\n                shader_data[\"color\"] = self.color_by_val\n            else:\n                self.fill_in_shader_color_info(shader_data)\n        return shader_data\n\n    def fill_in_shader_color_info(self, shader_data):\n        \"\"\"Fills in the shader color data when the surface\n        is all one color.\n\n        Parameters\n        ----------\n        shader_data\n            The vertices of the surface.\n\n        Returns\n        -------\n        shader_dtype\n            An array containing the shader data (vertices and\n            color of each vertex)\n        \"\"\"\n        self.read_data_to_shader(shader_data, \"color\", \"rgbas\")\n        return shader_data\n\n    def _get_color_by_value(self, s_points):\n        \"\"\"Matches each vertex to a color associated to it's z-value.\n\n        Parameters\n        ----------\n        s_points\n           The vertices of the surface.\n\n        Returns\n        -------\n        List\n            A list of colors matching the vertex inputs.\n        \"\"\"\n        if type(self.colorscale[0]) in (list, tuple):\n            new_colors, pivots = [\n                [i for i, j in self.colorscale],\n                [j for i, j in self.colorscale],\n            ]\n        else:\n            new_colors = self.colorscale\n\n            pivot_min = self.axes.z_range[0]\n            pivot_max = self.axes.z_range[1]\n            pivot_frequency = (pivot_max - pivot_min) / (len(new_colors) - 1)\n            pivots = np.arange(\n                start=pivot_min,\n                stop=pivot_max + pivot_frequency,\n                step=pivot_frequency,\n            )\n\n        return_colors = []\n        for point in s_points:\n            axis_value = self.axes.point_to_coords(point)[self.colorscale_axis]\n            if axis_value <= pivots[0]:\n                return_colors.append(color_to_rgba(new_colors[0], self.opacity))\n            elif axis_value >= pivots[-1]:\n                return_colors.append(color_to_rgba(new_colors[-1], self.opacity))\n            else:\n                for i, pivot in enumerate(pivots):\n                    if pivot > axis_value:\n                        color_index = (axis_value - pivots[i - 1]) / (\n                            pivots[i] - pivots[i - 1]\n                        )\n                        color_index = max(min(color_index, 1), 0)\n                        temp_color = interpolate_color(\n                            new_colors[i - 1],\n                            new_colors[i],\n                            color_index,\n                        )\n                        break\n                return_colors.append(color_to_rgba(temp_color, self.opacity))\n\n        return return_colors\n\n    def get_shader_vert_indices(self):\n        return self.get_triangle_indices()"}, {"name": "OpenGLSurfaceGroup", "code": "class OpenGLSurfaceGroup(OpenGLSurface):\n    def __init__(self, *parametric_surfaces, resolution=None, **kwargs):\n        self.resolution = (0, 0) if resolution is None else resolution\n        super().__init__(uv_func=None, **kwargs)\n        self.add(*parametric_surfaces)\n\n    def init_points(self):\n        pass"}, {"name": "OpenGLSurfaceMesh", "code": "class OpenGLSurfaceMesh(OpenGLVGroup):\n    def __init__(\n        self,\n        uv_surface,\n        resolution=None,\n        stroke_width=1,\n        normal_nudge=1e-2,\n        depth_test=True,\n        flat_stroke=False,\n        **kwargs,\n    ):\n        if not isinstance(uv_surface, OpenGLSurface):\n            raise Exception(\"uv_surface must be of type OpenGLSurface\")\n        self.uv_surface = uv_surface\n        self.resolution = resolution if resolution is not None else (21, 21)\n        self.normal_nudge = normal_nudge\n        super().__init__(\n            stroke_width=stroke_width,\n            depth_test=depth_test,\n            flat_stroke=flat_stroke,\n            **kwargs,\n        )\n\n    def init_points(self):\n        uv_surface = self.uv_surface\n\n        full_nu, full_nv = uv_surface.resolution\n        part_nu, part_nv = self.resolution\n        u_indices = np.linspace(0, full_nu, part_nu).astype(int)\n        v_indices = np.linspace(0, full_nv, part_nv).astype(int)\n\n        points, du_points, dv_points = uv_surface.get_surface_points_and_nudged_points()\n        normals = uv_surface.get_unit_normals()\n        nudged_points = points + self.normal_nudge * normals\n\n        for ui in u_indices:\n            path = OpenGLVMobject()\n            full_ui = full_nv * ui\n            path.set_points_smoothly(nudged_points[full_ui : full_ui + full_nv])\n            self.add(path)\n        for vi in v_indices:\n            path = OpenGLVMobject()\n            path.set_points_smoothly(nudged_points[vi::full_nv])\n            self.add(path)"}, {"name": "OpenGLTangentLine", "code": "class OpenGLTangentLine(OpenGLLine):\n    def __init__(self, vmob, alpha, length=1, d_alpha=1e-6, **kwargs):\n        self.length = length\n        self.d_alpha = d_alpha\n        da = self.d_alpha\n        a1 = clip(alpha - da, 0, 1)\n        a2 = clip(alpha + da, 0, 1)\n        super().__init__(vmob.pfp(a1), vmob.pfp(a2), **kwargs)\n        self.scale(self.length / self.get_length())"}, {"name": "OpenGLTexturedSurface", "code": "class OpenGLTexturedSurface(OpenGLSurface):\n    shader_dtype = [\n        (\"point\", np.float32, (3,)),\n        (\"du_point\", np.float32, (3,)),\n        (\"dv_point\", np.float32, (3,)),\n        (\"im_coords\", np.float32, (2,)),\n        (\"opacity\", np.float32, (1,)),\n    ]\n    shader_folder = \"textured_surface\"\n    im_coords = _Data()\n    opacity = _Data()\n    num_textures = _Uniforms()\n\n    def __init__(\n        self,\n        uv_surface: OpenGLSurface,\n        image_file: str | Path,\n        dark_image_file: str | Path = None,\n        image_mode: str | Iterable[str] = \"RGBA\",\n        shader_folder: str | Path = None,\n        **kwargs,\n    ):\n        self.uniforms = {}\n\n        if not isinstance(uv_surface, OpenGLSurface):\n            raise Exception(\"uv_surface must be of type OpenGLSurface\")\n        if isinstance(image_file, np.ndarray):\n            image_file = change_to_rgba_array(image_file)\n\n        # Set texture information\n        if isinstance(image_mode, (str, Path)):\n            image_mode = [image_mode] * 2\n        image_mode_light, image_mode_dark = image_mode\n        texture_paths = {\n            \"LightTexture\": self.get_image_from_file(\n                image_file,\n                image_mode_light,\n            ),\n            \"DarkTexture\": self.get_image_from_file(\n                dark_image_file or image_file,\n                image_mode_dark,\n            ),\n        }\n        if dark_image_file:\n            self.num_textures = 2\n\n        self.uv_surface = uv_surface\n        self.uv_func = uv_surface.uv_func\n        self.u_range = uv_surface.u_range\n        self.v_range = uv_surface.v_range\n        self.resolution = uv_surface.resolution\n        self.gloss = self.uv_surface.gloss\n        super().__init__(texture_paths=texture_paths, **kwargs)\n\n    def get_image_from_file(\n        self,\n        image_file: str | Path,\n        image_mode: str,\n    ):\n        image_file = get_full_raster_image_path(image_file)\n        return Image.open(image_file).convert(image_mode)\n\n    def init_data(self):\n        super().init_data()\n        self.im_coords = np.zeros((0, 2))\n        self.opacity = np.zeros((0, 1))\n\n    def init_points(self):\n        nu, nv = self.uv_surface.resolution\n        self.set_points(self.uv_surface.points)\n        self.im_coords = np.array(\n            [\n                [u, v]\n                for u in np.linspace(0, 1, nu)\n                for v in np.linspace(1, 0, nv)  # Reverse y-direction\n            ],\n        )\n\n    def init_colors(self):\n        self.opacity = np.array([self.uv_surface.rgbas[:, 3]])\n\n    def set_opacity(self, opacity, recurse=True):\n        for mob in self.get_family(recurse):\n            mob.opacity = np.array([[o] for o in listify(opacity)])\n        return self\n\n    def pointwise_become_partial(self, tsmobject, a, b, axis=1):\n        super().pointwise_become_partial(tsmobject, a, b, axis)\n        im_coords = self.im_coords\n        im_coords[:] = tsmobject.im_coords\n        if a <= 0 and b >= 1:\n            return self\n        nu, nv = tsmobject.resolution\n        im_coords[:] = self.get_partial_points_array(im_coords, a, b, (nu, nv, 2), axis)\n        return self\n\n    def fill_in_shader_color_info(self, shader_data):\n        self.read_data_to_shader(shader_data, \"opacity\", \"opacity\")\n        self.read_data_to_shader(shader_data, \"im_coords\", \"im_coords\")\n        return shader_data"}, {"name": "OpenGLTipableVMobject", "code": "class OpenGLTipableVMobject(OpenGLVMobject):\n    \"\"\"\n    Meant for shared functionality between Arc and Line.\n    Functionality can be classified broadly into these groups:\n\n        * Adding, Creating, Modifying tips\n            - add_tip calls create_tip, before pushing the new tip\n                into the TipableVMobject's list of submobjects\n            - stylistic and positional configuration\n\n        * Checking for tips\n            - Boolean checks for whether the TipableVMobject has a tip\n                and a starting tip\n\n        * Getters\n            - Straightforward accessors, returning information pertaining\n                to the TipableVMobject instance's tip(s), its length etc\n    \"\"\"\n\n    # Adding, Creating, Modifying tips\n\n    def __init__(\n        self,\n        tip_length=DEFAULT_ARROW_TIP_LENGTH,\n        normal_vector=OUT,\n        tip_config={},\n        **kwargs,\n    ):\n        self.tip_length = tip_length\n        self.normal_vector = normal_vector\n        self.tip_config = tip_config\n        super().__init__(**kwargs)\n\n    def add_tip(self, at_start=False, **kwargs):\n        \"\"\"\n        Adds a tip to the TipableVMobject instance, recognising\n        that the endpoints might need to be switched if it's\n        a 'starting tip' or not.\n        \"\"\"\n        tip = self.create_tip(at_start, **kwargs)\n        self.reset_endpoints_based_on_tip(tip, at_start)\n        self.asign_tip_attr(tip, at_start)\n        self.add(tip)\n        return self\n\n    def create_tip(self, at_start=False, **kwargs):\n        \"\"\"\n        Stylises the tip, positions it spacially, and returns\n        the newly instantiated tip to the caller.\n        \"\"\"\n        tip = self.get_unpositioned_tip(**kwargs)\n        self.position_tip(tip, at_start)\n        return tip\n\n    def get_unpositioned_tip(self, **kwargs):\n        \"\"\"\n        Returns a tip that has been stylistically configured,\n        but has not yet been given a position in space.\n        \"\"\"\n        config = {}\n        config.update(self.tip_config)\n        config.update(kwargs)\n        return OpenGLArrowTip(**config)\n\n    def position_tip(self, tip, at_start=False):\n        # Last two control points, defining both\n        # the end, and the tangency direction\n        if at_start:\n            anchor = self.get_start()\n            handle = self.get_first_handle()\n        else:\n            handle = self.get_last_handle()\n            anchor = self.get_end()\n        tip.rotate(angle_of_vector(handle - anchor) - PI - tip.get_angle())\n        tip.shift(anchor - tip.get_tip_point())\n        return tip\n\n    def reset_endpoints_based_on_tip(self, tip, at_start):\n        if self.get_length() == 0:\n            # Zero length, put_start_and_end_on wouldn't\n            # work\n            return self\n\n        if at_start:\n            start = tip.get_base()\n            end = self.get_end()\n        else:\n            start = self.get_start()\n            end = tip.get_base()\n        self.put_start_and_end_on(start, end)\n        return self\n\n    def asign_tip_attr(self, tip, at_start):\n        if at_start:\n            self.start_tip = tip\n        else:\n            self.tip = tip\n        return self\n\n    # Checking for tips\n    def has_tip(self):\n        return hasattr(self, \"tip\") and self.tip in self\n\n    def has_start_tip(self):\n        return hasattr(self, \"start_tip\") and self.start_tip in self\n\n    # Getters\n    def pop_tips(self):\n        start, end = self.get_start_and_end()\n        result = OpenGLVGroup()\n        if self.has_tip():\n            result.add(self.tip)\n            self.remove(self.tip)\n        if self.has_start_tip():\n            result.add(self.start_tip)\n            self.remove(self.start_tip)\n        self.put_start_and_end_on(start, end)\n        return result\n\n    def get_tips(self):\n        \"\"\"\n        Returns a VGroup (collection of VMobjects) containing\n        the TipableVMObject instance's tips.\n        \"\"\"\n        result = OpenGLVGroup()\n        if hasattr(self, \"tip\"):\n            result.add(self.tip)\n        if hasattr(self, \"start_tip\"):\n            result.add(self.start_tip)\n        return result\n\n    def get_tip(self):\n        \"\"\"Returns the TipableVMobject instance's (first) tip,\n        otherwise throws an exception.\n        \"\"\"\n        tips = self.get_tips()\n        if len(tips) == 0:\n            raise Exception(\"tip not found\")\n        else:\n            return tips[0]\n\n    def get_default_tip_length(self):\n        return self.tip_length\n\n    def get_first_handle(self):\n        return self.points[1]\n\n    def get_last_handle(self):\n        return self.points[-2]\n\n    def get_end(self):\n        if self.has_tip():\n            return self.tip.get_start()\n        else:\n            return super().get_end()\n\n    def get_start(self):\n        if self.has_start_tip():\n            return self.start_tip.get_start()\n        else:\n            return super().get_start()\n\n    def get_length(self):\n        start, end = self.get_start_and_end()\n        return np.linalg.norm(start - end)"}, {"name": "OpenGLTriangle", "code": "class OpenGLTriangle(OpenGLRegularPolygon):\n    def __init__(self, **kwargs):\n        super().__init__(n=3, **kwargs)"}, {"name": "OpenGLVector", "code": "class OpenGLVector(OpenGLArrow):\n    def __init__(self, direction=RIGHT, buff=0, **kwargs):\n        self.buff = buff\n        if len(direction) == 2:\n            direction = np.hstack([direction, 0])\n        super().__init__(ORIGIN, direction, buff=buff, **kwargs)"}, {"name": "OpenGLVectorizedPoint", "code": "class OpenGLVectorizedPoint(OpenGLPoint, OpenGLVMobject):\n    def __init__(\n        self,\n        location=ORIGIN,\n        color=BLACK,\n        fill_opacity=0,\n        stroke_width=0,\n        artificial_width=0.01,\n        artificial_height=0.01,\n        **kwargs,\n    ):\n        self.artificial_width = artificial_width\n        self.artificial_height = artificial_height\n\n        super().__init__(\n            color=color, fill_opacity=fill_opacity, stroke_width=stroke_width, **kwargs\n        )\n        self.set_points(np.array([location]))"}, {"name": "OpenGLVGroup", "code": "class OpenGLVGroup(OpenGLVMobject):\n    \"\"\"A group of vectorized mobjects.\n\n    This can be used to group multiple :class:`~.OpenGLVMobject` instances together\n    in order to scale, move, ... them together.\n\n    Examples\n    --------\n\n    To add :class:`~.OpenGLVMobject`s to a :class:`~.OpenGLVGroup`, you can either use the\n    :meth:`~.OpenGLVGroup.add` method, or use the `+` and `+=` operators. Similarly, you\n    can subtract elements of a OpenGLVGroup via :meth:`~.OpenGLVGroup.remove` method, or\n    `-` and `-=` operators:\n\n    .. doctest::\n\n        >>> from manim import config\n        >>> original_renderer = config.renderer\n        >>> config.renderer = \"opengl\"\n\n        >>> from manim import Triangle, Square\n        >>> from manim.opengl import OpenGLVGroup\n        >>> config.renderer\n        <RendererType.OPENGL: 'opengl'>\n        >>> vg = OpenGLVGroup()\n        >>> triangle, square = Triangle(), Square()\n        >>> vg.add(triangle)\n        OpenGLVGroup(Triangle)\n        >>> vg + square  # a new OpenGLVGroup is constructed\n        OpenGLVGroup(Triangle, Square)\n        >>> vg  # not modified\n        OpenGLVGroup(Triangle)\n        >>> vg += square  # modifies vg\n        >>> vg\n        OpenGLVGroup(Triangle, Square)\n        >>> vg.remove(triangle)\n        OpenGLVGroup(Square)\n        >>> vg - square  # a new OpenGLVGroup is constructed\n        OpenGLVGroup()\n        >>> vg  # not modified\n        OpenGLVGroup(Square)\n        >>> vg -= square  # modifies vg\n        >>> vg\n        OpenGLVGroup()\n\n        >>> config.renderer = original_renderer\n\n    .. manim:: ArcShapeIris\n        :save_last_frame:\n\n        class ArcShapeIris(Scene):\n            def construct(self):\n                colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]\n                radius = [1 + rad * 0.1 for rad in range(len(colors))]\n\n                circles_group = OpenGLVGroup()\n\n                # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]\n                circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)\n                                    for rad, col in zip(radius, colors)])\n                self.add(circles_group)\n    \"\"\"\n\n    def __init__(self, *vmobjects, **kwargs):\n        super().__init__(**kwargs)\n        self.add(*vmobjects)\n\n    def __repr__(self):\n        return (\n            self.__class__.__name__\n            + \"(\"\n            + \", \".join(str(mob) for mob in self.submobjects)\n            + \")\"\n        )\n\n    def __str__(self):\n        return (\n            f\"{self.__class__.__name__} of {len(self.submobjects)} \"\n            f\"submobject{'s' if len(self.submobjects) > 0 else ''}\"\n        )\n\n    def add(self, *vmobjects: OpenGLVMobject):\n        \"\"\"Checks if all passed elements are an instance of OpenGLVMobject and then add them to submobjects\n\n        Parameters\n        ----------\n        vmobjects\n            List of OpenGLVMobject to add\n\n        Returns\n        -------\n        :class:`OpenGLVGroup`\n\n        Raises\n        ------\n        TypeError\n            If one element of the list is not an instance of OpenGLVMobject\n\n        Examples\n        --------\n        .. manim:: AddToOpenGLVGroup\n\n            class AddToOpenGLVGroup(Scene):\n                def construct(self):\n                    circle_red = Circle(color=RED)\n                    circle_green = Circle(color=GREEN)\n                    circle_blue = Circle(color=BLUE)\n                    circle_red.shift(LEFT)\n                    circle_blue.shift(RIGHT)\n                    gr = OpenGLVGroup(circle_red, circle_green)\n                    gr2 = OpenGLVGroup(circle_blue) # Constructor uses add directly\n                    self.add(gr,gr2)\n                    self.wait()\n                    gr += gr2 # Add group to another\n                    self.play(\n                        gr.animate.shift(DOWN),\n                    )\n                    gr -= gr2 # Remove group\n                    self.play( # Animate groups separately\n                        gr.animate.shift(LEFT),\n                        gr2.animate.shift(UP),\n                    )\n                    self.play( #Animate groups without modification\n                        (gr+gr2).animate.shift(RIGHT)\n                    )\n                    self.play( # Animate group without component\n                        (gr-circle_red).animate.shift(RIGHT)\n                    )\n        \"\"\"\n        return super().add(*vmobjects)\n\n    def __add__(self, vmobject):\n        return OpenGLVGroup(*self.submobjects, vmobject)\n\n    def __iadd__(self, vmobject):\n        return self.add(vmobject)\n\n    def __sub__(self, vmobject):\n        copy = OpenGLVGroup(*self.submobjects)\n        copy.remove(vmobject)\n        return copy\n\n    def __isub__(self, vmobject):\n        return self.remove(vmobject)\n\n    def __setitem__(self, key: int, value: OpenGLVMobject | Sequence[OpenGLVMobject]):\n        \"\"\"Override the [] operator for item assignment.\n\n        Parameters\n        ----------\n        key\n            The index of the submobject to be assigned\n        value\n            The vmobject value to assign to the key\n\n        Returns\n        -------\n        None\n\n        Tests\n        -----\n\n        .. doctest::\n\n            >>> from manim import config\n            >>> original_renderer = config.renderer\n            >>> config.renderer = \"opengl\"\n\n            >>> vgroup = OpenGLVGroup(OpenGLVMobject())\n            >>> new_obj = OpenGLVMobject()\n            >>> vgroup[0] = new_obj\n\n            >>> config.renderer = original_renderer\n        \"\"\"\n        self._assert_valid_submobjects(tuplify(value))\n        self.submobjects[key] = value"}, {"name": "OpenGLVMobject", "code": "class OpenGLVMobject(OpenGLMobject):\n    \"\"\"A vectorized mobject.\"\"\"\n\n    fill_dtype = [\n        (\"point\", np.float32, (3,)),\n        (\"unit_normal\", np.float32, (3,)),\n        (\"color\", np.float32, (4,)),\n        (\"vert_index\", np.float32, (1,)),\n    ]\n    stroke_dtype = [\n        (\"point\", np.float32, (3,)),\n        (\"prev_point\", np.float32, (3,)),\n        (\"next_point\", np.float32, (3,)),\n        (\"unit_normal\", np.float32, (3,)),\n        (\"stroke_width\", np.float32, (1,)),\n        (\"color\", np.float32, (4,)),\n    ]\n    stroke_shader_folder = \"quadratic_bezier_stroke\"\n    fill_shader_folder = \"quadratic_bezier_fill\"\n\n    fill_rgba = _Data()\n    stroke_rgba = _Data()\n    stroke_width = _Data()\n    unit_normal = _Data()\n\n    def __init__(\n        self,\n        fill_color: ParsableManimColor | None = None,\n        fill_opacity: float = 0.0,\n        stroke_color: ParsableManimColor | None = None,\n        stroke_opacity: float = 1.0,\n        stroke_width: float = DEFAULT_STROKE_WIDTH,\n        draw_stroke_behind_fill: bool = False,\n        # Indicates that it will not be displayed, but\n        # that it should count in parent mobject's path\n        pre_function_handle_to_anchor_scale_factor: float = 0.01,\n        make_smooth_after_applying_functions: float = False,\n        background_image_file: str | None = None,\n        # This is within a pixel\n        # TODO, do we care about accounting for\n        # varying zoom levels?\n        tolerance_for_point_equality: float = 1e-8,\n        n_points_per_curve: int = 3,\n        long_lines: bool = False,\n        should_subdivide_sharp_curves: bool = False,\n        should_remove_null_curves: bool = False,\n        # Could also be \"bevel\", \"miter\", \"round\"\n        joint_type: LineJointType | None = None,\n        flat_stroke: bool = True,\n        render_primitive=moderngl.TRIANGLES,\n        triangulation_locked: bool = False,\n        **kwargs,\n    ):\n        self.data = {}\n        self.fill_opacity = fill_opacity\n        self.stroke_opacity = stroke_opacity\n        self.stroke_width = stroke_width\n        self.draw_stroke_behind_fill = draw_stroke_behind_fill\n        # Indicates that it will not be displayed, but\n        # that it should count in parent mobject's path\n        self.pre_function_handle_to_anchor_scale_factor = (\n            pre_function_handle_to_anchor_scale_factor\n        )\n        self.make_smooth_after_applying_functions = make_smooth_after_applying_functions\n        self.background_image_file = background_image_file\n        # This is within a pixel\n        # TODO, do we care about accounting for\n        # varying zoom levels?\n        self.tolerance_for_point_equality = tolerance_for_point_equality\n        self.n_points_per_curve = n_points_per_curve\n        self.long_lines = long_lines\n        self.should_subdivide_sharp_curves = should_subdivide_sharp_curves\n        self.should_remove_null_curves = should_remove_null_curves\n        if joint_type is None:\n            joint_type = LineJointType.AUTO\n        self.joint_type = joint_type\n        self.flat_stroke = flat_stroke\n        self.render_primitive = render_primitive\n        self.triangulation_locked = triangulation_locked\n\n        self.needs_new_triangulation = True\n        self.triangulation = np.zeros(0, dtype=\"i4\")\n        self.orientation = 1\n\n        self.fill_data = None\n        self.stroke_data = None\n        self.fill_shader_wrapper = None\n        self.stroke_shader_wrapper = None\n        self.init_shader_data()\n\n        super().__init__(**kwargs)\n        self.refresh_unit_normal()\n\n        if fill_color is not None:\n            self.fill_color = ManimColor.parse(fill_color)\n        if stroke_color is not None:\n            self.stroke_color = ManimColor.parse(stroke_color)\n\n    def _assert_valid_submobjects(self, submobjects: Iterable[OpenGLVMobject]) -> Self:\n        return self._assert_valid_submobjects_internal(submobjects, OpenGLVMobject)\n\n    def get_group_class(self):\n        return OpenGLVGroup\n\n    @staticmethod\n    def get_mobject_type_class():\n        return OpenGLVMobject\n\n    def init_data(self):\n        super().init_data()\n        self.data.pop(\"rgbas\")\n        self.fill_rgba = np.zeros((1, 4))\n        self.stroke_rgba = np.zeros((1, 4))\n        self.unit_normal = np.zeros((1, 3))\n        # stroke_width belongs to self.data, but is defined through init_colors+set_stroke\n\n    # Colors\n    def init_colors(self):\n        self.set_fill(\n            color=self.fill_color or self.color,\n            opacity=self.fill_opacity,\n        )\n        self.set_stroke(\n            color=self.stroke_color or self.color,\n            width=self.stroke_width,\n            opacity=self.stroke_opacity,\n            background=self.draw_stroke_behind_fill,\n        )\n        self.set_gloss(self.gloss)\n        self.set_flat_stroke(self.flat_stroke)\n        return self\n\n    def set_fill(\n        self,\n        color: ParsableManimColor | None = None,\n        opacity: float | None = None,\n        recurse: bool = True,\n    ) -> OpenGLVMobject:\n        \"\"\"Set the fill color and fill opacity of a :class:`OpenGLVMobject`.\n\n        Parameters\n        ----------\n        color\n            Fill color of the :class:`OpenGLVMobject`.\n        opacity\n            Fill opacity of the :class:`OpenGLVMobject`.\n        recurse\n            If ``True``, the fill color of all submobjects is also set.\n\n        Returns\n        -------\n        OpenGLVMobject\n            self. For chaining purposes.\n\n        Examples\n        --------\n        .. manim:: SetFill\n            :save_last_frame:\n\n            class SetFill(Scene):\n                def construct(self):\n                    square = Square().scale(2).set_fill(WHITE,1)\n                    circle1 = Circle().set_fill(GREEN,0.8)\n                    circle2 = Circle().set_fill(YELLOW) # No fill_opacity\n                    circle3 = Circle().set_fill(color = '#FF2135', opacity = 0.2)\n                    group = Group(circle1,circle2,circle3).arrange()\n                    self.add(square)\n                    self.add(group)\n\n        See Also\n        --------\n        :meth:`~.OpenGLVMobject.set_style`\n        \"\"\"\n        if opacity is not None:\n            self.fill_opacity = opacity\n        if recurse:\n            for submobject in self.submobjects:\n                submobject.set_fill(color, opacity, recurse)\n\n        self.set_rgba_array(color, opacity, \"fill_rgba\", recurse)\n        return self\n\n    def set_stroke(\n        self,\n        color=None,\n        width=None,\n        opacity=None,\n        background=None,\n        recurse=True,\n    ):\n        if opacity is not None:\n            self.stroke_opacity = opacity\n        if recurse:\n            for submobject in self.submobjects:\n                submobject.set_stroke(\n                    color=color,\n                    width=width,\n                    opacity=opacity,\n                    background=background,\n                    recurse=recurse,\n                )\n\n        self.set_rgba_array(color, opacity, \"stroke_rgba\", recurse)\n\n        if width is not None:\n            for mob in self.get_family(recurse):\n                mob.stroke_width = np.array([[width] for width in tuplify(width)])\n\n        if background is not None:\n            for mob in self.get_family(recurse):\n                mob.draw_stroke_behind_fill = background\n        return self\n\n    def set_style(\n        self,\n        fill_color=None,\n        fill_opacity=None,\n        fill_rgba=None,\n        stroke_color=None,\n        stroke_opacity=None,\n        stroke_rgba=None,\n        stroke_width=None,\n        gloss=None,\n        shadow=None,\n        recurse=True,\n    ):\n        if fill_rgba is not None:\n            self.fill_rgba = resize_with_interpolation(fill_rgba, len(fill_rgba))\n        else:\n            self.set_fill(color=fill_color, opacity=fill_opacity, recurse=recurse)\n\n        if stroke_rgba is not None:\n            self.stroke_rgba = resize_with_interpolation(stroke_rgba, len(fill_rgba))\n            self.set_stroke(width=stroke_width)\n        else:\n            self.set_stroke(\n                color=stroke_color,\n                width=stroke_width,\n                opacity=stroke_opacity,\n                recurse=recurse,\n            )\n\n        if gloss is not None:\n            self.set_gloss(gloss, recurse=recurse)\n        if shadow is not None:\n            self.set_shadow(shadow, recurse=recurse)\n        return self\n\n    def get_style(self):\n        return {\n            \"fill_rgba\": self.fill_rgba,\n            \"stroke_rgba\": self.stroke_rgba,\n            \"stroke_width\": self.stroke_width,\n            \"gloss\": self.gloss,\n            \"shadow\": self.shadow,\n        }\n\n    def match_style(self, vmobject, recurse=True):\n        vmobject_style = vmobject.get_style()\n        if config.renderer == RendererType.OPENGL:\n            vmobject_style[\"stroke_width\"] = vmobject_style[\"stroke_width\"][0][0]\n            vmobject_style[\"fill_opacity\"] = self.get_fill_opacity()\n        self.set_style(**vmobject_style, recurse=False)\n        if recurse:\n            # Does its best to match up submobject lists, and\n            # match styles accordingly\n            submobs1, submobs2 = self.submobjects, vmobject.submobjects\n            if len(submobs1) == 0:\n                return self\n            elif len(submobs2) == 0:\n                submobs2 = [vmobject]\n            for sm1, sm2 in zip(*make_even(submobs1, submobs2)):\n                sm1.match_style(sm2)\n        return self\n\n    def set_color(self, color, opacity=None, recurse=True):\n        if opacity is not None:\n            self.opacity = opacity\n\n        self.set_fill(color, opacity=opacity, recurse=recurse)\n        self.set_stroke(color, opacity=opacity, recurse=recurse)\n        return self\n\n    def set_opacity(self, opacity, recurse=True):\n        self.set_fill(opacity=opacity, recurse=recurse)\n        self.set_stroke(opacity=opacity, recurse=recurse)\n        return self\n\n    def fade(self, darkness=0.5, recurse=True):\n        factor = 1.0 - darkness\n        self.set_fill(\n            opacity=factor * self.get_fill_opacity(),\n            recurse=False,\n        )\n        self.set_stroke(\n            opacity=factor * self.get_stroke_opacity(),\n            recurse=False,\n        )\n        super().fade(darkness, recurse)\n        return self\n\n    # Todo im not quite sure why we are doing this\n    def get_fill_colors(self):\n        return [ManimColor.from_rgb(rgba[:3]) for rgba in self.fill_rgba]\n\n    def get_fill_opacities(self):\n        return self.fill_rgba[:, 3]\n\n    def get_stroke_colors(self):\n        return [ManimColor.from_rgb(rgba[:3]) for rgba in self.stroke_rgba]\n\n    def get_stroke_opacities(self):\n        return self.stroke_rgba[:, 3]\n\n    def get_stroke_widths(self):\n        return self.stroke_width\n\n    # TODO, it's weird for these to return the first of various lists\n    # rather than the full information\n    def get_fill_color(self):\n        \"\"\"\n        If there are multiple colors (for gradient)\n        this returns the first one\n        \"\"\"\n        return self.get_fill_colors()[0]\n\n    def get_fill_opacity(self):\n        \"\"\"\n        If there are multiple opacities, this returns the\n        first\n        \"\"\"\n        return self.get_fill_opacities()[0]\n\n    def get_stroke_color(self):\n        return self.get_stroke_colors()[0]\n\n    def get_stroke_width(self):\n        return self.get_stroke_widths()[0]\n\n    def get_stroke_opacity(self):\n        return self.get_stroke_opacities()[0]\n\n    def get_color(self):\n        if not self.has_fill():\n            return self.get_stroke_color()\n        return self.get_fill_color()\n\n    def get_colors(self):\n        if self.has_stroke():\n            return self.get_stroke_colors()\n        return self.get_fill_colors()\n\n    stroke_color = property(get_stroke_color, set_stroke)\n    color = property(get_color, set_color)\n    fill_color = property(get_fill_color, set_fill)\n\n    def has_stroke(self):\n        stroke_widths = self.get_stroke_widths()\n        stroke_opacities = self.get_stroke_opacities()\n        return (\n            stroke_widths is not None\n            and stroke_opacities is not None\n            and any(stroke_widths)\n            and any(stroke_opacities)\n        )\n\n    def has_fill(self):\n        fill_opacities = self.get_fill_opacities()\n        return fill_opacities is not None and any(fill_opacities)\n\n    def get_opacity(self):\n        if self.has_fill():\n            return self.get_fill_opacity()\n        return self.get_stroke_opacity()\n\n    def set_flat_stroke(self, flat_stroke=True, recurse=True):\n        for mob in self.get_family(recurse):\n            mob.flat_stroke = flat_stroke\n        return self\n\n    def get_flat_stroke(self):\n        return self.flat_stroke\n\n    # Points\n    def set_anchors_and_handles(self, anchors1, handles, anchors2):\n        assert len(anchors1) == len(handles) == len(anchors2)\n        nppc = self.n_points_per_curve\n        new_points = np.zeros((nppc * len(anchors1), self.dim))\n        arrays = [anchors1, handles, anchors2]\n        for index, array in enumerate(arrays):\n            new_points[index::nppc] = array\n        self.set_points(new_points)\n        return self\n\n    def start_new_path(self, point):\n        assert self.get_num_points() % self.n_points_per_curve == 0\n        self.append_points([point])\n        return self\n\n    def add_cubic_bezier_curve(self, anchor1, handle1, handle2, anchor2):\n        new_points = get_quadratic_approximation_of_cubic(\n            anchor1,\n            handle1,\n            handle2,\n            anchor2,\n        )\n        self.append_points(new_points)\n\n    def add_cubic_bezier_curve_to(self, handle1, handle2, anchor):\n        \"\"\"Add cubic bezier curve to the path.\"\"\"\n        self.throw_error_if_no_points()\n        quadratic_approx = get_quadratic_approximation_of_cubic(\n            self.get_last_point(),\n            handle1,\n            handle2,\n            anchor,\n        )\n        if self.has_new_path_started():\n            self.append_points(quadratic_approx[1:])\n        else:\n            self.append_points(quadratic_approx)\n\n    def add_quadratic_bezier_curve_to(self, handle, anchor):\n        self.throw_error_if_no_points()\n        if self.has_new_path_started():\n            self.append_points([handle, anchor])\n        else:\n            self.append_points([self.get_last_point(), handle, anchor])\n\n    def add_line_to(self, point: Sequence[float]) -> OpenGLVMobject:\n        \"\"\"Add a straight line from the last point of OpenGLVMobject to the given point.\n\n        Parameters\n        ----------\n\n        point\n            end of the straight line.\n        \"\"\"\n        end = self.points[-1]\n        alphas = np.linspace(0, 1, self.n_points_per_curve)\n        if self.long_lines:\n            halfway = interpolate(end, point, 0.5)\n            points = [interpolate(end, halfway, a) for a in alphas] + [\n                interpolate(halfway, point, a) for a in alphas\n            ]\n        else:\n            points = [interpolate(end, point, a) for a in alphas]\n        if self.has_new_path_started():\n            points = points[1:]\n        self.append_points(points)\n        return self\n\n    def add_smooth_curve_to(self, point):\n        if self.has_new_path_started():\n            self.add_line_to(point)\n        else:\n            self.throw_error_if_no_points()\n            new_handle = self.get_reflection_of_last_handle()\n            self.add_quadratic_bezier_curve_to(new_handle, point)\n        return self\n\n    def add_smooth_cubic_curve_to(self, handle, point):\n        self.throw_error_if_no_points()\n        new_handle = self.get_reflection_of_last_handle()\n        self.add_cubic_bezier_curve_to(new_handle, handle, point)\n\n    def has_new_path_started(self):\n        return self.get_num_points() % self.n_points_per_curve == 1\n\n    def get_last_point(self):\n        return self.points[-1]\n\n    def get_reflection_of_last_handle(self):\n        points = self.points\n        return 2 * points[-1] - points[-2]\n\n    def close_path(self):\n        if not self.is_closed():\n            self.add_line_to(self.get_subpaths()[-1][0])\n\n    def is_closed(self):\n        return self.consider_points_equals(self.points[0], self.points[-1])\n\n    def subdivide_sharp_curves(self, angle_threshold=30 * DEGREES, recurse=True):\n        vmobs = [vm for vm in self.get_family(recurse) if vm.has_points()]\n        for vmob in vmobs:\n            new_points = []\n            for tup in vmob.get_bezier_tuples():\n                angle = angle_between_vectors(tup[1] - tup[0], tup[2] - tup[1])\n                if angle > angle_threshold:\n                    n = int(np.ceil(angle / angle_threshold))\n                    alphas = np.linspace(0, 1, n + 1)\n                    new_points.extend(\n                        [\n                            partial_bezier_points(tup, a1, a2)\n                            for a1, a2 in zip(alphas, alphas[1:])\n                        ],\n                    )\n                else:\n                    new_points.append(tup)\n            vmob.set_points(np.vstack(new_points))\n        return self\n\n    def add_points_as_corners(self, points):\n        for point in points:\n            self.add_line_to(point)\n        return points\n\n    def set_points_as_corners(self, points: Iterable[float]) -> OpenGLVMobject:\n        \"\"\"Given an array of points, set them as corner of the vmobject.\n\n        To achieve that, this algorithm sets handles aligned with the anchors such that the resultant bezier curve will be the segment\n        between the two anchors.\n\n        Parameters\n        ----------\n        points\n            Array of points that will be set as corners.\n\n        Returns\n        -------\n        OpenGLVMobject\n            self. For chaining purposes.\n        \"\"\"\n        nppc = self.n_points_per_curve\n        points = np.array(points)\n        self.set_anchors_and_handles(\n            *(interpolate(points[:-1], points[1:], a) for a in np.linspace(0, 1, nppc))\n        )\n        return self\n\n    def set_points_smoothly(self, points, true_smooth=False):\n        self.set_points_as_corners(points)\n        self.make_smooth()\n        return self\n\n    def change_anchor_mode(self, mode):\n        \"\"\"Changes the anchor mode of the bezier curves. This will modify the handles.\n\n        There can be only three modes, \"jagged\", \"approx_smooth\"  and \"true_smooth\".\n\n        Returns\n        -------\n        OpenGLVMobject\n            For chaining purposes.\n        \"\"\"\n        assert mode in (\"jagged\", \"approx_smooth\", \"true_smooth\")\n        nppc = self.n_points_per_curve\n        for submob in self.family_members_with_points():\n            subpaths = submob.get_subpaths()\n            submob.clear_points()\n            for subpath in subpaths:\n                anchors = np.vstack([subpath[::nppc], subpath[-1:]])\n                new_subpath = np.array(subpath)\n                if mode == \"approx_smooth\":\n                    # TODO: get_smooth_quadratic_bezier_handle_points is not defined\n                    new_subpath[1::nppc] = get_smooth_quadratic_bezier_handle_points(\n                        anchors,\n                    )\n                elif mode == \"true_smooth\":\n                    h1, h2 = get_smooth_cubic_bezier_handle_points(anchors)\n                    new_subpath = get_quadratic_approximation_of_cubic(\n                        anchors[:-1],\n                        h1,\n                        h2,\n                        anchors[1:],\n                    )\n                elif mode == \"jagged\":\n                    new_subpath[1::nppc] = 0.5 * (anchors[:-1] + anchors[1:])\n                submob.append_points(new_subpath)\n            submob.refresh_triangulation()\n        return self\n\n    def make_smooth(self):\n        \"\"\"\n        This will double the number of points in the mobject,\n        so should not be called repeatedly.  It also means\n        transforming between states before and after calling\n        this might have strange artifacts\n        \"\"\"\n        self.change_anchor_mode(\"true_smooth\")\n        return self\n\n    def make_approximately_smooth(self):\n        \"\"\"\n        Unlike make_smooth, this will not change the number of\n        points, but it also does not result in a perfectly smooth\n        curve.  It's most useful when the points have been\n        sampled at a not-too-low rate from a continuous function,\n        as in the case of ParametricCurve\n        \"\"\"\n        self.change_anchor_mode(\"approx_smooth\")\n        return self\n\n    def make_jagged(self):\n        self.change_anchor_mode(\"jagged\")\n        return self\n\n    def add_subpath(self, points):\n        assert len(points) % self.n_points_per_curve == 0\n        self.append_points(points)\n        return self\n\n    def append_vectorized_mobject(self, vectorized_mobject):\n        new_points = list(vectorized_mobject.points)\n\n        if self.has_new_path_started():\n            # Remove last point, which is starting\n            # a new path\n            self.resize_data(len(self.points - 1))\n        self.append_points(new_points)\n        return self\n\n    #\n    def consider_points_equals(self, p0, p1):\n        return np.linalg.norm(p1 - p0) < self.tolerance_for_point_equality\n\n    # Information about the curve\n    def force_direction(self, target_direction: str):\n        \"\"\"Makes sure that points are either directed clockwise or\n        counterclockwise.\n\n        Parameters\n        ----------\n        target_direction\n            Either ``\"CW\"`` or ``\"CCW\"``.\n        \"\"\"\n        if target_direction not in (\"CW\", \"CCW\"):\n            raise ValueError('Invalid input for force_direction. Use \"CW\" or \"CCW\"')\n\n        if self.get_direction() != target_direction:\n            self.reverse_points()\n\n        return self\n\n    def reverse_direction(self):\n        \"\"\"Reverts the point direction by inverting the point order.\n\n        Returns\n        -------\n        :class:`OpenGLVMobject`\n            Returns self.\n\n        Examples\n        --------\n        .. manim:: ChangeOfDirection\n\n            class ChangeOfDirection(Scene):\n                def construct(self):\n                    ccw = RegularPolygon(5)\n                    ccw.shift(LEFT)\n                    cw = RegularPolygon(5)\n                    cw.shift(RIGHT).reverse_direction()\n\n                    self.play(Create(ccw), Create(cw),\n                    run_time=4)\n        \"\"\"\n        self.set_points(self.points[::-1])\n        return self\n\n    def get_bezier_tuples_from_points(self, points):\n        nppc = self.n_points_per_curve\n        remainder = len(points) % nppc\n        points = points[: len(points) - remainder]\n        return points.reshape((-1, nppc, 3))\n\n    def get_bezier_tuples(self):\n        return self.get_bezier_tuples_from_points(self.points)\n\n    def get_subpaths_from_points(self, points):\n        nppc = self.n_points_per_curve\n        diffs = points[nppc - 1 : -1 : nppc] - points[nppc::nppc]\n        splits = (diffs * diffs).sum(1) > self.tolerance_for_point_equality\n        split_indices = np.arange(nppc, len(points), nppc, dtype=int)[splits]\n\n        # split_indices = filter(\n        #     lambda n: not self.consider_points_equals(points[n - 1], points[n]),\n        #     range(nppc, len(points), nppc)\n        # )\n        split_indices = [0, *split_indices, len(points)]\n        return [\n            points[i1:i2]\n            for i1, i2 in zip(split_indices, split_indices[1:])\n            if (i2 - i1) >= nppc\n        ]\n\n    def get_subpaths(self):\n        \"\"\"Returns subpaths formed by the curves of the OpenGLVMobject.\n\n        Subpaths are ranges of curves with each pair of consecutive\n        curves having their end/start points coincident.\n\n        Returns\n        -------\n        Tuple\n            subpaths.\n        \"\"\"\n        return self.get_subpaths_from_points(self.points)\n\n    def get_nth_curve_points(self, n: int) -> np.ndarray:\n        \"\"\"Returns the points defining the nth curve of the vmobject.\n\n        Parameters\n        ----------\n        n\n            index of the desired bezier curve.\n\n        Returns\n        -------\n        np.ndarray\n            points defininf the nth bezier curve (anchors, handles)\n        \"\"\"\n        assert n < self.get_num_curves()\n        nppc = self.n_points_per_curve\n        return self.points[nppc * n : nppc * (n + 1)]\n\n    def get_nth_curve_function(self, n: int) -> Callable[[float], np.ndarray]:\n        \"\"\"Returns the expression of the nth curve.\n\n        Parameters\n        ----------\n        n\n            index of the desired curve.\n\n        Returns\n        -------\n        typing.Callable[float]\n            expression of the nth bezier curve.\n        \"\"\"\n        return bezier(self.get_nth_curve_points(n))\n\n    def get_nth_curve_function_with_length(\n        self,\n        n: int,\n        sample_points: int | None = None,\n    ) -> tuple[Callable[[float], np.ndarray], float]:\n        \"\"\"Returns the expression of the nth curve along with its (approximate) length.\n\n        Parameters\n        ----------\n        n\n            The index of the desired curve.\n        sample_points\n            The number of points to sample to find the length.\n\n        Returns\n        -------\n        curve : Callable[[float], np.ndarray]\n            The function for the nth curve.\n        length : :class:`float`\n            The length of the nth curve.\n        \"\"\"\n        if sample_points is None:\n            sample_points = 10\n\n        curve = self.get_nth_curve_function(n)\n        norms = self.get_nth_curve_length_pieces(n, sample_points)\n\n        length = np.sum(norms)\n\n        return curve, length\n\n    def get_num_curves(self) -> int:\n        \"\"\"Returns the number of curves of the vmobject.\n\n        Returns\n        -------\n        int\n            number of curves. of the vmobject.\n        \"\"\"\n        return self.get_num_points() // self.n_points_per_curve\n\n    def get_nth_curve_length(\n        self,\n        n: int,\n        sample_points: int | None = None,\n    ) -> float:\n        \"\"\"Returns the (approximate) length of the nth curve.\n\n        Parameters\n        ----------\n        n\n            The index of the desired curve.\n        sample_points\n            The number of points to sample to find the length.\n\n        Returns\n        -------\n        length : :class:`float`\n            The length of the nth curve.\n        \"\"\"\n        _, length = self.get_nth_curve_function_with_length(n, sample_points)\n\n        return length\n\n    def get_curve_functions(\n        self,\n    ) -> Iterable[Callable[[float], np.ndarray]]:\n        \"\"\"Gets the functions for the curves of the mobject.\n\n        Returns\n        -------\n        Iterable[Callable[[float], np.ndarray]]\n            The functions for the curves.\n        \"\"\"\n        num_curves = self.get_num_curves()\n\n        for n in range(num_curves):\n            yield self.get_nth_curve_function(n)\n\n    def get_nth_curve_length_pieces(\n        self,\n        n: int,\n        sample_points: int | None = None,\n    ) -> np.ndarray:\n        \"\"\"Returns the array of short line lengths used for length approximation.\n\n        Parameters\n        ----------\n        n\n            The index of the desired curve.\n        sample_points\n            The number of points to sample to find the length.\n\n        Returns\n        -------\n        np.ndarray\n            The short length-pieces of the nth curve.\n        \"\"\"\n        if sample_points is None:\n            sample_points = 10\n\n        curve = self.get_nth_curve_function(n)\n        points = np.array([curve(a) for a in np.linspace(0, 1, sample_points)])\n        diffs = points[1:] - points[:-1]\n        norms = np.apply_along_axis(np.linalg.norm, 1, diffs)\n\n        return norms\n\n    def get_curve_functions_with_lengths(\n        self, **kwargs\n    ) -> Iterable[tuple[Callable[[float], np.ndarray], float]]:\n        \"\"\"Gets the functions and lengths of the curves for the mobject.\n\n        Parameters\n        ----------\n        **kwargs\n            The keyword arguments passed to :meth:`get_nth_curve_function_with_length`\n\n        Returns\n        -------\n        Iterable[Tuple[Callable[[float], np.ndarray], float]]\n            The functions and lengths of the curves.\n        \"\"\"\n        num_curves = self.get_num_curves()\n\n        for n in range(num_curves):\n            yield self.get_nth_curve_function_with_length(n, **kwargs)\n\n    def point_from_proportion(self, alpha: float) -> np.ndarray:\n        \"\"\"Gets the point at a proportion along the path of the :class:`OpenGLVMobject`.\n\n        Parameters\n        ----------\n        alpha\n            The proportion along the the path of the :class:`OpenGLVMobject`.\n\n        Returns\n        -------\n        :class:`numpy.ndarray`\n            The point on the :class:`OpenGLVMobject`.\n\n        Raises\n        ------\n        :exc:`ValueError`\n            If ``alpha`` is not between 0 and 1.\n        :exc:`Exception`\n            If the :class:`OpenGLVMobject` has no points.\n        \"\"\"\n        if alpha < 0 or alpha > 1:\n            raise ValueError(f\"Alpha {alpha} not between 0 and 1.\")\n\n        self.throw_error_if_no_points()\n        if alpha == 1:\n            return self.points[-1]\n\n        curves_and_lengths = tuple(self.get_curve_functions_with_lengths())\n\n        target_length = alpha * np.sum(\n            np.fromiter((length for _, length in curves_and_lengths), dtype=np.float64)\n        )\n        current_length = 0\n\n        for curve, length in curves_and_lengths:\n            if current_length + length >= target_length:\n                if length != 0:\n                    residue = (target_length - current_length) / length\n                else:\n                    residue = 0\n\n                return curve(residue)\n\n            current_length += length\n\n    def proportion_from_point(\n        self,\n        point: Iterable[float | int],\n    ) -> float:\n        \"\"\"Returns the proportion along the path of the :class:`OpenGLVMobject`\n        a particular given point is at.\n\n        Parameters\n        ----------\n        point\n            The Cartesian coordinates of the point which may or may not lie on the :class:`OpenGLVMobject`\n\n        Returns\n        -------\n        float\n            The proportion along the path of the :class:`OpenGLVMobject`.\n\n        Raises\n        ------\n        :exc:`ValueError`\n            If ``point`` does not lie on the curve.\n        :exc:`Exception`\n            If the :class:`OpenGLVMobject` has no points.\n        \"\"\"\n        self.throw_error_if_no_points()\n\n        # Iterate over each bezier curve that the ``VMobject`` is composed of, checking\n        # if the point lies on that curve. If it does not lie on that curve, add\n        # the whole length of the curve to ``target_length`` and move onto the next\n        # curve. If the point does lie on the curve, add how far along the curve\n        # the point is to ``target_length``.\n        # Then, divide ``target_length`` by the total arc length of the shape to get\n        # the proportion along the ``VMobject`` the point is at.\n\n        num_curves = self.get_num_curves()\n        total_length = self.get_arc_length()\n        target_length = 0\n        for n in range(num_curves):\n            control_points = self.get_nth_curve_points(n)\n            length = self.get_nth_curve_length(n)\n            proportions_along_bezier = proportions_along_bezier_curve_for_point(\n                point,\n                control_points,\n            )\n            if len(proportions_along_bezier) > 0:\n                proportion_along_nth_curve = max(proportions_along_bezier)\n                target_length += length * proportion_along_nth_curve\n                break\n            target_length += length\n        else:\n            raise ValueError(f\"Point {point} does not lie on this curve.\")\n\n        alpha = target_length / total_length\n\n        return alpha\n\n    def get_anchors_and_handles(self) -> Iterable[np.ndarray]:\n        \"\"\"\n        Returns anchors1, handles, anchors2,\n        where (anchors1[i], handles[i], anchors2[i])\n        will be three points defining a quadratic bezier curve\n        for any i in range(0, len(anchors1))\n        \"\"\"\n        nppc = self.n_points_per_curve\n        points = self.points\n        return [points[i::nppc] for i in range(nppc)]\n\n    def get_start_anchors(self) -> np.ndarray:\n        \"\"\"Returns the start anchors of the bezier curves.\n\n        Returns\n        -------\n        np.ndarray\n            Starting anchors\n        \"\"\"\n        return self.points[0 :: self.n_points_per_curve]\n\n    def get_end_anchors(self) -> np.ndarray:\n        \"\"\"Return the starting anchors of the bezier curves.\n\n        Returns\n        -------\n        np.ndarray\n            Starting anchors\n        \"\"\"\n        nppc = self.n_points_per_curve\n        return self.points[nppc - 1 :: nppc]\n\n    def get_anchors(self) -> Iterable[np.ndarray]:\n        \"\"\"Returns the anchors of the curves forming the OpenGLVMobject.\n\n        Returns\n        -------\n        Iterable[np.ndarray]\n            The anchors.\n        \"\"\"\n        points = self.points\n        if len(points) == 1:\n            return points\n\n        s = self.get_start_anchors()\n        e = self.get_end_anchors()\n        return list(it.chain.from_iterable(zip(s, e)))\n\n    def get_points_without_null_curves(self, atol=1e-9):\n        nppc = self.n_points_per_curve\n        points = self.points\n        distinct_curves = reduce(\n            op.or_,\n            [\n                (abs(points[i::nppc] - points[0::nppc]) > atol).any(1)\n                for i in range(1, nppc)\n            ],\n        )\n        return points[distinct_curves.repeat(nppc)]\n\n    def get_arc_length(self, sample_points_per_curve: int | None = None) -> float:\n        \"\"\"Return the approximated length of the whole curve.\n\n        Parameters\n        ----------\n        sample_points_per_curve\n            Number of sample points per curve used to approximate the length. More points result in a better approximation.\n\n        Returns\n        -------\n        float\n            The length of the :class:`OpenGLVMobject`.\n        \"\"\"\n        return np.sum(\n            length\n            for _, length in self.get_curve_functions_with_lengths(\n                sample_points=sample_points_per_curve,\n            )\n        )\n\n    def get_area_vector(self):\n        # Returns a vector whose length is the area bound by\n        # the polygon formed by the anchor points, pointing\n        # in a direction perpendicular to the polygon according\n        # to the right hand rule.\n        if not self.has_points():\n            return np.zeros(3)\n\n        nppc = self.n_points_per_curve\n        points = self.points\n        p0 = points[0::nppc]\n        p1 = points[nppc - 1 :: nppc]\n\n        # Each term goes through all edges [(x1, y1, z1), (x2, y2, z2)]\n        return 0.5 * np.array(\n            [\n                sum(\n                    (p0[:, 1] + p1[:, 1]) * (p1[:, 2] - p0[:, 2]),\n                ),  # Add up (y1 + y2)*(z2 - z1)\n                sum(\n                    (p0[:, 2] + p1[:, 2]) * (p1[:, 0] - p0[:, 0]),\n                ),  # Add up (z1 + z2)*(x2 - x1)\n                sum(\n                    (p0[:, 0] + p1[:, 0]) * (p1[:, 1] - p0[:, 1]),\n                ),  # Add up (x1 + x2)*(y2 - y1)\n            ],\n        )\n\n    def get_direction(self):\n        \"\"\"Uses :func:`~.space_ops.shoelace_direction` to calculate the direction.\n        The direction of points determines in which direction the\n        object is drawn, clockwise or counterclockwise.\n\n        Examples\n        --------\n        The default direction of a :class:`~.Circle` is counterclockwise::\n\n            >>> from manim import Circle\n            >>> Circle().get_direction()\n            'CCW'\n\n        Returns\n        -------\n        :class:`str`\n            Either ``\"CW\"`` or ``\"CCW\"``.\n        \"\"\"\n        return shoelace_direction(self.get_start_anchors())\n\n    def get_unit_normal(self, recompute=False):\n        if not recompute:\n            return self.unit_normal[0]\n\n        if len(self.points) < 3:\n            return OUT\n\n        area_vect = self.get_area_vector()\n        area = np.linalg.norm(area_vect)\n        if area > 0:\n            return area_vect / area\n        else:\n            points = self.points\n            return get_unit_normal(\n                points[1] - points[0],\n                points[2] - points[1],\n            )\n\n    def refresh_unit_normal(self):\n        for mob in self.get_family():\n            mob.unit_normal[:] = mob.get_unit_normal(recompute=True)\n        return self\n\n    # Alignment\n    def align_points(self, vmobject):\n        # TODO: This shortcut can be a bit over eager. What if they have the same length, but different subpath lengths?\n        if self.get_num_points() == len(vmobject.points):\n            return\n\n        for mob in self, vmobject:\n            # If there are no points, add one to\n            # where the \"center\" is\n            if not mob.has_points():\n                mob.start_new_path(mob.get_center())\n            # If there's only one point, turn it into\n            # a null curve\n            if mob.has_new_path_started():\n                mob.add_line_to(mob.points[0])\n\n        # Figure out what the subpaths are, and align\n        subpaths1 = self.get_subpaths()\n        subpaths2 = vmobject.get_subpaths()\n        n_subpaths = max(len(subpaths1), len(subpaths2))\n        # Start building new ones\n        new_subpaths1 = []\n        new_subpaths2 = []\n\n        nppc = self.n_points_per_curve\n\n        def get_nth_subpath(path_list, n):\n            if n >= len(path_list):\n                # Create a null path at the very end\n                return [path_list[-1][-1]] * nppc\n            path = path_list[n]\n            # Check for useless points at the end of the path and remove them\n            # https://github.com/ManimCommunity/manim/issues/1959\n            while len(path) > nppc:\n                # If the last nppc points are all equal to the preceding point\n                if self.consider_points_equals(path[-nppc:], path[-nppc - 1]):\n                    path = path[:-nppc]\n                else:\n                    break\n            return path\n\n        for n in range(n_subpaths):\n            sp1 = np.asarray(get_nth_subpath(subpaths1, n))\n            sp2 = np.asarray(get_nth_subpath(subpaths2, n))\n            diff1 = max(0, (len(sp2) - len(sp1)) // nppc)\n            diff2 = max(0, (len(sp1) - len(sp2)) // nppc)\n            sp1 = self.insert_n_curves_to_point_list(diff1, sp1)\n            sp2 = self.insert_n_curves_to_point_list(diff2, sp2)\n            new_subpaths1.append(sp1)\n            new_subpaths2.append(sp2)\n        self.set_points(np.vstack(new_subpaths1))\n        vmobject.set_points(np.vstack(new_subpaths2))\n        return self\n\n    def insert_n_curves(self, n: int, recurse=True) -> OpenGLVMobject:\n        \"\"\"Inserts n curves to the bezier curves of the vmobject.\n\n        Parameters\n        ----------\n        n\n            Number of curves to insert.\n\n        Returns\n        -------\n        OpenGLVMobject\n            for chaining.\n        \"\"\"\n        for mob in self.get_family(recurse):\n            if mob.get_num_curves() > 0:\n                new_points = mob.insert_n_curves_to_point_list(n, mob.points)\n                # TODO, this should happen in insert_n_curves_to_point_list\n                if mob.has_new_path_started():\n                    new_points = np.vstack([new_points, mob.get_last_point()])\n                mob.set_points(new_points)\n        return self\n\n    def insert_n_curves_to_point_list(self, n: int, points: np.ndarray) -> np.ndarray:\n        \"\"\"Given an array of k points defining a bezier curves\n         (anchors and handles), returns points defining exactly\n        k + n bezier curves.\n\n        Parameters\n        ----------\n        n\n            Number of desired curves.\n        points\n            Starting points.\n\n        Returns\n        -------\n        np.ndarray\n            Points generated.\n        \"\"\"\n        nppc = self.n_points_per_curve\n        if len(points) == 1:\n            return np.repeat(points, nppc * n, 0)\n\n        bezier_tuples = self.get_bezier_tuples_from_points(points)\n        current_number_of_curves = len(bezier_tuples)\n        new_number_of_curves = current_number_of_curves + n\n        new_bezier_tuples = bezier_remap(bezier_tuples, new_number_of_curves)\n        new_points = new_bezier_tuples.reshape(-1, 3)\n        return new_points\n\n    def interpolate(self, mobject1, mobject2, alpha, *args, **kwargs):\n        super().interpolate(mobject1, mobject2, alpha, *args, **kwargs)\n        if config[\"use_projection_fill_shaders\"]:\n            self.refresh_triangulation()\n        else:\n            if self.has_fill():\n                tri1 = mobject1.get_triangulation()\n                tri2 = mobject2.get_triangulation()\n                if len(tri1) != len(tri2) or not np.all(tri1 == tri2):\n                    self.refresh_triangulation()\n        return self\n\n    def pointwise_become_partial(\n        self, vmobject: OpenGLVMobject, a: float, b: float, remap: bool = True\n    ) -> OpenGLVMobject:\n        \"\"\"Given two bounds a and b, transforms the points of the self vmobject into the points of the vmobject\n        passed as parameter with respect to the bounds. Points here stand for control points of the bezier curves (anchors and handles)\n\n        Parameters\n        ----------\n        vmobject\n            The vmobject that will serve as a model.\n        a\n            upper-bound.\n        b\n            lower-bound\n        remap\n            if the point amount should be kept the same (True)\n            This option should be manually set to False if keeping the number of points is not needed\n        \"\"\"\n        assert isinstance(vmobject, OpenGLVMobject)\n        # Partial curve includes three portions:\n        # - A middle section, which matches the curve exactly\n        # - A start, which is some ending portion of an inner cubic\n        # - An end, which is the starting portion of a later inner cubic\n        if a <= 0 and b >= 1:\n            self.set_points(vmobject.points)\n            return self\n        bezier_triplets = vmobject.get_bezier_tuples()\n        num_quadratics = len(bezier_triplets)\n\n        # The following two lines will compute which bezier curves of the given mobject need to be processed.\n        # The residue basically indicates the proportion of the selected B\u00e8zier curve.\n        # Ex: if lower_index is 3, and lower_residue is 0.4, then the algorithm will append to the points 0.4 of the third bezier curve\n        lower_index, lower_residue = integer_interpolate(0, num_quadratics, a)\n        upper_index, upper_residue = integer_interpolate(0, num_quadratics, b)\n        self.clear_points()\n        if num_quadratics == 0:\n            return self\n        if lower_index == upper_index:\n            self.append_points(\n                partial_bezier_points(\n                    bezier_triplets[lower_index],\n                    lower_residue,\n                    upper_residue,\n                ),\n            )\n        else:\n            self.append_points(\n                partial_bezier_points(bezier_triplets[lower_index], lower_residue, 1),\n            )\n            inner_points = bezier_triplets[lower_index + 1 : upper_index]\n            if len(inner_points) > 0:\n                if remap:\n                    new_triplets = bezier_remap(inner_points, num_quadratics - 2)\n                else:\n                    new_triplets = bezier_triplets\n\n                self.append_points(np.asarray(new_triplets).reshape(-1, 3))\n            self.append_points(\n                partial_bezier_points(bezier_triplets[upper_index], 0, upper_residue),\n            )\n        return self\n\n    def get_subcurve(self, a: float, b: float) -> OpenGLVMobject:\n        \"\"\"Returns the subcurve of the OpenGLVMobject between the interval [a, b].\n        The curve is a OpenGLVMobject itself.\n\n        Parameters\n        ----------\n\n        a\n            The lower bound.\n        b\n            The upper bound.\n\n        Returns\n        -------\n        OpenGLVMobject\n            The subcurve between of [a, b]\n        \"\"\"\n        vmob = self.copy()\n        vmob.pointwise_become_partial(self, a, b)\n        return vmob\n\n    # Related to triangulation\n\n    def refresh_triangulation(self):\n        for mob in self.get_family():\n            mob.needs_new_triangulation = True\n        return self\n\n    def get_triangulation(self, normal_vector=None):\n        # Figure out how to triangulate the interior to know\n        # how to send the points as to the vertex shader.\n        # First triangles come directly from the points\n        if normal_vector is None:\n            normal_vector = self.get_unit_normal()\n\n        if not self.needs_new_triangulation:\n            return self.triangulation\n\n        points = self.points\n\n        if len(points) <= 1:\n            self.triangulation = np.zeros(0, dtype=\"i4\")\n            self.needs_new_triangulation = False\n            return self.triangulation\n\n        if not np.isclose(normal_vector, OUT).all():\n            # Rotate points such that unit normal vector is OUT\n            points = np.dot(points, z_to_vector(normal_vector))\n        indices = np.arange(len(points), dtype=int)\n\n        b0s = points[0::3]\n        b1s = points[1::3]\n        b2s = points[2::3]\n        v01s = b1s - b0s\n        v12s = b2s - b1s\n\n        crosses = cross2d(v01s, v12s)\n        convexities = np.sign(crosses)\n\n        atol = self.tolerance_for_point_equality\n        end_of_loop = np.zeros(len(b0s), dtype=bool)\n        end_of_loop[:-1] = (np.abs(b2s[:-1] - b0s[1:]) > atol).any(1)\n        end_of_loop[-1] = True\n\n        concave_parts = convexities < 0\n\n        # These are the vertices to which we'll apply a polygon triangulation\n        inner_vert_indices = np.hstack(\n            [\n                indices[0::3],\n                indices[1::3][concave_parts],\n                indices[2::3][end_of_loop],\n            ],\n        )\n        inner_vert_indices.sort()\n        rings = np.arange(1, len(inner_vert_indices) + 1)[inner_vert_indices % 3 == 2]\n\n        # Triangulate\n        inner_verts = points[inner_vert_indices]\n        inner_tri_indices = inner_vert_indices[\n            earclip_triangulation(inner_verts, rings)\n        ]\n\n        tri_indices = np.hstack([indices, inner_tri_indices])\n        self.triangulation = tri_indices\n        self.needs_new_triangulation = False\n        return tri_indices\n\n    @triggers_refreshed_triangulation\n    def set_points(self, points):\n        super().set_points(points)\n        return self\n\n    @triggers_refreshed_triangulation\n    def set_data(self, data):\n        super().set_data(data)\n        return self\n\n    # TODO, how to be smart about tangents here?\n    @triggers_refreshed_triangulation\n    def apply_function(self, function, make_smooth=False, **kwargs):\n        super().apply_function(function, **kwargs)\n        if self.make_smooth_after_applying_functions or make_smooth:\n            self.make_approximately_smooth()\n        return self\n\n    @triggers_refreshed_triangulation\n    def apply_points_function(self, *args, **kwargs):\n        super().apply_points_function(*args, **kwargs)\n        return self\n\n    @triggers_refreshed_triangulation\n    def flip(self, *args, **kwargs):\n        super().flip(*args, **kwargs)\n        return self\n\n    # For shaders\n    def init_shader_data(self):\n        self.fill_data = np.zeros(0, dtype=self.fill_dtype)\n        self.stroke_data = np.zeros(0, dtype=self.stroke_dtype)\n        self.fill_shader_wrapper = ShaderWrapper(\n            vert_data=self.fill_data,\n            vert_indices=np.zeros(0, dtype=\"i4\"),\n            shader_folder=self.fill_shader_folder,\n            render_primitive=self.render_primitive,\n        )\n        self.stroke_shader_wrapper = ShaderWrapper(\n            vert_data=self.stroke_data,\n            shader_folder=self.stroke_shader_folder,\n            render_primitive=self.render_primitive,\n        )\n\n    def refresh_shader_wrapper_id(self):\n        for wrapper in [self.fill_shader_wrapper, self.stroke_shader_wrapper]:\n            wrapper.refresh_id()\n        return self\n\n    def get_fill_shader_wrapper(self):\n        self.update_fill_shader_wrapper()\n        return self.fill_shader_wrapper\n\n    def update_fill_shader_wrapper(self):\n        self.fill_shader_wrapper.vert_data = self.get_fill_shader_data()\n        self.fill_shader_wrapper.vert_indices = self.get_triangulation()\n        self.fill_shader_wrapper.uniforms = self.get_fill_uniforms()\n        self.fill_shader_wrapper.depth_test = self.depth_test\n\n    def get_stroke_shader_wrapper(self):\n        self.update_stroke_shader_wrapper()\n        return self.stroke_shader_wrapper\n\n    def update_stroke_shader_wrapper(self):\n        self.stroke_shader_wrapper.vert_data = self.get_stroke_shader_data()\n        self.stroke_shader_wrapper.uniforms = self.get_stroke_uniforms()\n        self.stroke_shader_wrapper.depth_test = self.depth_test\n\n    def get_shader_wrapper_list(self):\n        # Build up data lists\n        fill_shader_wrappers = []\n        stroke_shader_wrappers = []\n        back_stroke_shader_wrappers = []\n        for submob in self.family_members_with_points():\n            if submob.has_fill() and not config[\"use_projection_fill_shaders\"]:\n                fill_shader_wrappers.append(submob.get_fill_shader_wrapper())\n            if submob.has_stroke() and not config[\"use_projection_stroke_shaders\"]:\n                ssw = submob.get_stroke_shader_wrapper()\n                if submob.draw_stroke_behind_fill:\n                    back_stroke_shader_wrappers.append(ssw)\n                else:\n                    stroke_shader_wrappers.append(ssw)\n\n        # Combine data lists\n        wrapper_lists = [\n            back_stroke_shader_wrappers,\n            fill_shader_wrappers,\n            stroke_shader_wrappers,\n        ]\n        result = []\n        for wlist in wrapper_lists:\n            if wlist:\n                wrapper = wlist[0]\n                wrapper.combine_with(*wlist[1:])\n                result.append(wrapper)\n        return result\n\n    def get_stroke_uniforms(self):\n        result = dict(super().get_shader_uniforms())\n        result[\"joint_type\"] = self.joint_type.value\n        result[\"flat_stroke\"] = float(self.flat_stroke)\n        return result\n\n    def get_fill_uniforms(self):\n        return {\n            \"is_fixed_in_frame\": float(self.is_fixed_in_frame),\n            \"is_fixed_orientation\": float(self.is_fixed_orientation),\n            \"fixed_orientation_center\": self.fixed_orientation_center,\n            \"gloss\": self.gloss,\n            \"shadow\": self.shadow,\n        }\n\n    def get_stroke_shader_data(self):\n        points = self.points\n        if len(self.stroke_data) != len(points):\n            self.stroke_data = np.zeros(len(points), dtype=OpenGLVMobject.stroke_dtype)\n\n        if \"points\" not in self.locked_data_keys:\n            nppc = self.n_points_per_curve\n            self.stroke_data[\"point\"] = points\n            self.stroke_data[\"prev_point\"][:nppc] = points[-nppc:]\n            self.stroke_data[\"prev_point\"][nppc:] = points[:-nppc]\n            self.stroke_data[\"next_point\"][:-nppc] = points[nppc:]\n            self.stroke_data[\"next_point\"][-nppc:] = points[:nppc]\n\n        self.read_data_to_shader(self.stroke_data, \"color\", \"stroke_rgba\")\n        self.read_data_to_shader(self.stroke_data, \"stroke_width\", \"stroke_width\")\n        self.read_data_to_shader(self.stroke_data, \"unit_normal\", \"unit_normal\")\n\n        return self.stroke_data\n\n    def get_fill_shader_data(self):\n        points = self.points\n        if len(self.fill_data) != len(points):\n            self.fill_data = np.zeros(len(points), dtype=OpenGLVMobject.fill_dtype)\n            self.fill_data[\"vert_index\"][:, 0] = range(len(points))\n\n        self.read_data_to_shader(self.fill_data, \"point\", \"points\")\n        self.read_data_to_shader(self.fill_data, \"color\", \"fill_rgba\")\n        self.read_data_to_shader(self.fill_data, \"unit_normal\", \"unit_normal\")\n\n        return self.fill_data\n\n    def refresh_shader_data(self):\n        self.get_fill_shader_data()\n        self.get_stroke_shader_data()\n\n    def get_fill_shader_vert_indices(self):\n        return self.get_triangulation()"}, {"name": "orthographic_projection_matrix", "code": "def orthographic_projection_matrix(\n    width: float | None = None,\n    height: float | None = None,\n    near: float = 1,\n    far: float = depth + 1,\n    format_: bool = True,\n) -> MatrixMN | FlattenedMatrix4x4:\n    if width is None:\n        width = config[\"frame_width\"]\n    if height is None:\n        height = config[\"frame_height\"]\n    projection_matrix = np.array(\n        [\n            [2 / width, 0, 0, 0],\n            [0, 2 / height, 0, 0],\n            [0, 0, -2 / (far - near), -(far + near) / (far - near)],\n            [0, 0, 0, 1],\n        ],\n    )\n    if format_:\n        return matrix_to_shader_input(projection_matrix)\n    else:\n        return projection_matrix"}, {"name": "override_animate", "code": "def override_animate(method: types.FunctionType) -> types.FunctionType:\n    r\"\"\"Decorator for overriding method animations.\n\n    This allows to specify a method (returning an :class:`~.Animation`)\n    which is called when the decorated method is used with the ``.animate`` syntax\n    for animating the application of a method.\n\n    .. seealso::\n\n        :attr:`OpenGLMobject.animate`\n\n    .. note::\n\n        Overridden methods cannot be combined with normal or other overridden\n        methods using method chaining with the ``.animate`` syntax.\n\n\n    Examples\n    --------\n\n    .. manim:: AnimationOverrideExample\n\n        class CircleWithContent(VGroup):\n            def __init__(self, content):\n                super().__init__()\n                self.circle = Circle()\n                self.content = content\n                self.add(self.circle, content)\n                content.move_to(self.circle.get_center())\n\n            def clear_content(self):\n                self.remove(self.content)\n                self.content = None\n\n            @override_animate(clear_content)\n            def _clear_content_animation(self, anim_args=None):\n                if anim_args is None:\n                    anim_args = {}\n                anim = Uncreate(self.content, **anim_args)\n                self.clear_content()\n                return anim\n\n        class AnimationOverrideExample(Scene):\n            def construct(self):\n                t = Text(\"hello!\")\n                my_mobject = CircleWithContent(t)\n                self.play(Create(my_mobject))\n                self.play(my_mobject.animate.clear_content())\n                self.wait()\n\n    \"\"\"\n\n    def decorator(animation_method):\n        method._override_animate = animation_method\n        return animation_method\n\n    return decorator"}, {"name": "override_animation", "code": "def override_animation(\n    animation_class: type[Animation],\n) -> Callable[[Callable], Callable]:\n    \"\"\"Decorator used to mark methods as overrides for specific :class:`~.Animation` types.\n\n    Should only be used to decorate methods of classes derived from :class:`~.Mobject`.\n    ``Animation`` overrides get inherited to subclasses of the ``Mobject`` who defined\n    them. They don't override subclasses of the ``Animation`` they override.\n\n    See Also\n    --------\n    :meth:`~.Mobject.add_animation_override`\n\n    Parameters\n    ----------\n    animation_class\n        The animation to be overridden.\n\n    Returns\n    -------\n    Callable[[Callable], Callable]\n        The actual decorator. This marks the method as overriding an animation.\n\n    Examples\n    --------\n\n    .. manim:: OverrideAnimationExample\n\n        class MySquare(Square):\n            @override_animation(FadeIn)\n            def _fade_in_override(self, **kwargs):\n                return Create(self, **kwargs)\n\n        class OverrideAnimationExample(Scene):\n            def construct(self):\n                self.play(FadeIn(MySquare()))\n\n    \"\"\"\n\n    def decorator(func):\n        func._override_animation = animation_class\n        return func\n\n    return decorator"}, {"name": "Paragraph", "code": "class Paragraph(VGroup):\n    r\"\"\"Display a paragraph of text.\n\n    For a given :class:`.Paragraph` ``par``, the attribute ``par.chars`` is a\n    :class:`.VGroup` containing all the lines. In this context, every line is\n    constructed as a :class:`.VGroup` of characters contained in the line.\n\n\n    Parameters\n    ----------\n    line_spacing\n        Represents the spacing between lines. Defaults to -1, which means auto.\n    alignment\n        Defines the alignment of paragraph. Defaults to None. Possible values are \"left\", \"right\" or \"center\".\n\n    Examples\n    --------\n    Normal usage::\n\n        paragraph = Paragraph(\n            \"this is a awesome\",\n            \"paragraph\",\n            \"With \\nNewlines\",\n            \"\\tWith Tabs\",\n            \"  With Spaces\",\n            \"With Alignments\",\n            \"center\",\n            \"left\",\n            \"right\",\n        )\n\n    Remove unwanted invisible characters::\n\n        self.play(Transform(remove_invisible_chars(paragraph.chars[0:2]),\n                            remove_invisible_chars(paragraph.chars[3][0:3]))\n\n    \"\"\"\n\n    def __init__(\n        self,\n        *text: Sequence[str],\n        line_spacing: float = -1,\n        alignment: str | None = None,\n        **kwargs,\n    ) -> None:\n        self.line_spacing = line_spacing\n        self.alignment = alignment\n        self.consider_spaces_as_chars = kwargs.get(\"disable_ligatures\", False)\n        super().__init__()\n\n        lines_str = \"\\n\".join(list(text))\n        self.lines_text = Text(lines_str, line_spacing=line_spacing, **kwargs)\n        lines_str_list = lines_str.split(\"\\n\")\n        self.chars = self._gen_chars(lines_str_list)\n\n        self.lines = [list(self.chars), [self.alignment] * len(self.chars)]\n        self.lines_initial_positions = [line.get_center() for line in self.lines[0]]\n        self.add(*self.lines[0])\n        self.move_to(np.array([0, 0, 0]))\n        if self.alignment:\n            self._set_all_lines_alignments(self.alignment)\n\n    def _gen_chars(self, lines_str_list: list) -> VGroup:\n        \"\"\"Function to convert a list of plain strings to a VGroup of VGroups of chars.\n\n        Parameters\n        ----------\n        lines_str_list\n            List of plain text strings.\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            The generated 2d-VGroup of chars.\n        \"\"\"\n        char_index_counter = 0\n        chars = self.get_group_class()()\n        for line_no in range(len(lines_str_list)):\n            line_str = lines_str_list[line_no]\n            # Count all the characters in line_str\n            # Spaces may or may not count as characters\n            if self.consider_spaces_as_chars:\n                char_count = len(line_str)\n            else:\n                char_count = 0\n                for char in line_str:\n                    if not char.isspace():\n                        char_count += 1\n\n            chars.add(self.get_group_class()())\n            chars[line_no].add(\n                *self.lines_text.chars[\n                    char_index_counter : char_index_counter + char_count\n                ]\n            )\n            char_index_counter += char_count\n            if self.consider_spaces_as_chars:\n                # If spaces count as characters, count the extra \\n character\n                # which separates Paragraph's lines to avoid issues\n                char_index_counter += 1\n        return chars\n\n    def _set_all_lines_alignments(self, alignment: str) -> Paragraph:\n        \"\"\"Function to set all line's alignment to a specific value.\n\n        Parameters\n        ----------\n        alignment\n            Defines the alignment of paragraph. Possible values are \"left\", \"right\", \"center\".\n        \"\"\"\n        for line_no in range(len(self.lines[0])):\n            self._change_alignment_for_a_line(alignment, line_no)\n        return self\n\n    def _set_line_alignment(self, alignment: str, line_no: int) -> Paragraph:\n        \"\"\"Function to set one line's alignment to a specific value.\n\n        Parameters\n        ----------\n        alignment\n            Defines the alignment of paragraph. Possible values are \"left\", \"right\", \"center\".\n        line_no\n            Defines the line number for which we want to set given alignment.\n        \"\"\"\n        self._change_alignment_for_a_line(alignment, line_no)\n        return self\n\n    def _set_all_lines_to_initial_positions(self) -> Paragraph:\n        \"\"\"Set all lines to their initial positions.\"\"\"\n        self.lines[1] = [None] * len(self.lines[0])\n        for line_no in range(len(self.lines[0])):\n            self[line_no].move_to(\n                self.get_center() + self.lines_initial_positions[line_no],\n            )\n        return self\n\n    def _set_line_to_initial_position(self, line_no: int) -> Paragraph:\n        \"\"\"Function to set one line to initial positions.\n\n        Parameters\n        ----------\n        line_no\n            Defines the line number for which we want to set given alignment.\n        \"\"\"\n        self.lines[1][line_no] = None\n        self[line_no].move_to(self.get_center() + self.lines_initial_positions[line_no])\n        return self\n\n    def _change_alignment_for_a_line(self, alignment: str, line_no: int) -> None:\n        \"\"\"Function to change one line's alignment to a specific value.\n\n        Parameters\n        ----------\n        alignment\n            Defines the alignment of paragraph. Possible values are \"left\", \"right\", \"center\".\n        line_no\n            Defines the line number for which we want to set given alignment.\n        \"\"\"\n        self.lines[1][line_no] = alignment\n        if self.lines[1][line_no] == \"center\":\n            self[line_no].move_to(\n                np.array([self.get_center()[0], self[line_no].get_center()[1], 0]),\n            )\n        elif self.lines[1][line_no] == \"right\":\n            self[line_no].move_to(\n                np.array(\n                    [\n                        self.get_right()[0] - self[line_no].width / 2,\n                        self[line_no].get_center()[1],\n                        0,\n                    ],\n                ),\n            )\n        elif self.lines[1][line_no] == \"left\":\n            self[line_no].move_to(\n                np.array(\n                    [\n                        self.get_left()[0] + self[line_no].width / 2,\n                        self[line_no].get_center()[1],\n                        0,\n                    ],\n                ),\n            )"}, {"name": "ParametricFunction", "code": "class ParametricFunction(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A parametric curve.\n\n    Parameters\n    ----------\n    function\n        The function to be plotted in the form of ``(lambda t: (x(t), y(t), z(t)))``\n    t_range\n        Determines the length that the function spans in the form of (t_min, t_max, step=0.01). By default ``[0, 1]``\n    scaling\n        Scaling class applied to the points of the function. Default of :class:`~.LinearBase`.\n    use_smoothing\n        Whether to interpolate between the points of the function after they have been created.\n        (Will have odd behaviour with a low number of points)\n    use_vectorized\n        Whether to pass in the generated t value array to the function as ``[t_0, t_1, ...]``.\n        Only use this if your function supports it. Output should be a numpy array\n        of shape ``[[x_0, x_1, ...], [y_0, y_1, ...], [z_0, z_1, ...]]`` but ``z`` can\n        also be 0 if the Axes is 2D\n    discontinuities\n        Values of t at which the function experiences discontinuity.\n    dt\n        The left and right tolerance for the discontinuities.\n\n\n    Examples\n    --------\n    .. manim:: PlotParametricFunction\n        :save_last_frame:\n\n        class PlotParametricFunction(Scene):\n            def func(self, t):\n                return (np.sin(2 * t), np.sin(3 * t), 0)\n\n            def construct(self):\n                func = ParametricFunction(self.func, t_range = (0, TAU), fill_opacity=0).set_color(RED)\n                self.add(func.scale(3))\n\n    .. manim:: ThreeDParametricSpring\n        :save_last_frame:\n\n        class ThreeDParametricSpring(ThreeDScene):\n            def construct(self):\n                curve1 = ParametricFunction(\n                    lambda u: (\n                        1.2 * np.cos(u),\n                        1.2 * np.sin(u),\n                        u * 0.05\n                    ), color=RED, t_range = (-3*TAU, 5*TAU, 0.01)\n                ).set_shade_in_3d(True)\n                axes = ThreeDAxes()\n                self.add(axes, curve1)\n                self.set_camera_orientation(phi=80 * DEGREES, theta=-60 * DEGREES)\n                self.wait()\n\n    .. attention::\n        If your function has discontinuities, you'll have to specify the location\n        of the discontinuities manually. See the following example for guidance.\n\n    .. manim:: DiscontinuousExample\n        :save_last_frame:\n\n        class DiscontinuousExample(Scene):\n            def construct(self):\n                ax1 = NumberPlane((-3, 3), (-4, 4))\n                ax2 = NumberPlane((-3, 3), (-4, 4))\n                VGroup(ax1, ax2).arrange()\n                discontinuous_function = lambda x: (x ** 2 - 2) / (x ** 2 - 4)\n                incorrect = ax1.plot(discontinuous_function, color=RED)\n                correct = ax2.plot(\n                    discontinuous_function,\n                    discontinuities=[-2, 2],  # discontinuous points\n                    dt=0.1,  # left and right tolerance of discontinuity\n                    color=GREEN,\n                )\n                self.add(ax1, ax2, incorrect, correct)\n    \"\"\"\n\n    def __init__(\n        self,\n        function: Callable[[float], Point3DLike],\n        t_range: tuple[float, float] | tuple[float, float, float] = (0, 1),\n        scaling: _ScaleBase = LinearBase(),\n        dt: float = 1e-8,\n        discontinuities: Iterable[float] | None = None,\n        use_smoothing: bool = True,\n        use_vectorized: bool = False,\n        **kwargs,\n    ):\n        def internal_parametric_function(t: float) -> Point3D:\n            \"\"\"Wrap ``function``'s output inside a NumPy array.\"\"\"\n            return np.asarray(function(t))\n\n        self.function = internal_parametric_function\n        if len(t_range) == 2:\n            t_range = (*t_range, 0.01)\n\n        self.scaling = scaling\n\n        self.dt = dt\n        self.discontinuities = discontinuities\n        self.use_smoothing = use_smoothing\n        self.use_vectorized = use_vectorized\n        self.t_min, self.t_max, self.t_step = t_range\n\n        super().__init__(**kwargs)\n\n    def get_function(self) -> Callable[[float], Point3D]:\n        return self.function\n\n    def get_point_from_function(self, t: float) -> Point3D:\n        return self.function(t)\n\n    def generate_points(self) -> Self:\n        if self.discontinuities is not None:\n            discontinuities = filter(\n                lambda t: self.t_min <= t <= self.t_max,\n                self.discontinuities,\n            )\n            discontinuities = np.array(list(discontinuities))\n            boundary_times = np.array(\n                [\n                    self.t_min,\n                    self.t_max,\n                    *(discontinuities - self.dt),\n                    *(discontinuities + self.dt),\n                ],\n            )\n            boundary_times.sort()\n        else:\n            boundary_times = [self.t_min, self.t_max]\n\n        for t1, t2 in zip(boundary_times[0::2], boundary_times[1::2]):\n            t_range = np.array(\n                [\n                    *self.scaling.function(np.arange(t1, t2, self.t_step)),\n                    self.scaling.function(t2),\n                ],\n            )\n\n            if self.use_vectorized:\n                x, y, z = self.function(t_range)\n                if not isinstance(z, np.ndarray):\n                    z = np.zeros_like(x)\n                points = np.stack([x, y, z], axis=1)\n            else:\n                points = np.array([self.function(t) for t in t_range])\n\n            self.start_new_path(points[0])\n            self.add_points_as_corners(points[1:])\n        if self.use_smoothing:\n            # TODO: not in line with upstream, approx_smooth does not exist\n            self.make_smooth()\n        return self\n\n    init_points = generate_points"}, {"name": "parse_cli_ctx", "code": "def parse_cli_ctx(parser: configparser.SectionProxy) -> dict[str, Any]:\n    formatter_settings: dict[str, str | int] = {\n        \"indent_increment\": int(parser[\"indent_increment\"]),\n        \"width\": int(parser[\"width\"]),\n        \"col1_max_width\": int(parser[\"col1_max_width\"]),\n        \"col2_min_width\": int(parser[\"col2_min_width\"]),\n        \"col_spacing\": int(parser[\"col_spacing\"]),\n        \"row_sep\": parser[\"row_sep\"] if parser[\"row_sep\"] else None,\n    }\n    theme_settings = {}\n    theme_keys = {\n        \"command_help\",\n        \"invoked_command\",\n        \"heading\",\n        \"constraint\",\n        \"section_help\",\n        \"col1\",\n        \"col2\",\n        \"epilog\",\n    }\n    for k, v in parser.items():\n        if k in theme_keys and v:\n            theme_settings.update({k: Style(v)})\n\n    formatter = {}\n    theme = parser[\"theme\"] if parser[\"theme\"] else None\n    if theme is None:\n        formatter = HelpFormatter.settings(\n            theme=HelpTheme(**theme_settings),\n            **formatter_settings,  # type: ignore[arg-type]\n        )\n    elif theme.lower() == \"dark\":\n        formatter = HelpFormatter.settings(\n            theme=HelpTheme.dark().with_(**theme_settings),\n            **formatter_settings,  # type: ignore[arg-type]\n        )\n    elif theme.lower() == \"light\":\n        formatter = HelpFormatter.settings(\n            theme=HelpTheme.light().with_(**theme_settings),\n            **formatter_settings,  # type: ignore[arg-type]\n        )\n\n    return Context.settings(\n        align_option_groups=parser[\"align_option_groups\"].lower() == \"true\",\n        align_sections=parser[\"align_sections\"].lower() == \"true\",\n        show_constraints=True,\n        formatter_settings=formatter,\n    )"}, {"name": "parse_module_attributes", "code": "def parse_module_attributes() -> tuple[AliasDocsDict, DataDict, TypeVarDict]:\n    \"\"\"Read all files, generate Abstract Syntax Trees from them, and\n    extract useful information about the type aliases defined in the\n    files: the category they belong to, their definition and their\n    description, separating them from the \"regular\" module attributes.\n\n    Returns\n    -------\n    ALIAS_DOCS_DICT : :class:`AliasDocsDict`\n        A dictionary containing the information from all the type\n        aliases in Manim. See :class:`AliasDocsDict` for more information.\n\n    DATA_DICT : :class:`DataDict`\n        A dictionary containing the names of all DOCUMENTED\n        module-level attributes which are not a :class:`TypeAlias`.\n\n    TYPEVAR_DICT : :class:`TypeVarDict`\n        A dictionary containing the definitions of :class:`TypeVar` objects,\n        organized by modules.\n    \"\"\"\n    global ALIAS_DOCS_DICT\n    global DATA_DICT\n    global TYPEVAR_DICT\n\n    if ALIAS_DOCS_DICT or DATA_DICT or TYPEVAR_DICT:\n        return ALIAS_DOCS_DICT, DATA_DICT, TYPEVAR_DICT\n\n    for module_path in MANIM_ROOT.rglob(\"*.py\"):\n        module_name_t1 = module_path.resolve().relative_to(MANIM_ROOT)\n        module_name_t2 = list(module_name_t1.parts)\n        module_name_t2[-1] = module_name_t2[-1].removesuffix(\".py\")\n        module_name = \".\".join(module_name_t2)\n\n        module_content = module_path.read_text(encoding=\"utf-8\")\n\n        # For storing TypeAliases\n        module_dict: ModuleLevelAliasDict = {}\n        category_dict: AliasCategoryDict | None = None\n        alias_info: AliasInfo | None = None\n\n        # For storing TypeVars\n        module_typevars: ModuleTypeVarDict = {}\n\n        # For storing regular module attributes\n        data_list: list[str] = []\n        data_name: str | None = None\n\n        for node in ast.iter_child_nodes(ast.parse(module_content)):\n            # If we encounter a string:\n            if (\n                type(node) is ast.Expr\n                and type(node.value) is ast.Constant\n                and type(node.value.value) is str\n            ):\n                string = node.value.value.strip()\n                # It can be the start of a category\n                section_str = \"[CATEGORY]\"\n                if string.startswith(section_str):\n                    category_name = string[len(section_str) :].strip()\n                    module_dict[category_name] = {}\n                    category_dict = module_dict[category_name]\n                    alias_info = None\n                # or a docstring of the alias defined before\n                elif alias_info:\n                    alias_info[\"doc\"] = string\n                # or a docstring of the module attribute defined before\n                elif data_name:\n                    data_list.append(data_name)\n                continue\n\n            # if it's defined under if TYPE_CHECKING\n            # go through the body of the if statement\n            if (\n                # NOTE: This logic does not (and cannot)\n                # check if the comparison is against a\n                # variable called TYPE_CHECKING\n                # It also says that you cannot do the following\n                # import typing as foo\n                # if foo.TYPE_CHECKING:\n                #   BAR: TypeAlias = ...\n                type(node) is ast.If\n                and (\n                    (\n                        # if TYPE_CHECKING\n                        type(node.test) is ast.Name and node.test.id == \"TYPE_CHECKING\"\n                    )\n                    or (\n                        # if typing.TYPE_CHECKING\n                        type(node.test) is ast.Attribute\n                        and type(node.test.value) is ast.Name\n                        and node.test.value.id == \"typing\"\n                        and node.test.attr == \"TYPE_CHECKING\"\n                    )\n                )\n            ):\n                inner_nodes: list[Any] = node.body\n            else:\n                inner_nodes = [node]\n\n            for node in inner_nodes:\n                # Check if this node is a TypeAlias (type <name> = <value>)\n                # or an AnnAssign annotated as TypeAlias (<target>: TypeAlias = <value>).\n                is_type_alias = (\n                    sys.version_info >= (3, 12) and type(node) is ast.TypeAlias\n                )\n                is_annotated_assignment_with_value = (\n                    type(node) is ast.AnnAssign\n                    and type(node.annotation) is ast.Name\n                    and node.annotation.id == \"TypeAlias\"\n                    and type(node.target) is ast.Name\n                    and node.value is not None\n                )\n                if is_type_alias or is_annotated_assignment_with_value:\n                    # TODO: ast.TypeAlias does not exist before Python 3.12, and that\n                    # could be the reason why MyPy does not recognize these as\n                    # attributes of node.\n                    alias_name = node.name.id if is_type_alias else node.target.id  # type: ignore[attr-defined]\n                    definition_node = node.value  # type: ignore[attr-defined]\n\n                    # If the definition is a Union, replace with vertical bar notation.\n                    # Instead of \"Union[Type1, Type2]\", we'll have \"Type1 | Type2\".\n                    if (\n                        type(definition_node) is ast.Subscript\n                        and type(definition_node.value) is ast.Name\n                        and definition_node.value.id == \"Union\"\n                    ):\n                        union_elements = definition_node.slice.elts  # type: ignore[attr-defined]\n                        definition = \" | \".join(\n                            ast.unparse(elem) for elem in union_elements\n                        )\n                    else:\n                        definition = ast.unparse(definition_node)\n\n                    definition = definition.replace(\"npt.\", \"\")\n                    if category_dict is None:\n                        module_dict[\"\"] = {}\n                        category_dict = module_dict[\"\"]\n                    category_dict[alias_name] = {\"definition\": definition}\n                    alias_info = category_dict[alias_name]\n                    continue\n\n                # Check if it is a typing.TypeVar (<target> = TypeVar(...)).\n                elif (\n                    type(node) is ast.Assign\n                    and type(node.targets[0]) is ast.Name\n                    and type(node.value) is ast.Call\n                    and type(node.value.func) is ast.Name\n                    and node.value.func.id.endswith(\"TypeVar\")\n                ):\n                    module_typevars[node.targets[0].id] = ast.unparse(\n                        node.value\n                    ).replace(\"_\", r\"\\_\")\n                    continue\n\n                # If here, the node is not a TypeAlias definition\n                alias_info = None\n\n                # It could still be a module attribute definition.\n                # Does the assignment have a target of type Name? Then\n                # it could be considered a definition of a module attribute.\n                if type(node) is ast.AnnAssign:\n                    target: Name | Attribute | Subscript | ast.expr | None = node.target\n                elif type(node) is ast.Assign and len(node.targets) == 1:\n                    target = node.targets[0]\n                else:\n                    target = None\n\n                if type(target) is ast.Name and not (\n                    type(node) is ast.Assign and target.id not in module_typevars\n                ):\n                    data_name = target.id\n                else:\n                    data_name = None\n\n        if len(module_dict) > 0:\n            ALIAS_DOCS_DICT[module_name] = module_dict\n        if len(data_list) > 0:\n            DATA_DICT[module_name] = data_list\n        if module_typevars:\n            TYPEVAR_DICT[module_name] = module_typevars\n\n    return ALIAS_DOCS_DICT, DATA_DICT, TYPEVAR_DICT"}, {"name": "parse_theme", "code": "def parse_theme(parser: configparser.SectionProxy) -> Theme | None:\n    \"\"\"Configure the rich style of logger and console output.\n\n    Parameters\n    ----------\n    parser\n        A parser containing any .cfg files in use.\n\n    Returns\n    -------\n    :class:`rich.Theme`\n        The rich theme to be used by the manim logger.\n\n    See Also\n    --------\n    :func:`make_logger`.\n\n    \"\"\"\n    theme: dict[str, Any] = {key.replace(\"_\", \".\"): parser[key] for key in parser}\n\n    theme[\"log.width\"] = None if theme[\"log.width\"] == \"-1\" else int(theme[\"log.width\"])\n    theme[\"log.height\"] = (\n        None if theme[\"log.height\"] == \"-1\" else int(theme[\"log.height\"])\n    )\n    theme[\"log.timestamps\"] = False\n    try:\n        custom_theme = Theme(\n            {\n                k: v\n                for k, v in theme.items()\n                if k not in [\"log.width\", \"log.height\", \"log.timestamps\"]\n            },\n        )\n    except (color.ColorParseError, errors.StyleSyntaxError):\n        printf(WRONG_COLOR_CONFIG_MSG)\n        custom_theme = None\n\n    return custom_theme"}, {"name": "partial_bezier_points", "code": "def partial_bezier_points(points: BezierPointsLike, a: float, b: float) -> BezierPoints:\n    r\"\"\"Given an array of ``points`` which define a B\u00e9zier curve, and two numbers :math:`a, b`\n    such that :math:`0 \\le a < b \\le 1`, return an array of the same size, which describes the\n    portion of the original B\u00e9zier curve on the interval :math:`[a, b]`.\n\n    :func:`partial_bezier_points` is conceptually equivalent to calling :func:`split_bezier`\n    twice and discarding unused B\u00e9zier curves, but this is more efficient and doesn't waste\n    computations.\n\n    .. seealso::\n        See :func:`split_bezier` for an explanation on how to split B\u00e9zier curves.\n\n    .. note::\n        To find the portion of a B\u00e9zier curve with :math:`t` between :math:`a` and :math:`b`:\n\n        1.  Split the curve at :math:`t = a` and extract its 2nd subcurve.\n        2.  We cannot evaluate the new subcurve at :math:`t = b` because its range of values for :math:`t` is different.\n            To find the correct value, we need to transform the interval :math:`[a, 1]` into :math:`[0, 1]`\n            by first subtracting :math:`a` to get :math:`[0, 1-a]` and then dividing by :math:`1-a`. Thus, our new\n            value must be :math:`t = \\frac{b - a}{1 - a}`. Define :math:`u = \\frac{b - a}{1 - a}`.\n        3.  Split the subcurve at :math:`t = u` and extract its 1st subcurve.\n\n        The final portion is a linear combination of points, and thus the process can be\n        summarized as a linear transformation by some matrix in terms of :math:`a` and :math:`b`.\n        This matrix is given explicitly for B\u00e9zier curves up to degree 3, which are often used in Manim.\n        For higher degrees, the algorithm described previously is used.\n\n        For the case of a quadratic B\u00e9zier curve:\n\n        * Step 1:\n\n        .. math::\n            H'_1\n            =\n            \\begin{pmatrix}\n                (1-a)^2 & 2(1-a)a & a^2 \\\\\n                0 & (1-a) & a \\\\\n                0 & 0 & 1\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                p_0 \\\\\n                p_1 \\\\\n                p_2\n            \\end{pmatrix}\n\n        * Step 2:\n\n        .. math::\n            H''_0\n            &=\n            \\begin{pmatrix}\n                1 & 0 & 0 \\\\\n                (1-u) & u & 0\\\\\n                (1-u)^2 & 2(1-u)u & u^2\n            \\end{pmatrix}\n            H'_1\n            \\\\\n            &\n            \\\\\n            &=\n            \\begin{pmatrix}\n                1 & 0 & 0 \\\\\n                (1-u) & u & 0\\\\\n                (1-u)^2 & 2(1-u)u & u^2\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                (1-a)^2 & 2(1-a)a & a^2 \\\\\n                0 & (1-a) & a \\\\\n                0 & 0 & 1\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                p_0 \\\\\n                p_1 \\\\\n                p_2\n            \\end{pmatrix}\n            \\\\\n            &\n            \\\\\n            &=\n            \\begin{pmatrix}\n                (1-a)^2 & 2(1-a)a & a^2 \\\\\n                (1-a)(1-b) & a(1-b) + (1-a)b & ab \\\\\n                (1-b)^2 & 2(1-b)b & b^2\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                p_0 \\\\\n                p_1 \\\\\n                p_2\n            \\end{pmatrix}\n\n        from where one can define a :math:`(3, 3)` matrix :math:`P_2` which, when applied over\n        the array of ``points``, will return the desired partial quadratic B\u00e9zier curve:\n\n        .. math::\n            P_2\n            =\n            \\begin{pmatrix}\n                (1-a)^2 & 2(1-a)a & a^2 \\\\\n                (1-a)(1-b) & a(1-b) + (1-a)b & ab \\\\\n                (1-b)^2 & 2(1-b)b & b^2\n            \\end{pmatrix}\n\n        Similarly, for the cubic B\u00e9zier curve case, one can define the following\n        :math:`(4, 4)` matrix :math:`P_3`:\n\n        .. math::\n            P_3\n            =\n            \\begin{pmatrix}\n                (1-a)^3 & 3(1-a)^2a & 3(1-a)a^2 & a^3 \\\\\n                (1-a)^2(1-b) & 2(1-a)a(1-b) + (1-a)^2b & a^2(1-b) + 2(1-a)ab & a^2b \\\\\n                (1-a)(1-b)^2 & a(1-b)^2 + 2(1-a)(1-b)b & 2a(1-b)b + (1-a)b^2 & ab^2 \\\\\n                (1-b)^3 & 3(1-b)^2b & 3(1-b)b^2 & b^3\n            \\end{pmatrix}\n\n    Parameters\n    ----------\n    points\n        set of points defining the bezier curve.\n    a\n        lower bound of the desired partial bezier curve.\n    b\n        upper bound of the desired partial bezier curve.\n\n    Returns\n    -------\n    :class:`~.BezierPoints`\n        An array containing the control points defining the partial B\u00e9zier curve.\n    \"\"\"\n    # Border cases\n    if a == 1:\n        arr = np.array(points)\n        arr[:] = arr[-1]\n        return arr\n    if b == 0:\n        arr = np.array(points)\n        arr[:] = arr[0]\n        return arr\n\n    points = np.asarray(points)\n    degree = points.shape[0] - 1\n\n    if degree == 3:\n        ma, mb = 1 - a, 1 - b\n        a2, b2, ma2, mb2 = a * a, b * b, ma * ma, mb * mb\n        a3, b3, ma3, mb3 = a2 * a, b2 * b, ma2 * ma, mb2 * mb\n\n        portion_matrix = np.array(\n            [\n                [ma3, 3 * ma2 * a, 3 * ma * a2, a3],\n                [ma2 * mb, 2 * ma * a * mb + ma2 * b, a2 * mb + 2 * ma * a * b, a2 * b],\n                [ma * mb2, a * mb2 + 2 * ma * mb * b, 2 * a * mb * b + ma * b2, a * b2],\n                [mb3, 3 * mb2 * b, 3 * mb * b2, b3],\n            ]\n        )\n        return portion_matrix @ points\n\n    if degree == 2:\n        ma, mb = 1 - a, 1 - b\n\n        portion_matrix = np.array(\n            [\n                [ma * ma, 2 * a * ma, a * a],\n                [ma * mb, a * mb + ma * b, a * b],\n                [mb * mb, 2 * b * mb, b * b],\n            ]\n        )\n        return portion_matrix @ points\n\n    if degree == 1:\n        direction = points[1] - points[0]\n        return np.array(\n            [\n                points[0] + a * direction,\n                points[0] + b * direction,\n            ]\n        )\n\n    if degree == 0:\n        return points\n\n    # Fallback case for nth degree B\u00e9ziers\n    # It is convenient that np.array copies points\n    arr = np.array(points, dtype=float)\n    N = arr.shape[0]\n\n    # Current state for an example B\u00e9zier curve C0 = [P0, P1, P2, P3]:\n    # arr = [P0, P1, P2, P3]\n    if a != 0:\n        for i in range(1, N):\n            # 1st iter: arr = [L0(a), L1(a), L2(a), P3]\n            # 2nd iter: arr = [Q0(a), Q1(a), L2(a), P3]\n            # 3rd iter: arr = [C0(a), Q1(a), L2(a), P3]\n            arr[: N - i] += a * (arr[1 : N - i + 1] - arr[: N - i])\n\n    # For faster calculations we shall define mu = 1 - u = (1 - b) / (1 - a).\n    # This is because:\n    # L0'(u) = P0' + u(P1' - P0')\n    #        = (1-u)P0' + uP1'\n    #        = muP0' + (1-mu)P1'\n    #        = P1' + mu(P0' - P1)\n    # In this way, one can do something similar to the first loop.\n    #\n    # Current state:\n    # arr = [C0(a), Q1(a), L2(a), P3]\n    #     = [P0', P1', P2', P3']\n    if b != 1:\n        mu = (1 - b) / (1 - a)\n        for i in range(1, N):\n            # 1st iter: arr = [P0', L0'(u), L1'(u), L2'(u)]\n            # 2nd iter: arr = [P0', L0'(u), Q0'(u), Q1'(u)]\n            # 3rd iter: arr = [P0', L0'(u), Q0'(u), C0'(u)]\n            arr[i:] += mu * (arr[i - 1 : -1] - arr[i:])\n\n    return arr"}, {"name": "path_along_arc", "code": "def path_along_arc(arc_angle: float, axis: Vector3D = OUT) -> PathFuncType:\n    \"\"\"This function transforms each point by moving it along a circular arc.\n\n    Parameters\n    ----------\n    arc_angle\n        The angle each point traverses around a circular arc.\n    axis\n        The axis of rotation.\n\n    Examples\n    --------\n\n    .. manim :: PathAlongArcExample\n\n        class PathAlongArcExample(Scene):\n            def construct(self):\n                colors = [RED, GREEN, BLUE]\n\n                starting_points = VGroup(\n                    *[\n                        Dot(LEFT + pos, color=color)\n                        for pos, color in zip([UP, DOWN, LEFT], colors)\n                    ]\n                )\n\n                finish_points = VGroup(\n                    *[\n                        Dot(RIGHT + pos, color=color)\n                        for pos, color in zip([ORIGIN, UP, DOWN], colors)\n                    ]\n                )\n\n                self.add(starting_points)\n                self.add(finish_points)\n                for dot in starting_points:\n                    self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n                self.wait()\n                self.play(\n                    Transform(\n                        starting_points,\n                        finish_points,\n                        path_func=utils.paths.path_along_arc(TAU * 2 / 3),\n                        run_time=3,\n                    )\n                )\n                self.wait()\n\n    \"\"\"\n    if abs(arc_angle) < STRAIGHT_PATH_THRESHOLD:\n        return straight_path()\n    if np.linalg.norm(axis) == 0:\n        axis = OUT\n    unit_axis = axis / np.linalg.norm(axis)\n\n    def path(\n        start_points: Point3D_Array, end_points: Point3D_Array, alpha: float\n    ) -> Point3D_Array:\n        vects = end_points - start_points\n        centers = start_points + 0.5 * vects\n        if arc_angle != np.pi:\n            centers += np.cross(unit_axis, vects / 2.0) / np.tan(arc_angle / 2)\n        rot_matrix = rotation_matrix(alpha * arc_angle, unit_axis)\n        return centers + np.dot(start_points - centers, rot_matrix.T)\n\n    return path"}, {"name": "path_along_circles", "code": "def path_along_circles(\n    arc_angle: float, circles_centers: np.ndarray, axis: Vector3D = OUT\n) -> PathFuncType:\n    \"\"\"This function transforms each point by moving it roughly along a circle, each with its own specified center.\n\n    The path may be seen as each point smoothly changing its orbit from its starting position to its destination.\n\n    Parameters\n    ----------\n    arc_angle\n        The angle each point traverses around the quasicircle.\n    circles_centers\n        The centers of each point's quasicircle to rotate around.\n    axis\n        The axis of rotation.\n\n    Examples\n    --------\n\n    .. manim :: PathAlongCirclesExample\n\n        class PathAlongCirclesExample(Scene):\n            def construct(self):\n                colors = [RED, GREEN, BLUE]\n\n                starting_points = VGroup(\n                    *[\n                        Dot(LEFT + pos, color=color)\n                        for pos, color in zip([UP, DOWN, LEFT], colors)\n                    ]\n                )\n\n                finish_points = VGroup(\n                    *[\n                        Dot(RIGHT + pos, color=color)\n                        for pos, color in zip([ORIGIN, UP, DOWN], colors)\n                    ]\n                )\n\n                self.add(starting_points)\n                self.add(finish_points)\n                for dot in starting_points:\n                    self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n                circle_center = Dot(3 * LEFT)\n                self.add(circle_center)\n\n                self.wait()\n                self.play(\n                    Transform(\n                        starting_points,\n                        finish_points,\n                        path_func=utils.paths.path_along_circles(\n                            2 * PI, circle_center.get_center()\n                        ),\n                        run_time=3,\n                    )\n                )\n                self.wait()\n\n    \"\"\"\n    if np.linalg.norm(axis) == 0:\n        axis = OUT\n    unit_axis = axis / np.linalg.norm(axis)\n\n    def path(\n        start_points: Point3D_Array, end_points: Point3D_Array, alpha: float\n    ) -> Point3D_Array:\n        detransformed_end_points = circles_centers + np.dot(\n            end_points - circles_centers, rotation_matrix(-arc_angle, unit_axis).T\n        )\n        rot_matrix = rotation_matrix(alpha * arc_angle, unit_axis)\n        return circles_centers + np.dot(\n            interpolate(start_points, detransformed_end_points, alpha)\n            - circles_centers,\n            rot_matrix.T,\n        )\n\n    return path"}, {"name": "Percent", "code": "class Percent:\n    def __init__(self, axis: Vector3D) -> None:\n        if np.array_equal(axis, constants.X_AXIS):\n            self.length = config.frame_width\n        if np.array_equal(axis, constants.Y_AXIS):\n            self.length = config.frame_height\n        if np.array_equal(axis, constants.Z_AXIS):\n            raise NotImplementedError(\"length of Z axis is undefined\")\n\n    def __mul__(self, val: float) -> float:\n        return val / 100 * self.length\n\n    def __rmul__(self, val: float) -> float:\n        return val / 100 * self.length"}, {"name": "perpendicular_bisector", "code": "def perpendicular_bisector(\n    line: Sequence[np.ndarray],\n    norm_vector: Vector3D = OUT,\n) -> Sequence[np.ndarray]:\n    \"\"\"Returns a list of two points that correspond\n    to the ends of the perpendicular bisector of the\n    two points given.\n\n    Parameters\n    ----------\n    line\n        a list of two numpy array points (corresponding\n        to the ends of a line).\n    norm_vector\n        the vector perpendicular to both the line given\n        and the perpendicular bisector.\n\n    Returns\n    -------\n    list\n        A list of two numpy array points that correspond\n        to the ends of the perpendicular bisector\n    \"\"\"\n    p1 = line[0]\n    p2 = line[1]\n    direction = cross(p1 - p2, norm_vector)\n    m = midpoint(p1, p2)\n    return [m + direction, m - direction]"}, {"name": "perspective_projection_matrix", "code": "def perspective_projection_matrix(\n    width: float | None = None,\n    height: float | None = None,\n    near: float = 2,\n    far: float = 50,\n    format_: bool = True,\n) -> MatrixMN | FlattenedMatrix4x4:\n    if width is None:\n        width = config[\"frame_width\"] / 6\n    if height is None:\n        height = config[\"frame_height\"] / 6\n    projection_matrix = np.array(\n        [\n            [2 * near / width, 0, 0, 0],\n            [0, 2 * near / height, 0, 0],\n            [0, 0, (far + near) / (near - far), (2 * far * near) / (near - far)],\n            [0, 0, -1, 0],\n        ],\n    )\n    if format_:\n        return matrix_to_shader_input(projection_matrix)\n    else:\n        return projection_matrix"}, {"name": "PGroup", "code": "class PGroup(PMobject):\n    \"\"\"A group for several point mobjects.\n\n    Examples\n    --------\n\n    .. manim:: PgroupExample\n        :save_last_frame:\n\n        class PgroupExample(Scene):\n            def construct(self):\n\n                p1 = PointCloudDot(radius=1, density=20, color=BLUE)\n                p1.move_to(4.5 * LEFT)\n                p2 = PointCloudDot()\n                p3 = PointCloudDot(radius=1.5, stroke_width=2.5, color=PINK)\n                p3.move_to(4.5 * RIGHT)\n                pList = PGroup(p1, p2, p3)\n\n                self.add(pList)\n\n    \"\"\"\n\n    def __init__(self, *pmobs: Any, **kwargs: Any) -> None:\n        if not all(isinstance(m, (PMobject, OpenGLPMobject)) for m in pmobs):\n            raise ValueError(\n                \"All submobjects must be of type PMobject or OpenGLPMObject\"\n                \" if using the opengl renderer\",\n            )\n        super().__init__(**kwargs)\n        self.add(*pmobs)\n\n    def fade_to(\n        self, color: ParsableManimColor, alpha: float, family: bool = True\n    ) -> Self:\n        if family:\n            for mob in self.submobjects:\n                mob.fade_to(color, alpha, family)\n        return self"}, {"name": "PhaseFlow", "code": "class PhaseFlow(Animation):\n    def __init__(\n        self,\n        function: Callable[[np.ndarray], np.ndarray],\n        mobject: Mobject,\n        virtual_time: float = 1,\n        suspend_mobject_updating: bool = False,\n        rate_func: Callable[[float], float] = linear,\n        **kwargs,\n    ) -> None:\n        self.virtual_time = virtual_time\n        self.function = function\n        super().__init__(\n            mobject,\n            suspend_mobject_updating=suspend_mobject_updating,\n            rate_func=rate_func,\n            **kwargs,\n        )\n\n    def interpolate_mobject(self, alpha: float) -> None:\n        if hasattr(self, \"last_alpha\"):\n            dt = self.virtual_time * (\n                self.rate_func(alpha) - self.rate_func(self.last_alpha)\n            )\n            self.mobject.apply_function(lambda p: p + dt * self.function(p))\n        self.last_alpha = alpha"}, {"name": "plugins", "code": "def plugins(list_available: bool) -> None:\n    \"\"\"Print a list of all available plugins when calling ``manim plugins -l``\n    or ``manim plugins --list``.\n\n    Parameters\n    ----------\n    list_available\n        If the ``-l`` or ``-list`` option is passed to ``manim plugins``, this\n        parameter will be set to ``True``, which will print a list of all\n        available plugins.\n    \"\"\"\n    if list_available:\n        list_plugins()"}, {"name": "PMobject", "code": "class PMobject(Mobject, metaclass=ConvertToOpenGL):\n    \"\"\"A disc made of a cloud of Dots\n\n    Examples\n    --------\n\n    .. manim:: PMobjectExample\n        :save_last_frame:\n\n        class PMobjectExample(Scene):\n            def construct(self):\n\n                pG = PGroup()  # This is just a collection of PMobject's\n\n                # As the scale factor increases, the number of points\n                # removed increases.\n                for sf in range(1, 9 + 1):\n                    p = PointCloudDot(density=20, radius=1).thin_out(sf)\n                    # PointCloudDot is a type of PMobject\n                    # and can therefore be added to a PGroup\n                    pG.add(p)\n\n                # This organizes all the shapes in a grid.\n                pG.arrange_in_grid()\n\n                self.add(pG)\n\n    \"\"\"\n\n    def __init__(self, stroke_width: int = DEFAULT_STROKE_WIDTH, **kwargs: Any) -> None:\n        self.stroke_width = stroke_width\n        super().__init__(**kwargs)\n\n    def reset_points(self) -> Self:\n        self.rgbas = np.zeros((0, 4))\n        self.points = np.zeros((0, 3))\n        return self\n\n    def get_array_attrs(self) -> list[str]:\n        return super().get_array_attrs() + [\"rgbas\"]\n\n    def add_points(\n        self,\n        points: npt.NDArray,\n        rgbas: npt.NDArray | None = None,\n        color: ParsableManimColor | None = None,\n        alpha: float = 1,\n    ) -> Self:\n        \"\"\"Add points.\n\n        Points must be a Nx3 numpy array.\n        Rgbas must be a Nx4 numpy array if it is not None.\n        \"\"\"\n        if not isinstance(points, np.ndarray):\n            points = np.array(points)\n        num_new_points = len(points)\n        self.points = np.append(self.points, points, axis=0)\n        if rgbas is None:\n            color = ManimColor(color) if color else self.color\n            rgbas = np.repeat([color_to_rgba(color, alpha)], num_new_points, axis=0)\n        elif len(rgbas) != len(points):\n            raise ValueError(\"points and rgbas must have same length\")\n        self.rgbas = np.append(self.rgbas, rgbas, axis=0)\n        return self\n\n    def set_color(\n        self, color: ParsableManimColor = YELLOW, family: bool = True\n    ) -> Self:\n        rgba = color_to_rgba(color)\n        mobs = self.family_members_with_points() if family else [self]\n        for mob in mobs:\n            mob.rgbas[:, :] = rgba\n        self.color = ManimColor.parse(color)\n        return self\n\n    def get_stroke_width(self) -> int:\n        return self.stroke_width\n\n    def set_stroke_width(self, width: int, family: bool = True) -> Self:\n        mobs = self.family_members_with_points() if family else [self]\n        for mob in mobs:\n            mob.stroke_width = width\n        return self\n\n    def set_color_by_gradient(self, *colors: ParsableManimColor) -> Self:\n        self.rgbas = np.array(\n            list(map(color_to_rgba, color_gradient(*colors, len(self.points)))),\n        )\n        return self\n\n    def set_colors_by_radial_gradient(\n        self,\n        center: Point3DLike | None = None,\n        radius: float = 1,\n        inner_color: ParsableManimColor = WHITE,\n        outer_color: ParsableManimColor = BLACK,\n    ) -> Self:\n        start_rgba, end_rgba = list(map(color_to_rgba, [inner_color, outer_color]))\n        if center is None:\n            center = self.get_center()\n        for mob in self.family_members_with_points():\n            distances = np.abs(self.points - center)\n            alphas = np.linalg.norm(distances, axis=1) / radius\n\n            mob.rgbas = np.array(\n                np.array(\n                    [interpolate(start_rgba, end_rgba, alpha) for alpha in alphas],\n                ),\n            )\n        return self\n\n    def match_colors(self, mobject: Mobject) -> Self:\n        Mobject.align_data(self, mobject)\n        self.rgbas = np.array(mobject.rgbas)\n        return self\n\n    def filter_out(self, condition: npt.NDArray) -> Self:\n        for mob in self.family_members_with_points():\n            to_eliminate = ~np.apply_along_axis(condition, 1, mob.points)\n            mob.points = mob.points[to_eliminate]\n            mob.rgbas = mob.rgbas[to_eliminate]\n        return self\n\n    def thin_out(self, factor: int = 5) -> Self:\n        \"\"\"Removes all but every nth point for n = factor\"\"\"\n        for mob in self.family_members_with_points():\n            num_points = self.get_num_points()\n            mob.apply_over_attr_arrays(\n                lambda arr, n=num_points: arr[np.arange(0, n, factor)],\n            )\n        return self\n\n    def sort_points(\n        self, function: Callable[[npt.NDArray[ManimFloat]], float] = lambda p: p[0]\n    ) -> Self:\n        \"\"\"Function is any map from R^3 to R\"\"\"\n        for mob in self.family_members_with_points():\n            indices = np.argsort(np.apply_along_axis(function, 1, mob.points))\n            mob.apply_over_attr_arrays(lambda arr, idx=indices: arr[idx])\n        return self\n\n    def fade_to(\n        self, color: ParsableManimColor, alpha: float, family: bool = True\n    ) -> Self:\n        self.rgbas = interpolate(self.rgbas, color_to_rgba(color), alpha)\n        for mob in self.submobjects:\n            mob.fade_to(color, alpha, family)\n        return self\n\n    def get_all_rgbas(self) -> npt.NDArray:\n        return self.get_merged_array(\"rgbas\")\n\n    def ingest_submobjects(self) -> Self:\n        attrs = self.get_array_attrs()\n        arrays = list(map(self.get_merged_array, attrs))\n        for attr, array in zip(attrs, arrays):\n            setattr(self, attr, array)\n        self.submobjects = []\n        return self\n\n    def get_color(self) -> ManimColor:\n        return rgba_to_color(self.rgbas[0, :])\n\n    def point_from_proportion(self, alpha: float) -> Any:\n        index = alpha * (self.get_num_points() - 1)\n        return self.points[np.floor(index)]\n\n    @staticmethod\n    def get_mobject_type_class() -> type[PMobject]:\n        return PMobject\n\n    # Alignment\n    def align_points_with_larger(self, larger_mobject: Mobject) -> None:\n        assert isinstance(larger_mobject, PMobject)\n        self.apply_over_attr_arrays(\n            lambda a: stretch_array_to_length(a, larger_mobject.get_num_points()),\n        )\n\n    def get_point_mobject(self, center: Point3DLike | None = None) -> Point:\n        if center is None:\n            center = self.get_center()\n        return Point(center)\n\n    def interpolate_color(\n        self, mobject1: Mobject, mobject2: Mobject, alpha: float\n    ) -> Self:\n        self.rgbas = interpolate(mobject1.rgbas, mobject2.rgbas, alpha)\n        self.set_stroke_width(\n            interpolate(\n                mobject1.get_stroke_width(),\n                mobject2.get_stroke_width(),\n                alpha,\n            ),\n        )\n        return self\n\n    def pointwise_become_partial(self, mobject: Mobject, a: float, b: float) -> None:\n        lower_index, upper_index = (int(x * mobject.get_num_points()) for x in (a, b))\n        for attr in self.get_array_attrs():\n            full_array = getattr(mobject, attr)\n            partial_array = full_array[lower_index:upper_index]\n            setattr(self, attr, partial_array)"}, {"name": "Point", "code": "class Point(PMobject):\n    \"\"\"A mobject representing a point.\n\n    Examples\n    --------\n\n    .. manim:: ExamplePoint\n        :save_last_frame:\n\n        class ExamplePoint(Scene):\n            def construct(self):\n                colorList = [RED, GREEN, BLUE, YELLOW]\n                for i in range(200):\n                    point = Point(location=[0.63 * np.random.randint(-4, 4), 0.37 * np.random.randint(-4, 4), 0], color=np.random.choice(colorList))\n                    self.add(point)\n                for i in range(200):\n                    point = Point(location=[0.37 * np.random.randint(-4, 4), 0.63 * np.random.randint(-4, 4), 0], color=np.random.choice(colorList))\n                    self.add(point)\n                self.add(point)\n    \"\"\"\n\n    def __init__(\n        self, location: Vector3D = ORIGIN, color: ManimColor = BLACK, **kwargs: Any\n    ) -> None:\n        self.location = location\n        super().__init__(color=color, **kwargs)\n\n    def init_points(self) -> None:\n        self.reset_points()\n        self.generate_points()\n        self.set_points([self.location])\n\n    def generate_points(self) -> None:\n        self.add_points(np.array([self.location]))"}, {"name": "point_lies_on_bezier", "code": "def point_lies_on_bezier(\n    point: Point3DLike,\n    control_points: BezierPointsLike,\n    round_to: float = 1e-6,\n) -> bool:\n    \"\"\"Checks if a given point lies on the bezier curves with the given control points.\n\n    This is done by solving the bezier polynomial with the point as the constant term; if\n    any real roots exist, the point lies on the bezier curve.\n\n    Parameters\n    ----------\n    point\n        The Cartesian Coordinates of the point to check.\n    control_points\n        The Cartesian Coordinates of the ordered control\n        points of the bezier curve on which the point may\n        or may not lie.\n    round_to\n        A float whose number of decimal places all values\n        such as coordinates of points will be rounded.\n\n    Returns\n    -------\n    bool\n        Whether the point lies on the curve.\n    \"\"\"\n    roots = proportions_along_bezier_curve_for_point(point, control_points, round_to)\n\n    return len(roots) > 0"}, {"name": "PointCloudDot", "code": "class PointCloudDot(Mobject1D):\n    \"\"\"A disc made of a cloud of dots.\n\n    Examples\n    --------\n    .. manim:: PointCloudDotExample\n        :save_last_frame:\n\n        class PointCloudDotExample(Scene):\n            def construct(self):\n                cloud_1 = PointCloudDot(color=RED)\n                cloud_2 = PointCloudDot(stroke_width=4, radius=1)\n                cloud_3 = PointCloudDot(density=15)\n\n                group = Group(cloud_1, cloud_2, cloud_3).arrange()\n                self.add(group)\n\n    .. manim:: PointCloudDotExample2\n\n        class PointCloudDotExample2(Scene):\n            def construct(self):\n                plane = ComplexPlane()\n                cloud = PointCloudDot(color=RED)\n                self.add(\n                    plane, cloud\n                )\n                self.wait()\n                self.play(\n                    cloud.animate.apply_complex_function(lambda z: np.exp(z))\n                )\n    \"\"\"\n\n    def __init__(\n        self,\n        center: Vector3D = ORIGIN,\n        radius: float = 2.0,\n        stroke_width: int = 2,\n        density: int = DEFAULT_POINT_DENSITY_1D,\n        color: ManimColor = YELLOW,\n        **kwargs: Any,\n    ) -> None:\n        self.radius = radius\n        self.epsilon = 1.0 / density\n        super().__init__(\n            stroke_width=stroke_width, density=density, color=color, **kwargs\n        )\n        self.shift(center)\n\n    def init_points(self) -> None:\n        self.reset_points()\n        self.generate_points()\n\n    def generate_points(self) -> None:\n        self.add_points(\n            np.array(\n                [\n                    r * (np.cos(theta) * RIGHT + np.sin(theta) * UP)\n                    for r in np.arange(self.epsilon, self.radius, self.epsilon)\n                    # Num is equal to int(stop - start)/ (step + 1) reformulated.\n                    for theta in np.linspace(\n                        0,\n                        2 * np.pi,\n                        num=int(2 * np.pi * (r + self.epsilon) / self.epsilon),\n                    )\n                ]\n            ),\n        )"}, {"name": "PolarPlane", "code": "class PolarPlane(Axes):\n    r\"\"\"Creates a polar plane with background lines.\n\n    Parameters\n    ----------\n    azimuth_step\n        The number of divisions in the azimuth (also known as the `angular coordinate` or `polar angle`). If ``None`` is specified then it will use the default\n        specified by ``azimuth_units``:\n\n        - ``\"PI radians\"`` or ``\"TAU radians\"``: 20\n        - ``\"degrees\"``: 36\n        - ``\"gradians\"``: 40\n        - ``None``: 1\n\n        A non-integer value will result in a partial division at the end of the circle.\n\n    size\n        The diameter of the plane.\n\n    radius_step\n        The distance between faded radius lines.\n\n    radius_max\n        The maximum value of the radius.\n\n    azimuth_units\n        Specifies a default labelling system for the azimuth. Choices are:\n\n        - ``\"PI radians\"``: Fractional labels in the interval :math:`\\left[0, 2\\pi\\right]` with :math:`\\pi` as a constant.\n        - ``\"TAU radians\"``: Fractional labels in the interval :math:`\\left[0, \\tau\\right]` (where :math:`\\tau = 2\\pi`) with :math:`\\tau` as a constant.\n        - ``\"degrees\"``: Decimal labels in the interval :math:`\\left[0, 360\\right]` with a degree (:math:`^{\\circ}`) symbol.\n        - ``\"gradians\"``: Decimal labels in the interval :math:`\\left[0, 400\\right]` with a superscript \"g\" (:math:`^{g}`).\n        - ``None``: Decimal labels in the interval :math:`\\left[0, 1\\right]`.\n\n    azimuth_compact_fraction\n        If the ``azimuth_units`` choice has fractional labels, choose whether to\n        combine the constant in a compact form :math:`\\tfrac{xu}{y}` as opposed to\n        :math:`\\tfrac{x}{y}u`, where :math:`u` is the constant.\n\n    azimuth_offset\n        The angle offset of the azimuth, expressed in radians.\n\n    azimuth_direction\n        The direction of the azimuth.\n\n        - ``\"CW\"``: Clockwise.\n        - ``\"CCW\"``: Anti-clockwise.\n\n    azimuth_label_buff\n        The buffer for the azimuth labels.\n\n    azimuth_label_font_size\n        The font size of the azimuth labels.\n\n    radius_config\n        The axis config for the radius.\n\n    Examples\n    --------\n    .. manim:: PolarPlaneExample\n        :ref_classes: PolarPlane\n        :save_last_frame:\n\n        class PolarPlaneExample(Scene):\n            def construct(self):\n                polarplane_pi = PolarPlane(\n                    azimuth_units=\"PI radians\",\n                    size=6,\n                    azimuth_label_font_size=33.6,\n                    radius_config={\"font_size\": 33.6},\n                ).add_coordinates()\n                self.add(polarplane_pi)\n    \"\"\"\n\n    def __init__(\n        self,\n        radius_max: float = config[\"frame_y_radius\"],\n        size: float | None = None,\n        radius_step: float = 1,\n        azimuth_step: float | None = None,\n        azimuth_units: str | None = \"PI radians\",\n        azimuth_compact_fraction: bool = True,\n        azimuth_offset: float = 0,\n        azimuth_direction: str = \"CCW\",\n        azimuth_label_buff: float = SMALL_BUFF,\n        azimuth_label_font_size: float = 24,\n        radius_config: dict[str, Any] | None = None,\n        background_line_style: dict[str, Any] | None = None,\n        faded_line_style: dict[str, Any] | None = None,\n        faded_line_ratio: int = 1,\n        make_smooth_after_applying_functions: bool = True,\n        **kwargs: Any,\n    ) -> None:\n        # error catching\n        if azimuth_units in [\"PI radians\", \"TAU radians\", \"degrees\", \"gradians\", None]:\n            self.azimuth_units = azimuth_units\n        else:\n            raise ValueError(\n                \"Invalid azimuth units. Expected one of: PI radians, TAU radians, degrees, gradians or None.\",\n            )\n\n        if azimuth_direction in [\"CW\", \"CCW\"]:\n            self.azimuth_direction = azimuth_direction\n        else:\n            raise ValueError(\"Invalid azimuth units. Expected one of: CW, CCW.\")\n\n        # configs\n        self.radius_config = {\n            \"stroke_width\": 2,\n            \"include_ticks\": False,\n            \"include_tip\": False,\n            \"line_to_number_buff\": SMALL_BUFF,\n            \"label_direction\": DL,\n            \"font_size\": 24,\n        }\n\n        self.background_line_style = {\n            \"stroke_color\": BLUE_D,\n            \"stroke_width\": 2,\n            \"stroke_opacity\": 1,\n        }\n\n        self.azimuth_step = (\n            (\n                {\n                    \"PI radians\": 20,\n                    \"TAU radians\": 20,\n                    \"degrees\": 36,\n                    \"gradians\": 40,\n                    None: 1,\n                }[azimuth_units]\n            )\n            if azimuth_step is None\n            else azimuth_step\n        )\n\n        self._update_default_configs(\n            (self.radius_config, self.background_line_style),\n            (radius_config, background_line_style),\n        )\n\n        # Defaults to a faded version of line_config\n        self.faded_line_style = faded_line_style\n        self.faded_line_ratio = faded_line_ratio\n        self.make_smooth_after_applying_functions = make_smooth_after_applying_functions\n        self.azimuth_offset = azimuth_offset\n        self.azimuth_label_buff = azimuth_label_buff\n        self.azimuth_label_font_size = azimuth_label_font_size\n        self.azimuth_compact_fraction = azimuth_compact_fraction\n\n        # init\n\n        super().__init__(\n            x_range=np.array((-radius_max, radius_max, radius_step)),\n            y_range=np.array((-radius_max, radius_max, radius_step)),\n            x_length=size,\n            y_length=size,\n            axis_config=self.radius_config,\n            **kwargs,\n        )\n\n        self._init_background_lines()\n\n    def _init_background_lines(self) -> None:\n        \"\"\"Will init all the lines of NumberPlanes (faded or not)\"\"\"\n        if self.faded_line_style is None:\n            style = dict(self.background_line_style)\n            # For anything numerical, like stroke_width\n            # and stroke_opacity, chop it in half\n            for key in style:\n                if isinstance(style[key], numbers.Number):\n                    style[key] *= 0.5\n            self.faded_line_style = style\n\n        self.background_lines, self.faded_lines = self._get_lines()\n        self.background_lines.set_style(\n            **self.background_line_style,\n        )\n        self.faded_lines.set_style(\n            **self.faded_line_style,\n        )\n        self.add_to_back(\n            self.faded_lines,\n            self.background_lines,\n        )\n\n    def _get_lines(self) -> tuple[VGroup, VGroup]:\n        \"\"\"Generate all the lines and circles, faded and not faded.\n\n        Returns\n        -------\n        Tuple[:class:`~.VGroup`, :class:`~.VGroup`]\n            The first (i.e the non faded lines and circles) and second (i.e the faded lines and circles) sets of lines and circles, respectively.\n        \"\"\"\n        center = self.get_origin()\n        ratio_faded_lines = self.faded_line_ratio\n        offset = self.azimuth_offset\n\n        if ratio_faded_lines == 0:  # don't show faded lines\n            ratio_faded_lines = 1  # i.e. set ratio to 1\n        rstep = (1 / ratio_faded_lines) * self.x_axis.x_range[2]\n        astep = (1 / ratio_faded_lines) * (TAU * (1 / self.azimuth_step))\n        rlines1 = VGroup()\n        rlines2 = VGroup()\n        alines1 = VGroup()\n        alines2 = VGroup()\n\n        rinput = np.arange(0, self.x_axis.x_range[1] + rstep, rstep)\n        ainput = np.arange(0, TAU, astep)\n\n        unit_vector = self.x_axis.get_unit_vector()[0]\n\n        for k, x in enumerate(rinput):\n            new_line = Circle(radius=x * unit_vector)\n            if k % ratio_faded_lines == 0:\n                alines1.add(new_line)\n            else:\n                alines2.add(new_line)\n\n        line = Line(center, self.get_x_axis().get_end())\n\n        for k, x in enumerate(ainput):\n            new_line = line.copy()\n            new_line.rotate(x + offset, about_point=center)\n            if k % ratio_faded_lines == 0:\n                rlines1.add(new_line)\n            else:\n                rlines2.add(new_line)\n\n        lines1 = VGroup(*rlines1, *alines1)\n        lines2 = VGroup(*rlines2, *alines2)\n        return lines1, lines2\n\n    def get_axes(self) -> VGroup:\n        \"\"\"Gets the axes.\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            A pair of axes.\n        \"\"\"\n        return self.axes\n\n    def get_vector(self, coords: Sequence[ManimFloat], **kwargs: Any) -> Arrow:\n        kwargs[\"buff\"] = 0\n        return Arrow(\n            self.coords_to_point(0, 0), self.coords_to_point(*coords), **kwargs\n        )\n\n    def prepare_for_nonlinear_transform(self, num_inserted_curves: int = 50) -> Self:\n        for mob in self.family_members_with_points():\n            num_curves = mob.get_num_curves()\n            if num_inserted_curves > num_curves:\n                mob.insert_n_curves(num_inserted_curves - num_curves)\n        return self\n\n    def get_coordinate_labels(\n        self,\n        r_values: Iterable[float] | None = None,\n        a_values: Iterable[float] | None = None,\n        **kwargs: Any,\n    ) -> VDict:\n        \"\"\"Gets labels for the coordinates\n\n        Parameters\n        ----------\n        r_values\n            Iterable of values along the radius, by default None.\n        a_values\n            Iterable of values along the azimuth, by default None.\n\n        Returns\n        -------\n        VDict\n            Labels for the radius and azimuth values.\n        \"\"\"\n        if r_values is None:\n            r_values = [r for r in self.get_x_axis().get_tick_range() if r >= 0]\n        if a_values is None:\n            a_values = np.arange(0, 1, 1 / self.azimuth_step)\n        r_mobs = self.get_x_axis().add_numbers(r_values)\n        if self.azimuth_direction == \"CCW\":\n            d = 1\n        elif self.azimuth_direction == \"CW\":\n            d = -1\n        else:\n            raise ValueError(\"Invalid azimuth direction. Expected one of: CW, CCW\")\n        a_points = [\n            {\n                \"label\": i,\n                \"point\": np.array(\n                    [\n                        self.get_right()[0]\n                        * np.cos(d * (i * TAU) + self.azimuth_offset),\n                        self.get_right()[0]\n                        * np.sin(d * (i * TAU) + self.azimuth_offset),\n                        0,\n                    ],\n                ),\n            }\n            for i in a_values\n        ]\n        if self.azimuth_units == \"PI radians\" or self.azimuth_units == \"TAU radians\":\n            a_tex = [\n                self.get_radian_label(\n                    i[\"label\"],\n                    font_size=self.azimuth_label_font_size,\n                ).next_to(\n                    i[\"point\"],\n                    direction=i[\"point\"],\n                    aligned_edge=i[\"point\"],\n                    buff=self.azimuth_label_buff,\n                )\n                for i in a_points\n            ]\n        elif self.azimuth_units == \"degrees\":\n            a_tex = [\n                MathTex(\n                    f\"{360 * i['label']:g}\" + r\"^{\\circ}\",\n                    font_size=self.azimuth_label_font_size,\n                ).next_to(\n                    i[\"point\"],\n                    direction=i[\"point\"],\n                    aligned_edge=i[\"point\"],\n                    buff=self.azimuth_label_buff,\n                )\n                for i in a_points\n            ]\n        elif self.azimuth_units == \"gradians\":\n            a_tex = [\n                MathTex(\n                    f\"{400 * i['label']:g}\" + r\"^{g}\",\n                    font_size=self.azimuth_label_font_size,\n                ).next_to(\n                    i[\"point\"],\n                    direction=i[\"point\"],\n                    aligned_edge=i[\"point\"],\n                    buff=self.azimuth_label_buff,\n                )\n                for i in a_points\n            ]\n        elif self.azimuth_units is None:\n            a_tex = [\n                MathTex(\n                    f\"{i['label']:g}\",\n                    font_size=self.azimuth_label_font_size,\n                ).next_to(\n                    i[\"point\"],\n                    direction=i[\"point\"],\n                    aligned_edge=i[\"point\"],\n                    buff=self.azimuth_label_buff,\n                )\n                for i in a_points\n            ]\n        a_mobs = VGroup(*a_tex)\n        self.coordinate_labels = VGroup(r_mobs, a_mobs)\n        return self.coordinate_labels\n\n    def add_coordinates(\n        self,\n        r_values: Iterable[float] | None = None,\n        a_values: Iterable[float] | None = None,\n    ) -> Self:\n        \"\"\"Adds the coordinates.\n\n        Parameters\n        ----------\n        r_values\n            Iterable of values along the radius, by default None.\n        a_values\n            Iterable of values along the azimuth, by default None.\n        \"\"\"\n        self.add(self.get_coordinate_labels(r_values, a_values))\n        return self\n\n    def get_radian_label(self, number, font_size: float = 24, **kwargs: Any) -> MathTex:\n        constant_label = {\"PI radians\": r\"\\pi\", \"TAU radians\": r\"\\tau\"}[\n            self.azimuth_units\n        ]\n        division = number * {\"PI radians\": 2, \"TAU radians\": 1}[self.azimuth_units]\n        frac = fr.Fraction(division).limit_denominator(max_denominator=100)\n        if frac.numerator == 0 & frac.denominator == 0:\n            string = r\"0\"\n        elif frac.numerator == 1 and frac.denominator == 1:\n            string = constant_label\n        elif frac.numerator == 1:\n            if self.azimuth_compact_fraction:\n                string = (\n                    r\"\\tfrac{\" + constant_label + r\"}{\" + str(frac.denominator) + \"}\"\n                )\n            else:\n                string = r\"\\tfrac{1}{\" + str(frac.denominator) + \"}\" + constant_label\n        elif frac.denominator == 1:\n            string = str(frac.numerator) + constant_label\n\n        else:\n            if self.azimuth_compact_fraction:\n                string = (\n                    r\"\\tfrac{\"\n                    + str(frac.numerator)\n                    + constant_label\n                    + r\"}{\"\n                    + str(frac.denominator)\n                    + r\"}\"\n                )\n            else:\n                string = (\n                    r\"\\tfrac{\"\n                    + str(frac.numerator)\n                    + r\"}{\"\n                    + str(frac.denominator)\n                    + r\"}\"\n                    + constant_label\n                )\n\n        return MathTex(string, font_size=font_size, **kwargs)"}, {"name": "Polygon", "code": "class Polygon:\n    \"\"\"\n    Initializes the Polygon with the given rings.\n\n    Parameters\n    ----------\n    rings\n        A sequence of points, where each sequence represents the rings of the polygon.\n        Typically, multiple rings indicate holes in the polygon.\n    \"\"\"\n\n    def __init__(self, rings: Sequence[Point2DLike_Array]) -> None:\n        np_rings: list[Point2D_Array] = [np.asarray(ring) for ring in rings]\n        # Flatten Array\n        csum = np.cumsum([ring.shape[0] for ring in np_rings])\n        self.array: Point2D_Array = np.concatenate(np_rings, axis=0)\n\n        # Compute Boundary\n        self.start: Point2D_Array = np.delete(self.array, csum - 1, axis=0)\n        self.stop: Point2D_Array = np.delete(self.array, csum % csum[-1], axis=0)\n        self.diff: Point2D_Array = np.delete(\n            np.diff(self.array, axis=0), csum[:-1] - 1, axis=0\n        )\n        self.norm: Point2D_Array = self.diff / np.einsum(\n            \"ij,ij->i\", self.diff, self.diff\n        ).reshape(-1, 1)\n\n        # Compute Centroid\n        x, y = self.start[:, 0], self.start[:, 1]\n        xr, yr = self.stop[:, 0], self.stop[:, 1]\n        self.area: float = 0.5 * (np.dot(x, yr) - np.dot(xr, y))\n        if self.area:\n            factor = x * yr - xr * y\n            cx = np.sum((x + xr) * factor) / (6.0 * self.area)\n            cy = np.sum((y + yr) * factor) / (6.0 * self.area)\n            self.centroid = np.array([cx, cy])\n\n    def compute_distance(self, point: Point2DLike) -> float:\n        \"\"\"Compute the minimum distance from a point to the polygon.\"\"\"\n        scalars = np.einsum(\"ij,ij->i\", self.norm, point - self.start)\n        clips = np.clip(scalars, 0, 1).reshape(-1, 1)\n        d: float = np.min(\n            np.linalg.norm(self.start + self.diff * clips - point, axis=1)\n        )\n        return d if self.inside(point) else -d\n\n    def _is_point_on_segment(\n        self,\n        x_point: float,\n        y_point: float,\n        x0: float,\n        y0: float,\n        x1: float,\n        y1: float,\n    ) -> bool:\n        \"\"\"\n        Check if a point is on the segment.\n\n        The segment is defined by (x0, y0) to (x1, y1).\n        \"\"\"\n        if min(x0, x1) <= x_point <= max(x0, x1) and min(y0, y1) <= y_point <= max(\n            y0, y1\n        ):\n            dx = x1 - x0\n            dy = y1 - y0\n            cross = dx * (y_point - y0) - dy * (x_point - x0)\n            return bool(np.isclose(cross, 0.0))\n        return False\n\n    def _ray_crosses_segment(\n        self,\n        x_point: float,\n        y_point: float,\n        x0: float,\n        y0: float,\n        x1: float,\n        y1: float,\n    ) -> bool:\n        \"\"\"\n        Check if a horizontal ray to the right from point (x_point, y_point) crosses the segment.\n\n        The segment is defined by (x0, y0) to (x1, y1).\n        \"\"\"\n        if (y0 > y_point) != (y1 > y_point):\n            slope = (x1 - x0) / (y1 - y0)\n            x_intersect = slope * (y_point - y0) + x0\n            return bool(x_point < x_intersect)\n        return False\n\n    def inside(self, point: Point2DLike) -> bool:\n        \"\"\"\n        Check if a point is inside the polygon.\n\n        Uses ray casting algorithm and checks boundary points consistently.\n        \"\"\"\n        point_x, point_y = point\n        start_x, start_y = self.start[:, 0], self.start[:, 1]\n        stop_x, stop_y = self.stop[:, 0], self.stop[:, 1]\n        segment_count = len(start_x)\n\n        for i in range(segment_count):\n            if self._is_point_on_segment(\n                point_x,\n                point_y,\n                start_x[i],\n                start_y[i],\n                stop_x[i],\n                stop_y[i],\n            ):\n                return True\n\n        crossings = 0\n        for i in range(segment_count):\n            if self._ray_crosses_segment(\n                point_x,\n                point_y,\n                start_x[i],\n                start_y[i],\n                stop_x[i],\n                stop_y[i],\n            ):\n                crossings += 1\n\n        return crossings % 2 == 1"}, {"name": "Polygram", "code": "class Polygram(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A generalized :class:`Polygon`, allowing for disconnected sets of edges.\n\n    Parameters\n    ----------\n    vertex_groups\n        The groups of vertices making up the :class:`Polygram`.\n\n        The first vertex in each group is repeated to close the shape.\n        Each point must be 3-dimensional: ``[x,y,z]``\n    color\n        The color of the :class:`Polygram`.\n    kwargs\n        Forwarded to the parent constructor.\n\n    Examples\n    --------\n    .. manim:: PolygramExample\n\n        import numpy as np\n\n        class PolygramExample(Scene):\n            def construct(self):\n                hexagram = Polygram(\n                    [[0, 2, 0], [-np.sqrt(3), -1, 0], [np.sqrt(3), -1, 0]],\n                    [[-np.sqrt(3), 1, 0], [0, -2, 0], [np.sqrt(3), 1, 0]],\n                )\n                self.add(hexagram)\n\n                dot = Dot()\n                self.play(MoveAlongPath(dot, hexagram), run_time=5, rate_func=linear)\n                self.remove(dot)\n                self.wait()\n    \"\"\"\n\n    def __init__(\n        self,\n        *vertex_groups: Point3DLike_Array,\n        color: ParsableManimColor = BLUE,\n        **kwargs: Any,\n    ):\n        super().__init__(color=color, **kwargs)\n\n        for vertices in vertex_groups:\n            # The inferred type for *vertices is Any, but it should be\n            # Point3D_Array\n            first_vertex, *vertices = vertices\n            first_vertex = np.array(first_vertex)\n\n            self.start_new_path(first_vertex)\n            self.add_points_as_corners(\n                [*(np.array(vertex) for vertex in vertices), first_vertex],\n            )\n\n    def get_vertices(self) -> Point3D_Array:\n        \"\"\"Gets the vertices of the :class:`Polygram`.\n\n        Returns\n        -------\n        :class:`numpy.ndarray`\n            The vertices of the :class:`Polygram`.\n\n        Examples\n        --------\n        ::\n\n            >>> sq = Square()\n            >>> sq.get_vertices()\n            array([[ 1.,  1.,  0.],\n                   [-1.,  1.,  0.],\n                   [-1., -1.,  0.],\n                   [ 1., -1.,  0.]])\n        \"\"\"\n        return self.get_start_anchors()\n\n    def get_vertex_groups(self) -> list[Point3D_Array]:\n        \"\"\"Gets the vertex groups of the :class:`Polygram`.\n\n        Returns\n        -------\n        list[Point3D_Array]\n            The list of vertex groups of the :class:`Polygram`.\n\n        Examples\n        --------\n        ::\n\n            >>> poly = Polygram([ORIGIN, RIGHT, UP, LEFT + UP], [LEFT, LEFT + UP, 2 * LEFT])\n            >>> groups = poly.get_vertex_groups()\n            >>> len(groups)\n            2\n            >>> groups[0]\n            array([[ 0.,  0.,  0.],\n                   [ 1.,  0.,  0.],\n                   [ 0.,  1.,  0.],\n                   [-1.,  1.,  0.]])\n            >>> groups[1]\n            array([[-1.,  0.,  0.],\n                   [-1.,  1.,  0.],\n                   [-2.,  0.,  0.]])\n        \"\"\"\n        vertex_groups = []\n\n        # TODO: If any of the original vertex groups contained the starting vertex N\n        # times, then .get_vertex_groups() splits it into N vertex groups.\n        group = []\n        for start, end in zip(self.get_start_anchors(), self.get_end_anchors()):\n            group.append(start)\n\n            if self.consider_points_equals(end, group[0]):\n                vertex_groups.append(np.array(group))\n                group = []\n\n        return vertex_groups\n\n    def round_corners(\n        self,\n        radius: float | list[float] = 0.5,\n        evenly_distribute_anchors: bool = False,\n        components_per_rounded_corner: int = 2,\n    ) -> Self:\n        \"\"\"Rounds off the corners of the :class:`Polygram`.\n\n        Parameters\n        ----------\n        radius\n            The curvature of the corners of the :class:`Polygram`.\n        evenly_distribute_anchors\n            Break long line segments into proportionally-sized segments.\n        components_per_rounded_corner\n            The number of points used to represent the rounded corner curve.\n\n\n        .. seealso::\n            :class:`.~RoundedRectangle`\n\n        .. note::\n            If `radius` is supplied as a single value, then the same radius\n            will be applied to all corners.  If `radius` is a list, then the\n            individual values will be applied sequentially, with the first\n            corner receiving `radius[0]`, the second corner receiving\n            `radius[1]`, etc.  The radius list will be repeated as necessary.\n\n            The `components_per_rounded_corner` value is provided so that the\n            fidelity of the rounded corner may be fine-tuned as needed.  2 is\n            an appropriate value for most shapes, however a larger value may be\n            need if the rounded corner is particularly large.  2 is the minimum\n            number allowed, representing the start and end of the curve.  3 will\n            result in a start, middle, and end point, meaning 2 curves will be\n            generated.\n\n            The option to `evenly_distribute_anchors` is provided so that the\n            line segments (the part part of each line remaining after rounding\n            off the corners) can be subdivided to a density similar to that of\n            the average density of the rounded corners.  This may be desirable\n            in situations in which an even distribution of curves is desired\n            for use in later transformation animations.  Be aware, though, that\n            enabling this option can result in an an object containing\n            significantly more points than the original, especially when the\n            rounded corner curves are small.\n\n        Examples\n        --------\n        .. manim:: PolygramRoundCorners\n            :save_last_frame:\n\n            class PolygramRoundCorners(Scene):\n                def construct(self):\n                    star = Star(outer_radius=2)\n\n                    shapes = VGroup(star)\n                    shapes.add(star.copy().round_corners(radius=0.1))\n                    shapes.add(star.copy().round_corners(radius=0.25))\n\n                    shapes.arrange(RIGHT)\n                    self.add(shapes)\n        \"\"\"\n        if radius == 0:\n            return self\n\n        new_points: list[Point3D] = []\n\n        for vertex_group in self.get_vertex_groups():\n            arcs = []\n\n            # Repeat the radius list as necessary in order to provide a radius\n            # for each vertex.\n            if isinstance(radius, (int, float)):\n                radius_list = [radius] * len(vertex_group)\n            else:\n                radius_list = radius * ceil(len(vertex_group) / len(radius))\n\n            for current_radius, (v1, v2, v3) in zip(\n                radius_list, adjacent_n_tuples(vertex_group, 3)\n            ):\n                vect1 = v2 - v1\n                vect2 = v3 - v2\n                unit_vect1 = normalize(vect1)\n                unit_vect2 = normalize(vect2)\n\n                angle = angle_between_vectors(vect1, vect2)\n                # Negative radius gives concave curves\n                angle *= np.sign(current_radius)\n\n                # Distance between vertex and start of the arc\n                cut_off_length = current_radius * np.tan(angle / 2)\n\n                # Determines counterclockwise vs. clockwise\n                sign = np.sign(np.cross(vect1, vect2)[2])\n\n                arc = ArcBetweenPoints(\n                    v2 - unit_vect1 * cut_off_length,\n                    v2 + unit_vect2 * cut_off_length,\n                    angle=sign * angle,\n                    num_components=components_per_rounded_corner,\n                )\n                arcs.append(arc)\n\n            if evenly_distribute_anchors:\n                # Determine the average length of each curve\n                nonzero_length_arcs = [arc for arc in arcs if len(arc.points) > 4]\n                if len(nonzero_length_arcs) > 0:\n                    total_arc_length = sum(\n                        [arc.get_arc_length() for arc in nonzero_length_arcs]\n                    )\n                    num_curves = (\n                        sum([len(arc.points) for arc in nonzero_length_arcs]) / 4\n                    )\n                    average_arc_length = total_arc_length / num_curves\n                else:\n                    average_arc_length = 1.0\n\n            # To ensure that we loop through starting with last\n            arcs = [arcs[-1], *arcs[:-1]]\n            from manim.mobject.geometry.line import Line\n\n            for arc1, arc2 in adjacent_pairs(arcs):\n                new_points.extend(arc1.points)\n\n                line = Line(arc1.get_end(), arc2.get_start())\n\n                # Make sure anchors are evenly distributed, if necessary\n                if evenly_distribute_anchors:\n                    line.insert_n_curves(ceil(line.get_length() / average_arc_length))\n\n                new_points.extend(line.points)\n\n        self.set_points(np.array(new_points))\n\n        return self"}, {"name": "Polyhedron", "code": "class Polyhedron(VGroup):\n    \"\"\"An abstract polyhedra class.\n\n    In this implementation, polyhedra are defined with a list of vertex coordinates in space, and a list\n    of faces. This implementation mirrors that of a standard polyhedral data format (OFF, object file format).\n\n    Parameters\n    ----------\n    vertex_coords\n        A list of coordinates of the corresponding vertices in the polyhedron. Each coordinate will correspond to\n        a vertex. The vertices are indexed with the usual indexing of Python.\n    faces_list\n        A list of faces. Each face is a sublist containing the indices of the vertices that form the corners of that face.\n    faces_config\n        Configuration for the polygons representing the faces of the polyhedron.\n    graph_config\n        Configuration for the graph containing the vertices and edges of the polyhedron.\n\n    Examples\n    --------\n    To understand how to create a custom polyhedra, let's use the example of a rather simple one - a square pyramid.\n\n    .. manim:: SquarePyramidScene\n        :save_last_frame:\n\n        class SquarePyramidScene(ThreeDScene):\n            def construct(self):\n                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n                vertex_coords = [\n                    [1, 1, 0],\n                    [1, -1, 0],\n                    [-1, -1, 0],\n                    [-1, 1, 0],\n                    [0, 0, 2]\n                ]\n                faces_list = [\n                    [0, 1, 4],\n                    [1, 2, 4],\n                    [2, 3, 4],\n                    [3, 0, 4],\n                    [0, 1, 2, 3]\n                ]\n                pyramid = Polyhedron(vertex_coords, faces_list)\n                self.add(pyramid)\n\n    In defining the polyhedron above, we first defined the coordinates of the vertices.\n    These are the corners of the square base, given as the first four coordinates in the vertex list,\n    and the apex, the last coordinate in the list.\n\n    Next, we define the faces of the polyhedron. The triangular surfaces of the pyramid are polygons\n    with two adjacent vertices in the base and the vertex at the apex as corners. We thus define these\n    surfaces in the first four elements of our face list. The last element defines the base of the pyramid.\n\n    The graph and faces of polyhedra can also be accessed and modified directly, after instantiation.\n    They are stored in the `graph` and `faces` attributes respectively.\n\n    .. manim:: PolyhedronSubMobjects\n        :save_last_frame:\n\n        class PolyhedronSubMobjects(ThreeDScene):\n            def construct(self):\n                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n                octahedron = Octahedron(edge_length = 3)\n                octahedron.graph[0].set_color(RED)\n                octahedron.faces[2].set_color(YELLOW)\n                self.add(octahedron)\n    \"\"\"\n\n    def __init__(\n        self,\n        vertex_coords: list[list[float] | np.ndarray],\n        faces_list: list[list[int]],\n        faces_config: dict[str, str | int | float | bool] = {},\n        graph_config: dict[str, str | int | float | bool] = {},\n    ):\n        super().__init__()\n        self.faces_config = dict(\n            {\"fill_opacity\": 0.5, \"shade_in_3d\": True}, **faces_config\n        )\n        self.graph_config = dict(\n            {\n                \"vertex_type\": Dot3D,\n                \"edge_config\": {\n                    \"stroke_opacity\": 0,  # I find that having the edges visible makes the polyhedra look weird\n                },\n            },\n            **graph_config,\n        )\n        self.vertex_coords = vertex_coords\n        self.vertex_indices = list(range(len(self.vertex_coords)))\n        self.layout = dict(enumerate(self.vertex_coords))\n        self.faces_list = faces_list\n        self.face_coords = [[self.layout[j] for j in i] for i in faces_list]\n        self.edges = self.get_edges(self.faces_list)\n        self.faces = self.create_faces(self.face_coords)\n        self.graph = Graph(\n            self.vertex_indices, self.edges, layout=self.layout, **self.graph_config\n        )\n        self.add(self.faces, self.graph)\n        self.add_updater(self.update_faces)\n\n    def get_edges(self, faces_list: list[list[int]]) -> list[tuple[int, int]]:\n        \"\"\"Creates list of cyclic pairwise tuples.\"\"\"\n        edges = []\n        for face in faces_list:\n            edges += zip(face, face[1:] + face[:1])\n        return edges\n\n    def create_faces(\n        self,\n        face_coords: list[list[list | np.ndarray]],\n    ) -> VGroup:\n        \"\"\"Creates VGroup of faces from a list of face coordinates.\"\"\"\n        face_group = VGroup()\n        for face in face_coords:\n            face_group.add(Polygon(*face, **self.faces_config))\n        return face_group\n\n    def update_faces(self, m: Mobject):\n        face_coords = self.extract_face_coords()\n        new_faces = self.create_faces(face_coords)\n        self.faces.match_points(new_faces)\n\n    def extract_face_coords(self) -> list[list[np.ndarray]]:\n        \"\"\"Extracts the coordinates of the vertices in the graph.\n        Used for updating faces.\n        \"\"\"\n        new_vertex_coords = []\n        for v in self.graph.vertices:\n            new_vertex_coords.append(self.graph[v].get_center())\n        layout = dict(enumerate(new_vertex_coords))\n        return [[layout[j] for j in i] for i in self.faces_list]"}, {"name": "polylabel", "code": "def polylabel(rings: Sequence[Point3DLike_Array], precision: float = 0.01) -> Cell:\n    \"\"\"\n    Finds the pole of inaccessibility (the point that is farthest from the edges of the polygon)\n    using an iterative grid-based approach.\n\n    Parameters\n    ----------\n    rings\n        A list of lists, where each list is a sequence of points representing the rings of the polygon.\n        Typically, multiple rings indicate holes in the polygon.\n    precision\n        The precision of the result (default is 0.01).\n\n    Returns\n    -------\n    Cell\n        A Cell containing the pole of inaccessibility to a given precision.\n    \"\"\"\n    # Precompute Polygon Data\n    np_rings: list[Point2D_Array] = [np.asarray(ring)[:, :2] for ring in rings]\n    polygon = Polygon(np_rings)\n\n    # Bounding Box\n    mins = np.min(polygon.array, axis=0)\n    maxs = np.max(polygon.array, axis=0)\n    dims = maxs - mins\n    s = np.min(dims)\n    h = s / 2.0\n\n    # Initial Grid\n    queue: PriorityQueue[Cell] = PriorityQueue()\n    xv, yv = np.meshgrid(np.arange(mins[0], maxs[0], s), np.arange(mins[1], maxs[1], s))\n    for corner in np.vstack([xv.ravel(), yv.ravel()]).T:\n        queue.put(Cell(corner + h, h, polygon))\n\n    # Initial Guess\n    best = Cell(polygon.centroid, 0, polygon)\n    bbox = Cell(mins + (dims / 2), 0, polygon)\n    if bbox.d > best.d:\n        best = bbox\n\n    # While there are cells to consider...\n    directions = np.array([[-1, -1], [1, -1], [-1, 1], [1, 1]])\n    while not queue.empty():\n        cell = queue.get()\n        if cell > best:\n            best = cell\n        # If a cell is promising, subdivide!\n        if cell.p - best.d > precision:\n            h = cell.h / 2.0\n            offsets = cell.c + directions * h\n            queue.put(Cell(offsets[0], h, polygon))\n            queue.put(Cell(offsets[1], h, polygon))\n            queue.put(Cell(offsets[2], h, polygon))\n            queue.put(Cell(offsets[3], h, polygon))\n    return best"}, {"name": "prepare_animation", "code": "def prepare_animation(\n    anim: Animation | mobject._AnimationBuilder,\n) -> Animation:\n    r\"\"\"Returns either an unchanged animation, or the animation built\n    from a passed animation factory.\n\n    Examples\n    --------\n\n    ::\n\n        >>> from manim import Square, FadeIn\n        >>> s = Square()\n        >>> prepare_animation(FadeIn(s))\n        FadeIn(Square)\n\n    ::\n\n        >>> prepare_animation(s.animate.scale(2).rotate(42))\n        _MethodAnimation(Square)\n\n    ::\n\n        >>> prepare_animation(42)\n        Traceback (most recent call last):\n        ...\n        TypeError: Object 42 cannot be converted to an animation\n\n    \"\"\"\n    if isinstance(anim, mobject._AnimationBuilder):\n        return anim.build()\n\n    if isinstance(anim, opengl_mobject._AnimationBuilder):\n        return anim.build()\n\n    if isinstance(anim, Animation):\n        return anim\n\n    raise TypeError(f\"Object {anim} cannot be converted to an animation\")"}, {"name": "print_all_tex_errors", "code": "def print_all_tex_errors(log_file: Path, tex_compiler: str, tex_file: Path) -> None:\n    if not log_file.exists():\n        raise RuntimeError(\n            f\"{tex_compiler} failed but did not produce a log file. \"\n            \"Check your LaTeX installation.\",\n        )\n    with log_file.open(encoding=\"utf-8\") as f:\n        tex_compilation_log = f.readlines()\n    error_indices = [\n        index for index, line in enumerate(tex_compilation_log) if line.startswith(\"!\")\n    ]\n    if error_indices:\n        with tex_file.open() as f:\n            tex = f.readlines()\n        for error_index in error_indices:\n            print_tex_error(tex_compilation_log, error_index, tex)"}, {"name": "print_family", "code": "def print_family(mobject: Mobject, n_tabs: int = 0) -> None:\n    \"\"\"For debugging purposes\"\"\"\n    print(\"\\t\" * n_tabs, mobject, id(mobject))\n    for submob in mobject.submobjects:\n        print_family(submob, n_tabs + 1)"}, {"name": "print_tex_error", "code": "def print_tex_error(\n    tex_compilation_log: Sequence[str],\n    error_start_index: int,\n    tex_source: Sequence[str],\n) -> None:\n    logger.error(\n        f\"LaTeX compilation error: {tex_compilation_log[error_start_index][2:]}\",\n    )\n\n    # TeX errors eventually contain a line beginning 'l.xxx` where xxx is the line number that caused the compilation\n    # failure. This code finds the next such line after the error current error message\n    line_of_tex_error = (\n        int(\n            [\n                log_line\n                for log_line in tex_compilation_log[error_start_index:]\n                if log_line.startswith(\"l.\")\n            ][0]\n            .split(\" \")[0]\n            .split(\".\")[1],\n        )\n        - 1\n    )\n    # our tex error may be on a line outside our user input because of post-processing\n    if line_of_tex_error >= len(tex_source):\n        return None\n\n    context = [\"Context of error: \\n\"]\n    if line_of_tex_error < 3:\n        context += tex_source[: line_of_tex_error + 3]\n        context[-4] = \"-> \" + context[-4]\n    elif line_of_tex_error > len(tex_source) - 3:\n        context += tex_source[line_of_tex_error - 1 :]\n        context[1] = \"-> \" + context[1]\n    else:\n        context += tex_source[line_of_tex_error - 3 : line_of_tex_error + 3]\n        context[-4] = \"-> \" + context[-4]\n\n    context_joined = \"\".join(context)\n    logger.error(context_joined)\n\n    for insights in LATEX_ERROR_INSIGHTS:\n        prob, get_insight = insights\n        matching = re.search(\n            prob,\n            \"\".join(tex_compilation_log[error_start_index])[2:],\n        )\n        if matching is not None:\n            for insight in get_insight(matching):\n                logger.info(insight)"}, {"name": "print_version_and_exit", "code": "def print_version_and_exit(\n    ctx: click.Context, param: click.Option, value: str | None\n) -> None:\n    \"\"\"Same as :func:`show_splash`, but also exit when giving a value by\n    console.\n\n    Parameters\n    ----------\n    ctx\n        The Click context.\n    param\n        A Click option.\n    value\n        A string value given by console, or None.\n    \"\"\"\n    show_splash(ctx, param, value)\n    if value:\n        ctx.exit()"}, {"name": "Prism", "code": "class Prism(Cube):\n    \"\"\"A right rectangular prism (or rectangular cuboid).\n    Defined by the length of each side in ``[x, y, z]`` format.\n\n    Parameters\n    ----------\n    dimensions\n        Dimensions of the :class:`Prism` in ``[x, y, z]`` format.\n\n    Examples\n    --------\n\n    .. manim:: ExamplePrism\n        :save_last_frame:\n\n        class ExamplePrism(ThreeDScene):\n            def construct(self):\n                self.set_camera_orientation(phi=60 * DEGREES, theta=150 * DEGREES)\n                prismSmall = Prism(dimensions=[1, 2, 3]).rotate(PI / 2)\n                prismLarge = Prism(dimensions=[1.5, 3, 4.5]).move_to([2, 0, 0])\n                self.add(prismSmall, prismLarge)\n    \"\"\"\n\n    def __init__(\n        self, dimensions: tuple[float, float, float] | np.ndarray = [3, 2, 1], **kwargs\n    ) -> None:\n        self.dimensions = dimensions\n        super().__init__(**kwargs)\n\n    def generate_points(self) -> None:\n        \"\"\"Creates the sides of the :class:`Prism`.\"\"\"\n        super().generate_points()\n        for dim, value in enumerate(self.dimensions):\n            self.rescale_to_fit(value, dim, stretch=True)"}, {"name": "process_name_list", "code": "def process_name_list(option_input: str, reference_type: str) -> list[str]:\n    r\"\"\"Reformats a string of space separated class names\n    as a list of strings containing valid Sphinx references.\n\n    Tests\n    -----\n\n    ::\n\n        >>> process_name_list(\"Tex TexTemplate\", \"class\")\n        [':class:`~.Tex`', ':class:`~.TexTemplate`']\n        >>> process_name_list(\"Scene.play Mobject.rotate\", \"func\")\n        [':func:`~.Scene.play`', ':func:`~.Mobject.rotate`']\n    \"\"\"\n    return [f\":{reference_type}:`~.{name}`\" for name in option_input.split()]"}, {"name": "project", "code": "def project(default_settings: bool, **kwargs: Any) -> None:\n    \"\"\"Creates a new project.\n\n    PROJECT_NAME is the name of the folder in which the new project will be initialized.\n    \"\"\"\n    project_name: Path\n    if kwargs[\"project_name\"]:\n        project_name = kwargs[\"project_name\"]\n    else:\n        project_name = click.prompt(\"Project Name\", type=Path)\n\n    # in the future when implementing a full template system. Choices are going to be saved in some sort of config file for templates\n    template_name = click.prompt(\n        \"Template\",\n        type=click.Choice(get_template_names(), False),\n        default=\"Default\",\n    )\n\n    if project_name.is_dir():\n        console.print(\n            f\"\\nFolder [red]{project_name}[/red] exists. Please type another name\\n\",\n        )\n    else:\n        project_name.mkdir()\n        new_cfg: dict[str, Any] = {}\n        new_cfg_path = Path.resolve(project_name / \"manim.cfg\")\n\n        if not default_settings:\n            for key, value in CFG_DEFAULTS.items():\n                if key == \"scene_names\":\n                    new_cfg[key] = template_name + \"Template\"\n                elif key == \"resolution\":\n                    new_cfg[key] = select_resolution()\n                else:\n                    new_cfg[key] = click.prompt(f\"\\n{key}\", default=value)\n\n            console.print(\"\\n\", new_cfg)\n            if click.confirm(\"Do you want to continue?\", default=True, abort=True):\n                copy_template_files(project_name, template_name)\n                update_cfg(new_cfg, new_cfg_path)\n        else:\n            copy_template_files(project_name, template_name)\n            update_cfg(CFG_DEFAULTS, new_cfg_path)"}, {"name": "prompt_user_for_choice", "code": "def prompt_user_for_choice(scene_classes: list[type[Scene]]) -> list[type[Scene]]:\n    num_to_class = {}\n    SceneFileWriter.force_output_as_scene_name = True\n    for count, scene_class in enumerate(scene_classes, 1):\n        name = scene_class.__name__\n        console.print(f\"{count}: {name}\", style=\"logging.level.info\")\n        num_to_class[count] = scene_class\n    try:\n        user_input = console.input(\n            f\"[log.message] {CHOOSE_NUMBER_MESSAGE} [/log.message]\",\n        )\n        scene_classes = [\n            num_to_class[int(num_str)]\n            for num_str in re.split(r\"\\s*,\\s*\", user_input.strip())\n        ]\n        config[\"scene_names\"] = [scene_class.__name__ for scene_class in scene_classes]\n        return scene_classes\n    except KeyError:\n        logger.error(INVALID_NUMBER_MESSAGE)\n        sys.exit(2)\n    except EOFError:\n        sys.exit(1)\n    except ValueError:\n        logger.error(\"No scenes were selected. Exiting.\")\n        sys.exit(1)"}, {"name": "proportions_along_bezier_curve_for_point", "code": "def proportions_along_bezier_curve_for_point(\n    point: Point3DLike,\n    control_points: BezierPointsLike,\n    round_to: float = 1e-6,\n) -> MatrixMN:\n    \"\"\"Obtains the proportion along the bezier curve corresponding to a given point\n    given the bezier curve's control points.\n\n    The bezier polynomial is constructed using the coordinates of the given point\n    as well as the bezier curve's control points. On solving the polynomial for each dimension,\n    if there are roots common to every dimension, those roots give the proportion along the\n    curve the point is at. If there are no real roots, the point does not lie on the curve.\n\n    Parameters\n    ----------\n    point\n        The Cartesian Coordinates of the point whose parameter\n        should be obtained.\n    control_points\n        The Cartesian Coordinates of the ordered control\n        points of the bezier curve on which the point may\n        or may not lie.\n    round_to\n        A float whose number of decimal places all values\n        such as coordinates of points will be rounded.\n\n    Returns\n    -------\n        np.ndarray[float]\n            List containing possible parameters (the proportions along the bezier curve)\n            for the given point on the given bezier curve.\n            This usually only contains one or zero elements, but if the\n            point is, say, at the beginning/end of a closed loop, may return\n            a list with more than 1 value, corresponding to the beginning and\n            end etc. of the loop.\n\n    Raises\n    ------\n    :class:`ValueError`\n        When ``point`` and the control points have different shapes.\n    \"\"\"\n    # Method taken from\n    # http://polymathprogrammer.com/2012/04/03/does-point-lie-on-bezier-curve/\n\n    if not all(np.shape(point) == np.shape(c_p) for c_p in control_points):\n        raise ValueError(\n            f\"Point {point} and Control Points {control_points} have different shapes.\",\n        )\n\n    control_points = np.array(control_points)\n    n = len(control_points) - 1\n\n    roots = []\n    for dim, coord in enumerate(point):\n        control_coords = control_points[:, dim]\n        terms = []\n        for term_power in range(n, -1, -1):\n            outercoeff = choose(n, term_power)\n            term = []\n            sign = 1\n            for subterm_num in range(term_power, -1, -1):\n                innercoeff = choose(term_power, subterm_num) * sign\n                subterm = innercoeff * control_coords[subterm_num]\n                if term_power == 0:\n                    subterm -= coord\n                term.append(subterm)\n                sign *= -1\n            terms.append(outercoeff * sum(np.array(term)))\n        if all(term == 0 for term in terms):\n            # Then both Bezier curve and Point lie on the same plane.\n            # Roots will be none, but in this specific instance, we don't need to consider that.\n            continue\n        bezier_polynom = np.polynomial.Polynomial(terms[::-1])\n        polynom_roots = bezier_polynom.roots()\n        if len(polynom_roots) > 0:\n            polynom_roots = np.around(polynom_roots, int(np.log10(1 / round_to)))\n        roots.append(polynom_roots)\n\n    roots = [[root for root in rootlist if root.imag == 0] for rootlist in roots]\n    # Get common roots\n    # arg-type: ignore\n    roots = reduce(np.intersect1d, roots)\n    result = np.asarray([r.real for r in roots if 0 <= r.real <= 1])\n    return result"}, {"name": "QualityDict", "code": "class QualityDict(TypedDict):\n    flag: str | None\n    pixel_height: int\n    pixel_width: int\n    frame_rate: int"}, {"name": "quaternion_conjugate", "code": "def quaternion_conjugate(quaternion: Sequence[float]) -> np.ndarray:\n    \"\"\"Used for finding the conjugate of the quaternion\n\n    Parameters\n    ----------\n    quaternion\n        The quaternion for which you want to find the conjugate for.\n\n    Returns\n    -------\n    np.ndarray\n        The conjugate of the quaternion.\n    \"\"\"\n    result = np.array(quaternion)\n    result[1:] *= -1\n    return result"}, {"name": "quaternion_from_angle_axis", "code": "def quaternion_from_angle_axis(\n    angle: float,\n    axis: np.ndarray,\n    axis_normalized: bool = False,\n) -> list[float]:\n    \"\"\"Gets a quaternion from an angle and an axis.\n    For more information, check `this Wikipedia page\n    <https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles>`__.\n\n    Parameters\n    ----------\n    angle\n        The angle for the quaternion.\n    axis\n        The axis for the quaternion\n    axis_normalized\n        Checks whether the axis is normalized, by default False\n\n    Returns\n    -------\n    list[float]\n        Gives back a quaternion from the angle and axis\n    \"\"\"\n    if not axis_normalized:\n        axis = normalize(axis)\n    return [np.cos(angle / 2), *(np.sin(angle / 2) * axis)]"}, {"name": "quaternion_mult", "code": "def quaternion_mult(\n    *quats: Sequence[float],\n) -> np.ndarray | list[float | np.ndarray]:\n    \"\"\"Gets the Hamilton product of the quaternions provided.\n    For more information, check `this Wikipedia page\n    <https://en.wikipedia.org/wiki/Quaternion>`__.\n\n    Returns\n    -------\n    Union[np.ndarray, List[Union[float, np.ndarray]]]\n        Returns a list of product of two quaternions.\n    \"\"\"\n    if len(quats) == 0:\n        return [1, 0, 0, 0]\n    result = quats[0]\n    for next_quat in quats[1:]:\n        w1, x1, y1, z1 = result\n        w2, x2, y2, z2 = next_quat\n        result = [\n            w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2,\n            w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2,\n            w1 * y2 + y1 * w2 + z1 * x2 - x1 * z2,\n            w1 * z2 + z1 * w2 + x1 * y2 - y1 * x2,\n        ]\n    return result"}, {"name": "QuickHull", "code": "class QuickHull:\n    \"\"\"\n    QuickHull algorithm for constructing a convex hull from a set of points.\n\n    Parameters\n    ----------\n    tolerance\n        A tolerance threshold for determining when points lie on the convex hull (default is 1e-5).\n\n    Attributes\n    ----------\n    facets\n        List of facets considered.\n    removed\n        Set of internal facets that have been removed from the hull during the construction process.\n    outside\n        Dictionary mapping each facet to its outside points and eye point.\n    neighbors\n        Mapping of subfacets to their neighboring facets. Each subfacet links precisely two neighbors.\n    unclaimed\n        Points that have not yet been classified as inside or outside the current hull.\n    internal\n        An internal point (i.e., the center of the initial simplex) used as a reference during hull construction.\n    tolerance\n        The tolerance used to determine if points are considered outside the current hull.\n    \"\"\"\n\n    def __init__(self, tolerance: float = 1e-5) -> None:\n        self.facets: list[Facet] = []\n        self.removed: set[Facet] = set()\n        self.outside: dict[Facet, tuple[PointND_Array | None, PointND | None]] = {}\n        self.neighbors: dict[SubFacet, set[Facet]] = {}\n        self.unclaimed: PointND_Array | None = None\n        self.internal: PointND | None = None\n        self.tolerance = tolerance\n\n    def initialize(self, points: PointND_Array) -> None:\n        # Sample Points\n        simplex = points[\n            np.random.choice(points.shape[0], points.shape[1] + 1, replace=False)\n        ]\n        self.unclaimed = points\n        new_internal: PointND = np.mean(simplex, axis=0)\n        self.internal = new_internal\n\n        # Build Simplex\n        for c in range(simplex.shape[0]):\n            facet = Facet(np.delete(simplex, c, axis=0), internal=new_internal)\n            self.classify(facet)\n            self.facets.append(facet)\n\n        # Attach Neighbors\n        for f in self.facets:\n            for sf in f.subfacets:\n                self.neighbors.setdefault(sf, set()).add(f)\n\n    def classify(self, facet: Facet) -> None:\n        assert self.unclaimed is not None, (\n            \"Call .initialize() before using .classify().\"\n        )\n\n        if not self.unclaimed.size:\n            self.outside[facet] = (None, None)\n            return\n\n        # Compute Projections\n        projections = (self.unclaimed - facet.center) @ facet.normal\n        arg = np.argmax(projections)\n        mask = projections > self.tolerance\n\n        # Identify Eye and Outside Set\n        eye = self.unclaimed[arg] if projections[arg] > self.tolerance else None\n        outside = self.unclaimed[mask]\n        self.outside[facet] = (outside, eye)\n        self.unclaimed = self.unclaimed[~mask]\n\n    def compute_horizon(self, eye: PointND, start_facet: Facet) -> Horizon:\n        horizon = Horizon()\n        self._recursive_horizon(eye, start_facet, horizon)\n        return horizon\n\n    def _recursive_horizon(self, eye: PointND, facet: Facet, horizon: Horizon) -> bool:\n        visible = np.dot(facet.normal, eye - facet.center) > 0\n        if not visible:\n            return False\n\n        # If the eye is visible from the facet:\n        # Label the facet as visible and cross each edge\n        horizon.facets.add(facet)\n        for subfacet in facet.subfacets:\n            neighbor = (self.neighbors[subfacet] - {facet}).pop()\n            # If the neighbor is not visible, then the edge shared must be on the boundary\n            if neighbor not in horizon.facets and not self._recursive_horizon(\n                eye, neighbor, horizon\n            ):\n                horizon.boundary.append(subfacet)\n        return True\n\n    def build(self, points: PointND_Array) -> None:\n        num, dim = points.shape\n        if (dim == 0) or (num < dim + 1):\n            raise ValueError(\"Not enough points supplied to build Convex Hull!\")\n        if dim == 1:\n            raise ValueError(\"The Convex Hull of 1D data is its min-max!\")\n\n        self.initialize(points)\n\n        # This helps the type checker.\n        assert self.unclaimed is not None\n        assert self.internal is not None\n\n        while True:\n            updated = False\n            for facet in self.facets:\n                if facet in self.removed:\n                    continue\n                outside, eye = self.outside[facet]\n                if eye is not None:\n                    updated = True\n                    horizon = self.compute_horizon(eye, facet)\n                    for f in horizon.facets:\n                        points_to_append = self.outside[f][0]\n                        # TODO: is this always true?\n                        assert points_to_append is not None\n                        self.unclaimed = np.vstack((self.unclaimed, points_to_append))\n                        self.removed.add(f)\n                        for sf in f.subfacets:\n                            self.neighbors[sf].discard(f)\n                            if self.neighbors[sf] == set():\n                                del self.neighbors[sf]\n                    for sf in horizon.boundary:\n                        nf = Facet(\n                            np.vstack((sf.coordinates, eye)), internal=self.internal\n                        )\n                        self.classify(nf)\n                        self.facets.append(nf)\n                        for nsf in nf.subfacets:\n                            self.neighbors.setdefault(nsf, set()).add(nf)\n            if not updated:\n                break"}, {"name": "QuickHullPoint", "code": "class QuickHullPoint:\n    def __init__(self, coordinates: PointND_Array) -> None:\n        self.coordinates = coordinates\n\n    def __hash__(self) -> int:\n        return hash(self.coordinates.tobytes())\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, QuickHullPoint):\n            raise ValueError\n        are_coordinates_equal: bool = np.array_equal(\n            self.coordinates, other.coordinates\n        )\n        return are_coordinates_equal"}, {"name": "R3_to_complex", "code": "def R3_to_complex(point: Sequence[float]) -> np.ndarray:\n    return complex(*point[:2])"}, {"name": "random_bright_color", "code": "def random_bright_color() -> ManimColor:\n    \"\"\"Return a random bright color: a random color averaged with ``WHITE``.\n\n    .. warning::\n        This operation is very expensive. Please keep in mind the performance loss.\n\n    Returns\n    -------\n    ManimColor\n        A random bright :class:`ManimColor`.\n    \"\"\"\n    curr_rgb = color_to_rgb(random_color())\n    new_rgb = 0.5 * (curr_rgb + np.ones(3))\n    return ManimColor(new_rgb)"}, {"name": "random_color", "code": "def random_color() -> ManimColor:\n    \"\"\"Return a random :class:`ManimColor`.\n\n    Returns\n    -------\n    ManimColor\n        A random :class:`ManimColor`.\n    \"\"\"\n    return RandomColorGenerator._random_color()"}, {"name": "RandomColorGenerator", "code": "class RandomColorGenerator:\n    _singleton: RandomColorGenerator | None = None\n    \"\"\"A generator for producing random colors from a given list of Manim colors,\n    optionally in a reproducible sequence using a seed value.\n\n    When initialized with a specific seed, this class produces a deterministic\n    sequence of :class:`.ManimColor` instances. If no seed is provided, the selection is\n    non-deterministic using Python\u2019s global random state.\n\n    Parameters\n    ----------\n    seed\n        A seed value to initialize the internal random number generator.\n        If ``None`` (the default), colors are chosen using the global random state.\n\n    sample_colors\n        A custom list of Manim colors to sample from. Defaults to the full Manim\n        color palette.\n\n    Examples\n    --------\n    Without a seed (non-deterministic)::\n\n        >>> from manim import RandomColorGenerator, ManimColor, RED, GREEN, BLUE\n        >>> rnd = RandomColorGenerator()\n        >>> isinstance(rnd.next(), ManimColor)\n        True\n\n    With a seed (deterministic sequence)::\n\n        >>> rnd = RandomColorGenerator(42)\n        >>> rnd.next()\n        ManimColor('#ECE7E2')\n        >>> rnd.next()\n        ManimColor('#BBBBBB')\n        >>> rnd.next()\n        ManimColor('#BBBBBB')\n\n    Re-initializing with the same seed gives the same sequence::\n\n        >>> rnd2 = RandomColorGenerator(42)\n        >>> rnd2.next()\n        ManimColor('#ECE7E2')\n        >>> rnd2.next()\n        ManimColor('#BBBBBB')\n        >>> rnd2.next()\n        ManimColor('#BBBBBB')\n\n    Using a custom color list::\n\n        >>> custom_palette = [RED, GREEN, BLUE]\n        >>> rnd_custom = RandomColorGenerator(1, sample_colors=custom_palette)\n        >>> rnd_custom.next() in custom_palette\n        True\n        >>> rnd_custom.next() in custom_palette\n        True\n\n    Without a seed and custom palette (non-deterministic)::\n\n        >>> rnd_nodet = RandomColorGenerator(sample_colors=[RED])\n        >>> rnd_nodet.next()\n        ManimColor('#FC6255')\n    \"\"\"\n\n    def __init__(\n        self,\n        seed: int | None = None,\n        sample_colors: list[ManimColor] | None = None,\n    ) -> None:\n        self.choice = random.choice if seed is None else random.Random(seed).choice\n\n        from manim.utils.color.manim_colors import _all_manim_colors\n\n        self.colors = _all_manim_colors if sample_colors is None else sample_colors\n\n    def next(self) -> ManimColor:\n        \"\"\"Returns the next color from the configured color list.\n\n        Returns\n        -------\n        ManimColor\n            A randomly selected color from the specified color list.\n\n        Examples\n        --------\n        Usage::\n\n            >>> from manim import RandomColorGenerator, RED\n            >>> rnd = RandomColorGenerator(sample_colors=[RED])\n            >>> rnd.next()\n            ManimColor('#FC6255')\n        \"\"\"\n        return self.choice(self.colors)\n\n    @classmethod\n    def _random_color(cls) -> ManimColor:\n        \"\"\"Internal method to generate a random color using the singleton instance of\n        `RandomColorGenerator`.\n        It will be used by proxy method `random_color` publicly available\n        and makes it backwards compatible.\n\n        Returns\n        -------\n        ManimColor:\n            A randomly selected color from the configured color list of\n            the singleton instance.\n        \"\"\"\n        if cls._singleton is None:\n            cls._singleton = cls()\n        return cls._singleton.next()"}, {"name": "RateFunction", "code": "class RateFunction(Protocol):\n    def __call__(self, t: float, *args: Any, **kwargs: Any) -> float: ..."}, {"name": "Rectangle", "code": "class Rectangle(Polygon):\n    \"\"\"A quadrilateral with two sets of parallel sides.\n\n    Parameters\n    ----------\n    color\n        The color of the rectangle.\n    height\n        The vertical height of the rectangle.\n    width\n        The horizontal width of the rectangle.\n    grid_xstep\n        Space between vertical grid lines.\n    grid_ystep\n        Space between horizontal grid lines.\n    mark_paths_closed\n        No purpose.\n    close_new_points\n        No purpose.\n    kwargs\n        Additional arguments to be passed to :class:`Polygon`\n\n    Examples\n    ----------\n    .. manim:: RectangleExample\n        :save_last_frame:\n\n        class RectangleExample(Scene):\n            def construct(self):\n                rect1 = Rectangle(width=4.0, height=2.0, grid_xstep=1.0, grid_ystep=0.5)\n                rect2 = Rectangle(width=1.0, height=4.0)\n                rect3 = Rectangle(width=2.0, height=2.0, grid_xstep=1.0, grid_ystep=1.0)\n                rect3.grid_lines.set_stroke(width=1)\n\n                rects = Group(rect1, rect2, rect3).arrange(buff=1)\n                self.add(rects)\n    \"\"\"\n\n    def __init__(\n        self,\n        color: ParsableManimColor = WHITE,\n        height: float = 2.0,\n        width: float = 4.0,\n        grid_xstep: float | None = None,\n        grid_ystep: float | None = None,\n        mark_paths_closed: bool = True,\n        close_new_points: bool = True,\n        **kwargs: Any,\n    ):\n        super().__init__(UR, UL, DL, DR, color=color, **kwargs)\n        self.stretch_to_fit_width(width)\n        self.stretch_to_fit_height(height)\n\n        v = self.get_vertices()\n        self.grid_lines = VGroup()\n\n        if grid_xstep or grid_ystep:\n            from manim.mobject.geometry.line import Line\n\n            v = self.get_vertices()\n\n        if grid_xstep:\n            grid_xstep = abs(grid_xstep)\n            count = int(width / grid_xstep)\n            grid = VGroup(\n                *(\n                    Line(\n                        v[1] + i * grid_xstep * RIGHT,\n                        v[1] + i * grid_xstep * RIGHT + height * DOWN,\n                        color=color,\n                    )\n                    for i in range(1, count)\n                )\n            )\n            self.grid_lines.add(grid)\n\n        if grid_ystep:\n            grid_ystep = abs(grid_ystep)\n            count = int(height / grid_ystep)\n            grid = VGroup(\n                *(\n                    Line(\n                        v[1] + i * grid_ystep * DOWN,\n                        v[1] + i * grid_ystep * DOWN + width * RIGHT,\n                        color=color,\n                    )\n                    for i in range(1, count)\n                )\n            )\n            self.grid_lines.add(grid)\n\n        if self.grid_lines:\n            self.add(self.grid_lines)"}, {"name": "register_font", "code": "def register_font(font_file: str | Path):\n    \"\"\"Temporarily add a font file to Pango's search path.\n\n    This searches for the font_file at various places. The order it searches it described below.\n\n    1. Absolute path.\n    2. In ``assets/fonts`` folder.\n    3. In ``font/`` folder.\n    4. In the same directory.\n\n    Parameters\n    ----------\n    font_file\n        The font file to add.\n\n    Examples\n    --------\n    Use ``with register_font(...)`` to add a font file to search\n    path.\n\n    .. code-block:: python\n\n        with register_font(\"path/to/font_file.ttf\"):\n            a = Text(\"Hello\", font=\"Custom Font Name\")\n\n    Raises\n    ------\n    FileNotFoundError:\n        If the font doesn't exists.\n\n    AttributeError:\n        If this method is used on macOS.\n\n    .. important ::\n\n        This method is available for macOS for ``ManimPango>=v0.2.3``. Using this\n        method with previous releases will raise an :class:`AttributeError` on macOS.\n    \"\"\"\n    input_folder = Path(config.input_file).parent.resolve()\n    possible_paths = [\n        Path(font_file),\n        input_folder / \"assets/fonts\" / font_file,\n        input_folder / \"fonts\" / font_file,\n        input_folder / font_file,\n    ]\n    for path in possible_paths:\n        path = path.resolve()\n        if path.exists():\n            file_path = path\n            logger.debug(\"Found file at %s\", file_path.absolute())\n            break\n    else:\n        error = f\"Can't find {font_file}.Tried these : {possible_paths}\"\n        raise FileNotFoundError(error)\n\n    try:\n        assert manimpango.register_font(str(file_path))\n        yield\n    finally:\n        manimpango.unregister_font(str(file_path))"}, {"name": "regular_vertices", "code": "def regular_vertices(\n    n: int, *, radius: float = 1, start_angle: float | None = None\n) -> tuple[np.ndarray, float]:\n    \"\"\"Generates regularly spaced vertices around a circle centered at the origin.\n\n    Parameters\n    ----------\n    n\n        The number of vertices\n    radius\n        The radius of the circle that the vertices are placed on.\n    start_angle\n        The angle the vertices start at.\n\n        If unspecified, for even ``n`` values, ``0`` will be used.\n        For odd ``n`` values, 90 degrees is used.\n\n    Returns\n    -------\n    vertices : :class:`numpy.ndarray`\n        The regularly spaced vertices.\n    start_angle : :class:`float`\n        The angle the vertices start at.\n    \"\"\"\n    if start_angle is None:\n        start_angle = 0 if n % 2 == 0 else TAU / 4\n\n    start_vector = rotate_vector(RIGHT * radius, start_angle)\n    vertices = compass_directions(n, start_vector)\n\n    return vertices, start_angle"}, {"name": "RegularPolygon", "code": "class RegularPolygon(RegularPolygram):\n    \"\"\"An n-sided regular :class:`Polygon`.\n\n    Parameters\n    ----------\n    n\n        The number of sides of the :class:`RegularPolygon`.\n    kwargs\n        Forwarded to the parent constructor.\n\n    Examples\n    --------\n    .. manim:: RegularPolygonExample\n        :save_last_frame:\n\n        class RegularPolygonExample(Scene):\n            def construct(self):\n                poly_1 = RegularPolygon(n=6)\n                poly_2 = RegularPolygon(n=6, start_angle=30*DEGREES, color=GREEN)\n                poly_3 = RegularPolygon(n=10, color=RED)\n\n                poly_group = Group(poly_1, poly_2, poly_3).scale(1.5).arrange(buff=1)\n                self.add(poly_group)\n    \"\"\"\n\n    def __init__(self, n: int = 6, **kwargs: Any) -> None:\n        super().__init__(n, density=1, **kwargs)"}, {"name": "RegularPolygram", "code": "class RegularPolygram(Polygram):\n    \"\"\"A :class:`Polygram` with regularly spaced vertices.\n\n    Parameters\n    ----------\n    num_vertices\n        The number of vertices.\n    density\n        The density of the :class:`RegularPolygram`.\n\n        Can be thought of as how many vertices to hop\n        to draw a line between them. Every ``density``-th\n        vertex is connected.\n    radius\n        The radius of the circle that the vertices are placed on.\n    start_angle\n        The angle the vertices start at; the rotation of\n        the :class:`RegularPolygram`.\n    kwargs\n        Forwarded to the parent constructor.\n\n    Examples\n    --------\n    .. manim:: RegularPolygramExample\n        :save_last_frame:\n\n        class RegularPolygramExample(Scene):\n            def construct(self):\n                pentagram = RegularPolygram(5, radius=2)\n                self.add(pentagram)\n    \"\"\"\n\n    def __init__(\n        self,\n        num_vertices: int,\n        *,\n        density: int = 2,\n        radius: float = 1,\n        start_angle: float | None = None,\n        **kwargs: Any,\n    ) -> None:\n        # Regular polygrams can be expressed by the number of their vertices\n        # and their density. This relation can be expressed as its Schl\u00e4fli\n        # symbol: {num_vertices/density}.\n        #\n        # For instance, a pentagon can be expressed as {5/1} or just {5}.\n        # A pentagram, however, can be expressed as {5/2}.\n        # A hexagram *would* be expressed as {6/2}, except that 6 and 2\n        # are not coprime, and it can be simplified to 2{3}, which corresponds\n        # to the fact that a hexagram is actually made up of 2 triangles.\n        #\n        # See https://en.wikipedia.org/wiki/Polygram_(geometry)#Generalized_regular_polygons\n        # for more information.\n\n        num_gons = np.gcd(num_vertices, density)\n        num_vertices //= num_gons\n        density //= num_gons\n\n        # Utility function for generating the individual\n        # polygon vertices.\n        def gen_polygon_vertices(start_angle: float | None) -> tuple[list[Any], float]:\n            reg_vertices, start_angle = regular_vertices(\n                num_vertices,\n                radius=radius,\n                start_angle=start_angle,\n            )\n\n            vertices = []\n            i = 0\n            while True:\n                vertices.append(reg_vertices[i])\n\n                i += density\n                i %= num_vertices\n                if i == 0:\n                    break\n\n            return vertices, start_angle\n\n        first_group, self.start_angle = gen_polygon_vertices(start_angle)\n        vertex_groups = [first_group]\n\n        for i in range(1, num_gons):\n            start_angle = self.start_angle + (i / num_gons) * TAU / num_vertices\n            group, _ = gen_polygon_vertices(start_angle)\n\n            vertex_groups.append(group)\n\n        super().__init__(*vertex_groups, **kwargs)"}, {"name": "remove_invisible_chars", "code": "def remove_invisible_chars(mobject: SVGMobject) -> SVGMobject:\n    \"\"\"Function to remove unwanted invisible characters from some mobjects.\n\n    Parameters\n    ----------\n    mobject\n        Any SVGMobject from which we want to remove unwanted invisible characters.\n\n    Returns\n    -------\n    :class:`~.SVGMobject`\n        The SVGMobject without unwanted invisible characters.\n    \"\"\"\n    # TODO: Refactor needed\n    iscode = False\n    if mobject.__class__.__name__ == \"Text\":\n        mobject = mobject[:]\n    elif mobject.__class__.__name__ == \"Code\":\n        iscode = True\n        code = mobject\n        mobject = mobject.code\n    mobject_without_dots = VGroup()\n    if mobject[0].__class__ == VGroup:\n        for i in range(len(mobject)):\n            mobject_without_dots.add(VGroup())\n            mobject_without_dots[i].add(*(k for k in mobject[i] if k.__class__ != Dot))\n    else:\n        mobject_without_dots.add(*(k for k in mobject if k.__class__ != Dot))\n    if iscode:\n        code.code = mobject_without_dots\n        return code\n    return mobject_without_dots"}, {"name": "remove_list_redundancies", "code": "def remove_list_redundancies(lst: Reversible[H]) -> list[H]:\n    \"\"\"Used instead of ``list(set(l))`` to maintain order.\n    Keeps the last occurrence of each element.\n    \"\"\"\n    reversed_result = []\n    used = set()\n    for x in reversed(lst):\n        if x not in used:\n            reversed_result.append(x)\n            used.add(x)\n    reversed_result.reverse()\n    return reversed_result"}, {"name": "remove_nones", "code": "def remove_nones(sequence: Iterable[T | None]) -> list[T]:\n    \"\"\"Removes elements where bool(x) evaluates to False.\n\n    Examples\n    --------\n    .. code-block:: pycon\n\n        >>> remove_nones([\"m\", \"\", \"l\", 0, 42, False, True])\n        ['m', 'l', 42, True]\n    \"\"\"\n    # Note this is redundant with it.chain\n    return [x for x in sequence if x]"}, {"name": "RemoveTextLetterByLetter", "code": "class RemoveTextLetterByLetter(AddTextLetterByLetter):\n    \"\"\"Remove a :class:`~.Text` letter by letter from the scene.\n\n    Parameters\n    ----------\n    time_per_char\n        Frequency of appearance of the letters.\n\n    .. tip::\n\n        This is currently only possible for class:`~.Text` and not for class:`~.MathTex`\n\n    \"\"\"\n\n    def __init__(\n        self,\n        text: Text,\n        suspend_mobject_updating: bool = False,\n        int_func: Callable[[np.ndarray], np.ndarray] = np.ceil,\n        rate_func: Callable[[float], float] = linear,\n        time_per_char: float = 0.1,\n        run_time: float | None = None,\n        reverse_rate_function=True,\n        introducer=False,\n        remover=True,\n        **kwargs,\n    ) -> None:\n        super().__init__(\n            text,\n            suspend_mobject_updating=suspend_mobject_updating,\n            int_func=int_func,\n            rate_func=rate_func,\n            time_per_char=time_per_char,\n            run_time=run_time,\n            reverse_rate_function=reverse_rate_function,\n            introducer=introducer,\n            remover=remover,\n            **kwargs,\n        )"}, {"name": "render", "code": "def render(**kwargs: Any) -> ClickArgs | dict[str, Any]:\n    \"\"\"Render SCENE(S) from the input FILE.\n\n    FILE is the file path of the script or a config file.\n\n    SCENES is an optional list of scenes in the file.\n    \"\"\"\n    if kwargs[\"save_as_gif\"]:\n        logger.warning(\"--save_as_gif is deprecated, please use --format=gif instead!\")\n        kwargs[\"format\"] = \"gif\"\n\n    if kwargs[\"save_pngs\"]:\n        logger.warning(\"--save_pngs is deprecated, please use --format=png instead!\")\n        kwargs[\"format\"] = \"png\"\n\n    if kwargs[\"show_in_file_browser\"]:\n        logger.warning(\n            \"The short form of show_in_file_browser is deprecated and will be moved to support --format.\",\n        )\n\n    click_args = ClickArgs(kwargs)\n    if kwargs[\"jupyter\"]:\n        return click_args\n\n    config.digest_args(click_args)\n    file = Path(config.input_file)\n    if config.renderer == RendererType.OPENGL:\n        from manim.renderer.opengl_renderer import OpenGLRenderer\n\n        try:\n            renderer = OpenGLRenderer()\n            keep_running = True\n            while keep_running:\n                for SceneClass in scene_classes_from_file(file):\n                    with tempconfig({}):\n                        scene = SceneClass(renderer)\n                        rerun = scene.render()\n                    if rerun or config[\"write_all\"]:\n                        renderer.num_plays = 0\n                        continue\n                    else:\n                        keep_running = False\n                        break\n                if config[\"write_all\"]:\n                    keep_running = False\n\n        except Exception:\n            error_console.print_exception()\n            sys.exit(1)\n    else:\n        for SceneClass in scene_classes_from_file(file):\n            try:\n                with tempconfig({}):\n                    scene = SceneClass()\n                    scene.render()\n            except Exception:\n                error_console.print_exception()\n                sys.exit(1)\n\n    if config.notify_outdated_version:\n        manim_info_url = \"https://pypi.org/pypi/manim/json\"\n        warn_prompt = \"Cannot check if latest release of manim is installed\"\n\n        try:\n            with urllib.request.urlopen(\n                urllib.request.Request(manim_info_url),\n                timeout=10,\n            ) as response:\n                response = cast(http.client.HTTPResponse, response)\n                json_data = json.loads(response.read())\n        except urllib.error.HTTPError:\n            logger.debug(\"HTTP Error: %s\", warn_prompt)\n        except urllib.error.URLError:\n            logger.debug(\"URL Error: %s\", warn_prompt)\n        except json.JSONDecodeError:\n            logger.debug(\n                \"Error while decoding JSON from %r: %s\", manim_info_url, warn_prompt\n            )\n        except Exception:\n            logger.debug(\"Something went wrong: %s\", warn_prompt)\n        else:\n            stable = json_data[\"info\"][\"version\"]\n            if stable != __version__:\n                console.print(\n                    f\"You are using manim version [red]v{__version__}[/red], but version [green]v{stable}[/green] is available.\",\n                )\n                console.print(\n                    \"You should consider upgrading via [yellow]pip install -U manim[/yellow]\",\n                )\n\n    return kwargs"}, {"name": "render_mobject_fills_with_matrix", "code": "def render_mobject_fills_with_matrix(renderer, model_matrix, mobjects):\n    # Precompute the total number of vertices for which to reserve space.\n    # Note that triangulate_mobject() will cache its results.\n    total_size = 0\n    for submob in mobjects:\n        total_size += triangulate_mobject(submob).shape[0]\n\n    attributes = np.empty(\n        total_size,\n        dtype=[\n            (\"in_vert\", np.float32, (3,)),\n            (\"in_color\", np.float32, (4,)),\n            (\"texture_coords\", np.float32, (2,)),\n            (\"texture_mode\", np.int32),\n        ],\n    )\n\n    write_offset = 0\n    for submob in mobjects:\n        if not submob.has_points():\n            continue\n        mobject_triangulation = triangulate_mobject(submob)\n        end_offset = write_offset + mobject_triangulation.shape[0]\n        attributes[write_offset:end_offset] = mobject_triangulation\n        attributes[\"in_color\"][write_offset:end_offset] = np.repeat(\n            submob.fill_rgba,\n            mobject_triangulation.shape[0],\n            axis=0,\n        )\n        write_offset = end_offset\n\n    fill_shader = Shader(renderer.context, name=\"vectorized_mobject_fill\")\n    fill_shader.set_uniform(\n        \"u_model_view_matrix\",\n        opengl.matrix_to_shader_input(\n            renderer.camera.unformatted_view_matrix @ model_matrix,\n        ),\n    )\n    fill_shader.set_uniform(\n        \"u_projection_matrix\",\n        renderer.scene.camera.projection_matrix,\n    )\n\n    vbo = renderer.context.buffer(attributes.tobytes())\n    vao = renderer.context.simple_vertex_array(\n        fill_shader.shader_program,\n        vbo,\n        *attributes.dtype.names,\n    )\n    vao.render()\n    vao.release()\n    vbo.release()"}, {"name": "render_mobject_strokes_with_matrix", "code": "def render_mobject_strokes_with_matrix(renderer, model_matrix, mobjects):\n    # Precompute the total number of vertices for which to reserve space.\n    total_size = 0\n    for submob in mobjects:\n        total_size += submob.points.shape[0]\n\n    points = np.empty((total_size, 3))\n    colors = np.empty((total_size, 4))\n    widths = np.empty(total_size)\n\n    write_offset = 0\n    for submob in mobjects:\n        if not submob.has_points():\n            continue\n        end_offset = write_offset + submob.points.shape[0]\n\n        points[write_offset:end_offset] = submob.points\n        if submob.stroke_rgba.shape[0] == points[write_offset:end_offset].shape[0]:\n            colors[write_offset:end_offset] = submob.stroke_rgba\n        else:\n            colors[write_offset:end_offset] = np.repeat(\n                submob.stroke_rgba,\n                submob.points.shape[0],\n                axis=0,\n            )\n        widths[write_offset:end_offset] = np.repeat(\n            submob.stroke_width,\n            submob.points.shape[0],\n        )\n        write_offset = end_offset\n\n    stroke_data = np.zeros(\n        len(points),\n        dtype=[\n            # (\"previous_curve\", np.float32, (3, 3)),\n            (\"current_curve\", np.float32, (3, 3)),\n            # (\"next_curve\", np.float32, (3, 3)),\n            (\"tile_coordinate\", np.float32, (2,)),\n            (\"in_color\", np.float32, (4,)),\n            (\"in_width\", np.float32),\n        ],\n    )\n\n    stroke_data[\"in_color\"] = colors\n    stroke_data[\"in_width\"] = widths\n    curves = np.reshape(points, (-1, 3, 3))\n    # stroke_data[\"previous_curve\"] = np.repeat(np.roll(curves, 1, axis=0), 3, axis=0)\n    stroke_data[\"current_curve\"] = np.repeat(curves, 3, axis=0)\n    # stroke_data[\"next_curve\"] = np.repeat(np.roll(curves, -1, axis=0), 3, axis=0)\n\n    # Repeat each vertex in order to make a tile.\n    stroke_data = np.tile(stroke_data, 2)\n    stroke_data[\"tile_coordinate\"] = np.vstack(\n        (\n            np.tile(\n                [\n                    [0.0, 0.0],\n                    [0.0, 1.0],\n                    [1.0, 1.0],\n                ],\n                (len(points) // 3, 1),\n            ),\n            np.tile(\n                [\n                    [0.0, 0.0],\n                    [1.0, 0.0],\n                    [1.0, 1.0],\n                ],\n                (len(points) // 3, 1),\n            ),\n        ),\n    )\n\n    shader = Shader(renderer.context, \"vectorized_mobject_stroke\")\n    shader.set_uniform(\n        \"u_model_view_matrix\",\n        opengl.matrix_to_shader_input(\n            renderer.camera.unformatted_view_matrix @ model_matrix,\n        ),\n    )\n    shader.set_uniform(\"u_projection_matrix\", renderer.scene.camera.projection_matrix)\n    shader.set_uniform(\"manim_unit_normal\", tuple(-mobjects[0].unit_normal[0]))\n\n    vbo = renderer.context.buffer(stroke_data.tobytes())\n    vao = renderer.context.simple_vertex_array(\n        shader.shader_program, vbo, *stroke_data.dtype.names\n    )\n    renderer.frame_buffer_object.use()\n    vao.render()\n    vao.release()\n    vbo.release()"}, {"name": "render_opengl_vectorized_mobject_fill", "code": "def render_opengl_vectorized_mobject_fill(renderer, mobject):\n    matrix_to_mobject_list = build_matrix_lists(mobject)\n\n    for matrix_tuple, mobject_list in matrix_to_mobject_list.items():\n        model_matrix = np.array(matrix_tuple).reshape((4, 4))\n        render_mobject_fills_with_matrix(renderer, model_matrix, mobject_list)"}, {"name": "render_opengl_vectorized_mobject_stroke", "code": "def render_opengl_vectorized_mobject_stroke(renderer, mobject):\n    matrix_to_mobject_list = build_matrix_lists(mobject)\n    for matrix_tuple, mobject_list in matrix_to_mobject_list.items():\n        model_matrix = np.array(matrix_tuple).reshape((4, 4))\n        render_mobject_strokes_with_matrix(renderer, model_matrix, mobject_list)"}, {"name": "RendererType", "code": "class RendererType(Enum):\n    \"\"\"An enumeration of all renderer types that can be assigned to\n    the ``config.renderer`` attribute.\n\n    Manim's configuration allows assigning string values to the renderer\n    setting, the values are then replaced by the corresponding enum object.\n    In other words, you can run::\n\n        config.renderer = \"opengl\"\n\n    and checking the renderer afterwards reveals that the attribute has\n    assumed the value::\n\n        <RendererType.OPENGL: 'opengl'>\n    \"\"\"\n\n    CAIRO = \"cairo\"  #: A renderer based on the cairo backend.\n    OPENGL = \"opengl\""}, {"name": "replace_keys", "code": "def replace_keys(default: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"Replace ``_`` with ``.`` and vice versa in a dictionary's keys for\n    ``rich``.\n\n    Parameters\n    ----------\n    default\n        The dictionary whose keys will be checked and replaced.\n\n    Returns\n    -------\n    :class:`dict`\n        The dictionary whose keys are modified by replacing ``_`` with ``.``\n        and vice versa.\n    \"\"\"\n    for key in default:\n        if \"_\" in key:\n            temp = default[key]\n            del default[key]\n            key = key.replace(\"_\", \".\")\n            default[key] = temp\n        else:\n            temp = default[key]\n            del default[key]\n            key = key.replace(\".\", \"_\")\n            default[key] = temp\n    return default"}, {"name": "ReplacementTransform", "code": "class ReplacementTransform(Transform):\n    \"\"\"Replaces and morphs a mobject into a target mobject.\n\n    Parameters\n    ----------\n    mobject\n        The starting :class:`~.Mobject`.\n    target_mobject\n        The target :class:`~.Mobject`.\n    kwargs\n        Further keyword arguments that are passed to :class:`Transform`.\n\n    Examples\n    --------\n\n    .. manim:: ReplacementTransformOrTransform\n        :quality: low\n\n        class ReplacementTransformOrTransform(Scene):\n            def construct(self):\n                # set up the numbers\n                r_transform = VGroup(*[Integer(i) for i in range(1,4)])\n                text_1 = Text(\"ReplacementTransform\", color=RED)\n                r_transform.add(text_1)\n\n                transform = VGroup(*[Integer(i) for i in range(4,7)])\n                text_2 = Text(\"Transform\", color=BLUE)\n                transform.add(text_2)\n\n                ints = VGroup(r_transform, transform)\n                texts = VGroup(text_1, text_2).scale(0.75)\n                r_transform.arrange(direction=UP, buff=1)\n                transform.arrange(direction=UP, buff=1)\n\n                ints.arrange(buff=2)\n                self.add(ints, texts)\n\n                # The mobs replace each other and none are left behind\n                self.play(ReplacementTransform(r_transform[0], r_transform[1]))\n                self.play(ReplacementTransform(r_transform[1], r_transform[2]))\n\n                # The mobs linger after the Transform()\n                self.play(Transform(transform[0], transform[1]))\n                self.play(Transform(transform[1], transform[2]))\n                self.wait()\n\n    \"\"\"\n\n    def __init__(self, mobject: Mobject, target_mobject: Mobject, **kwargs) -> None:\n        super().__init__(\n            mobject, target_mobject, replace_mobject_with_target_in_scene=True, **kwargs\n        )"}, {"name": "RerunSceneException", "code": "class RerunSceneException(Exception):\n    pass"}, {"name": "RerunSceneHandler", "code": "class RerunSceneHandler(FileSystemEventHandler):\n    \"\"\"A class to handle rerunning a Scene after the input file is modified.\"\"\"\n\n    def __init__(self, queue):\n        super().__init__()\n        self.queue = queue\n\n    def on_modified(self, event):\n        self.queue.put((\"rerun_file\", [], {}))"}, {"name": "resize_array", "code": "def resize_array(nparray: npt.NDArray[F], length: int) -> npt.NDArray[F]:\n    \"\"\"Extends/truncates nparray so that ``len(result) == length``.\n        The elements of nparray are cycled to achieve the desired length.\n\n    See Also\n    --------\n    resize_preserving_order : favours earlier elements instead of cycling them\n    make_even_by_cycling : similar cycling behaviour for balancing 2 iterables\n\n    Examples\n    --------\n    .. code-block:: pycon\n\n        >>> points = np.array([[1, 2], [3, 4]])\n        >>> resize_array(points, 1)\n        array([[1, 2]])\n        >>> resize_array(points, 3)\n        array([[1, 2],\n               [3, 4],\n               [1, 2]])\n        >>> resize_array(points, 2)\n        array([[1, 2],\n               [3, 4]])\n    \"\"\"\n    if len(nparray) == length:\n        return nparray\n    return np.resize(nparray, (length, *nparray.shape[1:]))"}, {"name": "resize_preserving_order", "code": "def resize_preserving_order(\n    nparray: npt.NDArray[np.float64], length: int\n) -> npt.NDArray[np.float64]:\n    \"\"\"Extends/truncates nparray so that ``len(result) == length``.\n        The elements of nparray are duplicated to achieve the desired length\n        (favours earlier elements).\n\n        Constructs a zeroes array of length if nparray is empty.\n\n    See Also\n    --------\n    resize_array : cycles elements instead of favouring earlier ones\n    make_even : similar earlier-favouring behaviour for balancing 2 iterables\n\n    Examples\n    --------\n    .. code-block:: pycon\n\n        >>> resize_preserving_order(np.array([]), 5)\n        array([0., 0., 0., 0., 0.])\n\n        >>> nparray = np.array([[1, 2], [3, 4]])\n        >>> resize_preserving_order(nparray, 1)\n        array([[1, 2]])\n\n        >>> resize_preserving_order(nparray, 3)\n        array([[1, 2],\n               [1, 2],\n               [3, 4]])\n    \"\"\"\n    if len(nparray) == 0:\n        return np.zeros((length, *nparray.shape[1:]))\n    if len(nparray) == length:\n        return nparray\n    indices = np.arange(length) * len(nparray) // length\n    return nparray[indices]"}, {"name": "resize_with_interpolation", "code": "def resize_with_interpolation(nparray: npt.NDArray[F], length: int) -> npt.NDArray[F]:\n    \"\"\"Extends/truncates nparray so that ``len(result) == length``.\n        New elements are interpolated to achieve the desired length.\n\n        Note that if nparray's length changes, its dtype may too\n        (e.g. int -> float: see Examples)\n\n    See Also\n    --------\n    resize_array : cycles elements instead of interpolating\n    resize_preserving_order : favours earlier elements instead of interpolating\n\n    Examples\n    --------\n    .. code-block:: pycon\n\n        >>> nparray = np.array([[1, 2], [3, 4]])\n        >>> resize_with_interpolation(nparray, 1)\n        array([[1., 2.]])\n        >>> resize_with_interpolation(nparray, 4)\n        array([[1.        , 2.        ],\n               [1.66666667, 2.66666667],\n               [2.33333333, 3.33333333],\n               [3.        , 4.        ]])\n        >>> nparray = np.array([[[1, 2], [3, 4]]])\n        >>> nparray = np.array([[1, 2], [3, 4], [5, 6]])\n        >>> resize_with_interpolation(nparray, 4)\n        array([[1.        , 2.        ],\n               [2.33333333, 3.33333333],\n               [3.66666667, 4.66666667],\n               [5.        , 6.        ]])\n        >>> nparray = np.array([[1, 2], [3, 4], [1, 2]])\n        >>> resize_with_interpolation(nparray, 4)\n        array([[1.        , 2.        ],\n               [2.33333333, 3.33333333],\n               [2.33333333, 3.33333333],\n               [1.        , 2.        ]])\n    \"\"\"\n    if len(nparray) == length:\n        return nparray\n    cont_indices = np.linspace(0, len(nparray) - 1, length)\n    return np.array(\n        [\n            (1 - a) * nparray[lh] + a * nparray[rh]\n            for ci in cont_indices\n            for lh, rh, a in [(int(ci), int(np.ceil(ci)), ci % 1)]\n        ],\n    )"}, {"name": "Restore", "code": "class Restore(ApplyMethod):\n    \"\"\"Transforms a mobject to its last saved state.\n\n    To save the state of a mobject, use the :meth:`~.Mobject.save_state` method.\n\n    Examples\n    --------\n\n    .. manim:: RestoreExample\n\n        class RestoreExample(Scene):\n            def construct(self):\n                s = Square()\n                s.save_state()\n                self.play(FadeIn(s))\n                self.play(s.animate.set_color(PURPLE).set_opacity(0.5).shift(2*LEFT).scale(3))\n                self.play(s.animate.shift(5*DOWN).rotate(PI/4))\n                self.wait()\n                self.play(Restore(s), run_time=2)\n\n    \"\"\"\n\n    def __init__(self, mobject: Mobject, **kwargs) -> None:\n        super().__init__(mobject.restore, **kwargs)"}, {"name": "restructure_list_to_exclude_certain_family_members", "code": "def restructure_list_to_exclude_certain_family_members(\n    mobject_list: list[Mobject], to_remove: list[Mobject]\n) -> list[Mobject]:\n    \"\"\"\n    Removes anything in to_remove from mobject_list, but in the event that one of\n    the items to be removed is a member of the family of an item in mobject_list,\n    the other family members are added back into the list.\n\n    This is useful in cases where a scene contains a group, e.g. Group(m1, m2, m3),\n    but one of its submobjects is removed, e.g. scene.remove(m1), it's useful\n    for the list of mobject_list to be edited to contain other submobjects, but not m1.\n    \"\"\"\n    new_list: list[Mobject] = []\n    to_remove = extract_mobject_family_members(to_remove)\n\n    def add_safe_mobjects_from_list(\n        list_to_examine: list[Mobject], set_to_remove: set[Mobject]\n    ) -> None:\n        for mob in list_to_examine:\n            if mob in set_to_remove:\n                continue\n            intersect = set_to_remove.intersection(mob.get_family())\n            if intersect:\n                add_safe_mobjects_from_list(mob.submobjects, intersect)\n            else:\n                new_list.append(mob)\n\n    add_safe_mobjects_from_list(mobject_list, set(to_remove))\n    return new_list"}, {"name": "rgb_to_color", "code": "def rgb_to_color(\n    rgb: RGB_Array_Float | RGB_Tuple_Float | RGB_Array_Int | RGB_Tuple_Int,\n) -> ManimColor:\n    \"\"\"Helper function for use in functional style programming. Refer to\n    :meth:`ManimColor.from_rgb`.\n\n    Parameters\n    ----------\n    rgb\n        A 3 element iterable.\n\n    Returns\n    -------\n    ManimColor\n        A ManimColor with the corresponding value.\n    \"\"\"\n    return ManimColor.from_rgb(rgb)"}, {"name": "rgb_to_hex", "code": "def rgb_to_hex(\n    rgb: RGB_Array_Float | RGB_Tuple_Float | RGB_Array_Int | RGB_Tuple_Int,\n) -> str:\n    \"\"\"Helper function for use in functional style programming. Refer to\n    :meth:`ManimColor.from_rgb` and :meth:`ManimColor.to_hex`.\n\n    Parameters\n    ----------\n    rgb\n        A 3 element iterable.\n\n    Returns\n    -------\n    str\n        A hex representation of the color.\n    \"\"\"\n    return ManimColor.from_rgb(rgb).to_hex()"}, {"name": "rgba_to_color", "code": "def rgba_to_color(\n    rgba: RGBA_Array_Float | RGBA_Tuple_Float | RGBA_Array_Int | RGBA_Tuple_Int,\n) -> ManimColor:\n    \"\"\"Helper function for use in functional style programming. Refer to\n    :meth:`ManimColor.from_rgba`.\n\n    Parameters\n    ----------\n    rgba\n        A 4 element iterable.\n\n    Returns\n    -------\n    ManimColor\n        A ManimColor with the corresponding value\n    \"\"\"\n    return ManimColor.from_rgba(rgba)"}, {"name": "RightAngle", "code": "class RightAngle(Angle):\n    \"\"\"An elbow-type mobject representing a right angle between two lines.\n\n    Parameters\n    ----------\n    line1\n        The first line.\n    line2\n        The second line.\n    length\n        The length of the arms.\n    **kwargs\n        Further keyword arguments that are passed to the constructor of :class:`Angle`.\n\n    Examples\n    --------\n    .. manim:: RightAngleExample\n        :save_last_frame:\n\n        class RightAngleExample(Scene):\n            def construct(self):\n                line1 = Line( LEFT, RIGHT )\n                line2 = Line( DOWN, UP )\n                rightangles = [\n                    RightAngle(line1, line2),\n                    RightAngle(line1, line2, length=0.4, quadrant=(1,-1)),\n                    RightAngle(line1, line2, length=0.5, quadrant=(-1,1), stroke_width=8),\n                    RightAngle(line1, line2, length=0.7, quadrant=(-1,-1), color=RED),\n                ]\n                plots = VGroup()\n                for rightangle in rightangles:\n                    plot=VGroup(line1.copy(),line2.copy(), rightangle)\n                    plots.add(plot)\n                plots.arrange(buff=1.5)\n                self.add(plots)\n    \"\"\"\n\n    def __init__(\n        self,\n        line1: Line,\n        line2: Line,\n        length: float | None = None,\n        **kwargs: Any,\n    ) -> None:\n        super().__init__(line1, line2, radius=length, elbow=True, **kwargs)"}, {"name": "Rotate", "code": "class Rotate(Transform):\n    \"\"\"Animation that rotates a Mobject.\n\n    Parameters\n    ----------\n    mobject\n        The mobject to be rotated.\n    angle\n        The rotation angle.\n    axis\n        The rotation axis as a numpy vector.\n    about_point\n        The rotation center.\n    about_edge\n        If ``about_point`` is ``None``, this argument specifies\n        the direction of the bounding box point to be taken as\n        the rotation center.\n\n    Examples\n    --------\n    .. manim:: UsingRotate\n\n        class UsingRotate(Scene):\n            def construct(self):\n                self.play(\n                    Rotate(\n                        Square(side_length=0.5).shift(UP * 2),\n                        angle=2*PI,\n                        about_point=ORIGIN,\n                        rate_func=linear,\n                    ),\n                    Rotate(Square(side_length=0.5), angle=2*PI, rate_func=linear),\n                    )\n\n    See also\n    --------\n    :class:`~.Rotating`, :meth:`~.Mobject.rotate`\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        angle: float = PI,\n        axis: np.ndarray = OUT,\n        about_point: Sequence[float] | None = None,\n        about_edge: Sequence[float] | None = None,\n        **kwargs,\n    ) -> None:\n        if \"path_arc\" not in kwargs:\n            kwargs[\"path_arc\"] = angle\n        if \"path_arc_axis\" not in kwargs:\n            kwargs[\"path_arc_axis\"] = axis\n        self.angle = angle\n        self.axis = axis\n        self.about_edge = about_edge\n        self.about_point = about_point\n        if self.about_point is None:\n            self.about_point = mobject.get_center()\n        super().__init__(mobject, path_arc_centers=self.about_point, **kwargs)\n\n    def create_target(self) -> Mobject:\n        target = self.mobject.copy()\n        target.rotate(\n            self.angle,\n            axis=self.axis,\n            about_point=self.about_point,\n            about_edge=self.about_edge,\n        )\n        return target"}, {"name": "rotate_in_place_matrix", "code": "def rotate_in_place_matrix(\n    initial_position: Point3D, x: float = 0, y: float = 0, z: float = 0\n) -> MatrixMN:\n    return np.matmul(\n        translation_matrix(*-initial_position),\n        np.matmul(\n            rotation_matrix(x, y, z),\n            translation_matrix(*initial_position),\n        ),\n    )"}, {"name": "rotate_vector", "code": "def rotate_vector(\n    vector: np.ndarray, angle: float, axis: np.ndarray = OUT\n) -> np.ndarray:\n    \"\"\"Function for rotating a vector.\n\n    Parameters\n    ----------\n    vector\n        The vector to be rotated.\n    angle\n        The angle to be rotated by.\n    axis\n        The axis to be rotated, by default OUT\n\n    Returns\n    -------\n    np.ndarray\n        The rotated vector with provided angle and axis.\n\n    Raises\n    ------\n    ValueError\n        If vector is not of dimension 2 or 3.\n    \"\"\"\n    if len(vector) > 3:\n        raise ValueError(\"Vector must have the correct dimensions.\")\n    if len(vector) == 2:\n        vector = np.append(vector, 0)\n    return rotation_matrix(angle, axis) @ vector"}, {"name": "Rotating", "code": "class Rotating(Animation):\n    \"\"\"Animation that rotates a Mobject.\n\n    Parameters\n    ----------\n    mobject\n        The mobject to be rotated.\n    angle\n        The rotation angle in radians. Predefined constants such as ``DEGREES``\n        can also be used to specify the angle in degrees.\n    axis\n        The rotation axis as a numpy vector.\n    about_point\n        The rotation center.\n    about_edge\n        If ``about_point`` is ``None``, this argument specifies\n        the direction of the bounding box point to be taken as\n        the rotation center.\n    run_time\n        The duration of the animation in seconds.\n    rate_func\n        The function defining the animation progress based on the relative\n        runtime (see :mod:`~.rate_functions`) .\n    **kwargs\n        Additional keyword arguments passed to :class:`~.Animation`.\n\n    Examples\n    --------\n    .. manim:: RotatingDemo\n\n        class RotatingDemo(Scene):\n            def construct(self):\n                circle = Circle(radius=1, color=BLUE)\n                line = Line(start=ORIGIN, end=RIGHT)\n                arrow = Arrow(start=ORIGIN, end=RIGHT, buff=0, color=GOLD)\n                vg = VGroup(circle,line,arrow)\n                self.add(vg)\n                anim_kw = {\"about_point\": arrow.get_start(), \"run_time\": 1}\n                self.play(Rotating(arrow, 180*DEGREES, **anim_kw))\n                self.play(Rotating(arrow, PI, **anim_kw))\n                self.play(Rotating(vg, PI, about_point=RIGHT))\n                self.play(Rotating(vg, PI, axis=UP, about_point=ORIGIN))\n                self.play(Rotating(vg, PI, axis=RIGHT, about_edge=UP))\n                self.play(vg.animate.move_to(ORIGIN))\n\n    .. manim:: RotatingDifferentAxis\n\n        class RotatingDifferentAxis(ThreeDScene):\n            def construct(self):\n                axes = ThreeDAxes()\n                cube = Cube()\n                arrow2d = Arrow(start=[0, -1.2, 1], end=[0, 1.2, 1], color=YELLOW_E)\n                cube_group = VGroup(cube,arrow2d)\n                self.set_camera_orientation(gamma=0, phi=40*DEGREES, theta=40*DEGREES)\n                self.add(axes, cube_group)\n                play_kw = {\"run_time\": 1.5}\n                self.play(Rotating(cube_group, PI), **play_kw)\n                self.play(Rotating(cube_group, PI, axis=UP), **play_kw)\n                self.play(Rotating(cube_group, 180*DEGREES, axis=RIGHT), **play_kw)\n                self.wait(0.5)\n\n    See also\n    --------\n    :class:`~.Rotate`, :meth:`~.Mobject.rotate`\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        angle: float = TAU,\n        axis: np.ndarray = OUT,\n        about_point: np.ndarray | None = None,\n        about_edge: np.ndarray | None = None,\n        run_time: float = 5,\n        rate_func: Callable[[float], float] = linear,\n        **kwargs,\n    ) -> None:\n        self.angle = angle\n        self.axis = axis\n        self.about_point = about_point\n        self.about_edge = about_edge\n        super().__init__(mobject, run_time=run_time, rate_func=rate_func, **kwargs)\n\n    def interpolate_mobject(self, alpha: float) -> None:\n        self.mobject.become(self.starting_mobject)\n        self.mobject.rotate(\n            self.rate_func(alpha) * self.angle,\n            axis=self.axis,\n            about_point=self.about_point,\n            about_edge=self.about_edge,\n        )"}, {"name": "rotation_about_z", "code": "def rotation_about_z(angle: float) -> np.ndarray:\n    \"\"\"Returns a rotation matrix for a given angle.\n\n    Parameters\n    ----------\n    angle\n        Angle for the rotation matrix.\n\n    Returns\n    -------\n    np.ndarray\n        Gives back the rotated matrix.\n    \"\"\"\n    c, s = np.cos(angle), np.sin(angle)\n    return np.array(\n        [\n            [c, -s, 0],\n            [s, c, 0],\n            [0, 0, 1],\n        ]\n    )"}, {"name": "rotation_matrix", "code": "def rotation_matrix(\n    angle: float,\n    axis: np.ndarray,\n    homogeneous: bool = False,\n) -> np.ndarray:\n    \"\"\"Rotation in R^3 about a specified axis of rotation.\"\"\"\n    inhomogeneous_rotation_matrix = Rotation.from_rotvec(\n        angle * normalize(np.array(axis))\n    ).as_matrix()\n    if not homogeneous:\n        return inhomogeneous_rotation_matrix\n    else:\n        rotation_matrix = np.eye(4)\n        rotation_matrix[:3, :3] = inhomogeneous_rotation_matrix\n        return rotation_matrix"}, {"name": "rotation_matrix_from_quaternion", "code": "def rotation_matrix_from_quaternion(quat: np.ndarray) -> np.ndarray:\n    return np.transpose(rotation_matrix_transpose_from_quaternion(quat))"}, {"name": "rotation_matrix_transpose", "code": "def rotation_matrix_transpose(angle: float, axis: np.ndarray) -> np.ndarray:\n    if all(np.array(axis)[:2] == np.zeros(2)):\n        return rotation_about_z(angle * np.sign(axis[2])).T\n    return rotation_matrix(angle, axis).T"}, {"name": "rotation_matrix_transpose_from_quaternion", "code": "def rotation_matrix_transpose_from_quaternion(quat: np.ndarray) -> list[np.ndarray]:\n    \"\"\"Converts the quaternion, quat, to an equivalent rotation matrix representation.\n    For more information, check `this page\n    <https://in.mathworks.com/help/driving/ref/quaternion.rotmat.html>`_.\n\n    Parameters\n    ----------\n    quat\n        The quaternion which is to be converted.\n\n    Returns\n    -------\n    List[np.ndarray]\n        Gives back the Rotation matrix representation, returned as a 3-by-3\n        matrix or 3-by-3-by-N multidimensional array.\n    \"\"\"\n    quat_inv = quaternion_conjugate(quat)\n    return [\n        quaternion_mult(quat, [0, *basis], quat_inv)[1:]\n        for basis in [\n            [1, 0, 0],\n            [0, 1, 0],\n            [0, 0, 1],\n        ]\n    ]"}, {"name": "RoundedRectangle", "code": "class RoundedRectangle(Rectangle):\n    \"\"\"A rectangle with rounded corners.\n\n    Parameters\n    ----------\n    corner_radius\n        The curvature of the corners of the rectangle.\n    kwargs\n        Additional arguments to be passed to :class:`Rectangle`\n\n    Examples\n    --------\n    .. manim:: RoundedRectangleExample\n        :save_last_frame:\n\n        class RoundedRectangleExample(Scene):\n            def construct(self):\n                rect_1 = RoundedRectangle(corner_radius=0.5)\n                rect_2 = RoundedRectangle(corner_radius=1.5, height=4.0, width=4.0)\n\n                rect_group = Group(rect_1, rect_2).arrange(buff=1)\n                self.add(rect_group)\n    \"\"\"\n\n    def __init__(self, corner_radius: float | list[float] = 0.5, **kwargs: Any):\n        super().__init__(**kwargs)\n        self.corner_radius = corner_radius\n        self.round_corners(self.corner_radius)"}, {"name": "running_start", "code": "def running_start(\n    t: float,\n    pull_factor: float = -0.5,\n) -> float:\n    t2 = t * t\n    t3 = t2 * t\n    t4 = t3 * t\n    t5 = t4 * t\n    t6 = t5 * t\n    mt = 1 - t\n    mt2 = mt * mt\n    mt3 = mt2 * mt\n    mt4 = mt3 * mt\n\n    # This is equivalent to creating a B\u00e9zier with [0, 0, pull_factor, pull_factor, 1, 1, 1]\n    # and evaluating it at t.\n    return (\n        15 * t2 * mt4 * pull_factor\n        + 20 * t3 * mt3 * pull_factor\n        + 15 * t4 * mt2\n        + 6 * t5 * mt\n        + t6\n    )"}, {"name": "rush_from", "code": "def rush_from(t: float, inflection: float = 10.0) -> float:\n    return 2 * smooth(t / 2.0 + 0.5, inflection) - 1"}, {"name": "rush_into", "code": "def rush_into(t: float, inflection: float = 10.0) -> float:\n    return 2 * smooth(t / 2.0, inflection)"}, {"name": "SampleSpace", "code": "class SampleSpace(Rectangle):\n    \"\"\"A mobject representing a twodimensional rectangular\n    sampling space.\n\n    Examples\n    --------\n    .. manim:: ExampleSampleSpace\n        :save_last_frame:\n\n        class ExampleSampleSpace(Scene):\n            def construct(self):\n                poly1 = SampleSpace(stroke_width=15, fill_opacity=1)\n                poly2 = SampleSpace(width=5, height=3, stroke_width=5, fill_opacity=0.5)\n                poly3 = SampleSpace(width=2, height=2, stroke_width=5, fill_opacity=0.1)\n                poly3.divide_vertically(p_list=np.array([0.37, 0.13, 0.5]), colors=[BLACK, WHITE, GRAY], vect=RIGHT)\n                poly_group = VGroup(poly1, poly2, poly3).arrange()\n                self.add(poly_group)\n    \"\"\"\n\n    def __init__(\n        self,\n        height=3,\n        width=3,\n        fill_color=DARK_GREY,\n        fill_opacity=1,\n        stroke_width=0.5,\n        stroke_color=LIGHT_GREY,\n        default_label_scale_val=1,\n    ):\n        super().__init__(\n            height=height,\n            width=width,\n            fill_color=fill_color,\n            fill_opacity=fill_opacity,\n            stroke_width=stroke_width,\n            stroke_color=stroke_color,\n        )\n        self.default_label_scale_val = default_label_scale_val\n\n    def add_title(self, title=\"Sample space\", buff=MED_SMALL_BUFF):\n        # TODO, should this really exist in SampleSpaceScene\n        title_mob = Tex(title)\n        if title_mob.width > self.width:\n            title_mob.width = self.width\n        title_mob.next_to(self, UP, buff=buff)\n        self.title = title_mob\n        self.add(title_mob)\n\n    def add_label(self, label):\n        self.label = label\n\n    def complete_p_list(self, p_list):\n        new_p_list = list(tuplify(p_list))\n        remainder = 1.0 - sum(new_p_list)\n        if abs(remainder) > EPSILON:\n            new_p_list.append(remainder)\n        return new_p_list\n\n    def get_division_along_dimension(self, p_list, dim, colors, vect):\n        p_list = self.complete_p_list(p_list)\n        colors = color_gradient(colors, len(p_list))\n\n        last_point = self.get_edge_center(-vect)\n        parts = VGroup()\n        for factor, color in zip(p_list, colors):\n            part = SampleSpace()\n            part.set_fill(color, 1)\n            part.replace(self, stretch=True)\n            part.stretch(factor, dim)\n            part.move_to(last_point, -vect)\n            last_point = part.get_edge_center(vect)\n            parts.add(part)\n        return parts\n\n    def get_horizontal_division(self, p_list, colors=[GREEN_E, BLUE_E], vect=DOWN):\n        return self.get_division_along_dimension(p_list, 1, colors, vect)\n\n    def get_vertical_division(self, p_list, colors=[MAROON_B, YELLOW], vect=RIGHT):\n        return self.get_division_along_dimension(p_list, 0, colors, vect)\n\n    def divide_horizontally(self, *args, **kwargs):\n        self.horizontal_parts = self.get_horizontal_division(*args, **kwargs)\n        self.add(self.horizontal_parts)\n\n    def divide_vertically(self, *args, **kwargs):\n        self.vertical_parts = self.get_vertical_division(*args, **kwargs)\n        self.add(self.vertical_parts)\n\n    def get_subdivision_braces_and_labels(\n        self,\n        parts,\n        labels,\n        direction,\n        buff=SMALL_BUFF,\n        min_num_quads=1,\n    ):\n        label_mobs = VGroup()\n        braces = VGroup()\n        for label, part in zip(labels, parts):\n            brace = Brace(part, direction, min_num_quads=min_num_quads, buff=buff)\n            if isinstance(label, (Mobject, OpenGLMobject)):\n                label_mob = label\n            else:\n                label_mob = MathTex(label)\n                label_mob.scale(self.default_label_scale_val)\n            label_mob.next_to(brace, direction, buff)\n\n            braces.add(brace)\n            label_mobs.add(label_mob)\n        parts.braces = braces\n        parts.labels = label_mobs\n        parts.label_kwargs = {\n            \"labels\": label_mobs.copy(),\n            \"direction\": direction,\n            \"buff\": buff,\n        }\n        return VGroup(parts.braces, parts.labels)\n\n    def get_side_braces_and_labels(self, labels, direction=LEFT, **kwargs):\n        assert hasattr(self, \"horizontal_parts\")\n        parts = self.horizontal_parts\n        return self.get_subdivision_braces_and_labels(\n            parts, labels, direction, **kwargs\n        )\n\n    def get_top_braces_and_labels(self, labels, **kwargs):\n        assert hasattr(self, \"vertical_parts\")\n        parts = self.vertical_parts\n        return self.get_subdivision_braces_and_labels(parts, labels, UP, **kwargs)\n\n    def get_bottom_braces_and_labels(self, labels, **kwargs):\n        assert hasattr(self, \"vertical_parts\")\n        parts = self.vertical_parts\n        return self.get_subdivision_braces_and_labels(parts, labels, DOWN, **kwargs)\n\n    def add_braces_and_labels(self):\n        for attr in \"horizontal_parts\", \"vertical_parts\":\n            if not hasattr(self, attr):\n                continue\n            parts = getattr(self, attr)\n            for subattr in \"braces\", \"labels\":\n                if hasattr(parts, subattr):\n                    self.add(getattr(parts, subattr))\n\n    def __getitem__(self, index):\n        if hasattr(self, \"horizontal_parts\"):\n            return self.horizontal_parts[index]\n        elif hasattr(self, \"vertical_parts\"):\n            return self.vertical_parts[index]\n        return self.split()[index]"}, {"name": "scale_matrix", "code": "def scale_matrix(scale_factor: float = 1) -> npt.NDArray:\n    return np.array(\n        [\n            [scale_factor, 0, 0, 0],\n            [0, scale_factor, 0, 0],\n            [0, 0, scale_factor, 0],\n            [0, 0, 0, 1],\n        ],\n        dtype=ManimFloat,\n    )"}, {"name": "ScaleInPlace", "code": "class ScaleInPlace(ApplyMethod):\n    \"\"\"Animation that scales a mobject by a certain factor.\n\n    Examples\n    --------\n\n    .. manim:: ScaleInPlaceExample\n\n        class ScaleInPlaceExample(Scene):\n            def construct(self):\n                self.play(ScaleInPlace(Text(\"Hello World!\"), 2))\n\n    \"\"\"\n\n    def __init__(self, mobject: Mobject, scale_factor: float, **kwargs) -> None:\n        super().__init__(mobject.scale, scale_factor, **kwargs)"}, {"name": "scene", "code": "def scene(**kwargs: Any) -> None:\n    \"\"\"Inserts a SCENE to an existing FILE or creates a new FILE.\n\n    SCENE is the name of the scene that will be inserted.\n\n    FILE is the name of file in which the SCENE will be inserted.\n    \"\"\"\n    template_name: str = click.prompt(\n        \"template\",\n        type=click.Choice(get_template_names(), False),\n        default=\"Default\",\n    )\n    scene = (get_template_path() / f\"{template_name}.mtp\").resolve().read_text()\n    scene = scene.replace(template_name + \"Template\", kwargs[\"scene_name\"], 1)\n\n    if kwargs[\"file_name\"]:\n        file_name = Path(kwargs[\"file_name\"])\n\n        if file_name.suffix != \".py\":\n            file_name = file_name.with_suffix(file_name.suffix + \".py\")\n\n        if file_name.is_file():\n            # file exists so we are going to append new scene to that file\n            with file_name.open(\"a\") as f:\n                f.write(\"\\n\\n\\n\" + scene)\n        else:\n            # file does not exist so we create a new file, append the scene and prepend the import statement\n            file_name.write_text(\"\\n\\n\\n\" + scene)\n\n            add_import_statement(file_name)\n    else:\n        # file name is not provided so we assume it is main.py\n        # if main.py does not exist we do not continue\n        with Path(\"main.py\").open(\"a\") as f:\n            f.write(\"\\n\\n\\n\" + scene)"}, {"name": "Scene", "code": "class Scene:\n    \"\"\"A Scene is the canvas of your animation.\n\n    The primary role of :class:`Scene` is to provide the user with tools to manage\n    mobjects and animations.  Generally speaking, a manim script consists of a class\n    that derives from :class:`Scene` whose :meth:`Scene.construct` method is overridden\n    by the user's code.\n\n    Mobjects are displayed on screen by calling :meth:`Scene.add` and removed from\n    screen by calling :meth:`Scene.remove`.  All mobjects currently on screen are kept\n    in :attr:`Scene.mobjects`.  Animations are played by calling :meth:`Scene.play`.\n\n    A :class:`Scene` is rendered internally by calling :meth:`Scene.render`.  This in\n    turn calls :meth:`Scene.setup`, :meth:`Scene.construct`, and\n    :meth:`Scene.tear_down`, in that order.\n\n    It is not recommended to override the ``__init__`` method in user Scenes.  For code\n    that should be ran before a Scene is rendered, use :meth:`Scene.setup` instead.\n\n    Examples\n    --------\n    Override the :meth:`Scene.construct` method with your code.\n\n    .. code-block:: python\n\n        class MyScene(Scene):\n            def construct(self):\n                self.play(Write(Text(\"Hello World!\")))\n\n    \"\"\"\n\n    def __init__(\n        self,\n        renderer: CairoRenderer | OpenGLRenderer | None = None,\n        camera_class: type[Camera] = Camera,\n        always_update_mobjects: bool = False,\n        random_seed: int | None = None,\n        skip_animations: bool = False,\n    ) -> None:\n        self.camera_class = camera_class\n        self.always_update_mobjects = always_update_mobjects\n        self.random_seed = random_seed\n        self.skip_animations = skip_animations\n\n        self.animations = None\n        self.stop_condition = None\n        self.moving_mobjects = []\n        self.static_mobjects = []\n        self.time_progression = None\n        self.duration = None\n        self.last_t = None\n        self.queue = Queue()\n        self.skip_animation_preview = False\n        self.meshes = []\n        self.camera_target = ORIGIN\n        self.widgets = []\n        self.dearpygui_imported = dearpygui_imported\n        self.updaters = []\n        self.point_lights = []\n        self.ambient_light = None\n        self.key_to_function_map = {}\n        self.mouse_press_callbacks = []\n        self.interactive_mode = False\n\n        if config.renderer == RendererType.OPENGL:\n            # Items associated with interaction\n            self.mouse_point = OpenGLPoint()\n            self.mouse_drag_point = OpenGLPoint()\n            if renderer is None:\n                renderer = OpenGLRenderer()\n\n        if renderer is None:\n            self.renderer = CairoRenderer(\n                camera_class=self.camera_class,\n                skip_animations=self.skip_animations,\n            )\n        else:\n            self.renderer = renderer\n        self.renderer.init_scene(self)\n\n        self.mobjects = []\n        # TODO, remove need for foreground mobjects\n        self.foreground_mobjects = []\n        if self.random_seed is not None:\n            random.seed(self.random_seed)\n            np.random.seed(self.random_seed)\n\n    @property\n    def camera(self):\n        return self.renderer.camera\n\n    @property\n    def time(self) -> float:\n        \"\"\"The time since the start of the scene.\"\"\"\n        return self.renderer.time\n\n    def __deepcopy__(self, clone_from_id):\n        cls = self.__class__\n        result = cls.__new__(cls)\n        clone_from_id[id(self)] = result\n        for k, v in self.__dict__.items():\n            if k in [\"renderer\", \"time_progression\"]:\n                continue\n            if k == \"camera_class\":\n                setattr(result, k, v)\n            setattr(result, k, copy.deepcopy(v, clone_from_id))\n        result.mobject_updater_lists = []\n\n        # Update updaters\n        for mobject in self.mobjects:\n            cloned_updaters = []\n            for updater in mobject.updaters:\n                # Make the cloned updater use the cloned Mobjects as free variables\n                # rather than the original ones. Analyzing function bytecode with the\n                # dis module will help in understanding this.\n                # https://docs.python.org/3/library/dis.html\n                # TODO: Do the same for function calls recursively.\n                free_variable_map = inspect.getclosurevars(updater).nonlocals\n                cloned_co_freevars = []\n                cloned_closure = []\n                for free_variable_name in updater.__code__.co_freevars:\n                    free_variable_value = free_variable_map[free_variable_name]\n\n                    # If the referenced variable has not been cloned, raise.\n                    if id(free_variable_value) not in clone_from_id:\n                        raise Exception(\n                            f\"{free_variable_name} is referenced from an updater \"\n                            \"but is not an attribute of the Scene, which isn't \"\n                            \"allowed.\",\n                        )\n\n                    # Add the cloned object's name to the free variable list.\n                    cloned_co_freevars.append(free_variable_name)\n\n                    # Add a cell containing the cloned object's reference to the\n                    # closure list.\n                    cloned_closure.append(\n                        types.CellType(clone_from_id[id(free_variable_value)]),\n                    )\n\n                cloned_updater = types.FunctionType(\n                    updater.__code__.replace(co_freevars=tuple(cloned_co_freevars)),\n                    updater.__globals__,\n                    updater.__name__,\n                    updater.__defaults__,\n                    tuple(cloned_closure),\n                )\n                cloned_updaters.append(cloned_updater)\n            mobject_clone = clone_from_id[id(mobject)]\n            mobject_clone.updaters = cloned_updaters\n            if len(cloned_updaters) > 0:\n                result.mobject_updater_lists.append((mobject_clone, cloned_updaters))\n        return result\n\n    def render(self, preview: bool = False):\n        \"\"\"\n        Renders this Scene.\n\n        Parameters\n        ---------\n        preview\n            If true, opens scene in a file viewer.\n        \"\"\"\n        self.setup()\n        try:\n            self.construct()\n        except EndSceneEarlyException:\n            pass\n        except RerunSceneException:\n            self.remove(*self.mobjects)\n            self.renderer.clear_screen()\n            self.renderer.num_plays = 0\n            return True\n        self.tear_down()\n        # We have to reset these settings in case of multiple renders.\n        self.renderer.scene_finished(self)\n\n        # Show info only if animations are rendered or to get image\n        if (\n            self.renderer.num_plays\n            or config[\"format\"] == \"png\"\n            or config[\"save_last_frame\"]\n        ):\n            logger.info(\n                f\"Rendered {str(self)}\\nPlayed {self.renderer.num_plays} animations\",\n            )\n\n        # If preview open up the render after rendering.\n        if preview:\n            config[\"preview\"] = True\n\n        if config[\"preview\"] or config[\"show_in_file_browser\"]:\n            open_media_file(self.renderer.file_writer)\n\n    def setup(self):\n        \"\"\"\n        This is meant to be implemented by any scenes which\n        are commonly subclassed, and have some common setup\n        involved before the construct method is called.\n        \"\"\"\n        pass\n\n    def tear_down(self):\n        \"\"\"\n        This is meant to be implemented by any scenes which\n        are commonly subclassed, and have some common method\n        to be invoked before the scene ends.\n        \"\"\"\n        pass\n\n    def construct(self):\n        \"\"\"Add content to the Scene.\n\n        From within :meth:`Scene.construct`, display mobjects on screen by calling\n        :meth:`Scene.add` and remove them from screen by calling :meth:`Scene.remove`.\n        All mobjects currently on screen are kept in :attr:`Scene.mobjects`.  Play\n        animations by calling :meth:`Scene.play`.\n\n        Notes\n        -----\n        Initialization code should go in :meth:`Scene.setup`.  Termination code should\n        go in :meth:`Scene.tear_down`.\n\n        Examples\n        --------\n        A typical manim script includes a class derived from :class:`Scene` with an\n        overridden :meth:`Scene.construct` method:\n\n        .. code-block:: python\n\n            class MyScene(Scene):\n                def construct(self):\n                    self.play(Write(Text(\"Hello World!\")))\n\n        See Also\n        --------\n        :meth:`Scene.setup`\n        :meth:`Scene.render`\n        :meth:`Scene.tear_down`\n\n        \"\"\"\n        pass  # To be implemented in subclasses\n\n    def next_section(\n        self,\n        name: str = \"unnamed\",\n        section_type: str = DefaultSectionType.NORMAL,\n        skip_animations: bool = False,\n    ) -> None:\n        \"\"\"Create separation here; the last section gets finished and a new one gets created.\n        ``skip_animations`` skips the rendering of all animations in this section.\n        Refer to :doc:`the documentation</tutorials/output_and_config>` on how to use sections.\n        \"\"\"\n        self.renderer.file_writer.next_section(name, section_type, skip_animations)\n\n    def __str__(self):\n        return self.__class__.__name__\n\n    def get_attrs(self, *keys: str):\n        \"\"\"\n        Gets attributes of a scene given the attribute's identifier/name.\n\n        Parameters\n        ----------\n        *keys\n            Name(s) of the argument(s) to return the attribute of.\n\n        Returns\n        -------\n        list\n            List of attributes of the passed identifiers.\n        \"\"\"\n        return [getattr(self, key) for key in keys]\n\n    def update_mobjects(self, dt: float):\n        \"\"\"\n        Begins updating all mobjects in the Scene.\n\n        Parameters\n        ----------\n        dt\n            Change in time between updates. Defaults (mostly) to 1/frames_per_second\n        \"\"\"\n        for mobject in self.mobjects:\n            mobject.update(dt)\n\n    def update_meshes(self, dt):\n        for obj in self.meshes:\n            for mesh in obj.get_family():\n                mesh.update(dt)\n\n    def update_self(self, dt: float):\n        \"\"\"Run all scene updater functions.\n\n        Among all types of update functions (mobject updaters, mesh updaters,\n        scene updaters), scene update functions are called last.\n\n        Parameters\n        ----------\n        dt\n            Scene time since last update.\n\n        See Also\n        --------\n        :meth:`.Scene.add_updater`\n        :meth:`.Scene.remove_updater`\n        \"\"\"\n        for func in self.updaters:\n            func(dt)\n\n    def should_update_mobjects(self) -> bool:\n        \"\"\"\n        Returns True if the mobjects of this scene should be updated.\n\n        In particular, this checks whether\n\n        - the :attr:`always_update_mobjects` attribute of :class:`.Scene`\n          is set to ``True``,\n        - the :class:`.Scene` itself has time-based updaters attached,\n        - any mobject in this :class:`.Scene` has time-based updaters attached.\n\n        This is only called when a single Wait animation is played.\n        \"\"\"\n        wait_animation = self.animations[0]\n        if wait_animation.is_static_wait is None:\n            should_update = (\n                self.always_update_mobjects\n                or self.updaters\n                or wait_animation.stop_condition is not None\n                or any(\n                    mob.has_time_based_updater()\n                    for mob in self.get_mobject_family_members()\n                )\n            )\n            wait_animation.is_static_wait = not should_update\n        return not wait_animation.is_static_wait\n\n    def get_top_level_mobjects(self):\n        \"\"\"\n        Returns all mobjects which are not submobjects.\n\n        Returns\n        -------\n        list\n            List of top level mobjects.\n        \"\"\"\n        # Return only those which are not in the family\n        # of another mobject from the scene\n        families = [m.get_family() for m in self.mobjects]\n\n        def is_top_level(mobject):\n            num_families = sum((mobject in family) for family in families)\n            return num_families == 1\n\n        return list(filter(is_top_level, self.mobjects))\n\n    def get_mobject_family_members(self):\n        \"\"\"\n        Returns list of family-members of all mobjects in scene.\n        If a Circle() and a VGroup(Rectangle(),Triangle()) were added,\n        it returns not only the Circle(), Rectangle() and Triangle(), but\n        also the VGroup() object.\n\n        Returns\n        -------\n        list\n            List of mobject family members.\n        \"\"\"\n        if config.renderer == RendererType.OPENGL:\n            family_members = []\n            for mob in self.mobjects:\n                family_members.extend(mob.get_family())\n            return family_members\n        elif config.renderer == RendererType.CAIRO:\n            return extract_mobject_family_members(\n                self.mobjects,\n                use_z_index=self.renderer.camera.use_z_index,\n            )\n\n    def add(self, *mobjects: Mobject):\n        \"\"\"\n        Mobjects will be displayed, from background to\n        foreground in the order with which they are added.\n\n        Parameters\n        ---------\n        *mobjects\n            Mobjects to add.\n\n        Returns\n        -------\n        Scene\n            The same scene after adding the Mobjects in.\n\n        \"\"\"\n        if config.renderer == RendererType.OPENGL:\n            new_mobjects = []\n            new_meshes = []\n            for mobject_or_mesh in mobjects:\n                if isinstance(mobject_or_mesh, Object3D):\n                    new_meshes.append(mobject_or_mesh)\n                else:\n                    new_mobjects.append(mobject_or_mesh)\n            self.remove(*new_mobjects)\n            self.mobjects += new_mobjects\n            self.remove(*new_meshes)\n            self.meshes += new_meshes\n        elif config.renderer == RendererType.CAIRO:\n            mobjects = [*mobjects, *self.foreground_mobjects]\n            self.restructure_mobjects(to_remove=mobjects)\n            self.mobjects += mobjects\n            if self.moving_mobjects:\n                self.restructure_mobjects(\n                    to_remove=mobjects,\n                    mobject_list_name=\"moving_mobjects\",\n                )\n                self.moving_mobjects += mobjects\n        return self\n\n    def add_mobjects_from_animations(self, animations: list[Animation]) -> None:\n        curr_mobjects = self.get_mobject_family_members()\n        for animation in animations:\n            if animation.is_introducer():\n                continue\n            # Anything animated that's not already in the\n            # scene gets added to the scene\n            mob = animation.mobject\n            if mob is not None and mob not in curr_mobjects:\n                self.add(mob)\n                curr_mobjects += mob.get_family()\n\n    def remove(self, *mobjects: Mobject):\n        \"\"\"\n        Removes mobjects in the passed list of mobjects\n        from the scene and the foreground, by removing them\n        from \"mobjects\" and \"foreground_mobjects\"\n\n        Parameters\n        ----------\n        *mobjects\n            The mobjects to remove.\n        \"\"\"\n        if config.renderer == RendererType.OPENGL:\n            mobjects_to_remove = []\n            meshes_to_remove = set()\n            for mobject_or_mesh in mobjects:\n                if isinstance(mobject_or_mesh, Object3D):\n                    meshes_to_remove.add(mobject_or_mesh)\n                else:\n                    mobjects_to_remove.append(mobject_or_mesh)\n            self.mobjects = restructure_list_to_exclude_certain_family_members(\n                self.mobjects,\n                mobjects_to_remove,\n            )\n            self.meshes = list(\n                filter(lambda mesh: mesh not in set(meshes_to_remove), self.meshes),\n            )\n            return self\n        elif config.renderer == RendererType.CAIRO:\n            for list_name in \"mobjects\", \"foreground_mobjects\":\n                self.restructure_mobjects(mobjects, list_name, False)\n            return self\n\n    def replace(self, old_mobject: Mobject, new_mobject: Mobject) -> None:\n        \"\"\"Replace one mobject in the scene with another, preserving draw order.\n\n        If ``old_mobject`` is a submobject of some other Mobject (e.g. a\n        :class:`.Group`), the new_mobject will replace it inside the group,\n        without otherwise changing the parent mobject.\n\n        Parameters\n        ----------\n        old_mobject\n            The mobject to be replaced. Must be present in the scene.\n        new_mobject\n            A mobject which must not already be in the scene.\n\n        \"\"\"\n        if old_mobject is None or new_mobject is None:\n            raise ValueError(\"Specified mobjects cannot be None\")\n\n        def replace_in_list(\n            mobj_list: list[Mobject], old_m: Mobject, new_m: Mobject\n        ) -> bool:\n            # We use breadth-first search because some Mobjects get very deep and\n            # we expect top-level elements to be the most common targets for replace.\n            for i in range(0, len(mobj_list)):\n                # Is this the old mobject?\n                if mobj_list[i] == old_m:\n                    # If so, write the new object to the same spot and stop looking.\n                    mobj_list[i] = new_m\n                    return True\n            # Now check all the children of all these mobs.\n            for mob in mobj_list:  # noqa: SIM110\n                if replace_in_list(mob.submobjects, old_m, new_m):\n                    # If we found it in a submobject, stop looking.\n                    return True\n            # If we did not find the mobject in the mobject list or any submobjects,\n            # (or the list was empty), indicate we did not make the replacement.\n            return False\n\n        # Make use of short-circuiting conditionals to check mobjects and then\n        # foreground_mobjects\n        replaced = replace_in_list(\n            self.mobjects, old_mobject, new_mobject\n        ) or replace_in_list(self.foreground_mobjects, old_mobject, new_mobject)\n\n        if not replaced:\n            raise ValueError(f\"Could not find {old_mobject} in scene\")\n\n    def add_updater(self, func: Callable[[float], None]) -> None:\n        \"\"\"Add an update function to the scene.\n\n        The scene updater functions are run every frame,\n        and they are the last type of updaters to run.\n\n        .. WARNING::\n\n            When using the Cairo renderer, scene updaters that\n            modify mobjects are not detected in the same way\n            that mobject updaters are. To be more concrete,\n            a mobject only modified via a scene updater will\n            not necessarily be added to the list of *moving\n            mobjects* and thus might not be updated every frame.\n\n            TL;DR: Use mobject updaters to update mobjects.\n\n        Parameters\n        ----------\n        func\n            The updater function. It takes a float, which is the\n            time difference since the last update (usually equal\n            to the frame rate).\n\n        See also\n        --------\n        :meth:`.Scene.remove_updater`\n        :meth:`.Scene.update_self`\n        \"\"\"\n        self.updaters.append(func)\n\n    def remove_updater(self, func: Callable[[float], None]) -> None:\n        \"\"\"Remove an update function from the scene.\n\n        Parameters\n        ----------\n        func\n            The updater function to be removed.\n\n        See also\n        --------\n        :meth:`.Scene.add_updater`\n        :meth:`.Scene.update_self`\n        \"\"\"\n        self.updaters = [f for f in self.updaters if f is not func]\n\n    def restructure_mobjects(\n        self,\n        to_remove: Sequence[Mobject],\n        mobject_list_name: str = \"mobjects\",\n        extract_families: bool = True,\n    ):\n        \"\"\"\n        tl:wr\n            If your scene has a Group(), and you removed a mobject from the Group,\n            this dissolves the group and puts the rest of the mobjects directly\n            in self.mobjects or self.foreground_mobjects.\n\n        In cases where the scene contains a group, e.g. Group(m1, m2, m3), but one\n        of its submobjects is removed, e.g. scene.remove(m1), the list of mobjects\n        will be edited to contain other submobjects, but not m1, e.g. it will now\n        insert m2 and m3 to where the group once was.\n\n        Parameters\n        ----------\n        to_remove\n            The Mobject to remove.\n\n        mobject_list_name\n            The list of mobjects (\"mobjects\", \"foreground_mobjects\" etc) to remove from.\n\n        extract_families\n            Whether the mobject's families should be recursively extracted.\n\n        Returns\n        -------\n        Scene\n            The Scene mobject with restructured Mobjects.\n        \"\"\"\n        if extract_families:\n            to_remove = extract_mobject_family_members(\n                to_remove,\n                use_z_index=self.renderer.camera.use_z_index,\n            )\n        _list = getattr(self, mobject_list_name)\n        new_list = self.get_restructured_mobject_list(_list, to_remove)\n        setattr(self, mobject_list_name, new_list)\n        return self\n\n    def get_restructured_mobject_list(self, mobjects: list, to_remove: list):\n        \"\"\"\n        Given a list of mobjects and a list of mobjects to be removed, this\n        filters out the removable mobjects from the list of mobjects.\n\n        Parameters\n        ----------\n\n        mobjects\n            The Mobjects to check.\n\n        to_remove\n            The list of mobjects to remove.\n\n        Returns\n        -------\n        list\n            The list of mobjects with the mobjects to remove removed.\n        \"\"\"\n        new_mobjects = []\n\n        def add_safe_mobjects_from_list(list_to_examine, set_to_remove):\n            for mob in list_to_examine:\n                if mob in set_to_remove:\n                    continue\n                intersect = set_to_remove.intersection(mob.get_family())\n                if intersect:\n                    add_safe_mobjects_from_list(mob.submobjects, intersect)\n                else:\n                    new_mobjects.append(mob)\n\n        add_safe_mobjects_from_list(mobjects, set(to_remove))\n        return new_mobjects\n\n    # TODO, remove this, and calls to this\n    def add_foreground_mobjects(self, *mobjects: Mobject):\n        \"\"\"\n        Adds mobjects to the foreground, and internally to the list\n        foreground_mobjects, and mobjects.\n\n        Parameters\n        ----------\n        *mobjects\n            The Mobjects to add to the foreground.\n\n        Returns\n        ------\n        Scene\n            The Scene, with the foreground mobjects added.\n        \"\"\"\n        self.foreground_mobjects = list_update(self.foreground_mobjects, mobjects)\n        self.add(*mobjects)\n        return self\n\n    def add_foreground_mobject(self, mobject: Mobject):\n        \"\"\"\n        Adds a single mobject to the foreground, and internally to the list\n        foreground_mobjects, and mobjects.\n\n        Parameters\n        ----------\n        mobject\n            The Mobject to add to the foreground.\n\n        Returns\n        ------\n        Scene\n            The Scene, with the foreground mobject added.\n        \"\"\"\n        return self.add_foreground_mobjects(mobject)\n\n    def remove_foreground_mobjects(self, *to_remove: Mobject):\n        \"\"\"\n        Removes mobjects from the foreground, and internally from the list\n        foreground_mobjects.\n\n        Parameters\n        ----------\n        *to_remove\n            The mobject(s) to remove from the foreground.\n\n        Returns\n        ------\n        Scene\n            The Scene, with the foreground mobjects removed.\n        \"\"\"\n        self.restructure_mobjects(to_remove, \"foreground_mobjects\")\n        return self\n\n    def remove_foreground_mobject(self, mobject: Mobject):\n        \"\"\"\n        Removes a single mobject from the foreground, and internally from the list\n        foreground_mobjects.\n\n        Parameters\n        ----------\n        mobject\n            The mobject to remove from the foreground.\n\n        Returns\n        ------\n        Scene\n            The Scene, with the foreground mobject removed.\n        \"\"\"\n        return self.remove_foreground_mobjects(mobject)\n\n    def bring_to_front(self, *mobjects: Mobject):\n        \"\"\"\n        Adds the passed mobjects to the scene again,\n        pushing them to he front of the scene.\n\n        Parameters\n        ----------\n        *mobjects\n            The mobject(s) to bring to the front of the scene.\n\n        Returns\n        ------\n        Scene\n            The Scene, with the mobjects brought to the front\n            of the scene.\n        \"\"\"\n        self.add(*mobjects)\n        return self\n\n    def bring_to_back(self, *mobjects: Mobject):\n        \"\"\"\n        Removes the mobject from the scene and\n        adds them to the back of the scene.\n\n        Parameters\n        ----------\n        *mobjects\n            The mobject(s) to push to the back of the scene.\n\n        Returns\n        ------\n        Scene\n            The Scene, with the mobjects pushed to the back\n            of the scene.\n        \"\"\"\n        self.remove(*mobjects)\n        self.mobjects = list(mobjects) + self.mobjects\n        return self\n\n    def clear(self):\n        \"\"\"\n        Removes all mobjects present in self.mobjects\n        and self.foreground_mobjects from the scene.\n\n        Returns\n        ------\n        Scene\n            The Scene, with all of its mobjects in\n            self.mobjects and self.foreground_mobjects\n            removed.\n        \"\"\"\n        self.mobjects = []\n        self.foreground_mobjects = []\n        return self\n\n    def get_moving_mobjects(self, *animations: Animation):\n        \"\"\"\n        Gets all moving mobjects in the passed animation(s).\n\n        Parameters\n        ----------\n        *animations\n            The animations to check for moving mobjects.\n\n        Returns\n        ------\n        list\n            The list of mobjects that could be moving in\n            the Animation(s)\n        \"\"\"\n        # Go through mobjects from start to end, and\n        # as soon as there's one that needs updating of\n        # some kind per frame, return the list from that\n        # point forward.\n        animation_mobjects = [anim.mobject for anim in animations]\n        mobjects = self.get_mobject_family_members()\n        for i, mob in enumerate(mobjects):\n            update_possibilities = [\n                mob in animation_mobjects,\n                len(mob.get_family_updaters()) > 0,\n                mob in self.foreground_mobjects,\n            ]\n            if any(update_possibilities):\n                return mobjects[i:]\n        return []\n\n    def get_moving_and_static_mobjects(self, animations):\n        all_mobjects = list_update(self.mobjects, self.foreground_mobjects)\n        all_mobject_families = extract_mobject_family_members(\n            all_mobjects,\n            use_z_index=self.renderer.camera.use_z_index,\n            only_those_with_points=True,\n        )\n        moving_mobjects = self.get_moving_mobjects(*animations)\n        all_moving_mobject_families = extract_mobject_family_members(\n            moving_mobjects,\n            use_z_index=self.renderer.camera.use_z_index,\n        )\n        static_mobjects = list_difference_update(\n            all_mobject_families,\n            all_moving_mobject_families,\n        )\n        return all_moving_mobject_families, static_mobjects\n\n    def compile_animations(\n        self,\n        *args: Animation | Mobject | _AnimationBuilder,\n        **kwargs,\n    ):\n        \"\"\"\n        Creates _MethodAnimations from any _AnimationBuilders and updates animation\n        kwargs with kwargs passed to play().\n\n        Parameters\n        ----------\n        *args\n            Animations to be played.\n        **kwargs\n            Configuration for the call to play().\n\n        Returns\n        -------\n        Tuple[:class:`Animation`]\n            Animations to be played.\n        \"\"\"\n        animations = []\n        arg_anims = flatten_iterable_parameters(args)\n        # Allow passing a generator to self.play instead of comma separated arguments\n        for arg in arg_anims:\n            try:\n                animations.append(prepare_animation(arg))\n            except TypeError as e:\n                if inspect.ismethod(arg):\n                    raise TypeError(\n                        \"Passing Mobject methods to Scene.play is no longer\"\n                        \" supported. Use Mobject.animate instead.\",\n                    ) from e\n                else:\n                    raise TypeError(\n                        f\"Unexpected argument {arg} passed to Scene.play().\",\n                    ) from e\n\n        for animation in animations:\n            for k, v in kwargs.items():\n                setattr(animation, k, v)\n\n        return animations\n\n    def _get_animation_time_progression(\n        self, animations: list[Animation], duration: float\n    ):\n        \"\"\"\n        You will hardly use this when making your own animations.\n        This method is for Manim's internal use.\n\n        Uses :func:`~.get_time_progression` to obtain a\n        CommandLine ProgressBar whose ``fill_time`` is\n        dependent on the qualities of the passed Animation,\n\n        Parameters\n        ----------\n        animations\n            The list of animations to get\n            the time progression for.\n\n        duration\n            duration of wait time\n\n        Returns\n        -------\n        time_progression\n            The CommandLine Progress Bar.\n        \"\"\"\n        if len(animations) == 1 and isinstance(animations[0], Wait):\n            stop_condition = animations[0].stop_condition\n            if stop_condition is not None:\n                time_progression = self.get_time_progression(\n                    duration,\n                    f\"Waiting for {stop_condition.__name__}\",\n                    n_iterations=-1,  # So it doesn't show % progress\n                    override_skip_animations=True,\n                )\n            else:\n                time_progression = self.get_time_progression(\n                    duration,\n                    f\"Waiting {self.renderer.num_plays}\",\n                )\n        else:\n            time_progression = self.get_time_progression(\n                duration,\n                \"\".join(\n                    [\n                        f\"Animation {self.renderer.num_plays}: \",\n                        str(animations[0]),\n                        (\", etc.\" if len(animations) > 1 else \"\"),\n                    ],\n                ),\n            )\n        return time_progression\n\n    def get_time_progression(\n        self,\n        run_time: float,\n        description,\n        n_iterations: int | None = None,\n        override_skip_animations: bool = False,\n    ):\n        \"\"\"\n        You will hardly use this when making your own animations.\n        This method is for Manim's internal use.\n\n        Returns a CommandLine ProgressBar whose ``fill_time``\n        is dependent on the ``run_time`` of an animation,\n        the iterations to perform in that animation\n        and a bool saying whether or not to consider\n        the skipped animations.\n\n        Parameters\n        ----------\n        run_time\n            The ``run_time`` of the animation.\n\n        n_iterations\n            The number of iterations in the animation.\n\n        override_skip_animations\n            Whether or not to show skipped animations in the progress bar.\n\n        Returns\n        -------\n        time_progression\n            The CommandLine Progress Bar.\n        \"\"\"\n        if self.renderer.skip_animations and not override_skip_animations:\n            times = [run_time]\n        else:\n            step = 1 / config[\"frame_rate\"]\n            times = np.arange(0, run_time, step)\n        time_progression = tqdm(\n            times,\n            desc=description,\n            total=n_iterations,\n            leave=config[\"progress_bar\"] == \"leave\",\n            ascii=True if platform.system() == \"Windows\" else None,\n            disable=config[\"progress_bar\"] == \"none\",\n        )\n        return time_progression\n\n    @classmethod\n    def validate_run_time(\n        cls,\n        run_time: float,\n        method: Callable[[Any, ...], Any],\n        parameter_name: str = \"run_time\",\n    ) -> float:\n        method_name = f\"{cls.__name__}.{method.__name__}()\"\n        if run_time <= 0:\n            raise ValueError(\n                f\"{method_name} has a {parameter_name} of \"\n                f\"{run_time:g} <= 0 seconds which Manim cannot render. \"\n                f\"The {parameter_name} must be a positive number.\"\n            )\n\n        # config.frame_rate holds the number of frames per second\n        fps = config.frame_rate\n        seconds_per_frame = 1 / fps\n        if run_time < seconds_per_frame:\n            logger.warning(\n                f\"The original {parameter_name} of {method_name}, \"\n                f\"{run_time:g} seconds, is too short for the current frame \"\n                f\"rate of {fps:g} FPS. Rendering with the shortest possible \"\n                f\"{parameter_name} of {seconds_per_frame:g} seconds instead.\"\n            )\n            run_time = seconds_per_frame\n\n        return run_time\n\n    def get_run_time(self, animations: list[Animation]):\n        \"\"\"\n        Gets the total run time for a list of animations.\n\n        Parameters\n        ----------\n        animations\n            A list of the animations whose total\n            ``run_time`` is to be calculated.\n\n        Returns\n        -------\n        float\n            The total ``run_time`` of all of the animations in the list.\n        \"\"\"\n        run_time = max(animation.run_time for animation in animations)\n        run_time = self.validate_run_time(run_time, self.play, \"total run_time\")\n        return run_time\n\n    def play(\n        self,\n        *args: Animation | Mobject | _AnimationBuilder,\n        subcaption=None,\n        subcaption_duration=None,\n        subcaption_offset=0,\n        **kwargs,\n    ):\n        r\"\"\"Plays an animation in this scene.\n\n        Parameters\n        ----------\n\n        args\n            Animations to be played.\n        subcaption\n            The content of the external subcaption that should\n            be added during the animation.\n        subcaption_duration\n            The duration for which the specified subcaption is\n            added. If ``None`` (the default), the run time of the\n            animation is taken.\n        subcaption_offset\n            An offset (in seconds) for the start time of the\n            added subcaption.\n        kwargs\n            All other keywords are passed to the renderer.\n\n        \"\"\"\n        # If we are in interactive embedded mode, make sure this is running on the main thread (required for OpenGL)\n        if (\n            self.interactive_mode\n            and config.renderer == RendererType.OPENGL\n            and threading.current_thread().name != \"MainThread\"\n        ):\n            kwargs.update(\n                {\n                    \"subcaption\": subcaption,\n                    \"subcaption_duration\": subcaption_duration,\n                    \"subcaption_offset\": subcaption_offset,\n                }\n            )\n            self.queue.put(\n                (\n                    \"play\",\n                    args,\n                    kwargs,\n                )\n            )\n            return\n\n        start_time = self.time\n        self.renderer.play(self, *args, **kwargs)\n        run_time = self.time - start_time\n        if subcaption:\n            if subcaption_duration is None:\n                subcaption_duration = run_time\n            # The start of the subcaption needs to be offset by the\n            # run_time of the animation because it is added after\n            # the animation has already been played (and Scene.time\n            # has already been updated).\n            self.add_subcaption(\n                content=subcaption,\n                duration=subcaption_duration,\n                offset=-run_time + subcaption_offset,\n            )\n\n    def wait(\n        self,\n        duration: float = DEFAULT_WAIT_TIME,\n        stop_condition: Callable[[], bool] | None = None,\n        frozen_frame: bool | None = None,\n    ):\n        \"\"\"Plays a \"no operation\" animation.\n\n        Parameters\n        ----------\n        duration\n            The run time of the animation.\n        stop_condition\n            A function without positional arguments that is evaluated every time\n            a frame is rendered. The animation only stops when the return value\n            of the function is truthy, or when the time specified in ``duration``\n            passes.\n        frozen_frame\n            If True, updater functions are not evaluated, and the animation outputs\n            a frozen frame. If False, updater functions are called and frames\n            are rendered as usual. If None (the default), the scene tries to\n            determine whether or not the frame is frozen on its own.\n\n        See also\n        --------\n        :class:`.Wait`, :meth:`.should_mobjects_update`\n        \"\"\"\n        duration = self.validate_run_time(duration, self.wait, \"duration\")\n        self.play(\n            Wait(\n                run_time=duration,\n                stop_condition=stop_condition,\n                frozen_frame=frozen_frame,\n            )\n        )\n\n    def pause(self, duration: float = DEFAULT_WAIT_TIME):\n        \"\"\"Pauses the scene (i.e., displays a frozen frame).\n\n        This is an alias for :meth:`.wait` with ``frozen_frame``\n        set to ``True``.\n\n        Parameters\n        ----------\n        duration\n            The duration of the pause.\n\n        See also\n        --------\n        :meth:`.wait`, :class:`.Wait`\n        \"\"\"\n        duration = self.validate_run_time(duration, self.pause, \"duration\")\n        self.wait(duration=duration, frozen_frame=True)\n\n    def wait_until(self, stop_condition: Callable[[], bool], max_time: float = 60):\n        \"\"\"Wait until a condition is satisfied, up to a given maximum duration.\n\n        Parameters\n        ----------\n        stop_condition\n            A function with no arguments that determines whether or not the\n            scene should keep waiting.\n        max_time\n            The maximum wait time in seconds.\n        \"\"\"\n        max_time = self.validate_run_time(max_time, self.wait_until, \"max_time\")\n        self.wait(max_time, stop_condition=stop_condition)\n\n    def compile_animation_data(\n        self,\n        *animations: Animation | Mobject | _AnimationBuilder,\n        **play_kwargs,\n    ):\n        \"\"\"Given a list of animations, compile the corresponding\n        static and moving mobjects, and gather the animation durations.\n\n        This also begins the animations.\n\n        Parameters\n        ----------\n        animations\n            Animation or mobject with mobject method and params\n        play_kwargs\n            Named parameters affecting what was passed in ``animations``,\n            e.g. ``run_time``, ``lag_ratio`` and so on.\n\n        Returns\n        -------\n        self, None\n            None if there is nothing to play, or self otherwise.\n        \"\"\"\n        # NOTE TODO : returns statement of this method are wrong. It should return nothing, as it makes a little sense to get any information from this method.\n        # The return are kept to keep webgl renderer from breaking.\n        if len(animations) == 0:\n            raise ValueError(\"Called Scene.play with no animations\")\n\n        self.animations = self.compile_animations(*animations, **play_kwargs)\n        self.add_mobjects_from_animations(self.animations)\n\n        self.last_t = 0\n        self.stop_condition = None\n        self.moving_mobjects = []\n        self.static_mobjects = []\n\n        self.duration = self.get_run_time(self.animations)\n        if len(self.animations) == 1 and isinstance(self.animations[0], Wait):\n            if self.should_update_mobjects():\n                self.update_mobjects(dt=0)  # Any problems with this?\n                self.stop_condition = self.animations[0].stop_condition\n            else:\n                # Static image logic when the wait is static is done by the renderer, not here.\n                self.animations[0].is_static_wait = True\n                return None\n\n        return self\n\n    def begin_animations(self) -> None:\n        \"\"\"Start the animations of the scene.\"\"\"\n        for animation in self.animations:\n            animation._setup_scene(self)\n            animation.begin()\n\n        if config.renderer == RendererType.CAIRO:\n            # Paint all non-moving objects onto the screen, so they don't\n            # have to be rendered every frame\n            (\n                self.moving_mobjects,\n                self.static_mobjects,\n            ) = self.get_moving_and_static_mobjects(self.animations)\n\n    def is_current_animation_frozen_frame(self) -> bool:\n        \"\"\"Returns whether the current animation produces a static frame (generally a Wait).\"\"\"\n        return (\n            isinstance(self.animations[0], Wait)\n            and len(self.animations) == 1\n            and self.animations[0].is_static_wait\n        )\n\n    def play_internal(self, skip_rendering: bool = False):\n        \"\"\"\n        This method is used to prep the animations for rendering,\n        apply the arguments and parameters required to them,\n        render them, and write them to the video file.\n\n        Parameters\n        ----------\n        skip_rendering\n            Whether the rendering should be skipped, by default False\n        \"\"\"\n        self.duration = self.get_run_time(self.animations)\n        self.time_progression = self._get_animation_time_progression(\n            self.animations,\n            self.duration,\n        )\n        for t in self.time_progression:\n            self.update_to_time(t)\n            if not skip_rendering and not self.skip_animation_preview:\n                self.renderer.render(self, t, self.moving_mobjects)\n            if self.stop_condition is not None and self.stop_condition():\n                self.time_progression.close()\n                break\n\n        for animation in self.animations:\n            animation.finish()\n            animation.clean_up_from_scene(self)\n        if not self.renderer.skip_animations:\n            self.update_mobjects(0)\n        self.renderer.static_image = None\n        # Closing the progress bar at the end of the play.\n        self.time_progression.close()\n\n    def check_interactive_embed_is_valid(self):\n        if config[\"force_window\"]:\n            return True\n        if self.skip_animation_preview:\n            logger.warning(\n                \"Disabling interactive embed as 'skip_animation_preview' is enabled\",\n            )\n            return False\n        elif config[\"write_to_movie\"]:\n            logger.warning(\"Disabling interactive embed as 'write_to_movie' is enabled\")\n            return False\n        elif config[\"format\"]:\n            logger.warning(\n                \"Disabling interactive embed as '--format' is set as \"\n                + config[\"format\"],\n            )\n            return False\n        elif not self.renderer.window:\n            logger.warning(\"Disabling interactive embed as no window was created\")\n            return False\n        elif config.dry_run:\n            logger.warning(\"Disabling interactive embed as dry_run is enabled\")\n            return False\n        return True\n\n    def interactive_embed(self):\n        \"\"\"Like embed(), but allows for screen interaction.\"\"\"\n        if not self.check_interactive_embed_is_valid():\n            return\n        self.interactive_mode = True\n\n        def ipython(shell, namespace):\n            import manim.opengl\n\n            def load_module_into_namespace(module, namespace):\n                for name in dir(module):\n                    namespace[name] = getattr(module, name)\n\n            load_module_into_namespace(manim, namespace)\n            load_module_into_namespace(manim.opengl, namespace)\n\n            def embedded_rerun(*args, **kwargs):\n                self.queue.put((\"rerun_keyboard\", args, kwargs))\n                shell.exiter()\n\n            namespace[\"rerun\"] = embedded_rerun\n\n            shell(local_ns=namespace)\n            self.queue.put((\"exit_keyboard\", [], {}))\n\n        def get_embedded_method(method_name):\n            return lambda *args, **kwargs: self.queue.put((method_name, args, kwargs))\n\n        local_namespace = inspect.currentframe().f_back.f_locals\n        for method in (\"play\", \"wait\", \"add\", \"remove\"):\n            embedded_method = get_embedded_method(method)\n            # Allow for calling scene methods without prepending 'self.'.\n            local_namespace[method] = embedded_method\n\n        from sqlite3 import connect\n\n        from IPython.core.getipython import get_ipython\n        from IPython.terminal.embed import InteractiveShellEmbed\n        from traitlets.config import Config\n\n        cfg = Config()\n        cfg.TerminalInteractiveShell.confirm_exit = False\n        if get_ipython() is None:\n            shell = InteractiveShellEmbed.instance(config=cfg)\n        else:\n            shell = InteractiveShellEmbed(config=cfg)\n        hist = get_ipython().history_manager\n        hist.db = connect(hist.hist_file, check_same_thread=False)\n\n        keyboard_thread = threading.Thread(\n            target=ipython,\n            args=(shell, local_namespace),\n        )\n        # run as daemon to kill thread when main thread exits\n        if not shell.pt_app:\n            keyboard_thread.daemon = True\n        keyboard_thread.start()\n\n        if self.dearpygui_imported and config[\"enable_gui\"]:\n            if not dpg.is_dearpygui_running():\n                gui_thread = threading.Thread(\n                    target=configure_pygui,\n                    args=(self.renderer, self.widgets),\n                    kwargs={\"update\": False},\n                )\n                gui_thread.start()\n            else:\n                configure_pygui(self.renderer, self.widgets, update=True)\n\n        self.camera.model_matrix = self.camera.default_model_matrix\n\n        self.interact(shell, keyboard_thread)\n\n    def interact(self, shell, keyboard_thread):\n        event_handler = RerunSceneHandler(self.queue)\n        file_observer = Observer()\n        file_observer.schedule(event_handler, config[\"input_file\"], recursive=True)\n        file_observer.start()\n\n        self.quit_interaction = False\n        keyboard_thread_needs_join = shell.pt_app is not None\n        assert self.queue.qsize() == 0\n\n        last_time = time.time()\n        while not (self.renderer.window.is_closing or self.quit_interaction):\n            if not self.queue.empty():\n                tup = self.queue.get_nowait()\n                if tup[0].startswith(\"rerun\"):\n                    # Intentionally skip calling join() on the file thread to save time.\n                    if not tup[0].endswith(\"keyboard\"):\n                        if shell.pt_app:\n                            shell.pt_app.app.exit(exception=EOFError)\n                        file_observer.unschedule_all()\n                        raise RerunSceneException\n                    keyboard_thread.join()\n\n                    kwargs = tup[2]\n                    if \"from_animation_number\" in kwargs:\n                        config[\"from_animation_number\"] = kwargs[\n                            \"from_animation_number\"\n                        ]\n                    # # TODO: This option only makes sense if interactive_embed() is run at the\n                    # # end of a scene by default.\n                    # if \"upto_animation_number\" in kwargs:\n                    #     config[\"upto_animation_number\"] = kwargs[\n                    #         \"upto_animation_number\"\n                    #     ]\n\n                    keyboard_thread.join()\n                    file_observer.unschedule_all()\n                    raise RerunSceneException\n                elif tup[0].startswith(\"exit\"):\n                    # Intentionally skip calling join() on the file thread to save time.\n                    if not tup[0].endswith(\"keyboard\") and shell.pt_app:\n                        shell.pt_app.app.exit(exception=EOFError)\n                    keyboard_thread.join()\n                    # Remove exit_keyboard from the queue if necessary.\n                    while self.queue.qsize() > 0:\n                        self.queue.get()\n                    keyboard_thread_needs_join = False\n                    break\n                else:\n                    method, args, kwargs = tup\n                    getattr(self, method)(*args, **kwargs)\n            else:\n                self.renderer.animation_start_time = 0\n                dt = time.time() - last_time\n                last_time = time.time()\n                self.renderer.render(self, dt, self.moving_mobjects)\n                self.update_mobjects(dt)\n                self.update_meshes(dt)\n                self.update_self(dt)\n\n        # Join the keyboard thread if necessary.\n        if shell is not None and keyboard_thread_needs_join:\n            shell.pt_app.app.exit(exception=EOFError)\n            keyboard_thread.join()\n            # Remove exit_keyboard from the queue if necessary.\n            while self.queue.qsize() > 0:\n                self.queue.get()\n\n        file_observer.stop()\n        file_observer.join()\n\n        if self.dearpygui_imported and config[\"enable_gui\"]:\n            dpg.stop_dearpygui()\n\n        if self.renderer.window.is_closing:\n            self.renderer.window.destroy()\n\n    def embed(self):\n        if not config[\"preview\"]:\n            logger.warning(\"Called embed() while no preview window is available.\")\n            return\n        if config[\"write_to_movie\"]:\n            logger.warning(\"embed() is skipped while writing to a file.\")\n            return\n\n        self.renderer.animation_start_time = 0\n        self.renderer.render(self, -1, self.moving_mobjects)\n\n        # Configure IPython shell.\n        from IPython.terminal.embed import InteractiveShellEmbed\n\n        shell = InteractiveShellEmbed()\n\n        # Have the frame update after each command\n        shell.events.register(\n            \"post_run_cell\",\n            lambda *a, **kw: self.renderer.render(self, -1, self.moving_mobjects),\n        )\n\n        # Use the locals of the caller as the local namespace\n        # once embedded, and add a few custom shortcuts.\n        local_ns = inspect.currentframe().f_back.f_locals\n        # local_ns[\"touch\"] = self.interact\n        for method in (\n            \"play\",\n            \"wait\",\n            \"add\",\n            \"remove\",\n            \"interact\",\n            # \"clear\",\n            # \"save_state\",\n            # \"restore\",\n        ):\n            local_ns[method] = getattr(self, method)\n        shell(local_ns=local_ns, stack_depth=2)\n\n        # End scene when exiting an embed.\n        raise Exception(\"Exiting scene.\")\n\n    def update_to_time(self, t):\n        dt = t - self.last_t\n        self.last_t = t\n        for animation in self.animations:\n            animation.update_mobjects(dt)\n            alpha = t / animation.run_time\n            animation.interpolate(alpha)\n        self.update_mobjects(dt)\n        self.update_meshes(dt)\n        self.update_self(dt)\n\n    def add_subcaption(\n        self, content: str, duration: float = 1, offset: float = 0\n    ) -> None:\n        r\"\"\"Adds an entry in the corresponding subcaption file\n        at the current time stamp.\n\n        The current time stamp is obtained from ``Scene.time``.\n\n        Parameters\n        ----------\n\n        content\n            The subcaption content.\n        duration\n            The duration (in seconds) for which the subcaption is shown.\n        offset\n            This offset (in seconds) is added to the starting time stamp\n            of the subcaption.\n\n        Examples\n        --------\n\n        This example illustrates both possibilities for adding\n        subcaptions to Manimations::\n\n            class SubcaptionExample(Scene):\n                def construct(self):\n                    square = Square()\n                    circle = Circle()\n\n                    # first option: via the add_subcaption method\n                    self.add_subcaption(\"Hello square!\", duration=1)\n                    self.play(Create(square))\n\n                    # second option: within the call to Scene.play\n                    self.play(\n                        Transform(square, circle), subcaption=\"The square transforms.\"\n                    )\n\n        \"\"\"\n        subtitle = srt.Subtitle(\n            index=len(self.renderer.file_writer.subcaptions),\n            content=content,\n            start=datetime.timedelta(seconds=float(self.time + offset)),\n            end=datetime.timedelta(seconds=float(self.time + offset + duration)),\n        )\n        self.renderer.file_writer.subcaptions.append(subtitle)\n\n    def add_sound(\n        self,\n        sound_file: str,\n        time_offset: float = 0,\n        gain: float | None = None,\n        **kwargs,\n    ):\n        \"\"\"\n        This method is used to add a sound to the animation.\n\n        Parameters\n        ----------\n\n        sound_file\n            The path to the sound file.\n        time_offset\n            The offset in the sound file after which\n            the sound can be played.\n        gain\n            Amplification of the sound.\n\n        Examples\n        --------\n        .. manim:: SoundExample\n            :no_autoplay:\n\n            class SoundExample(Scene):\n                # Source of sound under Creative Commons 0 License. https://freesound.org/people/Druminfected/sounds/250551/\n                def construct(self):\n                    dot = Dot().set_color(GREEN)\n                    self.add_sound(\"click.wav\")\n                    self.add(dot)\n                    self.wait()\n                    self.add_sound(\"click.wav\")\n                    dot.set_color(BLUE)\n                    self.wait()\n                    self.add_sound(\"click.wav\")\n                    dot.set_color(RED)\n                    self.wait()\n\n        Download the resource for the previous example `here <https://github.com/ManimCommunity/manim/blob/main/docs/source/_static/click.wav>`_ .\n        \"\"\"\n        if self.renderer.skip_animations:\n            return\n        time = self.time + time_offset\n        self.renderer.file_writer.add_sound(sound_file, time, gain, **kwargs)\n\n    def on_mouse_motion(self, point, d_point):\n        self.mouse_point.move_to(point)\n        if SHIFT_VALUE in self.renderer.pressed_keys:\n            shift = -d_point\n            shift[0] *= self.camera.get_width() / 2\n            shift[1] *= self.camera.get_height() / 2\n            transform = self.camera.inverse_rotation_matrix\n            shift = np.dot(np.transpose(transform), shift)\n            self.camera.shift(shift)\n\n    def on_mouse_scroll(self, point, offset):\n        if not config.use_projection_stroke_shaders:\n            factor = 1 + np.arctan(-2.1 * offset[1])\n            self.camera.scale(factor, about_point=self.camera_target)\n        self.mouse_scroll_orbit_controls(point, offset)\n\n    def on_key_press(self, symbol, modifiers):\n        try:\n            char = chr(symbol)\n        except OverflowError:\n            logger.warning(\"The value of the pressed key is too large.\")\n            return\n\n        if char == \"r\":\n            self.camera.to_default_state()\n            self.camera_target = np.array([0, 0, 0], dtype=np.float32)\n        elif char == \"q\":\n            self.quit_interaction = True\n        else:\n            if char in self.key_to_function_map:\n                self.key_to_function_map[char]()\n\n    def on_key_release(self, symbol, modifiers):\n        pass\n\n    def on_mouse_drag(self, point, d_point, buttons, modifiers):\n        self.mouse_drag_point.move_to(point)\n        if buttons == 1:\n            self.camera.increment_theta(-d_point[0])\n            self.camera.increment_phi(d_point[1])\n        elif buttons == 4:\n            camera_x_axis = self.camera.model_matrix[:3, 0]\n            horizontal_shift_vector = -d_point[0] * camera_x_axis\n            vertical_shift_vector = -d_point[1] * np.cross(OUT, camera_x_axis)\n            total_shift_vector = horizontal_shift_vector + vertical_shift_vector\n            self.camera.shift(1.1 * total_shift_vector)\n\n        self.mouse_drag_orbit_controls(point, d_point, buttons, modifiers)\n\n    def mouse_scroll_orbit_controls(self, point, offset):\n        camera_to_target = self.camera_target - self.camera.get_position()\n        camera_to_target *= np.sign(offset[1])\n        shift_vector = 0.01 * camera_to_target\n        self.camera.model_matrix = (\n            opengl.translation_matrix(*shift_vector) @ self.camera.model_matrix\n        )\n\n    def mouse_drag_orbit_controls(self, point, d_point, buttons, modifiers):\n        # Left click drag.\n        if buttons == 1:\n            # Translate to target the origin and rotate around the z axis.\n            self.camera.model_matrix = (\n                opengl.rotation_matrix(z=-d_point[0])\n                @ opengl.translation_matrix(*-self.camera_target)\n                @ self.camera.model_matrix\n            )\n\n            # Rotation off of the z axis.\n            camera_position = self.camera.get_position()\n            camera_y_axis = self.camera.model_matrix[:3, 1]\n            axis_of_rotation = space_ops.normalize(\n                np.cross(camera_y_axis, camera_position),\n            )\n            rotation_matrix = space_ops.rotation_matrix(\n                d_point[1],\n                axis_of_rotation,\n                homogeneous=True,\n            )\n\n            maximum_polar_angle = self.camera.maximum_polar_angle\n            minimum_polar_angle = self.camera.minimum_polar_angle\n\n            potential_camera_model_matrix = rotation_matrix @ self.camera.model_matrix\n            potential_camera_location = potential_camera_model_matrix[:3, 3]\n            potential_camera_y_axis = potential_camera_model_matrix[:3, 1]\n            sign = (\n                np.sign(potential_camera_y_axis[2])\n                if potential_camera_y_axis[2] != 0\n                else 1\n            )\n            potential_polar_angle = sign * np.arccos(\n                potential_camera_location[2]\n                / np.linalg.norm(potential_camera_location),\n            )\n            if minimum_polar_angle <= potential_polar_angle <= maximum_polar_angle:\n                self.camera.model_matrix = potential_camera_model_matrix\n            else:\n                sign = np.sign(camera_y_axis[2]) if camera_y_axis[2] != 0 else 1\n                current_polar_angle = sign * np.arccos(\n                    camera_position[2] / np.linalg.norm(camera_position),\n                )\n                if potential_polar_angle > maximum_polar_angle:\n                    polar_angle_delta = maximum_polar_angle - current_polar_angle\n                else:\n                    polar_angle_delta = minimum_polar_angle - current_polar_angle\n                rotation_matrix = space_ops.rotation_matrix(\n                    polar_angle_delta,\n                    axis_of_rotation,\n                    homogeneous=True,\n                )\n                self.camera.model_matrix = rotation_matrix @ self.camera.model_matrix\n\n            # Translate to target the original target.\n            self.camera.model_matrix = (\n                opengl.translation_matrix(*self.camera_target)\n                @ self.camera.model_matrix\n            )\n        # Right click drag.\n        elif buttons == 4:\n            camera_x_axis = self.camera.model_matrix[:3, 0]\n            horizontal_shift_vector = -d_point[0] * camera_x_axis\n            vertical_shift_vector = -d_point[1] * np.cross(OUT, camera_x_axis)\n            total_shift_vector = horizontal_shift_vector + vertical_shift_vector\n\n            self.camera.model_matrix = (\n                opengl.translation_matrix(*total_shift_vector)\n                @ self.camera.model_matrix\n            )\n            self.camera_target += total_shift_vector\n\n    def set_key_function(self, char, func):\n        self.key_to_function_map[char] = func\n\n    def on_mouse_press(self, point, button, modifiers):\n        for func in self.mouse_press_callbacks:\n            func()"}, {"name": "scene_classes_from_file", "code": "def scene_classes_from_file(\n    file_path: Path, require_single_scene: bool = False, full_list: bool = False\n) -> type[Scene] | list[type[Scene]]:\n    module = get_module(file_path)\n    all_scene_classes = get_scene_classes_from_module(module)\n    if full_list:\n        return all_scene_classes\n    scene_classes_to_render = get_scenes_to_render(all_scene_classes)\n    if require_single_scene:\n        assert len(scene_classes_to_render) == 1\n        return scene_classes_to_render[0]\n    return scene_classes_to_render"}, {"name": "SceneFileWriter", "code": "class SceneFileWriter:\n    \"\"\"\n    SceneFileWriter is the object that actually writes the animations\n    played, into video files, using FFMPEG.\n    This is mostly for Manim's internal use. You will rarely, if ever,\n    have to use the methods for this class, unless tinkering with the very\n    fabric of Manim's reality.\n\n    Attributes\n    ----------\n        sections : list of :class:`.Section`\n            used to segment scene\n\n        sections_output_dir : :class:`pathlib.Path`\n            where are section videos stored\n\n        output_name : str\n            name of movie without extension and basis for section video names\n\n    Some useful attributes are:\n        \"write_to_movie\" (bool=False)\n            Whether or not to write the animations into a video file.\n        \"movie_file_extension\" (str=\".mp4\")\n            The file-type extension of the outputted video.\n        \"partial_movie_files\"\n            List of all the partial-movie files.\n\n    \"\"\"\n\n    force_output_as_scene_name = False\n\n    def __init__(\n        self,\n        renderer: CairoRenderer | OpenGLRenderer,\n        scene_name: StrPath,\n        **kwargs: Any,\n    ) -> None:\n        self.renderer = renderer\n        self.init_output_directories(scene_name)\n        self.init_audio()\n        self.frame_count = 0\n        self.partial_movie_files: list[str] = []\n        self.subcaptions: list[srt.Subtitle] = []\n        self.sections: list[Section] = []\n        # first section gets automatically created for convenience\n        # if you need the first section to be skipped, add a first section by hand, it will replace this one\n        self.next_section(\n            name=\"autocreated\", type_=DefaultSectionType.NORMAL, skip_animations=False\n        )\n\n    def init_output_directories(self, scene_name: StrPath) -> None:\n        \"\"\"Initialise output directories.\n\n        Notes\n        -----\n        The directories are read from ``config``, for example\n        ``config['media_dir']``.  If the target directories don't already\n        exist, they will be created.\n\n        \"\"\"\n        if config[\"dry_run\"]:  # in dry-run mode there is no output\n            return\n\n        module_name = config.get_dir(\"input_file\").stem if config[\"input_file\"] else \"\"\n\n        if SceneFileWriter.force_output_as_scene_name:\n            self.output_name = Path(scene_name)\n        elif config[\"output_file\"] and not config[\"write_all\"]:\n            self.output_name = config.get_dir(\"output_file\")\n        else:\n            self.output_name = Path(scene_name)\n\n        if config[\"media_dir\"]:\n            image_dir = guarantee_existence(\n                config.get_dir(\n                    \"images_dir\", module_name=module_name, scene_name=scene_name\n                ),\n            )\n            self.image_file_path = image_dir / add_extension_if_not_present(\n                self.output_name, \".png\"\n            )\n\n        if write_to_movie():\n            movie_dir = guarantee_existence(\n                config.get_dir(\n                    \"video_dir\", module_name=module_name, scene_name=scene_name\n                ),\n            )\n            self.movie_file_path = movie_dir / add_extension_if_not_present(\n                self.output_name, config[\"movie_file_extension\"]\n            )\n\n            # TODO: /dev/null would be good in case sections_output_dir is used without being set (doesn't work on Windows), everyone likes defensive programming, right?\n            self.sections_output_dir = Path(\"\")\n            if config.save_sections:\n                self.sections_output_dir = guarantee_existence(\n                    config.get_dir(\n                        \"sections_dir\", module_name=module_name, scene_name=scene_name\n                    )\n                )\n\n            if is_gif_format():\n                self.gif_file_path = add_extension_if_not_present(\n                    self.output_name, \".gif\"\n                )\n\n                if not config[\"output_file\"]:\n                    self.gif_file_path = add_version_before_extension(\n                        self.gif_file_path\n                    )\n\n                self.gif_file_path = movie_dir / self.gif_file_path\n\n            self.partial_movie_directory = guarantee_existence(\n                config.get_dir(\n                    \"partial_movie_dir\",\n                    scene_name=scene_name,\n                    module_name=module_name,\n                ),\n            )\n\n            if config[\"log_to_file\"]:\n                log_dir = guarantee_existence(config.get_dir(\"log_dir\"))\n                set_file_logger(\n                    scene_name=scene_name, module_name=module_name, log_dir=log_dir\n                )\n\n    def finish_last_section(self) -> None:\n        \"\"\"Delete current section if it is empty.\"\"\"\n        if len(self.sections) and self.sections[-1].is_empty():\n            self.sections.pop()\n\n    def next_section(self, name: str, type_: str, skip_animations: bool) -> None:\n        \"\"\"Create segmentation cut here.\"\"\"\n        self.finish_last_section()\n\n        # images don't support sections\n        section_video: str | None = None\n        # don't save when None\n        if (\n            not config.dry_run\n            and write_to_movie()\n            and config.save_sections\n            and not skip_animations\n        ):\n            # relative to index file\n            section_video = f\"{self.output_name}_{len(self.sections):04}_{name}{config.movie_file_extension}\"\n\n        self.sections.append(\n            Section(\n                type_,\n                section_video,\n                name,\n                skip_animations,\n            ),\n        )\n\n    def add_partial_movie_file(self, hash_animation: str):\n        \"\"\"Adds a new partial movie file path to `scene.partial_movie_files` and current section from a hash.\n        This method will compute the path from the hash. In addition to that it adds the new animation to the current section.\n\n        Parameters\n        ----------\n        hash_animation\n            Hash of the animation.\n        \"\"\"\n        if not hasattr(self, \"partial_movie_directory\") or not write_to_movie():\n            return\n\n        # None has to be added to partial_movie_files to keep the right index with scene.num_plays.\n        # i.e if an animation is skipped, scene.num_plays is still incremented and we add an element to partial_movie_file be even with num_plays.\n        if hash_animation is None:\n            self.partial_movie_files.append(None)\n            self.sections[-1].partial_movie_files.append(None)\n        else:\n            new_partial_movie_file = str(\n                self.partial_movie_directory\n                / f\"{hash_animation}{config['movie_file_extension']}\"\n            )\n            self.partial_movie_files.append(new_partial_movie_file)\n            self.sections[-1].partial_movie_files.append(new_partial_movie_file)\n\n    def get_resolution_directory(self):\n        \"\"\"Get the name of the resolution directory directly containing\n        the video file.\n\n        This method gets the name of the directory that immediately contains the\n        video file. This name is ``<height_in_pixels_of_video>p<frame_rate>``.\n        For example, if you are rendering an 854x480 px animation at 15fps,\n        the name of the directory that immediately contains the video,  file\n        will be ``480p15``.\n\n        The file structure should look something like::\n\n            MEDIA_DIR\n                |--Tex\n                |--texts\n                |--videos\n                |--<name_of_file_containing_scene>\n                    |--<height_in_pixels_of_video>p<frame_rate>\n                        |--<scene_name>.mp4\n\n        Returns\n        -------\n        :class:`str`\n            The name of the directory.\n        \"\"\"\n        pixel_height = config[\"pixel_height\"]\n        frame_rate = config[\"frame_rate\"]\n        return f\"{pixel_height}p{frame_rate}\"\n\n    # Sound\n    def init_audio(self):\n        \"\"\"Preps the writer for adding audio to the movie.\"\"\"\n        self.includes_sound = False\n\n    def create_audio_segment(self):\n        \"\"\"Creates an empty, silent, Audio Segment.\"\"\"\n        self.audio_segment = AudioSegment.silent()\n\n    def add_audio_segment(\n        self,\n        new_segment: AudioSegment,\n        time: float | None = None,\n        gain_to_background: float | None = None,\n    ):\n        \"\"\"\n        This method adds an audio segment from an\n        AudioSegment type object and suitable parameters.\n\n        Parameters\n        ----------\n        new_segment\n            The audio segment to add\n\n        time\n            the timestamp at which the\n            sound should be added.\n\n        gain_to_background\n            The gain of the segment from the background.\n        \"\"\"\n        if not self.includes_sound:\n            self.includes_sound = True\n            self.create_audio_segment()\n        segment = self.audio_segment\n        curr_end = segment.duration_seconds\n        if time is None:\n            time = curr_end\n        if time < 0:\n            raise ValueError(\"Adding sound at timestamp < 0\")\n\n        new_end = time + new_segment.duration_seconds\n        diff = new_end - curr_end\n        if diff > 0:\n            segment = segment.append(\n                AudioSegment.silent(int(np.ceil(diff * 1000))),\n                crossfade=0,\n            )\n        self.audio_segment = segment.overlay(\n            new_segment,\n            position=int(1000 * time),\n            gain_during_overlay=gain_to_background,\n        )\n\n    def add_sound(\n        self,\n        sound_file: str,\n        time: float | None = None,\n        gain: float | None = None,\n        **kwargs,\n    ):\n        \"\"\"\n        This method adds an audio segment from a sound file.\n\n        Parameters\n        ----------\n        sound_file\n            The path to the sound file.\n\n        time\n            The timestamp at which the audio should be added.\n\n        gain\n            The gain of the given audio segment.\n\n        **kwargs\n            This method uses add_audio_segment, so any keyword arguments\n            used there can be referenced here.\n\n        \"\"\"\n        file_path = get_full_sound_file_path(sound_file)\n        # we assume files with .wav / .raw suffix are actually\n        # .wav and .raw files, respectively.\n        if file_path.suffix not in (\".wav\", \".raw\"):\n            # we need to pass delete=False to work on Windows\n            # TODO: figure out a way to cache the wav file generated (benchmark needed)\n            with NamedTemporaryFile(suffix=\".wav\", delete=False) as wav_file_path:\n                convert_audio(file_path, wav_file_path, \"pcm_s16le\")\n                new_segment = AudioSegment.from_file(wav_file_path.name)\n                logger.info(f\"Automatically converted {file_path} to .wav\")\n            Path(wav_file_path.name).unlink()\n        else:\n            new_segment = AudioSegment.from_file(file_path)\n\n        if gain:\n            new_segment = new_segment.apply_gain(gain)\n        self.add_audio_segment(new_segment, time, **kwargs)\n\n    # Writers\n    def begin_animation(\n        self, allow_write: bool = False, file_path: StrPath | None = None\n    ) -> None:\n        \"\"\"\n        Used internally by manim to stream the animation to FFMPEG for\n        displaying or writing to a file.\n\n        Parameters\n        ----------\n        allow_write\n            Whether or not to write to a video file.\n        \"\"\"\n        if write_to_movie() and allow_write:\n            self.open_partial_movie_stream(file_path=file_path)\n\n    def end_animation(self, allow_write: bool = False) -> None:\n        \"\"\"\n        Internally used by Manim to stop streaming to\n        FFMPEG gracefully.\n\n        Parameters\n        ----------\n        allow_write\n            Whether or not to write to a video file.\n        \"\"\"\n        if write_to_movie() and allow_write:\n            self.close_partial_movie_stream()\n\n    def listen_and_write(self):\n        \"\"\"For internal use only: blocks until new frame is available on the queue.\"\"\"\n        while True:\n            num_frames, frame_data = self.queue.get()\n            if frame_data is None:\n                break\n\n            self.encode_and_write_frame(frame_data, num_frames)\n\n    def encode_and_write_frame(self, frame: PixelArray, num_frames: int) -> None:\n        \"\"\"\n        For internal use only: takes a given frame in ``np.ndarray`` format and\n        write it to the stream\n        \"\"\"\n        for _ in range(num_frames):\n            # Notes: precomputing reusing packets does not work!\n            # I.e., you cannot do `packets = encode(...)`\n            # and reuse it, as it seems that `mux(...)`\n            # consumes the packet.\n            # The same issue applies for `av_frame`,\n            # reusing it renders weird-looking frames.\n            av_frame = av.VideoFrame.from_ndarray(frame, format=\"rgba\")\n            for packet in self.video_stream.encode(av_frame):\n                self.video_container.mux(packet)\n\n    def write_frame(\n        self, frame_or_renderer: np.ndarray | OpenGLRenderer, num_frames: int = 1\n    ):\n        \"\"\"\n        Used internally by Manim to write a frame to\n        the FFMPEG input buffer.\n\n        Parameters\n        ----------\n        frame_or_renderer\n            Pixel array of the frame.\n        num_frames\n            The number of times to write frame.\n        \"\"\"\n        if write_to_movie():\n            frame: np.ndarray = (\n                frame_or_renderer.get_frame()\n                if config.renderer == RendererType.OPENGL\n                else frame_or_renderer\n            )\n\n            msg = (num_frames, frame)\n            self.queue.put(msg)\n\n        if is_png_format() and not config[\"dry_run\"]:\n            image: Image = (\n                frame_or_renderer.get_image()\n                if config.renderer == RendererType.OPENGL\n                else Image.fromarray(frame_or_renderer)\n            )\n            target_dir = self.image_file_path.parent / self.image_file_path.stem\n            extension = self.image_file_path.suffix\n            self.output_image(\n                image,\n                target_dir,\n                extension,\n                config[\"zero_pad\"],\n            )\n\n    def output_image(self, image: Image.Image, target_dir, ext, zero_pad: bool):\n        if zero_pad:\n            image.save(f\"{target_dir}{str(self.frame_count).zfill(zero_pad)}{ext}\")\n        else:\n            image.save(f\"{target_dir}{self.frame_count}{ext}\")\n        self.frame_count += 1\n\n    def save_final_image(self, image: np.ndarray):\n        \"\"\"\n        The name is a misnomer. This method saves the image\n        passed to it as an in the default image directory.\n\n        Parameters\n        ----------\n        image\n            The pixel array of the image to save.\n        \"\"\"\n        if config[\"dry_run\"]:\n            return\n        if not config[\"output_file\"]:\n            self.image_file_path = add_version_before_extension(self.image_file_path)\n\n        image.save(self.image_file_path)\n        self.print_file_ready_message(self.image_file_path)\n\n    def finish(self) -> None:\n        \"\"\"\n        Finishes writing to the FFMPEG buffer or writing images\n        to output directory.\n        Combines the partial movie files into the\n        whole scene.\n        If save_last_frame is True, saves the last\n        frame in the default image directory.\n        \"\"\"\n        if write_to_movie():\n            self.combine_to_movie()\n            if config.save_sections:\n                self.combine_to_section_videos()\n            if config[\"flush_cache\"]:\n                self.flush_cache_directory()\n            else:\n                self.clean_cache()\n        elif is_png_format() and not config[\"dry_run\"]:\n            target_dir = self.image_file_path.parent / self.image_file_path.stem\n            logger.info(\"\\n%i images ready at %s\\n\", self.frame_count, str(target_dir))\n        if self.subcaptions:\n            self.write_subcaption_file()\n\n    def open_partial_movie_stream(self, file_path=None) -> None:\n        \"\"\"Open a container holding a video stream.\n\n        This is used internally by Manim initialize the container holding\n        the video stream of a partial movie file.\n        \"\"\"\n        if file_path is None:\n            file_path = self.partial_movie_files[self.renderer.num_plays]\n        self.partial_movie_file_path = file_path\n\n        fps = to_av_frame_rate(config.frame_rate)\n\n        partial_movie_file_codec = \"libx264\"\n        partial_movie_file_pix_fmt = \"yuv420p\"\n        av_options = {\n            \"an\": \"1\",  # ffmpeg: -an, no audio\n            \"crf\": \"23\",  # ffmpeg: -crf, constant rate factor (improved bitrate)\n        }\n\n        if config.movie_file_extension == \".webm\":\n            partial_movie_file_codec = \"libvpx-vp9\"\n            av_options[\"-auto-alt-ref\"] = \"1\"\n            if config.transparent:\n                partial_movie_file_pix_fmt = \"yuva420p\"\n\n        elif config.transparent:\n            partial_movie_file_codec = \"qtrle\"\n            partial_movie_file_pix_fmt = \"argb\"\n\n        with av.open(file_path, mode=\"w\") as video_container:\n            stream = video_container.add_stream(\n                partial_movie_file_codec,\n                rate=fps,\n                options=av_options,\n            )\n            stream.pix_fmt = partial_movie_file_pix_fmt\n            stream.width = config.pixel_width\n            stream.height = config.pixel_height\n\n            self.video_container = video_container\n            self.video_stream = stream\n\n            self.queue: Queue[tuple[int, PixelArray | None]] = Queue()\n            self.writer_thread = Thread(target=self.listen_and_write, args=())\n            self.writer_thread.start()\n\n    def close_partial_movie_stream(self) -> None:\n        \"\"\"Close the currently opened video container.\n\n        Used internally by Manim to first flush the remaining packages\n        in the video stream holding a partial file, and then close\n        the corresponding container.\n        \"\"\"\n        self.queue.put((-1, None))\n        self.writer_thread.join()\n\n        for packet in self.video_stream.encode():\n            self.video_container.mux(packet)\n\n        self.video_container.close()\n\n        logger.info(\n            f\"Animation {self.renderer.num_plays} : Partial movie file written in %(path)s\",\n            {\"path\": f\"'{self.partial_movie_file_path}'\"},\n        )\n\n    def is_already_cached(self, hash_invocation: str):\n        \"\"\"Will check if a file named with `hash_invocation` exists.\n\n        Parameters\n        ----------\n        hash_invocation\n            The hash corresponding to an invocation to either `scene.play` or `scene.wait`.\n\n        Returns\n        -------\n        :class:`bool`\n            Whether the file exists.\n        \"\"\"\n        if not hasattr(self, \"partial_movie_directory\") or not write_to_movie():\n            return False\n        path = (\n            self.partial_movie_directory\n            / f\"{hash_invocation}{config['movie_file_extension']}\"\n        )\n        return path.exists()\n\n    def combine_files(\n        self,\n        input_files: list[str],\n        output_file: Path,\n        create_gif=False,\n        includes_sound=False,\n    ):\n        file_list = self.partial_movie_directory / \"partial_movie_file_list.txt\"\n        logger.debug(\n            f\"Partial movie files to combine ({len(input_files)} files): %(p)s\",\n            {\"p\": input_files[:5]},\n        )\n        with file_list.open(\"w\", encoding=\"utf-8\") as fp:\n            fp.write(\"# This file is used internally by FFMPEG.\\n\")\n            for pf_path in input_files:\n                pf_path = Path(pf_path).as_posix()\n                fp.write(f\"file 'file:{pf_path}'\\n\")\n\n        av_options = {\n            \"safe\": \"0\",  # needed to read files\n        }\n\n        if not includes_sound:\n            av_options[\"an\"] = \"1\"\n\n        partial_movies_input = av.open(\n            str(file_list), options=av_options, format=\"concat\"\n        )\n        partial_movies_stream = partial_movies_input.streams.video[0]\n        output_container = av.open(str(output_file), mode=\"w\")\n        output_container.metadata[\"comment\"] = (\n            f\"Rendered with Manim Community v{__version__}\"\n        )\n        output_stream = output_container.add_stream(\n            codec_name=\"gif\" if create_gif else None,\n            template=partial_movies_stream if not create_gif else None,\n        )\n        if config.transparent and config.movie_file_extension == \".webm\":\n            output_stream.pix_fmt = \"yuva420p\"\n        if create_gif:\n            \"\"\"\n            The following solution was largely inspired from this comment\n            https://github.com/imageio/imageio/issues/995#issuecomment-1580533018,\n            and the following code\n            https://github.com/imageio/imageio/blob/65d79140018bb7c64c0692ea72cb4093e8d632a0/imageio/plugins/pyav.py#L927-L996.\n            \"\"\"\n            output_stream.pix_fmt = \"rgb8\"\n            if config.transparent:\n                output_stream.pix_fmt = \"pal8\"\n            output_stream.width = config.pixel_width\n            output_stream.height = config.pixel_height\n            output_stream.rate = to_av_frame_rate(config.frame_rate)\n            graph = av.filter.Graph()\n            input_buffer = graph.add_buffer(template=partial_movies_stream)\n            split = graph.add(\"split\")\n            palettegen = graph.add(\"palettegen\", \"stats_mode=diff\")\n            paletteuse = graph.add(\n                \"paletteuse\", \"dither=bayer:bayer_scale=5:diff_mode=rectangle\"\n            )\n            output_sink = graph.add(\"buffersink\")\n\n            input_buffer.link_to(split)\n            split.link_to(palettegen, 0, 0)  # 1st input of split -> input of palettegen\n            split.link_to(paletteuse, 1, 0)  # 2nd output of split -> 1st input\n            palettegen.link_to(paletteuse, 0, 1)  # output of palettegen -> 2nd input\n            paletteuse.link_to(output_sink)\n\n            graph.configure()\n\n            for frame in partial_movies_input.decode(video=0):\n                graph.push(frame)\n\n            graph.push(None)  # EOF: https://github.com/PyAV-Org/PyAV/issues/886.\n\n            frames_written = 0\n            while True:\n                try:\n                    frame = graph.pull()\n                    if output_stream.codec_context.time_base is not None:\n                        frame.time_base = output_stream.codec_context.time_base\n                    frame.pts = frames_written\n                    frames_written += 1\n                    output_container.mux(output_stream.encode(frame))\n                except av.error.EOFError:\n                    break\n\n            for packet in output_stream.encode():\n                output_container.mux(packet)\n\n        else:\n            for packet in partial_movies_input.demux(partial_movies_stream):\n                # We need to skip the \"flushing\" packets that `demux` generates.\n                if packet.dts is None:\n                    continue\n\n                packet.dts = None  # This seems to be needed, as dts from consecutive\n                # files may not be monotically increasing, so we let libav compute it.\n\n                # We need to assign the packet to the new stream.\n                packet.stream = output_stream\n                output_container.mux(packet)\n\n        partial_movies_input.close()\n        output_container.close()\n\n    def combine_to_movie(self):\n        \"\"\"Used internally by Manim to combine the separate\n        partial movie files that make up a Scene into a single\n        video file for that Scene.\n        \"\"\"\n        partial_movie_files = [el for el in self.partial_movie_files if el is not None]\n        # NOTE: Here we should do a check and raise an exception if partial\n        # movie file is empty.  We can't, as a lot of stuff (in particular, in\n        # tests) use scene initialization, and this error would be raised as\n        # it's just an empty scene initialized.\n\n        # determine output path\n        movie_file_path = self.movie_file_path\n        if is_gif_format():\n            movie_file_path = self.gif_file_path\n\n        if len(partial_movie_files) == 0:  # Prevent calling concat on empty list\n            logger.info(\"No animations are contained in this scene.\")\n            return\n\n        logger.info(\"Combining to Movie file.\")\n        self.combine_files(\n            partial_movie_files,\n            movie_file_path,\n            is_gif_format(),\n            self.includes_sound,\n        )\n\n        # handle sound\n        if self.includes_sound and config.format != \"gif\":\n            sound_file_path = movie_file_path.with_suffix(\".wav\")\n            # Makes sure sound file length will match video file\n            self.add_audio_segment(AudioSegment.silent(0))\n            self.audio_segment.export(\n                sound_file_path,\n                format=\"wav\",\n                bitrate=\"312k\",\n            )\n            # Audio added to a VP9 encoded (webm) video file needs\n            # to be encoded as vorbis or opus. Directly exporting\n            # self.audio_segment with such a codec works in principle,\n            # but tries to call ffmpeg via its CLI -- which we want\n            # to avoid. This is why we need to do the conversion\n            # manually.\n            if config.movie_file_extension == \".webm\":\n                ogg_sound_file_path = sound_file_path.with_suffix(\".ogg\")\n                convert_audio(sound_file_path, ogg_sound_file_path, \"libvorbis\")\n                sound_file_path = ogg_sound_file_path\n            elif config.movie_file_extension == \".mp4\":\n                # Similarly, pyav may reject wav audio in an .mp4 file;\n                # convert to AAC.\n                aac_sound_file_path = sound_file_path.with_suffix(\".aac\")\n                convert_audio(sound_file_path, aac_sound_file_path, \"aac\")\n                sound_file_path = aac_sound_file_path\n\n            temp_file_path = movie_file_path.with_name(\n                f\"{movie_file_path.stem}_temp{movie_file_path.suffix}\"\n            )\n            av_options = {\n                \"shortest\": \"1\",\n                \"metadata\": f\"comment=Rendered with Manim Community v{__version__}\",\n            }\n\n            with (\n                av.open(movie_file_path) as video_input,\n                av.open(sound_file_path) as audio_input,\n            ):\n                video_stream = video_input.streams.video[0]\n                audio_stream = audio_input.streams.audio[0]\n                output_container = av.open(\n                    str(temp_file_path), mode=\"w\", options=av_options\n                )\n                output_video_stream = output_container.add_stream(template=video_stream)\n                output_audio_stream = output_container.add_stream(template=audio_stream)\n\n                for packet in video_input.demux(video_stream):\n                    # We need to skip the \"flushing\" packets that `demux` generates.\n                    if packet.dts is None:\n                        continue\n\n                    # We need to assign the packet to the new stream.\n                    packet.stream = output_video_stream\n                    output_container.mux(packet)\n\n                for packet in audio_input.demux(audio_stream):\n                    # We need to skip the \"flushing\" packets that `demux` generates.\n                    if packet.dts is None:\n                        continue\n\n                    # We need to assign the packet to the new stream.\n                    packet.stream = output_audio_stream\n                    output_container.mux(packet)\n\n                output_container.close()\n\n            shutil.move(str(temp_file_path), str(movie_file_path))\n            sound_file_path.unlink()\n\n        self.print_file_ready_message(str(movie_file_path))\n        if write_to_movie():\n            for file_path in partial_movie_files:\n                # We have to modify the accessed time so if we have to clean the cache we remove the one used the longest.\n                modify_atime(file_path)\n\n    def combine_to_section_videos(self) -> None:\n        \"\"\"Concatenate partial movie files for each section.\"\"\"\n        self.finish_last_section()\n        sections_index: list[dict[str, Any]] = []\n        for section in self.sections:\n            # only if section does want to be saved\n            if section.video is not None:\n                logger.info(f\"Combining partial files for section '{section.name}'\")\n                self.combine_files(\n                    section.get_clean_partial_movie_files(),\n                    self.sections_output_dir / section.video,\n                )\n                sections_index.append(section.get_dict(self.sections_output_dir))\n        with (self.sections_output_dir / f\"{self.output_name}.json\").open(\"w\") as file:\n            json.dump(sections_index, file, indent=4)\n\n    def clean_cache(self):\n        \"\"\"Will clean the cache by removing the oldest partial_movie_files.\"\"\"\n        cached_partial_movies = [\n            (self.partial_movie_directory / file_name)\n            for file_name in self.partial_movie_directory.iterdir()\n            if file_name != \"partial_movie_file_list.txt\"\n        ]\n        if len(cached_partial_movies) > config[\"max_files_cached\"]:\n            number_files_to_delete = (\n                len(cached_partial_movies) - config[\"max_files_cached\"]\n            )\n            oldest_files_to_delete = sorted(\n                cached_partial_movies,\n                key=lambda path: path.stat().st_atime,\n            )[:number_files_to_delete]\n            for file_to_delete in oldest_files_to_delete:\n                file_to_delete.unlink()\n            logger.info(\n                f\"The partial movie directory is full (> {config['max_files_cached']} files). Therefore, manim has removed the {number_files_to_delete} oldest file(s).\"\n                \" You can change this behaviour by changing max_files_cached in config.\",\n            )\n\n    def flush_cache_directory(self):\n        \"\"\"Delete all the cached partial movie files\"\"\"\n        cached_partial_movies = [\n            self.partial_movie_directory / file_name\n            for file_name in self.partial_movie_directory.iterdir()\n            if file_name != \"partial_movie_file_list.txt\"\n        ]\n        for f in cached_partial_movies:\n            f.unlink()\n        logger.info(\n            f\"Cache flushed. {len(cached_partial_movies)} file(s) deleted in %(par_dir)s.\",\n            {\"par_dir\": self.partial_movie_directory},\n        )\n\n    def write_subcaption_file(self):\n        \"\"\"Writes the subcaption file.\"\"\"\n        if config.output_file is None:\n            return\n        subcaption_file = Path(config.output_file).with_suffix(\".srt\")\n        subcaption_file.write_text(srt.compose(self.subcaptions), encoding=\"utf-8\")\n        logger.info(f\"Subcaption file has been written as {subcaption_file}\")\n\n    def print_file_ready_message(self, file_path):\n        \"\"\"Prints the \"File Ready\" message to STDOUT.\"\"\"\n        config[\"output_file\"] = file_path\n        logger.info(\"\\nFile ready at %(file_path)s\\n\", {\"file_path\": f\"'{file_path}'\"})"}, {"name": "ScreenRectangle", "code": "class ScreenRectangle(Rectangle):\n    def __init__(self, aspect_ratio=16.0 / 9.0, height=4, **kwargs):\n        super().__init__(width=aspect_ratio * height, height=height, **kwargs)\n\n    @property\n    def aspect_ratio(self):\n        \"\"\"The aspect ratio.\n\n        When set, the width is stretched to accommodate\n        the new aspect ratio.\n        \"\"\"\n        return self.width / self.height\n\n    @aspect_ratio.setter\n    def aspect_ratio(self, value):\n        self.stretch_to_fit_width(value * self.height)"}, {"name": "Section", "code": "class Section:\n    r\"\"\"A :class:`.Scene` can be segmented into multiple Sections.\n    Refer to :doc:`the documentation</tutorials/output_and_config>` for more info.\n    It consists of multiple animations.\n\n    Attributes\n    ----------\n        type\\_\n            Can be used by a third party applications to classify different types of sections.\n        video\n            Path to video file with animations belonging to section relative to sections directory.\n            If ``None``, then the section will not be saved.\n        name\n            Human readable, non-unique name for this section.\n        skip_animations\n            Skip rendering the animations in this section when ``True``.\n        partial_movie_files\n            Animations belonging to this section.\n\n    See Also\n    --------\n    :class:`.DefaultSectionType`\n    :meth:`.CairoRenderer.update_skipping_status`\n    :meth:`.OpenGLRenderer.update_skipping_status`\n    \"\"\"\n\n    def __init__(self, type_: str, video: str | None, name: str, skip_animations: bool):\n        self.type_ = type_\n        # None when not to be saved -> still keeps section alive\n        self.video: str | None = video\n        self.name = name\n        self.skip_animations = skip_animations\n        self.partial_movie_files: list[str | None] = []\n\n    def is_empty(self) -> bool:\n        \"\"\"Check whether this section is empty.\n\n        Note that animations represented by ``None`` are also counted.\n        \"\"\"\n        return len(self.partial_movie_files) == 0\n\n    def get_clean_partial_movie_files(self) -> list[str]:\n        \"\"\"Return all partial movie files that are not ``None``.\"\"\"\n        return [el for el in self.partial_movie_files if el is not None]\n\n    def get_dict(self, sections_dir: Path) -> dict[str, Any]:\n        \"\"\"Get dictionary representation with metadata of output video.\n\n        The output from this function is used from every section to build the sections index file.\n        The output video must have been created in the ``sections_dir`` before executing this method.\n        This is the main part of the Segmented Video API.\n        \"\"\"\n        if self.video is None:\n            raise ValueError(\n                f\"Section '{self.name}' cannot be exported as dict, it does not have a video path assigned to it\"\n            )\n\n        video_metadata = get_video_metadata(sections_dir / self.video)\n        return dict(\n            {\n                \"name\": self.name,\n                \"type\": self.type_,\n                \"video\": self.video,\n            },\n            **video_metadata,\n        )\n\n    def __repr__(self):\n        return f\"<Section '{self.name}' stored in '{self.video}'>\""}, {"name": "Sector", "code": "class Sector(AnnularSector):\n    \"\"\"A sector of a circle.\n\n    Examples\n    --------\n    .. manim:: ExampleSector\n        :save_last_frame:\n\n        class ExampleSector(Scene):\n            def construct(self):\n                sector = Sector(radius=2)\n                sector2 = Sector(radius=2.5, angle=60*DEGREES).move_to([-3, 0, 0])\n                sector.set_color(RED)\n                sector2.set_color(PINK)\n                self.add(sector, sector2)\n    \"\"\"\n\n    def __init__(self, radius: float = 1, **kwargs: Any) -> None:\n        super().__init__(inner_radius=0, outer_radius=radius, **kwargs)"}, {"name": "seek_full_path_from_defaults", "code": "def seek_full_path_from_defaults(\n    file_name: StrPath, default_dir: Path, extensions: list[str]\n) -> Path:\n    possible_paths = [Path(file_name).expanduser()]\n    possible_paths += [\n        Path(default_dir) / f\"{file_name}{extension}\" for extension in [\"\", *extensions]\n    ]\n    for path in possible_paths:\n        if path.exists():\n            return path\n    error = (\n        f\"From: {Path.cwd()}, could not find {file_name} at either \"\n        f\"of these locations: {list(map(str, possible_paths))}\"\n    )\n    raise OSError(error)"}, {"name": "select_resolution", "code": "def select_resolution() -> tuple[int, int]:\n    \"\"\"Prompts input of type click.Choice from user. Presents options from QUALITIES constant.\n\n    Returns\n    -------\n    tuple[int, int]\n        Tuple containing height and width.\n    \"\"\"\n    resolution_options: list[tuple[int, int]] = []\n    for quality in QUALITIES.items():\n        resolution_options.append(\n            (quality[1][\"pixel_height\"], quality[1][\"pixel_width\"]),\n        )\n    resolution_options.pop()\n    choice = click.prompt(\n        \"\\nSelect resolution:\\n\",\n        type=cloup.Choice([f\"{i[0]}p\" for i in resolution_options]),\n        show_default=False,\n        default=\"480p\",\n    )\n    matches = [res for res in resolution_options if f\"{res[0]}p\" == choice]\n    return matches[0]"}, {"name": "set_file_logger", "code": "def set_file_logger(scene_name: str, module_name: str, log_dir: Path) -> None:\n    \"\"\"Add a file handler to manim logger.\n\n    The path to the file is built using ``config.log_dir``.\n\n    Parameters\n    ----------\n    scene_name\n        The name of the scene, used in the name of the log file.\n    module_name\n        The name of the module, used in the name of the log file.\n    log_dir\n        Path to the folder where log files are stored.\n    \"\"\"\n    # Note: The log file name will be\n    # <name_of_animation_file>_<name_of_scene>.log, gotten from config.  So it\n    # can differ from the real name of the scene.  <name_of_scene> would only\n    # appear if scene name was provided when manim was called.\n    log_file_name = f\"{module_name}_{scene_name}.log\"\n    log_file_path = log_dir / log_file_name\n\n    file_handler = logging.FileHandler(log_file_path, mode=\"w\")\n    file_handler.setFormatter(JSONFormatter())\n\n    logger = logging.getLogger(\"manim\")\n    logger.addHandler(file_handler)\n    logger.info(\"Log file will be saved in %(logpath)s\", {\"logpath\": log_file_path})"}, {"name": "setup", "code": "def setup(app: Sphinx) -> SetupMetadata:\n    app.add_node(SkipManimNode, html=(visit, depart))\n\n    setup.app = app  # type: ignore[attr-defined]\n    setup.config = app.config  # type: ignore[attr-defined]\n    setup.confdir = app.confdir  # type: ignore[attr-defined]\n\n    app.add_directive(\"manim\", ManimDirective)\n\n    app.connect(\"builder-inited\", _delete_rendering_times)\n    app.connect(\"build-finished\", _log_rendering_times)\n\n    app.add_js_file(\"manim-binder.min.js\")\n    app.add_js_file(\n        None,\n        body=textwrap.dedent(\n            f\"\"\"\\\n                window.initManimBinder({{branch: \"v{manim_version}\"}})\n            \"\"\"\n        ).strip(),\n    )\n\n    metadata: SetupMetadata = {\n        \"parallel_read_safe\": False,\n        \"parallel_write_safe\": True,\n    }\n    return metadata"}, {"name": "SetupMetadata", "code": "class SetupMetadata(TypedDict):\n    parallel_read_safe: bool\n    parallel_write_safe: bool"}, {"name": "Shader", "code": "class Shader:\n    def __init__(\n        self,\n        context,\n        name=None,\n        source=None,\n    ):\n        global shader_program_cache\n        self.context = context\n        self.name = name\n\n        # See if the program is cached.\n        if (\n            self.name in shader_program_cache\n            and shader_program_cache[self.name].ctx == self.context\n        ):\n            self.shader_program = shader_program_cache[self.name]\n        elif source is not None:\n            # Generate the shader from inline code if it was passed.\n            self.shader_program = context.program(**source)\n        else:\n            # Search for a file containing the shader.\n            source_dict = {}\n            source_dict_key = {\n                \"vert\": \"vertex_shader\",\n                \"frag\": \"fragment_shader\",\n                \"geom\": \"geometry_shader\",\n            }\n            shader_folder = SHADER_FOLDER / name\n            for shader_file in shader_folder.iterdir():\n                shader_file_path = shader_folder / shader_file\n                shader_source = get_shader_code_from_file(shader_file_path)\n                source_dict[source_dict_key[shader_file_path.stem]] = shader_source\n            self.shader_program = context.program(**source_dict)\n\n        # Cache the shader.\n        if name is not None and name not in shader_program_cache:\n            shader_program_cache[self.name] = self.shader_program\n\n    def set_uniform(self, name, value):\n        with contextlib.suppress(KeyError):\n            self.shader_program[name] = value"}, {"name": "ShaderWrapper", "code": "class ShaderWrapper:\n    def __init__(\n        self,\n        vert_data=None,\n        vert_indices=None,\n        shader_folder=None,\n        uniforms=None,  # A dictionary mapping names of uniform variables\n        texture_paths=None,  # A dictionary mapping names to filepaths for textures.\n        depth_test=False,\n        render_primitive=moderngl.TRIANGLE_STRIP,\n    ):\n        self.vert_data = vert_data\n        self.vert_indices = vert_indices\n        self.vert_attributes = vert_data.dtype.names\n        self.shader_folder = Path(shader_folder or \"\")\n        self.uniforms = uniforms or {}\n        self.texture_paths = texture_paths or {}\n        self.depth_test = depth_test\n        self.render_primitive = str(render_primitive)\n        self.init_program_code()\n        self.refresh_id()\n\n    def copy(self):\n        result = copy.copy(self)\n        result.vert_data = np.array(self.vert_data)\n        if result.vert_indices is not None:\n            result.vert_indices = np.array(self.vert_indices)\n        if self.uniforms:\n            result.uniforms = dict(self.uniforms)\n        if self.texture_paths:\n            result.texture_paths = dict(self.texture_paths)\n        return result\n\n    def is_valid(self):\n        return all(\n            [\n                self.vert_data is not None,\n                self.program_code[\"vertex_shader\"] is not None,\n                self.program_code[\"fragment_shader\"] is not None,\n            ],\n        )\n\n    def get_id(self):\n        return self.id\n\n    def get_program_id(self):\n        return self.program_id\n\n    def create_id(self):\n        # A unique id for a shader\n        return \"|\".join(\n            map(\n                str,\n                [\n                    self.program_id,\n                    self.uniforms,\n                    self.texture_paths,\n                    self.depth_test,\n                    self.render_primitive,\n                ],\n            ),\n        )\n\n    def refresh_id(self):\n        self.program_id = self.create_program_id()\n        self.id = self.create_id()\n\n    def create_program_id(self):\n        return hash(\n            \"\".join(\n                self.program_code[f\"{name}_shader\"] or \"\"\n                for name in (\"vertex\", \"geometry\", \"fragment\")\n            ),\n        )\n\n    def init_program_code(self):\n        def get_code(name: str) -> str | None:\n            return get_shader_code_from_file(\n                self.shader_folder / f\"{name}.glsl\",\n            )\n\n        self.program_code = {\n            \"vertex_shader\": get_code(\"vert\"),\n            \"geometry_shader\": get_code(\"geom\"),\n            \"fragment_shader\": get_code(\"frag\"),\n        }\n\n    def get_program_code(self):\n        return self.program_code\n\n    def replace_code(self, old, new):\n        code_map = self.program_code\n        for name, _code in code_map.items():\n            if code_map[name] is None:\n                continue\n            code_map[name] = re.sub(old, new, code_map[name])\n        self.refresh_id()\n\n    def combine_with(self, *shader_wrappers):\n        # Assume they are of the same type\n        if len(shader_wrappers) == 0:\n            return\n        if self.vert_indices is not None:\n            num_verts = len(self.vert_data)\n            indices_list = [self.vert_indices]\n            data_list = [self.vert_data]\n            for sw in shader_wrappers:\n                indices_list.append(sw.vert_indices + num_verts)\n                data_list.append(sw.vert_data)\n                num_verts += len(sw.vert_data)\n            self.vert_indices = np.hstack(indices_list)\n            self.vert_data = np.hstack(data_list)\n        else:\n            self.vert_data = np.hstack(\n                [self.vert_data, *(sw.vert_data for sw in shader_wrappers)],\n            )\n        return self"}, {"name": "shoelace", "code": "def shoelace(x_y: Point2D_Array) -> float:\n    \"\"\"2D implementation of the shoelace formula.\n\n    Returns\n    -------\n    :class:`float`\n        Returns signed area.\n    \"\"\"\n    x = x_y[:, 0]\n    y = x_y[:, 1]\n    val: float = np.trapz(y, x)\n    return val"}, {"name": "shoelace_direction", "code": "def shoelace_direction(x_y: Point2D_Array) -> str:\n    \"\"\"\n    Uses the area determined by the shoelace method to determine whether\n    the input set of points is directed clockwise or counterclockwise.\n\n    Returns\n    -------\n    :class:`str`\n        Either ``\"CW\"`` or ``\"CCW\"``.\n    \"\"\"\n    area = shoelace(x_y)\n    return \"CW\" if area > 0 else \"CCW\""}, {"name": "show", "code": "def show() -> None:\n    parser = make_config_parser()\n    rich_non_style_entries = [a.replace(\".\", \"_\") for a in RICH_NON_STYLE_ENTRIES]\n    for category in parser:\n        console.print(f\"{category}\", style=\"bold green underline\")\n        for entry in parser[category]:\n            if category == \"logger\" and entry not in rich_non_style_entries:\n                console.print(f\"{entry} :\", end=\"\")\n                console.print(\n                    f\" {parser[category][entry]}\",\n                    style=parser[category][entry],\n                )\n            else:\n                console.print(f\"{entry} : {parser[category][entry]}\")\n        console.print(\"\\n\")"}, {"name": "show_diff_helper", "code": "def show_diff_helper(\n    frame_number: int,\n    frame_data: PixelArray,\n    expected_frame_data: PixelArray,\n    control_data_filename: str,\n) -> None:\n    \"\"\"Will visually display with matplotlib differences between frame generated and the one expected.\"\"\"\n    import matplotlib.gridspec as gridspec\n    import matplotlib.pyplot as plt\n\n    gs = gridspec.GridSpec(2, 2)\n    fig = plt.figure()\n    fig.suptitle(f\"Test difference summary at frame {frame_number}\", fontsize=16)\n\n    ax = fig.add_subplot(gs[0, 0])\n    ax.imshow(frame_data)\n    ax.set_title(\"Generated\")\n\n    ax = fig.add_subplot(gs[0, 1])\n    ax.imshow(expected_frame_data)\n    ax.set_title(\"Expected\")\n\n    ax = fig.add_subplot(gs[1, :])\n    diff_im = expected_frame_data.copy()\n    diff_im = np.where(\n        frame_data != np.array([0, 0, 0, 255]),\n        np.array([0, 255, 0, 255], dtype=\"uint8\"),\n        np.array([0, 0, 0, 255], dtype=\"uint8\"),\n    )  # Set any non-black pixels to green\n    np.putmask(\n        diff_im,\n        expected_frame_data != frame_data,\n        np.array([255, 0, 0, 255], dtype=\"uint8\"),\n    )  # Set any different pixels to red\n    ax.imshow(diff_im, interpolation=\"nearest\")\n    ax.set_title(\"Difference summary: (green = same, red = different)\")\n\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\")\n        try:\n            plt.show()\n        except UserWarning:\n            filename = f\"{control_data_filename[:-4]}-diff.pdf\"\n            plt.savefig(filename)\n            logging.warning(\n                \"Interactive matplotlib interface not available,\"\n                f\" diff saved to {filename}.\"\n            )"}, {"name": "show_splash", "code": "def show_splash(ctx: click.Context, param: click.Option, value: str | None) -> None:\n    \"\"\"When giving a value by console, show an initial message with the Manim\n    version before executing any other command: ``Manim Community vA.B.C``.\n\n    Parameters\n    ----------\n    ctx\n        The Click context.\n    param\n        A Click option.\n    value\n        A string value given by console, or None.\n    \"\"\"\n    if value:\n        console.print(f\"Manim Community [green]v{__version__}[/green]\\n\")"}, {"name": "ShowIncreasingSubsets", "code": "class ShowIncreasingSubsets(Animation):\n    \"\"\"Show one submobject at a time, leaving all previous ones displayed on screen.\n\n    Examples\n    --------\n\n    .. manim:: ShowIncreasingSubsetsScene\n\n        class ShowIncreasingSubsetsScene(Scene):\n            def construct(self):\n                p = VGroup(Dot(), Square(), Triangle())\n                self.add(p)\n                self.play(ShowIncreasingSubsets(p))\n                self.wait()\n    \"\"\"\n\n    def __init__(\n        self,\n        group: Mobject,\n        suspend_mobject_updating: bool = False,\n        int_func: Callable[[np.ndarray], np.ndarray] = np.floor,\n        reverse_rate_function=False,\n        **kwargs,\n    ) -> None:\n        self.all_submobs = list(group.submobjects)\n        self.int_func = int_func\n        for mobj in self.all_submobs:\n            mobj.set_opacity(0)\n        super().__init__(\n            group,\n            suspend_mobject_updating=suspend_mobject_updating,\n            reverse_rate_function=reverse_rate_function,\n            **kwargs,\n        )\n\n    def interpolate_mobject(self, alpha: float) -> None:\n        n_submobs = len(self.all_submobs)\n        value = (\n            1 - self.rate_func(alpha)\n            if self.reverse_rate_function\n            else self.rate_func(alpha)\n        )\n        index = int(self.int_func(value * n_submobs))\n        self.update_submobject_list(index)\n\n    def update_submobject_list(self, index: int) -> None:\n        for mobj in self.all_submobs[:index]:\n            mobj.set_opacity(1)\n        for mobj in self.all_submobs[index:]:\n            mobj.set_opacity(0)"}, {"name": "ShowPartial", "code": "class ShowPartial(Animation):\n    \"\"\"Abstract class for Animations that show the VMobject partially.\n\n    Raises\n    ------\n    :class:`TypeError`\n        If ``mobject`` is not an instance of :class:`~.VMobject`.\n\n    See Also\n    --------\n    :class:`Create`, :class:`~.ShowPassingFlash`\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: VMobject | OpenGLVMobject | OpenGLSurface | None,\n        **kwargs,\n    ):\n        pointwise = getattr(mobject, \"pointwise_become_partial\", None)\n        if not callable(pointwise):\n            raise TypeError(f\"{self.__class__.__name__} only works for VMobjects.\")\n        super().__init__(mobject, **kwargs)\n\n    def interpolate_submobject(\n        self,\n        submobject: Mobject,\n        starting_submobject: Mobject,\n        alpha: float,\n    ) -> None:\n        submobject.pointwise_become_partial(\n            starting_submobject, *self._get_bounds(alpha)\n        )\n\n    def _get_bounds(self, alpha: float) -> tuple[float, float]:\n        raise NotImplementedError(\"Please use Create or ShowPassingFlash\")"}, {"name": "ShowPassingFlash", "code": "class ShowPassingFlash(ShowPartial):\n    r\"\"\"Show only a sliver of the VMobject each frame.\n\n    Parameters\n    ----------\n    mobject\n        The mobject whose stroke is animated.\n    time_width\n        The length of the sliver relative to the length of the stroke.\n\n    Examples\n    --------\n    .. manim:: TimeWidthValues\n\n        class TimeWidthValues(Scene):\n            def construct(self):\n                p = RegularPolygon(5, color=DARK_GRAY, stroke_width=6).scale(3)\n                lbl = VMobject()\n                self.add(p, lbl)\n                p = p.copy().set_color(BLUE)\n                for time_width in [0.2, 0.5, 1, 2]:\n                    lbl.become(Tex(r\"\\texttt{time\\_width={{%.1f}}}\"%time_width))\n                    self.play(ShowPassingFlash(\n                        p.copy().set_color(BLUE),\n                        run_time=2,\n                        time_width=time_width\n                    ))\n\n    See Also\n    --------\n    :class:`~.Create`\n\n    \"\"\"\n\n    def __init__(self, mobject: VMobject, time_width: float = 0.1, **kwargs) -> None:\n        self.time_width = time_width\n        super().__init__(mobject, remover=True, introducer=True, **kwargs)\n\n    def _get_bounds(self, alpha: float) -> tuple[float, float]:\n        tw = self.time_width\n        upper = interpolate(0, 1 + tw, alpha)\n        lower = upper - tw\n        upper = min(upper, 1)\n        lower = max(lower, 0)\n        return (lower, upper)\n\n    def clean_up_from_scene(self, scene: Scene) -> None:\n        super().clean_up_from_scene(scene)\n        for submob, start in self.get_all_families_zipped():\n            submob.pointwise_become_partial(start, 0, 1)"}, {"name": "ShowPassingFlashWithThinningStrokeWidth", "code": "class ShowPassingFlashWithThinningStrokeWidth(AnimationGroup):\n    def __init__(self, vmobject, n_segments=10, time_width=0.1, remover=True, **kwargs):\n        self.n_segments = n_segments\n        self.time_width = time_width\n        self.remover = remover\n        max_stroke_width = vmobject.get_stroke_width()\n        max_time_width = kwargs.pop(\"time_width\", self.time_width)\n        super().__init__(\n            *(\n                ShowPassingFlash(\n                    vmobject.copy().set_stroke(width=stroke_width),\n                    time_width=time_width,\n                    **kwargs,\n                )\n                for stroke_width, time_width in zip(\n                    np.linspace(0, max_stroke_width, self.n_segments),\n                    np.linspace(max_time_width, 0, self.n_segments),\n                )\n            ),\n        )"}, {"name": "ShowSubmobjectsOneByOne", "code": "class ShowSubmobjectsOneByOne(ShowIncreasingSubsets):\n    \"\"\"Show one submobject at a time, removing all previously displayed ones from screen.\"\"\"\n\n    def __init__(\n        self,\n        group: Iterable[Mobject],\n        int_func: Callable[[np.ndarray], np.ndarray] = np.ceil,\n        **kwargs,\n    ) -> None:\n        new_group = Group(*group)\n        super().__init__(new_group, int_func=int_func, **kwargs)\n\n    def update_submobject_list(self, index: int) -> None:\n        current_submobjects = self.all_submobs[:index]\n        for mobj in current_submobjects[:-1]:\n            mobj.set_opacity(0)\n        if len(current_submobjects) > 0:\n            current_submobjects[-1].set_opacity(1)"}, {"name": "ShrinkToCenter", "code": "class ShrinkToCenter(ScaleInPlace):\n    \"\"\"Animation that makes a mobject shrink to center.\n\n    Examples\n    --------\n\n    .. manim:: ShrinkToCenterExample\n\n        class ShrinkToCenterExample(Scene):\n            def construct(self):\n                self.play(ShrinkToCenter(Text(\"Hello World!\")))\n\n    \"\"\"\n\n    def __init__(self, mobject: Mobject, **kwargs) -> None:\n        super().__init__(mobject, 0, **kwargs)"}, {"name": "sigmoid", "code": "def sigmoid(x: float) -> float:\n    r\"\"\"Returns the output of the logistic function.\n\n    The logistic function, a common example of a sigmoid function, is defined\n    as :math:`\\frac{1}{1 + e^{-x}}`.\n\n    References\n    ----------\n    - https://en.wikipedia.org/wiki/Sigmoid_function\n    - https://en.wikipedia.org/wiki/Logistic_function\n    \"\"\"\n    value: float = 1.0 / (1 + np.exp(-x))\n    return value"}, {"name": "SingleStringMathTex", "code": "class SingleStringMathTex(SVGMobject):\n    \"\"\"Elementary building block for rendering text with LaTeX.\n\n    Tests\n    -----\n    Check that creating a :class:`~.SingleStringMathTex` object works::\n\n        >>> SingleStringMathTex('Test') # doctest: +SKIP\n        SingleStringMathTex('Test')\n    \"\"\"\n\n    def __init__(\n        self,\n        tex_string: str,\n        stroke_width: float = 0,\n        should_center: bool = True,\n        height: float | None = None,\n        organize_left_to_right: bool = False,\n        tex_environment: str = \"align*\",\n        tex_template: TexTemplate | None = None,\n        font_size: float = DEFAULT_FONT_SIZE,\n        color: ParsableManimColor | None = None,\n        **kwargs,\n    ):\n        if color is None:\n            color = VMobject().color\n\n        self._font_size = font_size\n        self.organize_left_to_right = organize_left_to_right\n        self.tex_environment = tex_environment\n        if tex_template is None:\n            tex_template = config[\"tex_template\"]\n        self.tex_template = tex_template\n\n        assert isinstance(tex_string, str)\n        self.tex_string = tex_string\n        file_name = tex_to_svg_file(\n            self._get_modified_expression(tex_string),\n            environment=self.tex_environment,\n            tex_template=self.tex_template,\n        )\n        super().__init__(\n            file_name=file_name,\n            should_center=should_center,\n            stroke_width=stroke_width,\n            height=height,\n            color=color,\n            path_string_config={\n                \"should_subdivide_sharp_curves\": True,\n                \"should_remove_null_curves\": True,\n            },\n            **kwargs,\n        )\n        self.init_colors()\n\n        # used for scaling via font_size.setter\n        self.initial_height = self.height\n\n        if height is None:\n            self.font_size = self._font_size\n\n        if self.organize_left_to_right:\n            self._organize_submobjects_left_to_right()\n\n    def __repr__(self):\n        return f\"{type(self).__name__}({repr(self.tex_string)})\"\n\n    @property\n    def font_size(self):\n        \"\"\"The font size of the tex mobject.\"\"\"\n        return self.height / self.initial_height / SCALE_FACTOR_PER_FONT_POINT\n\n    @font_size.setter\n    def font_size(self, font_val):\n        if font_val <= 0:\n            raise ValueError(\"font_size must be greater than 0.\")\n        elif self.height > 0:\n            # sometimes manim generates a SingleStringMathex mobject with 0 height.\n            # can't be scaled regardless and will error without the elif.\n\n            # scale to a factor of the initial height so that setting\n            # font_size does not depend on current size.\n            self.scale(font_val / self.font_size)\n\n    def _get_modified_expression(self, tex_string):\n        result = tex_string\n        result = result.strip()\n        result = self._modify_special_strings(result)\n        return result\n\n    def _modify_special_strings(self, tex):\n        tex = tex.strip()\n        should_add_filler = reduce(\n            op.or_,\n            [\n                # Fraction line needs something to be over\n                tex == \"\\\\over\",\n                tex == \"\\\\overline\",\n                # Make sure sqrt has overbar\n                tex == \"\\\\sqrt\",\n                tex == \"\\\\sqrt{\",\n                # Need to add blank subscript or superscript\n                tex.endswith(\"_\"),\n                tex.endswith(\"^\"),\n                tex.endswith(\"dot\"),\n            ],\n        )\n\n        if should_add_filler:\n            filler = \"{\\\\quad}\"\n            tex += filler\n\n        if tex == \"\\\\substack\":\n            tex = \"\\\\quad\"\n\n        if tex == \"\":\n            tex = \"\\\\quad\"\n\n        # To keep files from starting with a line break\n        if tex.startswith(\"\\\\\\\\\"):\n            tex = tex.replace(\"\\\\\\\\\", \"\\\\quad\\\\\\\\\")\n\n        # Handle imbalanced \\left and \\right\n        num_lefts, num_rights = (\n            len([s for s in tex.split(substr)[1:] if s and s[0] in \"(){}[]|.\\\\\"])\n            for substr in (\"\\\\left\", \"\\\\right\")\n        )\n        if num_lefts != num_rights:\n            tex = tex.replace(\"\\\\left\", \"\\\\big\")\n            tex = tex.replace(\"\\\\right\", \"\\\\big\")\n\n        tex = self._remove_stray_braces(tex)\n\n        for context in [\"array\"]:\n            begin_in = (\"\\\\begin{%s}\" % context) in tex  # noqa: UP031\n            end_in = (\"\\\\end{%s}\" % context) in tex  # noqa: UP031\n            if begin_in ^ end_in:\n                # Just turn this into a blank string,\n                # which means caller should leave a\n                # stray \\\\begin{...} with other symbols\n                tex = \"\"\n        return tex\n\n    def _remove_stray_braces(self, tex):\n        r\"\"\"\n        Makes :class:`~.MathTex` resilient to unmatched braces.\n\n        This is important when the braces in the TeX code are spread over\n        multiple arguments as in, e.g., ``MathTex(r\"e^{i\", r\"\\tau} = 1\")``.\n        \"\"\"\n        # \"\\{\" does not count (it's a brace literal), but \"\\\\{\" counts (it's a new line and then brace)\n        num_lefts = tex.count(\"{\") - tex.count(\"\\\\{\") + tex.count(\"\\\\\\\\{\")\n        num_rights = tex.count(\"}\") - tex.count(\"\\\\}\") + tex.count(\"\\\\\\\\}\")\n        while num_rights > num_lefts:\n            tex = \"{\" + tex\n            num_lefts += 1\n        while num_lefts > num_rights:\n            tex = tex + \"}\"\n            num_rights += 1\n        return tex\n\n    def _organize_submobjects_left_to_right(self):\n        self.sort(lambda p: p[0])\n        return self\n\n    def get_tex_string(self):\n        return self.tex_string\n\n    def init_colors(self, propagate_colors=True):\n        for submobject in self.submobjects:\n            # needed to preserve original (non-black)\n            # TeX colors of individual submobjects\n            if submobject.color != BLACK:\n                continue\n            submobject.color = self.color\n            if config.renderer == RendererType.OPENGL:\n                submobject.init_colors()\n            elif config.renderer == RendererType.CAIRO:\n                submobject.init_colors(propagate_colors=propagate_colors)"}, {"name": "SkipManimNode", "code": "class SkipManimNode(nodes.Admonition, nodes.Element):\n    \"\"\"Auxiliary node class that is used when the ``skip-manim`` tag is present\n    or ``.pot`` files are being built.\n\n    Skips rendering the manim directive and outputs a placeholder instead.\n    \"\"\"\n\n    pass"}, {"name": "slow_into", "code": "def slow_into(t: float) -> float:\n    val: float = np.sqrt(1 - (1 - t) * (1 - t))\n    return val"}, {"name": "smart_replace", "code": "def smart_replace(base: str, alias: str, substitution: str) -> str:\n    \"\"\"Auxiliary function for substituting type aliases into a base\n    string, when there are overlaps between the aliases themselves.\n\n    Parameters\n    ----------\n    base\n        The string in which the type aliases will be located and\n        replaced.\n    alias\n        The substring to be substituted.\n    substitution\n        The string which will replace every occurrence of ``alias``.\n\n    Returns\n    -------\n    str\n        The new string after the alias substitution.\n    \"\"\"\n    occurrences = []\n    len_alias = len(alias)\n    len_base = len(base)\n\n    def condition(char: str) -> bool:\n        return not char.isalnum() and char != \"_\"\n\n    start = 0\n    i = 0\n    while True:\n        i = base.find(alias, start)\n        if i == -1:\n            break\n        if (i == 0 or condition(base[i - 1])) and (\n            i + len_alias == len_base or condition(base[i + len_alias])\n        ):\n            occurrences.append(i)\n        start = i + len_alias\n\n    for o in occurrences[::-1]:\n        base = base[:o] + substitution + base[o + len_alias :]\n\n    return base"}, {"name": "smooth", "code": "def smooth(t: float, inflection: float = 10.0) -> float:\n    error = sigmoid(-inflection / 2)\n    return min(\n        max((sigmoid(inflection * (t - 0.5)) - error) / (1 - 2 * error), 0),\n        1,\n    )"}, {"name": "SmoothedVectorizedHomotopy", "code": "class SmoothedVectorizedHomotopy(Homotopy):\n    def interpolate_submobject(\n        self,\n        submobject: Mobject,\n        starting_submobject: Mobject,\n        alpha: float,\n    ) -> None:\n        super().interpolate_submobject(submobject, starting_submobject, alpha)\n        submobject.make_smooth()"}, {"name": "smoothererstep", "code": "def smoothererstep(t: float) -> float:\n    \"\"\"Implementation of the 3rd order SmoothStep sigmoid function.\n    The 1st, 2nd and 3rd derivatives (speed, acceleration and jerk) are zero at the endpoints.\n    https://en.wikipedia.org/wiki/Smoothstep\n    \"\"\"\n    return 35 * t**4 - 84 * t**5 + 70 * t**6 - 20 * t**7"}, {"name": "smootherstep", "code": "def smootherstep(t: float) -> float:\n    \"\"\"Implementation of the 2nd order SmoothStep sigmoid function.\n    The 1st and 2nd derivatives (speed and acceleration) are zero at the endpoints.\n    https://en.wikipedia.org/wiki/Smoothstep\n    \"\"\"\n    return 6 * t**5 - 15 * t**4 + 10 * t**3"}, {"name": "smoothstep", "code": "def smoothstep(t: float) -> float:\n    \"\"\"Implementation of the 1st order SmoothStep sigmoid function.\n    The 1st derivative (speed) is zero at the endpoints.\n    https://en.wikipedia.org/wiki/Smoothstep\n    \"\"\"\n    return 3 * t**2 - 2 * t**3"}, {"name": "SpecialThreeDScene", "code": "class SpecialThreeDScene(ThreeDScene):\n    \"\"\"An extension of :class:`ThreeDScene` with more settings.\n\n    It has some extra configuration for axes, spheres,\n    and an override for low quality rendering. Further key differences\n    are:\n\n    * The camera shades applicable 3DMobjects by default,\n      except if rendering in low quality.\n    * Some default params for Spheres and Axes have been added.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        cut_axes_at_radius=True,\n        camera_config={\"should_apply_shading\": True, \"exponential_projection\": True},\n        three_d_axes_config={\n            \"num_axis_pieces\": 1,\n            \"axis_config\": {\n                \"unit_size\": 2,\n                \"tick_frequency\": 1,\n                \"numbers_with_elongated_ticks\": [0, 1, 2],\n                \"stroke_width\": 2,\n            },\n        },\n        sphere_config={\"radius\": 2, \"resolution\": (24, 48)},\n        default_angled_camera_position={\n            \"phi\": 70 * DEGREES,\n            \"theta\": -110 * DEGREES,\n        },\n        # When scene is extracted with -l flag, this\n        # configuration will override the above configuration.\n        low_quality_config={\n            \"camera_config\": {\"should_apply_shading\": False},\n            \"three_d_axes_config\": {\"num_axis_pieces\": 1},\n            \"sphere_config\": {\"resolution\": (12, 24)},\n        },\n        **kwargs,\n    ):\n        self.cut_axes_at_radius = cut_axes_at_radius\n        self.camera_config = camera_config\n        self.three_d_axes_config = three_d_axes_config\n        self.sphere_config = sphere_config\n        self.default_angled_camera_position = default_angled_camera_position\n        self.low_quality_config = low_quality_config\n        if self.renderer.camera_config[\"pixel_width\"] == config[\"pixel_width\"]:\n            _config = {}\n        else:\n            _config = self.low_quality_config\n        _config = merge_dicts_recursively(_config, kwargs)\n        super().__init__(**_config)\n\n    def get_axes(self):\n        \"\"\"Return a set of 3D axes.\n\n        Returns\n        -------\n        :class:`.ThreeDAxes`\n            A set of 3D axes.\n        \"\"\"\n        axes = ThreeDAxes(**self.three_d_axes_config)\n        for axis in axes:\n            if self.cut_axes_at_radius:\n                p0 = axis.get_start()\n                p1 = axis.number_to_point(-1)\n                p2 = axis.number_to_point(1)\n                p3 = axis.get_end()\n                new_pieces = VGroup(Line(p0, p1), Line(p1, p2), Line(p2, p3))\n                for piece in new_pieces:\n                    piece.shade_in_3d = True\n                new_pieces.match_style(axis.pieces)\n                axis.pieces.submobjects = new_pieces.submobjects\n            for tick in axis.tick_marks:\n                tick.add(VectorizedPoint(1.5 * tick.get_center()))\n        return axes\n\n    def get_sphere(self, **kwargs):\n        \"\"\"\n        Returns a sphere with the passed keyword arguments as properties.\n\n        Parameters\n        ----------\n        **kwargs\n            Any valid parameter of :class:`~.Sphere` or :class:`~.Surface`.\n\n        Returns\n        -------\n        :class:`~.Sphere`\n            The sphere object.\n        \"\"\"\n        config = merge_dicts_recursively(self.sphere_config, kwargs)\n        return Sphere(**config)\n\n    def get_default_camera_position(self):\n        \"\"\"\n        Returns the default_angled_camera position.\n\n        Returns\n        -------\n        dict\n            Dictionary of phi, theta, focal_distance, and gamma.\n        \"\"\"\n        return self.default_angled_camera_position\n\n    def set_camera_to_default_position(self):\n        \"\"\"Sets the camera to its default position.\"\"\"\n        self.set_camera_orientation(**self.default_angled_camera_position)"}, {"name": "Sphere", "code": "class Sphere(Surface):\n    \"\"\"A three-dimensional sphere.\n\n    Parameters\n    ----------\n    center\n        Center of the :class:`Sphere`.\n    radius\n        The radius of the :class:`Sphere`.\n    resolution\n        The number of samples taken of the :class:`Sphere`. A tuple can be used\n        to define different resolutions for ``u`` and ``v`` respectively.\n    u_range\n        The range of the ``u`` variable: ``(u_min, u_max)``.\n    v_range\n        The range of the ``v`` variable: ``(v_min, v_max)``.\n\n    Examples\n    --------\n\n    .. manim:: ExampleSphere\n        :save_last_frame:\n\n        class ExampleSphere(ThreeDScene):\n            def construct(self):\n                self.set_camera_orientation(phi=PI / 6, theta=PI / 6)\n                sphere1 = Sphere(\n                    center=(3, 0, 0),\n                    radius=1,\n                    resolution=(20, 20),\n                    u_range=[0.001, PI - 0.001],\n                    v_range=[0, TAU]\n                )\n                sphere1.set_color(RED)\n                self.add(sphere1)\n                sphere2 = Sphere(center=(-1, -3, 0), radius=2, resolution=(18, 18))\n                sphere2.set_color(GREEN)\n                self.add(sphere2)\n                sphere3 = Sphere(center=(-1, 2, 0), radius=2, resolution=(16, 16))\n                sphere3.set_color(BLUE)\n                self.add(sphere3)\n    \"\"\"\n\n    def __init__(\n        self,\n        center: Point3DLike = ORIGIN,\n        radius: float = 1,\n        resolution: Sequence[int] | None = None,\n        u_range: Sequence[float] = (0, TAU),\n        v_range: Sequence[float] = (0, PI),\n        **kwargs,\n    ) -> None:\n        if config.renderer == RendererType.OPENGL:\n            res_value = (101, 51)\n        elif config.renderer == RendererType.CAIRO:\n            res_value = (24, 12)\n        else:\n            raise Exception(\"Unknown renderer\")\n\n        resolution = resolution if resolution is not None else res_value\n\n        self.radius = radius\n\n        super().__init__(\n            self.func,\n            resolution=resolution,\n            u_range=u_range,\n            v_range=v_range,\n            **kwargs,\n        )\n\n        self.shift(center)\n\n    def func(self, u: float, v: float) -> np.ndarray:\n        \"\"\"The z values defining the :class:`Sphere` being plotted.\n\n        Returns\n        -------\n        :class:`numpy.array`\n            The z values defining the :class:`Sphere`.\n        \"\"\"\n        return self.radius * np.array(\n            [np.cos(u) * np.sin(v), np.sin(u) * np.sin(v), -np.cos(v)],\n        )"}, {"name": "spherical_to_cartesian", "code": "def spherical_to_cartesian(spherical: Sequence[float]) -> np.ndarray:\n    \"\"\"Returns a numpy array ``[x, y, z]`` based on the spherical\n    coordinates given.\n\n    Parameters\n    ----------\n    spherical\n        A list of three floats that correspond to the following:\n\n        r - The distance between the point and the origin.\n\n        theta - The azimuthal angle of the point to the positive x-axis.\n\n        phi - The vertical angle of the point to the positive z-axis.\n    \"\"\"\n    r, theta, phi = spherical\n    return np.array(\n        [\n            r * np.cos(theta) * np.sin(phi),\n            r * np.sin(theta) * np.sin(phi),\n            r * np.cos(phi),\n        ],\n    )"}, {"name": "SpinInFromNothing", "code": "class SpinInFromNothing(GrowFromCenter):\n    \"\"\"Introduce an :class:`~.Mobject` spinning and growing it from its center.\n\n    Parameters\n    ----------\n    mobject\n        The mobjects to be introduced.\n    angle\n        The amount of spinning before mobject reaches its full size. E.g. 2*PI means\n        that the object will do one full spin before being fully introduced.\n    point_color\n        Initial color of the mobject before growing to its full size. Leave empty to match mobject's color.\n\n    Examples\n    --------\n\n    .. manim :: SpinInFromNothingExample\n\n        class SpinInFromNothingExample(Scene):\n            def construct(self):\n                squares = [Square() for _ in range(3)]\n                VGroup(*squares).set_x(0).arrange(buff=2)\n                self.play(SpinInFromNothing(squares[0]))\n                self.play(SpinInFromNothing(squares[1], angle=2 * PI))\n                self.play(SpinInFromNothing(squares[2], point_color=RED))\n\n    \"\"\"\n\n    def __init__(\n        self, mobject: Mobject, angle: float = PI / 2, point_color: str = None, **kwargs\n    ) -> None:\n        self.angle = angle\n        super().__init__(\n            mobject, path_func=spiral_path(angle), point_color=point_color, **kwargs\n        )"}, {"name": "spiral_path", "code": "def spiral_path(angle: float, axis: Vector3D = OUT) -> PathFuncType:\n    \"\"\"This function transforms each point by moving along a spiral to its destination.\n\n    Parameters\n    ----------\n    angle\n        The angle each point traverses around a spiral.\n    axis\n        The axis of rotation.\n\n    Examples\n    --------\n\n    .. manim :: SpiralPathExample\n\n        class SpiralPathExample(Scene):\n            def construct(self):\n                colors = [RED, GREEN, BLUE]\n\n                starting_points = VGroup(\n                    *[\n                        Dot(LEFT + pos, color=color)\n                        for pos, color in zip([UP, DOWN, LEFT], colors)\n                    ]\n                )\n\n                finish_points = VGroup(\n                    *[\n                        Dot(RIGHT + pos, color=color)\n                        for pos, color in zip([ORIGIN, UP, DOWN], colors)\n                    ]\n                )\n\n                self.add(starting_points)\n                self.add(finish_points)\n                for dot in starting_points:\n                    self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n                self.wait()\n                self.play(\n                    Transform(\n                        starting_points,\n                        finish_points,\n                        path_func=utils.paths.spiral_path(2 * TAU),\n                        run_time=5,\n                    )\n                )\n                self.wait()\n\n    \"\"\"\n    if abs(angle) < STRAIGHT_PATH_THRESHOLD:\n        return straight_path()\n    if np.linalg.norm(axis) == 0:\n        axis = OUT\n    unit_axis = axis / np.linalg.norm(axis)\n\n    def path(\n        start_points: Point3D_Array, end_points: Point3D_Array, alpha: float\n    ) -> Point3D_Array:\n        rot_matrix = rotation_matrix((alpha - 1) * angle, unit_axis)\n        return start_points + alpha * np.dot(end_points - start_points, rot_matrix.T)\n\n    return path"}, {"name": "SpiralIn", "code": "class SpiralIn(Animation):\n    r\"\"\"Create the Mobject with sub-Mobjects flying in on spiral trajectories.\n\n    Parameters\n    ----------\n    shapes\n        The Mobject on which to be operated.\n\n    scale_factor\n        The factor used for scaling the effect.\n\n    fade_in_fraction\n        Fractional duration of initial fade-in of sub-Mobjects as they fly inward.\n\n    Examples\n    --------\n    .. manim :: SpiralInExample\n\n        class SpiralInExample(Scene):\n            def construct(self):\n                pi = MathTex(r\"\\pi\").scale(7)\n                pi.shift(2.25 * LEFT + 1.5 * UP)\n                circle = Circle(color=GREEN_C, fill_opacity=1).shift(LEFT)\n                square = Square(color=BLUE_D, fill_opacity=1).shift(UP)\n                shapes = VGroup(pi, circle, square)\n                self.play(SpiralIn(shapes))\n    \"\"\"\n\n    def __init__(\n        self,\n        shapes: Mobject,\n        scale_factor: float = 8,\n        fade_in_fraction=0.3,\n        **kwargs,\n    ) -> None:\n        self.shapes = shapes.copy()\n        self.scale_factor = scale_factor\n        self.shape_center = shapes.get_center()\n        self.fade_in_fraction = fade_in_fraction\n        for shape in shapes:\n            shape.final_position = shape.get_center()\n            shape.initial_position = (\n                shape.final_position\n                + (shape.final_position - self.shape_center) * self.scale_factor\n            )\n            shape.move_to(shape.initial_position)\n            shape.save_state()\n\n        super().__init__(shapes, introducer=True, **kwargs)\n\n    def interpolate_mobject(self, alpha: float) -> None:\n        alpha = self.rate_func(alpha)\n        for original_shape, shape in zip(self.shapes, self.mobject):\n            shape.restore()\n            fill_opacity = original_shape.get_fill_opacity()\n            stroke_opacity = original_shape.get_stroke_opacity()\n            new_fill_opacity = min(\n                fill_opacity, alpha * fill_opacity / self.fade_in_fraction\n            )\n            new_stroke_opacity = min(\n                stroke_opacity, alpha * stroke_opacity / self.fade_in_fraction\n            )\n            shape.shift((shape.final_position - shape.initial_position) * alpha)\n            shape.rotate(TAU * alpha, about_point=self.shape_center)\n            shape.rotate(-TAU * alpha, about_point=shape.get_center_of_mass())\n            shape.set_fill(opacity=new_fill_opacity)\n            shape.set_stroke(opacity=new_stroke_opacity)"}, {"name": "split_bezier", "code": "def split_bezier(points: BezierPointsLike, t: float) -> Spline:\n    r\"\"\"Split a B\u00e9zier curve at argument ``t`` into two curves.\n\n    .. note::\n\n        .. seealso::\n            `A Primer on B\u00e9zier Curves #10: Splitting curves. Pomax. <https://pomax.github.io/bezierinfo/#splitting>`_\n\n        As an example for a cubic B\u00e9zier curve, let :math:`p_0, p_1, p_2, p_3` be the points\n        needed for the curve :math:`C_0 = [p_0, \\ p_1, \\ p_2, \\ p_3]`.\n\n        Define the 3 linear B\u00e9ziers :math:`L_0, L_1, L_2` as interpolations of :math:`p_0, p_1, p_2, p_3`:\n\n        .. math::\n            L_0(t) &= p_0 + t(p_1 - p_0) \\\\\n            L_1(t) &= p_1 + t(p_2 - p_1) \\\\\n            L_2(t) &= p_2 + t(p_3 - p_2)\n\n        Define the 2 quadratic B\u00e9ziers :math:`Q_0, Q_1` as interpolations of :math:`L_0, L_1, L_2`:\n\n        .. math::\n            Q_0(t) &= L_0(t) + t(L_1(t) - L_0(t)) \\\\\n            Q_1(t) &= L_1(t) + t(L_2(t) - L_1(t))\n\n        Then :math:`C_0` is the following interpolation of :math:`Q_0` and :math:`Q_1`:\n\n        .. math::\n            C_0(t) = Q_0(t) + t(Q_1(t) - Q_0(t))\n\n        Evaluating :math:`C_0` at a value :math:`t=t'` splits :math:`C_0` into two cubic B\u00e9ziers :math:`H_0`\n        and :math:`H_1`, defined by some of the points we calculated earlier:\n\n        .. math::\n            H_0 &= [p_0, &\\ L_0(t'), &\\ Q_0(t'), &\\ C_0(t') &] \\\\\n            H_1 &= [p_0(t'), &\\ Q_1(t'), &\\ L_2(t'), &\\ p_3 &]\n\n        As the resulting curves are obtained from linear combinations of ``points``, everything can\n        be encoded into a matrix for efficiency, which is done for B\u00e9zier curves of degree up to 3.\n\n        .. seealso::\n            `A Primer on B\u00e9zier Curves #11: Splitting curves using matrices. Pomax. <https://pomax.github.io/bezierinfo/#matrixsplit>`_\n\n        For the simpler case of a quadratic B\u00e9zier curve:\n\n        .. math::\n            H_0\n            &=\n            \\begin{pmatrix}\n                p_0 \\\\\n                (1-t) p_0 + t p_1 \\\\\n                (1-t)^2 p_0 + 2(1-t)t p_1 + t^2 p_2 \\\\\n            \\end{pmatrix}\n            &=\n            \\begin{pmatrix}\n                1 & 0 & 0 \\\\\n                (1-t) & t & 0\\\\\n                (1-t)^2 & 2(1-t)t & t^2\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                p_0 \\\\\n                p_1 \\\\\n                p_2\n            \\end{pmatrix}\n            \\\\\n            &\n            \\\\\n            H_1\n            &=\n            \\begin{pmatrix}\n                (1-t)^2 p_0 + 2(1-t)t p_1 + t^2 p_2 \\\\\n                (1-t) p_1 + t p_2 \\\\\n                p_2\n            \\end{pmatrix}\n            &=\n            \\begin{pmatrix}\n                (1-t)^2 & 2(1-t)t & t^2 \\\\\n                0 & (1-t) & t \\\\\n                0 & 0 & 1\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                p_0 \\\\\n                p_1 \\\\\n                p_2\n            \\end{pmatrix}\n\n        from where one can define a :math:`(6, 3)` split matrix :math:`S_2` which can multiply\n        the array of ``points`` to compute the return value:\n\n        .. math::\n            S_2\n            &=\n            \\begin{pmatrix}\n                1 & 0 & 0 \\\\\n                (1-t) & t & 0 \\\\\n                (1-t)^2 & 2(1-t)t & t^2 \\\\\n                (1-t)^2 & 2(1-t)t & t^2 \\\\\n                0 & (1-t) & t \\\\\n                0 & 0 & 1\n            \\end{pmatrix}\n            \\\\\n            &\n            \\\\\n            S_2 P\n            &=\n            \\begin{pmatrix}\n                1 & 0 & 0 \\\\\n                (1-t) & t & 0 \\\\\n                (1-t)^2 & 2(1-t)t & t^2 \\\\\n                (1-t)^2 & 2(1-t)t & t^2 \\\\\n                0 & (1-t) & t \\\\\n                0 & 0 & 1\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                p_0 \\\\\n                p_1 \\\\\n                p_2\n            \\end{pmatrix}\n            =\n            \\begin{pmatrix}\n                \\vert \\\\\n                H_0 \\\\\n                \\vert \\\\\n                \\vert \\\\\n                H_1 \\\\\n                \\vert\n            \\end{pmatrix}\n\n        For the previous example with a cubic B\u00e9zier curve:\n\n        .. math::\n            H_0\n            &=\n            \\begin{pmatrix}\n                p_0 \\\\\n                (1-t) p_0 + t p_1 \\\\\n                (1-t)^2 p_0 + 2(1-t)t p_1 + t^2 p_2 \\\\\n                (1-t)^3 p_0 + 3(1-t)^2 t p_1 + 3(1-t)t^2 p_2 + t^3 p_3\n            \\end{pmatrix}\n            &=\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                (1-t) & t & 0 & 0 \\\\\n                (1-t)^2 & 2(1-t)t & t^2 & 0 \\\\\n                (1-t)^3 & 3(1-t)^2 t & 3(1-t)t^2 & t^3\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                p_0 \\\\\n                p_1 \\\\\n                p_2 \\\\\n                p_3\n            \\end{pmatrix}\n            \\\\\n            &\n            \\\\\n            H_1\n            &=\n            \\begin{pmatrix}\n                (1-t)^3 p_0 + 3(1-t)^2 t p_1 + 3(1-t)t^2 p_2 + t^3 p_3 \\\\\n                (1-t)^2 p_1 + 2(1-t)t p_2 + t^2 p_3 \\\\\n                (1-t) p_2 + t p_3 \\\\\n                p_3\n            \\end{pmatrix}\n            &=\n            \\begin{pmatrix}\n                (1-t)^3 & 3(1-t)^2 t & 3(1-t)t^2 & t^3 \\\\\n                0 & (1-t)^2 & 2(1-t)t & t^2 \\\\\n                0 & 0 & (1-t) & t \\\\\n                0 & 0 & 0 & 1\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                p_0 \\\\\n                p_1 \\\\\n                p_2 \\\\\n                p_3\n            \\end{pmatrix}\n\n        from where one can define a :math:`(8, 4)` split matrix :math:`S_3` which can multiply\n        the array of ``points`` to compute the return value:\n\n        .. math::\n            S_3\n            &=\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                (1-t) & t & 0 & 0 \\\\\n                (1-t)^2 & 2(1-t)t & t^2 & 0 \\\\\n                (1-t)^3 & 3(1-t)^2 t & 3(1-t)t^2 & t^3 \\\\\n                (1-t)^3 & 3(1-t)^2 t & 3(1-t)t^2 & t^3 \\\\\n                0 & (1-t)^2 & 2(1-t)t & t^2 \\\\\n                0 & 0 & (1-t) & t \\\\\n                0 & 0 & 0 & 1\n            \\end{pmatrix}\n            \\\\\n            &\n            \\\\\n            S_3 P\n            &=\n            \\begin{pmatrix}\n                1 & 0 & 0 & 0 \\\\\n                (1-t) & t & 0 & 0 \\\\\n                (1-t)^2 & 2(1-t)t & t^2 & 0 \\\\\n                (1-t)^3 & 3(1-t)^2 t & 3(1-t)t^2 & t^3 \\\\\n                (1-t)^3 & 3(1-t)^2 t & 3(1-t)t^2 & t^3 \\\\\n                0 & (1-t)^2 & 2(1-t)t & t^2 \\\\\n                0 & 0 & (1-t) & t \\\\\n                0 & 0 & 0 & 1\n            \\end{pmatrix}\n            \\begin{pmatrix}\n                p_0 \\\\\n                p_1 \\\\\n                p_2 \\\\\n                p_3\n            \\end{pmatrix}\n            =\n            \\begin{pmatrix}\n                \\vert \\\\\n                H_0 \\\\\n                \\vert \\\\\n                \\vert \\\\\n                H_1 \\\\\n                \\vert\n            \\end{pmatrix}\n\n    Parameters\n    ----------\n    points\n        The control points of the B\u00e9zier curve.\n\n    t\n        The ``t``-value at which to split the B\u00e9zier curve.\n\n    Returns\n    -------\n    :class:`~.Point3D_Array`\n        An array containing the control points defining the two B\u00e9zier curves.\n    \"\"\"\n    points = np.asarray(points)\n    N, dim = points.shape\n    degree = N - 1\n\n    if degree == 3:\n        mt = 1 - t\n        mt2 = mt * mt\n        mt3 = mt2 * mt\n        t2 = t * t\n        t3 = t2 * t\n        two_mt_t = 2 * mt * t\n        three_mt2_t = 3 * mt2 * t\n        three_mt_t2 = 3 * mt * t2\n\n        # Split matrix S3 explained in the docstring\n        split_matrix = np.array(\n            [\n                [1, 0, 0, 0],\n                [mt, t, 0, 0],\n                [mt2, two_mt_t, t2, 0],\n                [mt3, three_mt2_t, three_mt_t2, t3],\n                [mt3, three_mt2_t, three_mt_t2, t3],\n                [0, mt2, two_mt_t, t2],\n                [0, 0, mt, t],\n                [0, 0, 0, 1],\n            ]\n        )\n\n        return split_matrix @ points\n\n    if degree == 2:\n        mt = 1 - t\n        mt2 = mt * mt\n        t2 = t * t\n        two_tmt = 2 * t * mt\n\n        # Split matrix S2 explained in the docstring\n        split_matrix = np.array(\n            [\n                [1, 0, 0],\n                [mt, t, 0],\n                [mt2, two_tmt, t2],\n                [mt2, two_tmt, t2],\n                [0, mt, t],\n                [0, 0, 1],\n            ]\n        )\n\n        return split_matrix @ points\n\n    if degree == 1:\n        middle = points[0] + t * (points[1] - points[0])\n        return np.array([points[0], middle, middle, points[1]])\n\n    if degree == 0:\n        return np.array([points[0], points[0]])\n\n    # Fallback case for nth degree B\u00e9ziers\n    arr = np.empty((2, N, dim))\n    arr[1] = points\n    arr[0, 0] = points[0]\n\n    # Example for a cubic B\u00e9zier\n    # arr[0] = [P0 .. .. ..]\n    # arr[1] = [P0 P1 P2 P3]\n    for i in range(1, N):\n        # 1st iter: arr[1] = [L0 L1 L2 P3]\n        # 2nd iter: arr[1] = [Q0 Q1 L2 P3]\n        # 3rd iter: arr[1] = [C0 Q1 L2 P3]\n        arr[1, : N - i] += t * (arr[1, 1 : N - i + 1] - arr[1, : N - i])\n        # 1st iter: arr[0] = [P0 L0 .. ..]\n        # 2nd iter: arr[0] = [P0 L0 Q0 ..]\n        # 3rd iter: arr[0] = [P0 L0 Q0 C0]\n        arr[0, i] = arr[1, 0]\n\n    return arr.reshape(2 * N, dim)"}, {"name": "SplitScreenCamera", "code": "class SplitScreenCamera(OldMultiCamera):\n    def __init__(self, left_camera, right_camera, **kwargs):\n        Camera.__init__(self, **kwargs)  # to set attributes such as pixel_width\n        self.left_camera = left_camera\n        self.right_camera = right_camera\n\n        half_width = math.ceil(self.pixel_width / 2)\n        for camera in [self.left_camera, self.right_camera]:\n            camera.reset_pixel_shape(camera.pixel_height, half_width)\n\n        super().__init__(\n            (left_camera, (0, 0)),\n            (right_camera, (0, half_width)),\n        )"}, {"name": "Square", "code": "class Square(Rectangle):\n    \"\"\"A rectangle with equal side lengths.\n\n    Parameters\n    ----------\n    side_length\n        The length of the sides of the square.\n    kwargs\n        Additional arguments to be passed to :class:`Rectangle`.\n\n    Examples\n    --------\n    .. manim:: SquareExample\n        :save_last_frame:\n\n        class SquareExample(Scene):\n            def construct(self):\n                square_1 = Square(side_length=2.0).shift(DOWN)\n                square_2 = Square(side_length=1.0).next_to(square_1, direction=UP)\n                square_3 = Square(side_length=0.5).next_to(square_2, direction=UP)\n                self.add(square_1, square_2, square_3)\n    \"\"\"\n\n    def __init__(self, side_length: float = 2.0, **kwargs: Any) -> None:\n        super().__init__(height=side_length, width=side_length, **kwargs)\n\n    @property\n    def side_length(self) -> float:\n        return float(np.linalg.norm(self.get_vertices()[0] - self.get_vertices()[1]))\n\n    @side_length.setter\n    def side_length(self, value: float) -> None:\n        self.scale(value / self.side_length)"}, {"name": "squish_rate_func", "code": "def squish_rate_func(\n    func: RateFunction,\n    a: float = 0.4,\n    b: float = 0.6,\n) -> RateFunction:\n    def result(t: float, *args: Any, **kwargs: Any) -> float:\n        if a == b:\n            return a\n\n        if t < a:\n            new_t = 0.0\n        elif t > b:\n            new_t = 1.0\n        else:\n            new_t = (t - a) / (b - a)\n        return func(new_t, *args, **kwargs)\n\n    return result"}, {"name": "Star", "code": "class Star(Polygon):\n    \"\"\"A regular polygram without the intersecting lines.\n\n    Parameters\n    ----------\n    n\n        How many points on the :class:`Star`.\n    outer_radius\n        The radius of the circle that the outer vertices are placed on.\n    inner_radius\n        The radius of the circle that the inner vertices are placed on.\n\n        If unspecified, the inner radius will be\n        calculated such that the edges of the :class:`Star`\n        perfectly follow the edges of its :class:`RegularPolygram`\n        counterpart.\n    density\n        The density of the :class:`Star`. Only used if\n        ``inner_radius`` is unspecified.\n\n        See :class:`RegularPolygram` for more information.\n    start_angle\n        The angle the vertices start at; the rotation of\n        the :class:`Star`.\n    kwargs\n        Forwardeds to the parent constructor.\n\n    Raises\n    ------\n    :exc:`ValueError`\n        If ``inner_radius`` is unspecified and ``density``\n        is not in the range ``[1, n/2)``.\n\n    Examples\n    --------\n    .. manim:: StarExample\n\n        class StarExample(Scene):\n            def construct(self):\n                pentagram = RegularPolygram(5, radius=2)\n                star = Star(outer_radius=2, color=RED)\n\n                self.add(pentagram)\n                self.play(Create(star), run_time=3)\n                self.play(FadeOut(star), run_time=2)\n\n    .. manim:: DifferentDensitiesExample\n        :save_last_frame:\n\n        class DifferentDensitiesExample(Scene):\n            def construct(self):\n                density_2 = Star(7, outer_radius=2, density=2, color=RED)\n                density_3 = Star(7, outer_radius=2, density=3, color=PURPLE)\n\n                self.add(VGroup(density_2, density_3).arrange(RIGHT))\n\n    \"\"\"\n\n    def __init__(\n        self,\n        n: int = 5,\n        *,\n        outer_radius: float = 1,\n        inner_radius: float | None = None,\n        density: int = 2,\n        start_angle: float | None = TAU / 4,\n        **kwargs: Any,\n    ) -> None:\n        inner_angle = TAU / (2 * n)\n\n        if inner_radius is None:\n            # See https://math.stackexchange.com/a/2136292 for an\n            # overview of how to calculate the inner radius of a\n            # perfect star.\n\n            if density <= 0 or density >= n / 2:\n                raise ValueError(\n                    f\"Incompatible density {density} for number of points {n}\",\n                )\n\n            outer_angle = TAU * density / n\n            inverse_x = 1 - np.tan(inner_angle) * (\n                (np.cos(outer_angle) - 1) / np.sin(outer_angle)\n            )\n\n            inner_radius = outer_radius / (np.cos(inner_angle) * inverse_x)\n\n        outer_vertices, self.start_angle = regular_vertices(\n            n,\n            radius=outer_radius,\n            start_angle=start_angle,\n        )\n        inner_vertices, _ = regular_vertices(\n            n,\n            radius=inner_radius,\n            start_angle=self.start_angle + inner_angle,\n        )\n\n        vertices: list[npt.NDArray] = []\n        for pair in zip(outer_vertices, inner_vertices):\n            vertices.extend(pair)\n\n        super().__init__(*vertices, **kwargs)"}, {"name": "StealthTip", "code": "class StealthTip(ArrowTip):\n    r\"\"\"'Stealth' fighter / kite arrow shape.\n\n    Naming is inspired by the corresponding\n    `TikZ arrow shape <https://tikz.dev/tikz-arrows#sec-16.3>`__.\n    \"\"\"\n\n    def __init__(\n        self,\n        fill_opacity: float = 1,\n        stroke_width: float = 3,\n        length: float = DEFAULT_ARROW_TIP_LENGTH / 2,\n        start_angle: float = PI,\n        **kwargs: Any,\n    ):\n        self.start_angle = start_angle\n        VMobject.__init__(\n            self, fill_opacity=fill_opacity, stroke_width=stroke_width, **kwargs\n        )\n        self.set_points_as_corners(\n            np.array(\n                [\n                    [2, 0, 0],  # tip\n                    [-1.2, 1.6, 0],\n                    [0, 0, 0],  # base\n                    [-1.2, -1.6, 0],\n                    [2, 0, 0],  # close path, back to tip\n                ]\n            )\n        )\n        self.scale(length / self.length)\n\n    @property\n    def length(self) -> float:\n        \"\"\"The length of the arrow tip.\n\n        In this case, the length is computed as the height of\n        the triangle encompassing the stealth tip (otherwise,\n        the tip is scaled too large).\n        \"\"\"\n        return float(np.linalg.norm(self.vector) * 1.6)"}, {"name": "straight_path", "code": "def straight_path() -> PathFuncType:\n    \"\"\"Simplest path function. Each point in a set goes in a straight path toward its destination.\n\n    Examples\n    --------\n\n    .. manim :: StraightPathExample\n\n        class StraightPathExample(Scene):\n            def construct(self):\n                colors = [RED, GREEN, BLUE]\n\n                starting_points = VGroup(\n                    *[\n                        Dot(LEFT + pos, color=color)\n                        for pos, color in zip([UP, DOWN, LEFT], colors)\n                    ]\n                )\n\n                finish_points = VGroup(\n                    *[\n                        Dot(RIGHT + pos, color=color)\n                        for pos, color in zip([ORIGIN, UP, DOWN], colors)\n                    ]\n                )\n\n                self.add(starting_points)\n                self.add(finish_points)\n                for dot in starting_points:\n                    self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))\n\n                self.wait()\n                self.play(\n                    Transform(\n                        starting_points,\n                        finish_points,\n                        path_func=utils.paths.straight_path(),\n                        run_time=2,\n                    )\n                )\n                self.wait()\n\n    \"\"\"\n    return interpolate"}, {"name": "StreamLines", "code": "class StreamLines(VectorField):\n    \"\"\"StreamLines represent the flow of a :class:`VectorField` using the trace of moving agents.\n\n    Vector fields are always based on a function defining the vector at every position.\n    The values of this functions is displayed by moving many agents along the vector field\n    and showing their trace.\n\n    Parameters\n    ----------\n    func\n        The function defining the rate of change at every position of the vector field.\n    color\n        The color of the vector field. If set, position-specific coloring is disabled.\n    color_scheme\n        A function mapping a vector to a single value. This value gives the position in the color gradient defined using `min_color_scheme_value`, `max_color_scheme_value` and `colors`.\n    min_color_scheme_value\n        The value of the color_scheme function to be mapped to the first color in `colors`. Lower values also result in the first color of the gradient.\n    max_color_scheme_value\n        The value of the color_scheme function to be mapped to the last color in `colors`. Higher values also result in the last color of the gradient.\n    colors\n        The colors defining the color gradient of the vector field.\n    x_range\n        A sequence of x_min, x_max, delta_x\n    y_range\n        A sequence of y_min, y_max, delta_y\n    z_range\n        A sequence of z_min, z_max, delta_z\n    three_dimensions\n        Enables three_dimensions. Default set to False, automatically turns True if\n        z_range is not None.\n    noise_factor\n        The amount by which the starting position of each agent is altered along each axis. Defaults to :code:`delta_y / 2` if not defined.\n    n_repeats\n        The number of agents generated at each starting point.\n    dt\n        The factor by which the distance an agent moves per step is stretched. Lower values result in a better approximation of the trajectories in the vector field.\n    virtual_time\n        The time the agents get to move in the vector field. Higher values therefore result in longer stream lines. However, this whole time gets simulated upon creation.\n    max_anchors_per_line\n        The maximum number of anchors per line. Lines with more anchors get reduced in complexity, not in length.\n    padding\n        The distance agents can move out of the generation area before being terminated.\n    stroke_width\n        The stroke with of the stream lines.\n    opacity\n        The opacity of the stream lines.\n\n    Examples\n    --------\n\n    .. manim:: BasicUsage\n        :save_last_frame:\n\n        class BasicUsage(Scene):\n            def construct(self):\n                func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3\n                self.add(StreamLines(func))\n\n    .. manim:: SpawningAndFlowingArea\n        :save_last_frame:\n\n        class SpawningAndFlowingArea(Scene):\n            def construct(self):\n                func = lambda pos: np.sin(pos[0]) * UR + np.cos(pos[1]) * LEFT + pos / 5\n                stream_lines = StreamLines(\n                    func, x_range=[-3, 3, 0.2], y_range=[-2, 2, 0.2], padding=1\n                )\n\n                spawning_area = Rectangle(width=6, height=4)\n                flowing_area = Rectangle(width=8, height=6)\n                labels = [Tex(\"Spawning Area\"), Tex(\"Flowing Area\").shift(DOWN * 2.5)]\n                for lbl in labels:\n                    lbl.add_background_rectangle(opacity=0.6, buff=0.05)\n\n                self.add(stream_lines, spawning_area, flowing_area, *labels)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        func: Callable[[np.ndarray], np.ndarray],\n        color: ParsableManimColor | None = None,\n        color_scheme: Callable[[np.ndarray], float] | None = None,\n        min_color_scheme_value: float = 0,\n        max_color_scheme_value: float = 2,\n        colors: Sequence[ParsableManimColor] = DEFAULT_SCALAR_FIELD_COLORS,\n        # Determining stream line starting positions:\n        x_range: Sequence[float] = None,\n        y_range: Sequence[float] = None,\n        z_range: Sequence[float] = None,\n        three_dimensions: bool = False,\n        noise_factor: float | None = None,\n        n_repeats=1,\n        # Determining how lines are drawn\n        dt=0.05,\n        virtual_time=3,\n        max_anchors_per_line=100,\n        padding=3,\n        # Determining stream line appearance:\n        stroke_width=1,\n        opacity=1,\n        **kwargs,\n    ):\n        self.x_range = x_range or [\n            floor(-config[\"frame_width\"] / 2),\n            ceil(config[\"frame_width\"] / 2),\n        ]\n        self.y_range = y_range or [\n            floor(-config[\"frame_height\"] / 2),\n            ceil(config[\"frame_height\"] / 2),\n        ]\n        self.ranges = [self.x_range, self.y_range]\n\n        if three_dimensions or z_range:\n            self.z_range = z_range or self.y_range.copy()\n            self.ranges += [self.z_range]\n        else:\n            self.ranges += [[0, 0]]\n\n        for i in range(len(self.ranges)):\n            if len(self.ranges[i]) == 2:\n                self.ranges[i] += [0.5]\n            self.ranges[i][1] += self.ranges[i][2]\n\n        self.x_range, self.y_range, self.z_range = self.ranges\n\n        super().__init__(\n            func,\n            color,\n            color_scheme,\n            min_color_scheme_value,\n            max_color_scheme_value,\n            colors,\n            **kwargs,\n        )\n\n        self.noise_factor = (\n            noise_factor if noise_factor is not None else self.y_range[2] / 2\n        )\n        self.n_repeats = n_repeats\n        self.virtual_time = virtual_time\n        self.max_anchors_per_line = max_anchors_per_line\n        self.padding = padding\n        self.stroke_width = stroke_width\n\n        half_noise = self.noise_factor / 2\n        np.random.seed(0)\n        start_points = np.array(\n            [\n                (x - half_noise) * RIGHT\n                + (y - half_noise) * UP\n                + (z - half_noise) * OUT\n                + self.noise_factor * np.random.random(3)\n                for n in range(self.n_repeats)\n                for x in np.arange(*self.x_range)\n                for y in np.arange(*self.y_range)\n                for z in np.arange(*self.z_range)\n            ],\n        )\n\n        def outside_box(p):\n            return (\n                p[0] < self.x_range[0] - self.padding\n                or p[0] > self.x_range[1] + self.padding - self.x_range[2]\n                or p[1] < self.y_range[0] - self.padding\n                or p[1] > self.y_range[1] + self.padding - self.y_range[2]\n                or p[2] < self.z_range[0] - self.padding\n                or p[2] > self.z_range[1] + self.padding - self.z_range[2]\n            )\n\n        max_steps = ceil(virtual_time / dt) + 1\n        if not self.single_color:\n            self.background_img = self.get_colored_background_image()\n            if config[\"renderer\"] == RendererType.OPENGL:\n                self.values_to_rgbas = self.get_vectorized_rgba_gradient_function(\n                    min_color_scheme_value,\n                    max_color_scheme_value,\n                    colors,\n                )\n        for point in start_points:\n            points = [point]\n            for _ in range(max_steps):\n                last_point = points[-1]\n                new_point = last_point + dt * func(last_point)\n                if outside_box(new_point):\n                    break\n                points.append(new_point)\n            step = max_steps\n            if not step:\n                continue\n            line = get_vectorized_mobject_class()()\n            line.duration = step * dt\n            step = max(1, int(len(points) / self.max_anchors_per_line))\n            line.set_points_smoothly(points[::step])\n            if self.single_color:\n                line.set_stroke(\n                    color=self.color, width=self.stroke_width, opacity=opacity\n                )\n            else:\n                if config.renderer == RendererType.OPENGL:\n                    # scaled for compatibility with cairo\n                    line.set_stroke(width=self.stroke_width / 4.0)\n                    norms = np.array(\n                        [np.linalg.norm(self.func(point)) for point in line.points],\n                    )\n                    line.set_rgba_array_direct(\n                        self.values_to_rgbas(norms, opacity),\n                        name=\"stroke_rgba\",\n                    )\n                else:\n                    if np.any(self.z_range != np.array([0, 0.5, 0.5])):\n                        line.set_stroke(\n                            [self.pos_to_color(p) for p in line.get_anchors()],\n                        )\n                    else:\n                        line.color_using_background_image(self.background_img)\n                    line.set_stroke(width=self.stroke_width, opacity=opacity)\n            self.add(line)\n        self.stream_lines = [*self.submobjects]\n\n    def create(\n        self,\n        lag_ratio: float | None = None,\n        run_time: Callable[[float], float] | None = None,\n        **kwargs,\n    ) -> AnimationGroup:\n        \"\"\"The creation animation of the stream lines.\n\n        The stream lines appear in random order.\n\n        Parameters\n        ----------\n        lag_ratio\n            The lag ratio of the animation.\n            If undefined, it will be selected so that the total animation length is 1.5 times the run time of each stream line creation.\n        run_time\n            The run time of every single stream line creation. The runtime of the whole animation might be longer due to the `lag_ratio`.\n            If undefined, the virtual time of the stream lines is used as run time.\n\n        Returns\n        -------\n        :class:`~.AnimationGroup`\n            The creation animation of the stream lines.\n\n        Examples\n        --------\n\n        .. manim:: StreamLineCreation\n\n            class StreamLineCreation(Scene):\n                def construct(self):\n                    func = lambda pos: (pos[0] * UR + pos[1] * LEFT) - pos\n                    stream_lines = StreamLines(\n                        func,\n                        color=YELLOW,\n                        x_range=[-7, 7, 1],\n                        y_range=[-4, 4, 1],\n                        stroke_width=3,\n                        virtual_time=1,  # use shorter lines\n                        max_anchors_per_line=5,  # better performance with fewer anchors\n                    )\n                    self.play(stream_lines.create())  # uses virtual_time as run_time\n                    self.wait()\n\n        \"\"\"\n        if run_time is None:\n            run_time = self.virtual_time\n        if lag_ratio is None:\n            lag_ratio = run_time / 2 / len(self.submobjects)\n\n        animations = [\n            Create(line, run_time=run_time, **kwargs) for line in self.stream_lines\n        ]\n        random.shuffle(animations)\n        return AnimationGroup(*animations, lag_ratio=lag_ratio)\n\n    def start_animation(\n        self,\n        warm_up: bool = True,\n        flow_speed: float = 1,\n        time_width: float = 0.3,\n        rate_func: Callable[[float], float] = linear,\n        line_animation_class: type[ShowPassingFlash] = ShowPassingFlash,\n        **kwargs,\n    ) -> None:\n        \"\"\"Animates the stream lines using an updater.\n\n        The stream lines will continuously flow\n\n        Parameters\n        ----------\n        warm_up\n            If `True` the animation is initialized line by line. Otherwise it starts with all lines shown.\n        flow_speed\n            At `flow_speed=1` the distance the flow moves per second is equal to the magnitude of the vector field along its path. The speed value scales the speed of this flow.\n        time_width\n            The proportion of the stream line shown while being animated\n        rate_func\n            The rate function of each stream line flashing\n        line_animation_class\n            The animation class being used\n\n        Examples\n        --------\n\n        .. manim:: ContinuousMotion\n\n            class ContinuousMotion(Scene):\n                def construct(self):\n                    func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT\n                    stream_lines = StreamLines(func, stroke_width=3, max_anchors_per_line=30)\n                    self.add(stream_lines)\n                    stream_lines.start_animation(warm_up=False, flow_speed=1.5)\n                    self.wait(stream_lines.virtual_time / stream_lines.flow_speed)\n\n        \"\"\"\n        for line in self.stream_lines:\n            run_time = line.duration / flow_speed\n            line.anim = line_animation_class(\n                line,\n                run_time=run_time,\n                rate_func=rate_func,\n                time_width=time_width,\n                **kwargs,\n            )\n            line.anim.begin()\n            line.time = random.random() * self.virtual_time\n            if warm_up:\n                line.time *= -1\n            self.add(line.anim.mobject)\n\n        def updater(mob, dt):\n            for line in mob.stream_lines:\n                line.time += dt * flow_speed\n                if line.time >= self.virtual_time:\n                    line.time -= self.virtual_time\n                line.anim.interpolate(np.clip(line.time / line.anim.run_time, 0, 1))\n\n        self.add_updater(updater)\n        self.flow_animation = updater\n        self.flow_speed = flow_speed\n        self.time_width = time_width\n\n    def end_animation(self) -> AnimationGroup:\n        \"\"\"End the stream line animation smoothly.\n\n        Returns an animation resulting in fully displayed stream lines without a noticeable cut.\n\n        Returns\n        -------\n        :class:`~.AnimationGroup`\n            The animation fading out the running stream animation.\n\n        Raises\n        ------\n        ValueError\n            if no stream line animation is running\n\n        Examples\n        --------\n\n        .. manim:: EndAnimation\n\n            class EndAnimation(Scene):\n                def construct(self):\n                    func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT\n                    stream_lines = StreamLines(\n                        func, stroke_width=3, max_anchors_per_line=5, virtual_time=1, color=BLUE\n                    )\n                    self.add(stream_lines)\n                    stream_lines.start_animation(warm_up=False, flow_speed=1.5, time_width=0.5)\n                    self.wait(1)\n                    self.play(stream_lines.end_animation())\n\n        \"\"\"\n        if self.flow_animation is None:\n            raise ValueError(\"You have to start the animation before fading it out.\")\n\n        def hide_and_wait(mob, alpha):\n            if alpha == 0:\n                mob.set_stroke(opacity=0)\n            elif alpha == 1:\n                mob.set_stroke(opacity=1)\n\n        def finish_updater_cycle(line, alpha):\n            line.time += dt * self.flow_speed\n            line.anim.interpolate(min(line.time / line.anim.run_time, 1))\n            if alpha == 1:\n                self.remove(line.anim.mobject)\n                line.anim.finish()\n\n        max_run_time = self.virtual_time / self.flow_speed\n        creation_rate_func = ease_out_sine\n        creation_staring_speed = creation_rate_func(0.001) * 1000\n        creation_run_time = (\n            max_run_time / (1 + self.time_width) * creation_staring_speed\n        )\n        # creation_run_time is calculated so that the creation animation starts at the same speed\n        # as the regular line flash animation but eases out.\n\n        dt = 1 / config[\"frame_rate\"]\n        animations = []\n        self.remove_updater(self.flow_animation)\n        self.flow_animation = None\n\n        for line in self.stream_lines:\n            create = Create(\n                line,\n                run_time=creation_run_time,\n                rate_func=creation_rate_func,\n            )\n            if line.time <= 0:\n                animations.append(\n                    Succession(\n                        UpdateFromAlphaFunc(\n                            line,\n                            hide_and_wait,\n                            run_time=-line.time / self.flow_speed,\n                        ),\n                        create,\n                    ),\n                )\n                self.remove(line.anim.mobject)\n                line.anim.finish()\n            else:\n                remaining_time = max_run_time - line.time / self.flow_speed\n                animations.append(\n                    Succession(\n                        UpdateFromAlphaFunc(\n                            line,\n                            finish_updater_cycle,\n                            run_time=remaining_time,\n                        ),\n                        create,\n                    ),\n                )\n        return AnimationGroup(*animations)"}, {"name": "stretch_array_to_length", "code": "def stretch_array_to_length(nparray: npt.NDArray[F], length: int) -> npt.NDArray[F]:\n    # todo: is this the same as resize_preserving_order()?\n    curr_len = len(nparray)\n    if curr_len > length:\n        raise Warning(\"Trying to stretch array to a length shorter than its own\")\n    indices = np.arange(length) / float(length)\n    indices *= curr_len\n    return nparray[indices.astype(int)]"}, {"name": "subdivide_bezier", "code": "def subdivide_bezier(points: BezierPointsLike, n_divisions: int) -> Spline:\n    r\"\"\"Subdivide a B\u00e9zier curve into :math:`n` subcurves which have the same shape.\n\n    The points at which the curve is split are located at the\n    arguments :math:`t = \\frac{i}{n}`, for :math:`i \\in \\{1, ..., n-1\\}`.\n\n    .. seealso::\n\n        * See :func:`split_bezier` for an explanation on how to split B\u00e9zier curves.\n        * See :func:`partial_bezier_points` for an extra understanding of this function.\n\n\n    .. note::\n        The resulting subcurves can be expressed as linear combinations of\n        ``points``, which can be encoded in a single matrix that is precalculated\n        for 2nd and 3rd degree B\u00e9zier curves.\n\n        As an example for a quadratic B\u00e9zier curve: taking inspiration from the\n        explanation in :func:`partial_bezier_points`, where the following matrix\n        :math:`P_2` was defined to extract the portion of a quadratic B\u00e9zier\n        curve for :math:`t \\in [a, b]`:\n\n        .. math::\n            P_2\n            =\n            \\begin{pmatrix}\n                (1-a)^2 & 2(1-a)a & a^2 \\\\\n                (1-a)(1-b) & a(1-b) + (1-a)b & ab \\\\\n                (1-b)^2 & 2(1-b)b & b^2\n            \\end{pmatrix}\n\n        the plan is to replace :math:`[a, b]` with\n        :math:`\\left[ \\frac{i-1}{n}, \\frac{i}{n} \\right], \\ \\forall i \\in \\{1, ..., n\\}`.\n\n        As an example for :math:`n = 2` divisions, construct :math:`P_1` for\n        the interval :math:`\\left[ 0, \\frac{1}{2} \\right]`, and :math:`P_2` for the\n        interval :math:`\\left[ \\frac{1}{2}, 1 \\right]`:\n\n        .. math::\n            P_1\n            =\n            \\begin{pmatrix}\n                1 & 0 & 0 \\\\\n                0.5 & 0.5 & 0 \\\\\n                0.25 & 0.5 & 0.25\n            \\end{pmatrix}\n            ,\n            \\quad\n            P_2\n            =\n            \\begin{pmatrix}\n                0.25 & 0.5 & 0.25 \\\\\n                0 & 0.5 & 0.5 \\\\\n                0 & 0 & 1\n            \\end{pmatrix}\n\n        Therefore, the following :math:`(6, 3)` subdivision matrix :math:`D_2` can be\n        constructed, which will subdivide an array of ``points`` into 2 parts:\n\n        .. math::\n            D_2\n            =\n            \\begin{pmatrix}\n                M_1 \\\\\n                M_2\n            \\end{pmatrix}\n            =\n            \\begin{pmatrix}\n                1 & 0 & 0 \\\\\n                0.5 & 0.5 & 0 \\\\\n                0.25 & 0.5 & 0.25 \\\\\n                0.25 & 0.5 & 0.25 \\\\\n                0 & 0.5 & 0.5 \\\\\n                0 & 0 & 1\n            \\end{pmatrix}\n\n        For quadratic and cubic B\u00e9zier curves, the subdivision matrices are memoized for\n        efficiency. For higher degree curves, an iterative algorithm inspired by the\n        one from :func:`split_bezier` is used instead.\n\n    .. image:: /_static/bezier_subdivision_example.png\n\n    Parameters\n    ----------\n    points\n        The control points of the B\u00e9zier curve.\n\n    n_divisions\n        The number of curves to subdivide the B\u00e9zier curve into\n\n    Returns\n    -------\n    :class:`~.Spline`\n        An array containing the points defining the new :math:`n` subcurves.\n    \"\"\"\n    if n_divisions == 1:\n        return points\n\n    points = np.asarray(points)\n    N, dim = points.shape\n\n    if N <= 4:\n        subdivision_matrix = _get_subdivision_matrix(N, n_divisions)\n        return subdivision_matrix @ points\n\n    # Fallback case for an nth degree B\u00e9zier: successive splitting\n    beziers = np.empty((n_divisions, N, dim))\n    beziers[-1] = points\n    for curve_num in range(n_divisions - 1, 0, -1):\n        curr = beziers[curve_num]\n        prev = beziers[curve_num - 1]\n        prev[0] = curr[0]\n        a = (n_divisions - curve_num) / (n_divisions - curve_num + 1)\n        # Current state for an example cubic B\u00e9zier curve:\n        # prev = [P0 .. .. ..]\n        # curr = [P0 P1 P2 P3]\n        for i in range(1, N):\n            # 1st iter: curr = [L0 L1 L2 P3]\n            # 2nd iter: curr = [Q0 Q1 L2 P3]\n            # 3rd iter: curr = [C0 Q1 L2 P3]\n            curr[: N - i] += a * (curr[1 : N - i + 1] - curr[: N - i])\n            # 1st iter: prev = [P0 L0 .. ..]\n            # 2nd iter: prev = [P0 L0 Q0 ..]\n            # 3rd iter: prev = [P0 L0 Q0 C0]\n            prev[i] = curr[0]\n\n    return beziers.reshape(n_divisions * N, dim)"}, {"name": "SubFacet", "code": "class SubFacet:\n    def __init__(self, coordinates: PointND_Array) -> None:\n        self.coordinates = coordinates\n        self.points = frozenset(QuickHullPoint(c) for c in coordinates)\n\n    def __hash__(self) -> int:\n        return hash(self.points)\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, SubFacet):\n            raise ValueError\n        return self.points == other.points"}, {"name": "Succession", "code": "class Succession(AnimationGroup):\n    \"\"\"Plays a series of animations in succession.\n\n    Parameters\n    ----------\n    animations\n        Sequence of :class:`~.Animation` objects to be played.\n    lag_ratio\n        Defines the delay after which the animation is applied to submobjects. A lag_ratio of\n        ``n.nn`` means the next animation will play when ``nnn%`` of the current animation has played.\n        Defaults to 1.0, meaning that the next animation will begin when 100% of the current\n        animation has played.\n\n        This does not influence the total runtime of the animation. Instead the runtime\n        of individual animations is adjusted so that the complete animation has the defined\n        run time.\n\n    Examples\n    --------\n    .. manim:: SuccessionExample\n\n        class SuccessionExample(Scene):\n            def construct(self):\n                dot1 = Dot(point=LEFT * 2 + UP * 2, radius=0.16, color=BLUE)\n                dot2 = Dot(point=LEFT * 2 + DOWN * 2, radius=0.16, color=MAROON)\n                dot3 = Dot(point=RIGHT * 2 + DOWN * 2, radius=0.16, color=GREEN)\n                dot4 = Dot(point=RIGHT * 2 + UP * 2, radius=0.16, color=YELLOW)\n                self.add(dot1, dot2, dot3, dot4)\n\n                self.play(Succession(\n                    dot1.animate.move_to(dot2),\n                    dot2.animate.move_to(dot3),\n                    dot3.animate.move_to(dot4),\n                    dot4.animate.move_to(dot1)\n                ))\n    \"\"\"\n\n    def __init__(self, *animations: Animation, lag_ratio: float = 1, **kwargs) -> None:\n        super().__init__(*animations, lag_ratio=lag_ratio, **kwargs)\n\n    def begin(self) -> None:\n        if not self.animations:\n            raise ValueError(\n                f\"Trying to play {self} without animations, this is not supported. \"\n                \"Please add at least one subanimation.\"\n            )\n        self.update_active_animation(0)\n\n    def finish(self) -> None:\n        while self.active_animation is not None:\n            self.next_animation()\n\n    def update_mobjects(self, dt: float) -> None:\n        if self.active_animation:\n            self.active_animation.update_mobjects(dt)\n\n    def _setup_scene(self, scene) -> None:\n        if scene is None:\n            return\n        if self.is_introducer():\n            for anim in self.animations:\n                if not anim.is_introducer() and anim.mobject is not None:\n                    scene.add(anim.mobject)\n\n        self.scene = scene\n\n    def update_active_animation(self, index: int) -> None:\n        self.active_index = index\n        if index >= len(self.animations):\n            self.active_animation: Animation | None = None\n            self.active_start_time: float | None = None\n            self.active_end_time: float | None = None\n        else:\n            self.active_animation = self.animations[index]\n            self.active_animation._setup_scene(self.scene)\n            self.active_animation.begin()\n            self.active_start_time = self.anims_with_timings[index][\"start\"]\n            self.active_end_time = self.anims_with_timings[index][\"end\"]\n\n    def next_animation(self) -> None:\n        \"\"\"Proceeds to the next animation.\n\n        This method is called right when the active animation finishes.\n        \"\"\"\n        if self.active_animation is not None:\n            self.active_animation.finish()\n        self.update_active_animation(self.active_index + 1)\n\n    def interpolate(self, alpha: float) -> None:\n        current_time = self.rate_func(alpha) * self.max_end_time\n        while self.active_end_time is not None and current_time >= self.active_end_time:\n            self.next_animation()\n        if self.active_animation is not None and self.active_start_time is not None:\n            elapsed = current_time - self.active_start_time\n            active_run_time = self.active_animation.run_time\n            subalpha = elapsed / active_run_time if active_run_time != 0.0 else 1.0\n            self.active_animation.interpolate(subalpha)"}, {"name": "Surface", "code": "class Surface(VGroup, metaclass=ConvertToOpenGL):\n    \"\"\"Creates a Parametric Surface using a checkerboard pattern.\n\n    Parameters\n    ----------\n    func\n        The function defining the :class:`Surface`.\n    u_range\n        The range of the ``u`` variable: ``(u_min, u_max)``.\n    v_range\n        The range of the ``v`` variable: ``(v_min, v_max)``.\n    resolution\n        The number of samples taken of the :class:`Surface`. A tuple can be\n        used to define different resolutions for ``u`` and ``v`` respectively.\n    fill_color\n        The color of the :class:`Surface`. Ignored if ``checkerboard_colors``\n        is set.\n    fill_opacity\n        The opacity of the :class:`Surface`, from 0 being fully transparent\n        to 1 being fully opaque. Defaults to 1.\n    checkerboard_colors\n        ng individual faces alternating colors. Overrides ``fill_color``.\n    stroke_color\n        Color of the stroke surrounding each face of :class:`Surface`.\n    stroke_width\n        Width of the stroke surrounding each face of :class:`Surface`.\n        Defaults to 0.5.\n    should_make_jagged\n        Changes the anchor mode of the B\u00e9zier curves from smooth to jagged.\n        Defaults to ``False``.\n\n    Examples\n    --------\n    .. manim:: ParaSurface\n        :save_last_frame:\n\n        class ParaSurface(ThreeDScene):\n            def func(self, u, v):\n                return np.array([np.cos(u) * np.cos(v), np.cos(u) * np.sin(v), u])\n\n            def construct(self):\n                axes = ThreeDAxes(x_range=[-4,4], x_length=8)\n                surface = Surface(\n                    lambda u, v: axes.c2p(*self.func(u, v)),\n                    u_range=[-PI, PI],\n                    v_range=[0, TAU],\n                    resolution=8,\n                )\n                self.set_camera_orientation(theta=70 * DEGREES, phi=75 * DEGREES)\n                self.add(axes, surface)\n    \"\"\"\n\n    def __init__(\n        self,\n        func: Callable[[float, float], np.ndarray],\n        u_range: Sequence[float] = [0, 1],\n        v_range: Sequence[float] = [0, 1],\n        resolution: Sequence[int] = 32,\n        surface_piece_config: dict = {},\n        fill_color: ParsableManimColor = BLUE_D,\n        fill_opacity: float = 1.0,\n        checkerboard_colors: Sequence[ParsableManimColor] | bool = [BLUE_D, BLUE_E],\n        stroke_color: ParsableManimColor = LIGHT_GREY,\n        stroke_width: float = 0.5,\n        should_make_jagged: bool = False,\n        pre_function_handle_to_anchor_scale_factor: float = 0.00001,\n        **kwargs: Any,\n    ) -> None:\n        self.u_range = u_range\n        self.v_range = v_range\n        super().__init__(**kwargs)\n        self.resolution = resolution\n        self.surface_piece_config = surface_piece_config\n        self.fill_color: ManimColor = ManimColor(fill_color)\n        self.fill_opacity = fill_opacity\n        if checkerboard_colors:\n            self.checkerboard_colors: list[ManimColor] = [\n                ManimColor(x) for x in checkerboard_colors\n            ]\n        else:\n            self.checkerboard_colors = checkerboard_colors\n        self.stroke_color: ManimColor = ManimColor(stroke_color)\n        self.stroke_width = stroke_width\n        self.should_make_jagged = should_make_jagged\n        self.pre_function_handle_to_anchor_scale_factor = (\n            pre_function_handle_to_anchor_scale_factor\n        )\n        self._func = func\n        self._setup_in_uv_space()\n        self.apply_function(lambda p: func(p[0], p[1]))\n        if self.should_make_jagged:\n            self.make_jagged()\n\n    def func(self, u: float, v: float) -> np.ndarray:\n        return self._func(u, v)\n\n    def _get_u_values_and_v_values(self) -> tuple[np.ndarray, np.ndarray]:\n        res = tuplify(self.resolution)\n        if len(res) == 1:\n            u_res = v_res = res[0]\n        else:\n            u_res, v_res = res\n\n        u_values = np.linspace(*self.u_range, u_res + 1)\n        v_values = np.linspace(*self.v_range, v_res + 1)\n\n        return u_values, v_values\n\n    def _setup_in_uv_space(self) -> None:\n        u_values, v_values = self._get_u_values_and_v_values()\n        faces = VGroup()\n        for i in range(len(u_values) - 1):\n            for j in range(len(v_values) - 1):\n                u1, u2 = u_values[i : i + 2]\n                v1, v2 = v_values[j : j + 2]\n                face = ThreeDVMobject()\n                face.set_points_as_corners(\n                    [\n                        [u1, v1, 0],\n                        [u2, v1, 0],\n                        [u2, v2, 0],\n                        [u1, v2, 0],\n                        [u1, v1, 0],\n                    ],\n                )\n                faces.add(face)\n                face.u_index = i\n                face.v_index = j\n                face.u1 = u1\n                face.u2 = u2\n                face.v1 = v1\n                face.v2 = v2\n        faces.set_fill(color=self.fill_color, opacity=self.fill_opacity)\n        faces.set_stroke(\n            color=self.stroke_color,\n            width=self.stroke_width,\n            opacity=self.stroke_opacity,\n        )\n        self.add(*faces)\n        if self.checkerboard_colors:\n            self.set_fill_by_checkerboard(*self.checkerboard_colors)\n\n    def set_fill_by_checkerboard(\n        self, *colors: Iterable[ParsableManimColor], opacity: float | None = None\n    ) -> Self:\n        \"\"\"Sets the fill_color of each face of :class:`Surface` in\n        an alternating pattern.\n\n        Parameters\n        ----------\n        colors\n            List of colors for alternating pattern.\n        opacity\n            The fill_opacity of :class:`Surface`, from 0 being fully transparent\n            to 1 being fully opaque.\n\n        Returns\n        -------\n        :class:`~.Surface`\n            The parametric surface with an alternating pattern.\n        \"\"\"\n        n_colors = len(colors)\n        for face in self:\n            c_index = (face.u_index + face.v_index) % n_colors\n            face.set_fill(colors[c_index], opacity=opacity)\n        return self\n\n    def set_fill_by_value(\n        self,\n        axes: Mobject,\n        colorscale: list[ParsableManimColor] | ParsableManimColor | None = None,\n        axis: int = 2,\n        **kwargs,\n    ) -> Self:\n        \"\"\"Sets the color of each mobject of a parametric surface to a color\n        relative to its axis-value.\n\n        Parameters\n        ----------\n        axes\n            The axes for the parametric surface, which will be used to map\n            axis-values to colors.\n        colorscale\n            A list of colors, ordered from lower axis-values to higher axis-values.\n            If a list of tuples is passed containing colors paired with numbers,\n            then those numbers will be used as the pivots.\n        axis\n            The chosen axis to use for the color mapping. (0 = x, 1 = y, 2 = z)\n\n        Returns\n        -------\n        :class:`~.Surface`\n            The parametric surface with a gradient applied by value. For chaining.\n\n        Examples\n        --------\n        .. manim:: FillByValueExample\n            :save_last_frame:\n\n            class FillByValueExample(ThreeDScene):\n                def construct(self):\n                    resolution_fa = 8\n                    self.set_camera_orientation(phi=75 * DEGREES, theta=-160 * DEGREES)\n                    axes = ThreeDAxes(x_range=(0, 5, 1), y_range=(0, 5, 1), z_range=(-1, 1, 0.5))\n                    def param_surface(u, v):\n                        x = u\n                        y = v\n                        z = np.sin(x) * np.cos(y)\n                        return z\n                    surface_plane = Surface(\n                        lambda u, v: axes.c2p(u, v, param_surface(u, v)),\n                        resolution=(resolution_fa, resolution_fa),\n                        v_range=[0, 5],\n                        u_range=[0, 5],\n                        )\n                    surface_plane.set_style(fill_opacity=1)\n                    surface_plane.set_fill_by_value(axes=axes, colorscale=[(RED, -0.5), (YELLOW, 0), (GREEN, 0.5)], axis=2)\n                    self.add(axes, surface_plane)\n        \"\"\"\n        if \"colors\" in kwargs and colorscale is None:\n            colorscale = kwargs.pop(\"colors\")\n            if kwargs:\n                raise ValueError(\n                    \"Unsupported keyword argument(s): \"\n                    f\"{', '.join(str(key) for key in kwargs)}\"\n                )\n        if colorscale is None:\n            logger.warning(\n                \"The value passed to the colorscale keyword argument was None, \"\n                \"the surface fill color has not been changed\"\n            )\n            return self\n\n        ranges = [axes.x_range, axes.y_range, axes.z_range]\n\n        if type(colorscale[0]) is tuple:\n            new_colors, pivots = [\n                [i for i, j in colorscale],\n                [j for i, j in colorscale],\n            ]\n        else:\n            new_colors = colorscale\n\n            pivot_min = ranges[axis][0]\n            pivot_max = ranges[axis][1]\n            pivot_frequency = (pivot_max - pivot_min) / (len(new_colors) - 1)\n            pivots = np.arange(\n                start=pivot_min,\n                stop=pivot_max + pivot_frequency,\n                step=pivot_frequency,\n            )\n\n        for mob in self.family_members_with_points():\n            axis_value = axes.point_to_coords(mob.get_midpoint())[axis]\n            if axis_value <= pivots[0]:\n                mob.set_color(new_colors[0])\n            elif axis_value >= pivots[-1]:\n                mob.set_color(new_colors[-1])\n            else:\n                for i, pivot in enumerate(pivots):\n                    if pivot > axis_value:\n                        color_index = (axis_value - pivots[i - 1]) / (\n                            pivots[i] - pivots[i - 1]\n                        )\n                        color_index = min(color_index, 1)\n                        mob_color = interpolate_color(\n                            new_colors[i - 1],\n                            new_colors[i],\n                            color_index,\n                        )\n                        if config.renderer == RendererType.OPENGL:\n                            mob.set_color(mob_color, recurse=False)\n                        elif config.renderer == RendererType.CAIRO:\n                            mob.set_color(mob_color, family=False)\n                        break\n\n        return self"}, {"name": "SurroundingRectangle", "code": "class SurroundingRectangle(RoundedRectangle):\n    r\"\"\"A rectangle surrounding a :class:`~.Mobject`\n\n    Examples\n    --------\n    .. manim:: SurroundingRectExample\n        :save_last_frame:\n\n        class SurroundingRectExample(Scene):\n            def construct(self):\n                title = Title(\"A Quote from Newton\")\n                quote = Text(\n                    \"If I have seen further than others, \\n\"\n                    \"it is by standing upon the shoulders of giants.\",\n                    color=BLUE,\n                ).scale(0.75)\n                box = SurroundingRectangle(quote, color=YELLOW, buff=MED_LARGE_BUFF)\n\n                t2 = Tex(r\"Hello World\").scale(1.5)\n                box2 = SurroundingRectangle(t2, corner_radius=0.2)\n                mobjects = VGroup(VGroup(box, quote), VGroup(t2, box2)).arrange(DOWN)\n                self.add(title, mobjects)\n    \"\"\"\n\n    def __init__(\n        self,\n        *mobjects: Mobject,\n        color: ParsableManimColor = YELLOW,\n        buff: float = SMALL_BUFF,\n        corner_radius: float = 0.0,\n        **kwargs: Any,\n    ) -> None:\n        from manim.mobject.mobject import Group\n\n        if not all(isinstance(mob, (Mobject, OpenGLMobject)) for mob in mobjects):\n            raise TypeError(\n                \"Expected all inputs for parameter mobjects to be a Mobjects\"\n            )\n\n        group = Group(*mobjects)\n        super().__init__(\n            color=color,\n            width=group.width + 2 * buff,\n            height=group.height + 2 * buff,\n            corner_radius=corner_radius,\n            **kwargs,\n        )\n        self.buff = buff\n        self.move_to(group)"}, {"name": "SVGMobject", "code": "class SVGMobject(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A vectorized mobject created from importing an SVG file.\n\n    Parameters\n    ----------\n    file_name\n        The path to the SVG file.\n    should_center\n        Whether or not the mobject should be centered after\n        being imported.\n    height\n        The target height of the mobject, set to 2 Manim units by default.\n        If the height and width are both set to ``None``, the mobject\n        is imported without being scaled.\n    width\n        The target width of the mobject, set to ``None`` by default. If\n        the height and the width are both set to ``None``, the mobject\n        is imported without being scaled.\n    color\n        The color (both fill and stroke color) of the mobject. If\n        ``None`` (the default), the colors set in the SVG file\n        are used.\n    opacity\n        The opacity (both fill and stroke opacity) of the mobject.\n        If ``None`` (the default), the opacity set in the SVG file\n        is used.\n    fill_color\n        The fill color of the mobject. If ``None`` (the default),\n        the fill colors set in the SVG file are used.\n    fill_opacity\n        The fill opacity of the mobject. If ``None`` (the default),\n        the fill opacities set in the SVG file are used.\n    stroke_color\n        The stroke color of the mobject. If ``None`` (the default),\n        the stroke colors set in the SVG file are used.\n    stroke_opacity\n        The stroke opacity of the mobject. If ``None`` (the default),\n        the stroke opacities set in the SVG file are used.\n    stroke_width\n        The stroke width of the mobject. If ``None`` (the default),\n        the stroke width values set in the SVG file are used.\n    svg_default\n        A dictionary in which fallback values for unspecified\n        properties of elements in the SVG file are defined. If\n        ``None`` (the default), ``color``, ``opacity``, ``fill_color``\n        ``fill_opacity``, ``stroke_color``, and ``stroke_opacity``\n        are set to ``None``, and ``stroke_width`` is set to 0.\n    path_string_config\n        A dictionary with keyword arguments passed to\n        :class:`.VMobjectFromSVGPath` used for importing path elements.\n        If ``None`` (the default), no additional arguments are passed.\n    use_svg_cache\n        If True (default), the svg inputs (e.g. file_name, settings)\n        will be used as a key and a copy of the created mobject will\n        be saved using that key to be quickly retrieved if the same\n        inputs need be processed later. For large SVGs which are used\n        only once, this can be omitted to improve performance.\n    kwargs\n        Further arguments passed to the parent class.\n    \"\"\"\n\n    def __init__(\n        self,\n        file_name: str | os.PathLike | None = None,\n        should_center: bool = True,\n        height: float | None = 2,\n        width: float | None = None,\n        color: str | None = None,\n        opacity: float | None = None,\n        fill_color: str | None = None,\n        fill_opacity: float | None = None,\n        stroke_color: str | None = None,\n        stroke_opacity: float | None = None,\n        stroke_width: float | None = None,\n        svg_default: dict | None = None,\n        path_string_config: dict | None = None,\n        use_svg_cache: bool = True,\n        **kwargs,\n    ):\n        super().__init__(color=None, stroke_color=None, fill_color=None, **kwargs)\n\n        # process keyword arguments\n        self.file_name = Path(file_name) if file_name is not None else None\n\n        self.should_center = should_center\n        self.svg_height = height\n        self.svg_width = width\n        self.color = color\n        self.opacity = opacity\n        self.fill_color = fill_color\n        self.fill_opacity = fill_opacity\n        self.stroke_color = stroke_color\n        self.stroke_opacity = stroke_opacity\n        self.stroke_width = stroke_width\n\n        if svg_default is None:\n            svg_default = {\n                \"color\": None,\n                \"opacity\": None,\n                \"fill_color\": None,\n                \"fill_opacity\": None,\n                \"stroke_width\": 0,\n                \"stroke_color\": None,\n                \"stroke_opacity\": None,\n            }\n        self.svg_default = svg_default\n\n        if path_string_config is None:\n            path_string_config = {}\n        self.path_string_config = path_string_config\n\n        self.init_svg_mobject(use_svg_cache=use_svg_cache)\n\n        self.set_style(\n            fill_color=fill_color,\n            fill_opacity=fill_opacity,\n            stroke_color=stroke_color,\n            stroke_opacity=stroke_opacity,\n            stroke_width=stroke_width,\n        )\n        self.move_into_position()\n\n    def init_svg_mobject(self, use_svg_cache: bool) -> None:\n        \"\"\"Checks whether the SVG has already been imported and\n        generates it if not.\n\n        See also\n        --------\n        :meth:`.SVGMobject.generate_mobject`\n        \"\"\"\n        if use_svg_cache:\n            hash_val = hash_obj(self.hash_seed)\n            if hash_val in SVG_HASH_TO_MOB_MAP:\n                mob = SVG_HASH_TO_MOB_MAP[hash_val].copy()\n                self.add(*mob)\n                return\n\n        self.generate_mobject()\n        if use_svg_cache:\n            SVG_HASH_TO_MOB_MAP[hash_val] = self.copy()\n\n    @property\n    def hash_seed(self) -> tuple:\n        \"\"\"A unique hash representing the result of the generated\n        mobject points.\n\n        Used as keys in the ``SVG_HASH_TO_MOB_MAP`` caching dictionary.\n        \"\"\"\n        return (\n            self.__class__.__name__,\n            self.svg_default,\n            self.path_string_config,\n            self.file_name,\n            config.renderer,\n        )\n\n    def generate_mobject(self) -> None:\n        \"\"\"Parse the SVG and translate its elements to submobjects.\"\"\"\n        file_path = self.get_file_path()\n        element_tree = ET.parse(file_path)\n        new_tree = self.modify_xml_tree(element_tree)\n        # Create a temporary svg file to dump modified svg to be parsed\n        modified_file_path = file_path.with_name(f\"{file_path.stem}_{file_path.suffix}\")\n        new_tree.write(modified_file_path)\n\n        svg = se.SVG.parse(modified_file_path)\n        modified_file_path.unlink()\n\n        mobjects = self.get_mobjects_from(svg)\n        self.add(*mobjects)\n        self.flip(RIGHT)  # Flip y\n\n    def get_file_path(self) -> Path:\n        \"\"\"Search for an existing file based on the specified file name.\"\"\"\n        if self.file_name is None:\n            raise ValueError(\"Must specify file for SVGMobject\")\n        return get_full_vector_image_path(self.file_name)\n\n    def modify_xml_tree(self, element_tree: ET.ElementTree) -> ET.ElementTree:\n        \"\"\"Modifies the SVG element tree to include default\n        style information.\n\n        Parameters\n        ----------\n        element_tree\n            The parsed element tree from the SVG file.\n        \"\"\"\n        config_style_dict = self.generate_config_style_dict()\n        style_keys = (\n            \"fill\",\n            \"fill-opacity\",\n            \"stroke\",\n            \"stroke-opacity\",\n            \"stroke-width\",\n            \"style\",\n        )\n        root = element_tree.getroot()\n        root_style_dict = {k: v for k, v in root.attrib.items() if k in style_keys}\n\n        new_root = ET.Element(\"svg\", {})\n        config_style_node = ET.SubElement(new_root, \"g\", config_style_dict)\n        root_style_node = ET.SubElement(config_style_node, \"g\", root_style_dict)\n        root_style_node.extend(root)\n        return ET.ElementTree(new_root)\n\n    def generate_config_style_dict(self) -> dict[str, str]:\n        \"\"\"Generate a dictionary holding the default style information.\"\"\"\n        keys_converting_dict = {\n            \"fill\": (\"color\", \"fill_color\"),\n            \"fill-opacity\": (\"opacity\", \"fill_opacity\"),\n            \"stroke\": (\"color\", \"stroke_color\"),\n            \"stroke-opacity\": (\"opacity\", \"stroke_opacity\"),\n            \"stroke-width\": (\"stroke_width\",),\n        }\n        svg_default_dict = self.svg_default\n        result = {}\n        for svg_key, style_keys in keys_converting_dict.items():\n            for style_key in style_keys:\n                if svg_default_dict[style_key] is None:\n                    continue\n                result[svg_key] = str(svg_default_dict[style_key])\n        return result\n\n    def get_mobjects_from(self, svg: se.SVG) -> list[VMobject]:\n        \"\"\"Convert the elements of the SVG to a list of mobjects.\n\n        Parameters\n        ----------\n        svg\n            The parsed SVG file.\n        \"\"\"\n        result = []\n        for shape in svg.elements():\n            # can we combine the two continue cases into one?\n            if isinstance(shape, se.Group):  # noqa: SIM114\n                continue\n            elif isinstance(shape, se.Path):\n                mob = self.path_to_mobject(shape)\n            elif isinstance(shape, se.SimpleLine):\n                mob = self.line_to_mobject(shape)\n            elif isinstance(shape, se.Rect):\n                mob = self.rect_to_mobject(shape)\n            elif isinstance(shape, (se.Circle, se.Ellipse)):\n                mob = self.ellipse_to_mobject(shape)\n            elif isinstance(shape, se.Polygon):\n                mob = self.polygon_to_mobject(shape)\n            elif isinstance(shape, se.Polyline):\n                mob = self.polyline_to_mobject(shape)\n            elif isinstance(shape, se.Text):\n                mob = self.text_to_mobject(shape)\n            elif isinstance(shape, se.Use) or type(shape) is se.SVGElement:\n                continue\n            else:\n                logger.warning(f\"Unsupported element type: {type(shape)}\")\n                continue\n            if mob is None or not mob.has_points():\n                continue\n            self.apply_style_to_mobject(mob, shape)\n            if isinstance(shape, se.Transformable) and shape.apply:\n                self.handle_transform(mob, shape.transform)\n            result.append(mob)\n        return result\n\n    @staticmethod\n    def handle_transform(mob: VMobject, matrix: se.Matrix) -> VMobject:\n        \"\"\"Apply SVG transformations to the converted mobject.\n\n        Parameters\n        ----------\n        mob\n            The converted mobject.\n        matrix\n            The transformation matrix determined from the SVG\n            transformation.\n        \"\"\"\n        mat = np.array([[matrix.a, matrix.c], [matrix.b, matrix.d]])\n        vec = np.array([matrix.e, matrix.f, 0.0])\n        mob.apply_matrix(mat)\n        mob.shift(vec)\n        return mob\n\n    @staticmethod\n    def apply_style_to_mobject(mob: VMobject, shape: se.GraphicObject) -> VMobject:\n        \"\"\"Apply SVG style information to the converted mobject.\n\n        Parameters\n        ----------\n        mob\n            The converted mobject.\n        shape\n            The parsed SVG element.\n        \"\"\"\n        mob.set_style(\n            stroke_width=shape.stroke_width,\n            stroke_color=shape.stroke.hexrgb,\n            stroke_opacity=shape.stroke.opacity,\n            fill_color=shape.fill.hexrgb,\n            fill_opacity=shape.fill.opacity,\n        )\n        return mob\n\n    def path_to_mobject(self, path: se.Path) -> VMobjectFromSVGPath:\n        \"\"\"Convert a path element to a vectorized mobject.\n\n        Parameters\n        ----------\n        path\n            The parsed SVG path.\n        \"\"\"\n        return VMobjectFromSVGPath(path, **self.path_string_config)\n\n    @staticmethod\n    def line_to_mobject(line: se.Line) -> Line:\n        \"\"\"Convert a line element to a vectorized mobject.\n\n        Parameters\n        ----------\n        line\n            The parsed SVG line.\n        \"\"\"\n        return Line(\n            start=_convert_point_to_3d(line.x1, line.y1),\n            end=_convert_point_to_3d(line.x2, line.y2),\n        )\n\n    @staticmethod\n    def rect_to_mobject(rect: se.Rect) -> Rectangle:\n        \"\"\"Convert a rectangle element to a vectorized mobject.\n\n        Parameters\n        ----------\n        rect\n            The parsed SVG rectangle.\n        \"\"\"\n        if rect.rx == 0 or rect.ry == 0:\n            mob = Rectangle(\n                width=rect.width,\n                height=rect.height,\n            )\n        else:\n            mob = RoundedRectangle(\n                width=rect.width,\n                height=rect.height * rect.rx / rect.ry,\n                corner_radius=rect.rx,\n            )\n            mob.stretch_to_fit_height(rect.height)\n        mob.shift(\n            _convert_point_to_3d(rect.x + rect.width / 2, rect.y + rect.height / 2)\n        )\n        return mob\n\n    @staticmethod\n    def ellipse_to_mobject(ellipse: se.Ellipse | se.Circle) -> Circle:\n        \"\"\"Convert an ellipse or circle element to a vectorized mobject.\n\n        Parameters\n        ----------\n        ellipse\n            The parsed SVG ellipse or circle.\n        \"\"\"\n        mob = Circle(radius=ellipse.rx)\n        if ellipse.rx != ellipse.ry:\n            mob.stretch_to_fit_height(2 * ellipse.ry)\n        mob.shift(_convert_point_to_3d(ellipse.cx, ellipse.cy))\n        return mob\n\n    @staticmethod\n    def polygon_to_mobject(polygon: se.Polygon) -> Polygon:\n        \"\"\"Convert a polygon element to a vectorized mobject.\n\n        Parameters\n        ----------\n        polygon\n            The parsed SVG polygon.\n        \"\"\"\n        points = [_convert_point_to_3d(*point) for point in polygon]\n        return Polygon(*points)\n\n    def polyline_to_mobject(self, polyline: se.Polyline) -> VMobject:\n        \"\"\"Convert a polyline element to a vectorized mobject.\n\n        Parameters\n        ----------\n        polyline\n            The parsed SVG polyline.\n        \"\"\"\n        points = [_convert_point_to_3d(*point) for point in polyline]\n        vmobject_class = self.get_mobject_type_class()\n        return vmobject_class().set_points_as_corners(points)\n\n    @staticmethod\n    def text_to_mobject(text: se.Text):\n        \"\"\"Convert a text element to a vectorized mobject.\n\n        .. warning::\n\n            Not yet implemented.\n\n        Parameters\n        ----------\n        text\n            The parsed SVG text.\n        \"\"\"\n        logger.warning(f\"Unsupported element type: {type(text)}\")\n        return\n\n    def move_into_position(self) -> None:\n        \"\"\"Scale and move the generated mobject into position.\"\"\"\n        if self.should_center:\n            self.center()\n        if self.svg_height is not None:\n            self.set(height=self.svg_height)\n        if self.svg_width is not None:\n            self.set(width=self.svg_width)"}, {"name": "Swap", "code": "class Swap(CyclicReplace):\n    pass"}, {"name": "Table", "code": "class Table(VGroup):\n    r\"\"\"A mobject that displays a table on the screen.\n\n    Parameters\n    ----------\n    table\n        A 2D array or list of lists. Content of the table has to be a valid input\n        for the callable set in ``element_to_mobject``.\n    row_labels\n        List of :class:`~.VMobject` representing the labels of each row.\n    col_labels\n        List of :class:`~.VMobject` representing the labels of each column.\n    top_left_entry\n        The top-left entry of the table, can only be specified if row and\n        column labels are given.\n    v_buff\n        Vertical buffer passed to :meth:`~.Mobject.arrange_in_grid`, by default 0.8.\n    h_buff\n        Horizontal buffer passed to :meth:`~.Mobject.arrange_in_grid`, by default 1.3.\n    include_outer_lines\n        ``True`` if the table should include outer lines, by default False.\n    add_background_rectangles_to_entries\n        ``True`` if background rectangles should be added to entries, by default ``False``.\n    entries_background_color\n        Background color of entries if ``add_background_rectangles_to_entries`` is ``True``.\n    include_background_rectangle\n        ``True`` if the table should have a background rectangle, by default ``False``.\n    background_rectangle_color\n        Background color of table if ``include_background_rectangle`` is ``True``.\n    element_to_mobject\n        The :class:`~.Mobject` class applied to the table entries. by default :class:`~.Paragraph`. For common choices, see :mod:`~.text_mobject`/:mod:`~.tex_mobject`.\n    element_to_mobject_config\n        Custom configuration passed to :attr:`element_to_mobject`, by default {}.\n    arrange_in_grid_config\n        Dict passed to :meth:`~.Mobject.arrange_in_grid`, customizes the arrangement of the table.\n    line_config\n        Dict passed to :class:`~.Line`, customizes the lines of the table.\n    kwargs\n        Additional arguments to be passed to :class:`~.VGroup`.\n\n    Examples\n    --------\n\n    .. manim:: TableExamples\n        :save_last_frame:\n\n        class TableExamples(Scene):\n            def construct(self):\n                t0 = Table(\n                    [[\"This\", \"is a\"],\n                    [\"simple\", \"Table in \\\\n Manim.\"]])\n                t1 = Table(\n                    [[\"This\", \"is a\"],\n                    [\"simple\", \"Table.\"]],\n                    row_labels=[Text(\"R1\"), Text(\"R2\")],\n                    col_labels=[Text(\"C1\"), Text(\"C2\")])\n                t1.add_highlighted_cell((2,2), color=YELLOW)\n                t2 = Table(\n                    [[\"This\", \"is a\"],\n                    [\"simple\", \"Table.\"]],\n                    row_labels=[Text(\"R1\"), Text(\"R2\")],\n                    col_labels=[Text(\"C1\"), Text(\"C2\")],\n                    top_left_entry=Star().scale(0.3),\n                    include_outer_lines=True,\n                    arrange_in_grid_config={\"cell_alignment\": RIGHT})\n                t2.add(t2.get_cell((2,2), color=RED))\n                t3 = Table(\n                    [[\"This\", \"is a\"],\n                    [\"simple\", \"Table.\"]],\n                    row_labels=[Text(\"R1\"), Text(\"R2\")],\n                    col_labels=[Text(\"C1\"), Text(\"C2\")],\n                    top_left_entry=Star().scale(0.3),\n                    include_outer_lines=True,\n                    line_config={\"stroke_width\": 1, \"color\": YELLOW})\n                t3.remove(*t3.get_vertical_lines())\n                g = Group(\n                    t0,t1,t2,t3\n                ).scale(0.7).arrange_in_grid(buff=1)\n                self.add(g)\n\n    .. manim:: BackgroundRectanglesExample\n        :save_last_frame:\n\n        class BackgroundRectanglesExample(Scene):\n            def construct(self):\n                background = Rectangle(height=6.5, width=13)\n                background.set_fill(opacity=.5)\n                background.set_color([TEAL, RED, YELLOW])\n                self.add(background)\n                t0 = Table(\n                    [[\"This\", \"is a\"],\n                    [\"simple\", \"Table.\"]],\n                    add_background_rectangles_to_entries=True)\n                t1 = Table(\n                    [[\"This\", \"is a\"],\n                    [\"simple\", \"Table.\"]],\n                    include_background_rectangle=True)\n                g = Group(t0, t1).scale(0.7).arrange(buff=0.5)\n                self.add(g)\n    \"\"\"\n\n    def __init__(\n        self,\n        table: Iterable[Iterable[float | str | VMobject]],\n        row_labels: Iterable[VMobject] | None = None,\n        col_labels: Iterable[VMobject] | None = None,\n        top_left_entry: VMobject | None = None,\n        v_buff: float = 0.8,\n        h_buff: float = 1.3,\n        include_outer_lines: bool = False,\n        add_background_rectangles_to_entries: bool = False,\n        entries_background_color: ParsableManimColor = BLACK,\n        include_background_rectangle: bool = False,\n        background_rectangle_color: ParsableManimColor = BLACK,\n        element_to_mobject: Callable[\n            [float | str | VMobject],\n            VMobject,\n        ] = Paragraph,\n        element_to_mobject_config: dict = {},\n        arrange_in_grid_config: dict = {},\n        line_config: dict = {},\n        **kwargs,\n    ):\n        self.row_labels = row_labels\n        self.col_labels = col_labels\n        self.top_left_entry = top_left_entry\n        self.row_dim = len(table)\n        self.col_dim = len(table[0])\n        self.v_buff = v_buff\n        self.h_buff = h_buff\n        self.include_outer_lines = include_outer_lines\n        self.add_background_rectangles_to_entries = add_background_rectangles_to_entries\n        self.entries_background_color = ManimColor(entries_background_color)\n        self.include_background_rectangle = include_background_rectangle\n        self.background_rectangle_color = ManimColor(background_rectangle_color)\n        self.element_to_mobject = element_to_mobject\n        self.element_to_mobject_config = element_to_mobject_config\n        self.arrange_in_grid_config = arrange_in_grid_config\n        self.line_config = line_config\n\n        for row in table:\n            if len(row) == len(table[0]):\n                pass\n            else:\n                raise ValueError(\"Not all rows in table have the same length.\")\n\n        super().__init__(**kwargs)\n        mob_table = self._table_to_mob_table(table)\n        self.elements_without_labels = VGroup(*it.chain(*mob_table))\n        mob_table = self._add_labels(mob_table)\n        self._organize_mob_table(mob_table)\n        self.elements = VGroup(*it.chain(*mob_table))\n\n        if len(self.elements[0].get_all_points()) == 0:\n            self.elements.remove(self.elements[0])\n\n        self.add(self.elements)\n        self.center()\n        self.mob_table = mob_table\n        self._add_horizontal_lines()\n        self._add_vertical_lines()\n        if self.add_background_rectangles_to_entries:\n            self.add_background_to_entries(color=self.entries_background_color)\n        if self.include_background_rectangle:\n            self.add_background_rectangle(color=self.background_rectangle_color)\n\n    def _table_to_mob_table(\n        self,\n        table: Iterable[Iterable[float | str | VMobject]],\n    ) -> list:\n        \"\"\"Initializes the entries of ``table`` as :class:`~.VMobject`.\n\n        Parameters\n        ----------\n        table\n            A 2D array or list of lists. Content of the table has to be a valid input\n            for the callable set in ``element_to_mobject``.\n\n        Returns\n        --------\n        List\n            List of :class:`~.VMobject` from the entries of ``table``.\n        \"\"\"\n        return [\n            [\n                self.element_to_mobject(item, **self.element_to_mobject_config)\n                for item in row\n            ]\n            for row in table\n        ]\n\n    def _organize_mob_table(self, table: Iterable[Iterable[VMobject]]) -> VGroup:\n        \"\"\"Arranges the :class:`~.VMobject` of ``table`` in a grid.\n\n        Parameters\n        ----------\n        table\n            A 2D iterable object with :class:`~.VMobject` entries.\n\n        Returns\n        --------\n        :class:`~.VGroup`\n            The :class:`~.VMobject` of the ``table`` in a :class:`~.VGroup` already\n            arranged in a table-like grid.\n        \"\"\"\n        help_table = VGroup()\n        for i, row in enumerate(table):\n            for j, _ in enumerate(row):\n                help_table.add(table[i][j])\n        help_table.arrange_in_grid(\n            rows=len(table),\n            cols=len(table[0]),\n            buff=(self.h_buff, self.v_buff),\n            **self.arrange_in_grid_config,\n        )\n        return help_table\n\n    def _add_labels(self, mob_table: VGroup) -> VGroup:\n        \"\"\"Adds labels to an in a grid arranged :class:`~.VGroup`.\n\n        Parameters\n        ----------\n        mob_table\n            An in a grid organized class:`~.VGroup`.\n\n        Returns\n        --------\n        :class:`~.VGroup`\n            Returns the ``mob_table`` with added labels.\n        \"\"\"\n        if self.row_labels is not None:\n            for k in range(len(self.row_labels)):\n                mob_table[k] = [self.row_labels[k]] + mob_table[k]\n        if self.col_labels is not None:\n            if self.row_labels is not None:\n                if self.top_left_entry is not None:\n                    col_labels = [self.top_left_entry] + self.col_labels\n                    mob_table.insert(0, col_labels)\n                else:\n                    # Placeholder to use arrange_in_grid if top_left_entry is not set.\n                    # Import OpenGLVMobject to work with --renderer=opengl\n                    dummy_mobject = get_vectorized_mobject_class()()\n                    col_labels = [dummy_mobject] + self.col_labels\n                    mob_table.insert(0, col_labels)\n            else:\n                mob_table.insert(0, self.col_labels)\n        return mob_table\n\n    def _add_horizontal_lines(self) -> Table:\n        \"\"\"Adds the horizontal lines to the table.\"\"\"\n        anchor_left = self.get_left()[0] - 0.5 * self.h_buff\n        anchor_right = self.get_right()[0] + 0.5 * self.h_buff\n        line_group = VGroup()\n        if self.include_outer_lines:\n            anchor = self.get_rows()[0].get_top()[1] + 0.5 * self.v_buff\n            line = Line(\n                [anchor_left, anchor, 0], [anchor_right, anchor, 0], **self.line_config\n            )\n            line_group.add(line)\n            self.add(line)\n            anchor = self.get_rows()[-1].get_bottom()[1] - 0.5 * self.v_buff\n            line = Line(\n                [anchor_left, anchor, 0], [anchor_right, anchor, 0], **self.line_config\n            )\n            line_group.add(line)\n            self.add(line)\n        for k in range(len(self.mob_table) - 1):\n            anchor = self.get_rows()[k + 1].get_top()[1] + 0.5 * (\n                self.get_rows()[k].get_bottom()[1] - self.get_rows()[k + 1].get_top()[1]\n            )\n            line = Line(\n                [anchor_left, anchor, 0], [anchor_right, anchor, 0], **self.line_config\n            )\n            line_group.add(line)\n            self.add(line)\n        self.horizontal_lines = line_group\n        return self\n\n    def _add_vertical_lines(self) -> Table:\n        \"\"\"Adds the vertical lines to the table\"\"\"\n        anchor_top = self.get_rows().get_top()[1] + 0.5 * self.v_buff\n        anchor_bottom = self.get_rows().get_bottom()[1] - 0.5 * self.v_buff\n        line_group = VGroup()\n        if self.include_outer_lines:\n            anchor = self.get_columns()[0].get_left()[0] - 0.5 * self.h_buff\n            line = Line(\n                [anchor, anchor_top, 0], [anchor, anchor_bottom, 0], **self.line_config\n            )\n            line_group.add(line)\n            self.add(line)\n            anchor = self.get_columns()[-1].get_right()[0] + 0.5 * self.h_buff\n            line = Line(\n                [anchor, anchor_top, 0], [anchor, anchor_bottom, 0], **self.line_config\n            )\n            line_group.add(line)\n            self.add(line)\n        for k in range(len(self.mob_table[0]) - 1):\n            anchor = self.get_columns()[k + 1].get_left()[0] + 0.5 * (\n                self.get_columns()[k].get_right()[0]\n                - self.get_columns()[k + 1].get_left()[0]\n            )\n            line = Line(\n                [anchor, anchor_bottom, 0], [anchor, anchor_top, 0], **self.line_config\n            )\n            line_group.add(line)\n            self.add(line)\n        self.vertical_lines = line_group\n        return self\n\n    def get_horizontal_lines(self) -> VGroup:\n        \"\"\"Return the horizontal lines of the table.\n\n        Returns\n        --------\n        :class:`~.VGroup`\n            :class:`~.VGroup` containing all the horizontal lines of the table.\n\n        Examples\n        --------\n\n        .. manim:: GetHorizontalLinesExample\n            :save_last_frame:\n\n            class GetHorizontalLinesExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")])\n                    table.get_horizontal_lines().set_color(RED)\n                    self.add(table)\n        \"\"\"\n        return self.horizontal_lines\n\n    def get_vertical_lines(self) -> VGroup:\n        \"\"\"Return the vertical lines of the table.\n\n        Returns\n        --------\n        :class:`~.VGroup`\n            :class:`~.VGroup` containing all the vertical lines of the table.\n\n        Examples\n        --------\n\n        .. manim:: GetVerticalLinesExample\n            :save_last_frame:\n\n            class GetVerticalLinesExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")])\n                    table.get_vertical_lines()[0].set_color(RED)\n                    self.add(table)\n        \"\"\"\n        return self.vertical_lines\n\n    def get_columns(self) -> VGroup:\n        \"\"\"Return columns of the table as a :class:`~.VGroup` of :class:`~.VGroup`.\n\n        Returns\n        --------\n        :class:`~.VGroup`\n            :class:`~.VGroup` containing each column in a :class:`~.VGroup`.\n\n        Examples\n        --------\n\n        .. manim:: GetColumnsExample\n            :save_last_frame:\n\n            class GetColumnsExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")])\n                    table.add(SurroundingRectangle(table.get_columns()[1]))\n                    self.add(table)\n        \"\"\"\n        return VGroup(\n            *(\n                VGroup(*(row[i] for row in self.mob_table))\n                for i in range(len(self.mob_table[0]))\n            )\n        )\n\n    def get_rows(self) -> VGroup:\n        \"\"\"Return the rows of the table as a :class:`~.VGroup` of :class:`~.VGroup`.\n\n        Returns\n        --------\n        :class:`~.VGroup`\n            :class:`~.VGroup` containing each row in a :class:`~.VGroup`.\n\n        Examples\n        --------\n\n        .. manim:: GetRowsExample\n            :save_last_frame:\n\n            class GetRowsExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")])\n                    table.add(SurroundingRectangle(table.get_rows()[1]))\n                    self.add(table)\n        \"\"\"\n        return VGroup(*(VGroup(*row) for row in self.mob_table))\n\n    def set_column_colors(self, *colors: Iterable[ParsableManimColor]) -> Table:\n        \"\"\"Set individual colors for each column of the table.\n\n        Parameters\n        ----------\n        colors\n            An iterable of colors; each color corresponds to a column.\n\n        Examples\n        --------\n\n        .. manim:: SetColumnColorsExample\n            :save_last_frame:\n\n            class SetColumnColorsExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")]\n                    ).set_column_colors([RED,BLUE], GREEN)\n                    self.add(table)\n        \"\"\"\n        columns = self.get_columns()\n        for color, column in zip(colors, columns):\n            column.set_color(color)\n        return self\n\n    def set_row_colors(self, *colors: Iterable[ParsableManimColor]) -> Table:\n        \"\"\"Set individual colors for each row of the table.\n\n        Parameters\n        ----------\n        colors\n            An iterable of colors; each color corresponds to a row.\n\n        Examples\n        --------\n\n        .. manim:: SetRowColorsExample\n            :save_last_frame:\n\n            class SetRowColorsExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")]\n                    ).set_row_colors([RED,BLUE], GREEN)\n                    self.add(table)\n        \"\"\"\n        rows = self.get_rows()\n        for color, row in zip(colors, rows):\n            row.set_color(color)\n        return self\n\n    def get_entries(\n        self,\n        pos: Sequence[int] | None = None,\n    ) -> VMobject | VGroup:\n        \"\"\"Return the individual entries of the table (including labels) or one specific entry\n        if the parameter, ``pos``,  is set.\n\n        Parameters\n        ----------\n        pos\n            The position of a specific entry on the table. ``(1,1)`` being the top left entry\n            of the table.\n\n        Returns\n        -------\n        Union[:class:`~.VMobject`, :class:`~.VGroup`]\n            :class:`~.VGroup` containing all entries of the table (including labels)\n            or the :class:`~.VMobject` at the given position if ``pos`` is set.\n\n        Examples\n        --------\n\n        .. manim:: GetEntriesExample\n            :save_last_frame:\n\n            class GetEntriesExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")])\n                    ent = table.get_entries()\n                    for item in ent:\n                        item.set_color(random_bright_color())\n                    table.get_entries((2,2)).rotate(PI)\n                    self.add(table)\n        \"\"\"\n        if pos is not None:\n            if (\n                self.row_labels is not None\n                and self.col_labels is not None\n                and self.top_left_entry is None\n            ):\n                index = len(self.mob_table[0]) * (pos[0] - 1) + pos[1] - 2\n                return self.elements[index]\n            else:\n                index = len(self.mob_table[0]) * (pos[0] - 1) + pos[1] - 1\n                return self.elements[index]\n        else:\n            return self.elements\n\n    def get_entries_without_labels(\n        self,\n        pos: Sequence[int] | None = None,\n    ) -> VMobject | VGroup:\n        \"\"\"Return the individual entries of the table (without labels) or one specific entry\n        if the parameter, ``pos``, is set.\n\n        Parameters\n        ----------\n        pos\n            The position of a specific entry on the table. ``(1,1)`` being the top left entry\n            of the table (without labels).\n\n        Returns\n        -------\n        Union[:class:`~.VMobject`, :class:`~.VGroup`]\n            :class:`~.VGroup` containing all entries of the table (without labels)\n            or the :class:`~.VMobject` at the given position if ``pos`` is set.\n\n        Examples\n        --------\n\n        .. manim:: GetEntriesWithoutLabelsExample\n            :save_last_frame:\n\n            class GetEntriesWithoutLabelsExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")])\n                    ent = table.get_entries_without_labels()\n                    colors = [BLUE, GREEN, YELLOW, RED]\n                    for k in range(len(colors)):\n                        ent[k].set_color(colors[k])\n                    table.get_entries_without_labels((2,2)).rotate(PI)\n                    self.add(table)\n        \"\"\"\n        if pos is not None:\n            index = self.col_dim * (pos[0] - 1) + pos[1] - 1\n            return self.elements_without_labels[index]\n        else:\n            return self.elements_without_labels\n\n    def get_row_labels(self) -> VGroup:\n        \"\"\"Return the row labels of the table.\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            :class:`~.VGroup` containing the row labels of the table.\n\n        Examples\n        --------\n\n        .. manim:: GetRowLabelsExample\n            :save_last_frame:\n\n            class GetRowLabelsExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")])\n                    lab = table.get_row_labels()\n                    for item in lab:\n                        item.set_color(random_bright_color())\n                    self.add(table)\n        \"\"\"\n        return VGroup(*self.row_labels)\n\n    def get_col_labels(self) -> VGroup:\n        \"\"\"Return the column labels of the table.\n\n        Returns\n        --------\n        :class:`~.VGroup`\n            VGroup containing the column labels of the table.\n\n        Examples\n        --------\n\n        .. manim:: GetColLabelsExample\n            :save_last_frame:\n\n            class GetColLabelsExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")])\n                    lab = table.get_col_labels()\n                    for item in lab:\n                        item.set_color(random_bright_color())\n                    self.add(table)\n        \"\"\"\n        return VGroup(*self.col_labels)\n\n    def get_labels(self) -> VGroup:\n        \"\"\"Returns the labels of the table.\n\n        Returns\n        --------\n        :class:`~.VGroup`\n            :class:`~.VGroup` containing all the labels of the table.\n\n        Examples\n        --------\n\n        .. manim:: GetLabelsExample\n            :save_last_frame:\n\n            class GetLabelsExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")])\n                    lab = table.get_labels()\n                    colors = [BLUE, GREEN, YELLOW, RED]\n                    for k in range(len(colors)):\n                        lab[k].set_color(colors[k])\n                    self.add(table)\n        \"\"\"\n        label_group = VGroup()\n        if self.top_left_entry is not None:\n            label_group.add(self.top_left_entry)\n        for label in (self.col_labels, self.row_labels):\n            if label is not None:\n                label_group.add(*label)\n        return label_group\n\n    def add_background_to_entries(self, color: ParsableManimColor = BLACK) -> Table:\n        \"\"\"Adds a black :class:`~.BackgroundRectangle` to each entry of the table.\"\"\"\n        for mob in self.get_entries():\n            mob.add_background_rectangle(color=ManimColor(color))\n        return self\n\n    def get_cell(self, pos: Sequence[int] = (1, 1), **kwargs) -> Polygon:\n        \"\"\"Returns one specific cell as a rectangular :class:`~.Polygon` without the entry.\n\n        Parameters\n        ----------\n        pos\n            The position of a specific entry on the table. ``(1,1)`` being the top left entry\n            of the table.\n        kwargs\n            Additional arguments to be passed to :class:`~.Polygon`.\n\n        Returns\n        -------\n        :class:`~.Polygon`\n            Polygon mimicking one specific cell of the Table.\n\n        Examples\n        --------\n\n        .. manim:: GetCellExample\n            :save_last_frame:\n\n            class GetCellExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")])\n                    cell = table.get_cell((2,2), color=RED)\n                    self.add(table, cell)\n        \"\"\"\n        row = self.get_rows()[pos[0] - 1]\n        col = self.get_columns()[pos[1] - 1]\n        edge_UL = [\n            col.get_left()[0] - self.h_buff / 2,\n            row.get_top()[1] + self.v_buff / 2,\n            0,\n        ]\n        edge_UR = [\n            col.get_right()[0] + self.h_buff / 2,\n            row.get_top()[1] + self.v_buff / 2,\n            0,\n        ]\n        edge_DL = [\n            col.get_left()[0] - self.h_buff / 2,\n            row.get_bottom()[1] - self.v_buff / 2,\n            0,\n        ]\n        edge_DR = [\n            col.get_right()[0] + self.h_buff / 2,\n            row.get_bottom()[1] - self.v_buff / 2,\n            0,\n        ]\n        rec = Polygon(edge_UL, edge_UR, edge_DR, edge_DL, **kwargs)\n        return rec\n\n    def get_highlighted_cell(\n        self, pos: Sequence[int] = (1, 1), color: ParsableManimColor = YELLOW, **kwargs\n    ) -> BackgroundRectangle:\n        \"\"\"Returns a :class:`~.BackgroundRectangle` of the cell at the given position.\n\n        Parameters\n        ----------\n        pos\n            The position of a specific entry on the table. ``(1,1)`` being the top left entry\n            of the table.\n        color\n            The color used to highlight the cell.\n        kwargs\n            Additional arguments to be passed to :class:`~.BackgroundRectangle`.\n\n        Examples\n        --------\n\n        .. manim:: GetHighlightedCellExample\n            :save_last_frame:\n\n            class GetHighlightedCellExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")])\n                    highlight = table.get_highlighted_cell((2,2), color=GREEN)\n                    table.add_to_back(highlight)\n                    self.add(table)\n        \"\"\"\n        cell = self.get_cell(pos)\n        bg_cell = BackgroundRectangle(cell, color=ManimColor(color), **kwargs)\n        return bg_cell\n\n    def add_highlighted_cell(\n        self, pos: Sequence[int] = (1, 1), color: ParsableManimColor = YELLOW, **kwargs\n    ) -> Table:\n        \"\"\"Highlights one cell at a specific position on the table by adding a :class:`~.BackgroundRectangle`.\n\n        Parameters\n        ----------\n        pos\n            The position of a specific entry on the table. ``(1,1)`` being the top left entry\n            of the table.\n        color\n            The color used to highlight the cell.\n        kwargs\n            Additional arguments to be passed to :class:`~.BackgroundRectangle`.\n\n        Examples\n        --------\n\n        .. manim:: AddHighlightedCellExample\n            :save_last_frame:\n\n            class AddHighlightedCellExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")])\n                    table.add_highlighted_cell((2,2), color=GREEN)\n                    self.add(table)\n        \"\"\"\n        bg_cell = self.get_highlighted_cell(pos, color=ManimColor(color), **kwargs)\n        self.add_to_back(bg_cell)\n        entry = self.get_entries(pos)\n        entry.background_rectangle = bg_cell\n        return self\n\n    def create(\n        self,\n        lag_ratio: float = 1,\n        line_animation: Callable[[VMobject | VGroup], Animation] = Create,\n        label_animation: Callable[[VMobject | VGroup], Animation] = Write,\n        element_animation: Callable[[VMobject | VGroup], Animation] = Create,\n        entry_animation: Callable[[VMobject | VGroup], Animation] = FadeIn,\n        **kwargs,\n    ) -> AnimationGroup:\n        \"\"\"Customized create-type function for tables.\n\n        Parameters\n        ----------\n        lag_ratio\n            The lag ratio of the animation.\n        line_animation\n            The animation style of the table lines, see :mod:`~.creation` for examples.\n        label_animation\n            The animation style of the table labels, see :mod:`~.creation` for examples.\n        element_animation\n            The animation style of the table elements, see :mod:`~.creation` for examples.\n        entry_animation\n            The entry animation of the table background, see :mod:`~.creation` for examples.\n        kwargs\n            Further arguments passed to the creation animations.\n\n        Returns\n        -------\n        :class:`~.AnimationGroup`\n            AnimationGroup containing creation of the lines and of the elements.\n\n        Examples\n        --------\n\n        .. manim:: CreateTableExample\n\n            class CreateTableExample(Scene):\n                def construct(self):\n                    table = Table(\n                        [[\"First\", \"Second\"],\n                        [\"Third\",\"Fourth\"]],\n                        row_labels=[Text(\"R1\"), Text(\"R2\")],\n                        col_labels=[Text(\"C1\"), Text(\"C2\")],\n                        include_outer_lines=True)\n                    self.play(table.create())\n                    self.wait()\n        \"\"\"\n        animations: Sequence[Animation] = [\n            line_animation(\n                VGroup(self.vertical_lines, self.horizontal_lines),\n                **kwargs,\n            ),\n            element_animation(self.elements_without_labels.set_z_index(2), **kwargs),\n        ]\n\n        if self.get_labels():\n            animations += [\n                label_animation(self.get_labels(), **kwargs),\n            ]\n\n        if self.get_entries():\n            for entry in self.elements_without_labels:\n                try:\n                    animations += [\n                        entry_animation(\n                            entry.background_rectangle,\n                            **kwargs,\n                        )\n                    ]\n                except AttributeError:\n                    continue\n\n        return AnimationGroup(*animations, lag_ratio=lag_ratio)\n\n    def scale(self, scale_factor: float, **kwargs):\n        # h_buff and v_buff must be adjusted so that Table.get_cell\n        # can construct an accurate polygon for a cell.\n        self.h_buff *= scale_factor\n        self.v_buff *= scale_factor\n        super().scale(scale_factor, **kwargs)\n        return self"}, {"name": "TangentLine", "code": "class TangentLine(Line):\n    \"\"\"Constructs a line tangent to a :class:`~.VMobject` at a specific point.\n\n    Parameters\n    ----------\n    vmob\n        The VMobject on which the tangent line is drawn.\n    alpha\n        How far along the shape that the line will be constructed. range: 0-1.\n    length\n        Length of the tangent line.\n    d_alpha\n        The ``dx`` value\n    kwargs\n        Additional arguments to be passed to :class:`Line`\n\n\n    .. seealso::\n        :meth:`~.VMobject.point_from_proportion`\n\n    Examples\n    --------\n    .. manim:: TangentLineExample\n        :save_last_frame:\n\n        class TangentLineExample(Scene):\n            def construct(self):\n                circle = Circle(radius=2)\n                line_1 = TangentLine(circle, alpha=0.0, length=4, color=BLUE_D) # right\n                line_2 = TangentLine(circle, alpha=0.4, length=4, color=GREEN) # top left\n                self.add(circle, line_1, line_2)\n    \"\"\"\n\n    def __init__(\n        self,\n        vmob: VMobject,\n        alpha: float,\n        length: float = 1,\n        d_alpha: float = 1e-6,\n        **kwargs: Any,\n    ) -> None:\n        self.length = length\n        self.d_alpha = d_alpha\n        da = self.d_alpha\n        a1 = np.clip(alpha - da, 0, 1)\n        a2 = np.clip(alpha + da, 0, 1)\n        super().__init__(\n            vmob.point_from_proportion(a1), vmob.point_from_proportion(a2), **kwargs\n        )\n        self.scale(self.length / self.get_length())"}, {"name": "tempconfig", "code": "def tempconfig(temp: ManimConfig | dict[str, Any]) -> Generator[None, None, None]:\n    \"\"\"Context manager that temporarily modifies the global ``config`` object.\n\n    Inside the ``with`` statement, the modified config will be used.  After\n    context manager exits, the config will be restored to its original state.\n\n    Parameters\n    ----------\n    temp\n        Object whose keys will be used to temporarily update the global\n        ``config``.\n\n    Examples\n    --------\n\n    Use ``with tempconfig({...})`` to temporarily change the default values of\n    certain config options.\n\n    .. code-block:: pycon\n\n       >>> config[\"frame_height\"]\n       8.0\n       >>> with tempconfig({\"frame_height\": 100.0}):\n       ...     print(config[\"frame_height\"])\n       100.0\n       >>> config[\"frame_height\"]\n       8.0\n\n    \"\"\"\n    global config\n    original = config.copy()\n\n    temp = {k: v for k, v in temp.items() if k in original}\n\n    # In order to change the config that every module has access to, use\n    # update(), DO NOT use assignment.  Assigning config = some_dict will just\n    # make the local variable named config point to a new dictionary, it will\n    # NOT change the dictionary that every module has a reference to.\n    config.update(temp)\n    try:\n        yield\n    finally:\n        config.update(original)"}, {"name": "Tetrahedron", "code": "class Tetrahedron(Polyhedron):\n    \"\"\"A tetrahedron, one of the five platonic solids. It has 4 faces, 6 edges, and 4 vertices.\n\n    Parameters\n    ----------\n    edge_length\n        The length of an edge between any two vertices.\n\n    Examples\n    --------\n\n    .. manim:: TetrahedronScene\n        :save_last_frame:\n\n        class TetrahedronScene(ThreeDScene):\n            def construct(self):\n                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n                obj = Tetrahedron()\n                self.add(obj)\n    \"\"\"\n\n    def __init__(self, edge_length: float = 1, **kwargs):\n        unit = edge_length * np.sqrt(2) / 4\n        super().__init__(\n            vertex_coords=[\n                np.array([unit, unit, unit]),\n                np.array([unit, -unit, -unit]),\n                np.array([-unit, unit, -unit]),\n                np.array([-unit, -unit, unit]),\n            ],\n            faces_list=[[0, 1, 2], [3, 0, 2], [0, 1, 3], [3, 1, 2]],\n            **kwargs,\n        )"}, {"name": "Tex", "code": "class Tex(MathTex):\n    r\"\"\"A string compiled with LaTeX in normal mode.\n\n    The color can be set using\n    the ``color`` argument. Any parts of the ``tex_string`` that are colored by the\n    TeX commands ``\\color`` or ``\\textcolor`` will retain their original color.\n\n    Tests\n    -----\n\n    Check whether writing a LaTeX string works::\n\n        >>> Tex('The horse does not eat cucumber salad.') # doctest: +SKIP\n        Tex('The horse does not eat cucumber salad.')\n\n    \"\"\"\n\n    def __init__(\n        self, *tex_strings, arg_separator=\"\", tex_environment=\"center\", **kwargs\n    ):\n        super().__init__(\n            *tex_strings,\n            arg_separator=arg_separator,\n            tex_environment=tex_environment,\n            **kwargs,\n        )"}, {"name": "tex_hash", "code": "def tex_hash(expression: Any) -> str:\n    id_str = str(expression)\n    hasher = hashlib.sha256()\n    hasher.update(id_str.encode())\n    # Truncating at 16 bytes for cleanliness\n    return hasher.hexdigest()[:16]"}, {"name": "tex_to_svg_file", "code": "def tex_to_svg_file(\n    expression: str,\n    environment: str | None = None,\n    tex_template: TexTemplate | None = None,\n) -> Path:\n    r\"\"\"Takes a tex expression and returns the svg version of the compiled tex\n\n    Parameters\n    ----------\n    expression\n        String containing the TeX expression to be rendered, e.g. ``\\\\sqrt{2}`` or ``foo``\n    environment\n        The string containing the environment in which the expression should be typeset, e.g. ``align*``\n    tex_template\n        Template class used to typesetting. If not set, use default template set via `config[\"tex_template\"]`\n\n    Returns\n    -------\n    :class:`Path`\n        Path to generated SVG file.\n    \"\"\"\n    if tex_template is None:\n        tex_template = config[\"tex_template\"]\n    tex_file = generate_tex_file(expression, environment, tex_template)\n\n    # check if svg already exists\n    svg_file = tex_file.with_suffix(\".svg\")\n    if svg_file.exists():\n        return svg_file\n\n    dvi_file = compile_tex(\n        tex_file,\n        tex_template.tex_compiler,\n        tex_template.output_format,\n    )\n    svg_file = convert_to_svg(dvi_file, tex_template.output_format)\n    if not config[\"no_latex_cleanup\"]:\n        delete_nonsvg_files()\n    return svg_file"}, {"name": "TexFontTemplates", "code": "class TexFontTemplates:\n    \"\"\"\n    A collection of TeX templates for the fonts described at http://jf.burnol.free.fr/showcase.html\n\n    These templates are specifically designed to allow you to typeset formulae and mathematics using\n    different fonts. They are based on the mathastext LaTeX package.\n\n    Examples\n    ---------\n    Normal usage as a value for the keyword argument tex_template of Tex() and MathTex() mobjects::\n\n        ``Tex(\"My TeX code\", tex_template=TexFontTemplates.comic_sans)``\n\n    Notes\n    ------\n    Many of these templates require that specific fonts\n    are installed on your local machine.\n    For example, choosing the template TexFontTemplates.comic_sans will\n    not compile if the Comic Sans Microsoft font is not installed.\n\n    To experiment, try to render the TexFontTemplateLibrary example scene:\n         ``manim path/to/manim/example_scenes/advanced_tex_fonts.py TexFontTemplateLibrary -p -ql``\n    \"\"\"\n\n    american_typewriter = americantypewriter\n    \"\"\"American Typewriter\"\"\"\n    antykwa = aptxgm\n    \"\"\"Antykwa P\u00f3\u0142tawskiego (TX Fonts for Greek and math symbols)\"\"\"\n    apple_chancery = applechancery\n    \"\"\"Apple Chancery\"\"\"\n    auriocus_kalligraphicus = aksg\n    \"\"\"Auriocus Kalligraphicus (Symbol Greek)\"\"\"\n    baskervald_adf_fourier = baskervaldadff\n    \"\"\"Baskervald ADF with Fourier\"\"\"\n    baskerville_it = italicbaskerville\n    \"\"\"Baskerville (Italic)\"\"\"\n    biolinum = biolinum\n    \"\"\"Biolinum\"\"\"\n    brushscriptx = brushscriptxpx\n    \"\"\"BrushScriptX-Italic (PX math and Greek)\"\"\"\n    chalkboard_se = chalkboardse\n    \"\"\"Chalkboard SE\"\"\"\n    chalkduster = chalkduster\n    \"\"\"Chalkduster\"\"\"\n    comfortaa = comfortaa\n    \"\"\"Comfortaa\"\"\"\n    comic_sans = comicsansms\n    \"\"\"Comic Sans MS\"\"\"\n    droid_sans = droidsans\n    \"\"\"Droid Sans\"\"\"\n    droid_sans_it = italicdroidsans\n    \"\"\"Droid Sans (Italic)\"\"\"\n    droid_serif = droidserif\n    \"\"\"Droid Serif\"\"\"\n    droid_serif_px_it = italicdroidserifpx\n    \"\"\"Droid Serif (PX math symbols) (Italic)\"\"\"\n    ecf_augie = ecfaugieeg\n    \"\"\"ECF Augie (Euler Greek)\"\"\"\n    ecf_jd = ecfjdtx\n    \"\"\"ECF JD (with TX fonts)\"\"\"\n    ecf_skeetch = ecfscmg\n    \"\"\"ECF Skeetch (CM Greek)\"\"\"\n    ecf_tall_paul = ecftallpaul\n    \"\"\"ECF Tall Paul (with Symbol font)\"\"\"\n    ecf_webster = ecfwebstertx\n    \"\"\"ECF Webster (with TX fonts)\"\"\"\n    electrum_adf = electrumadfcm\n    \"\"\"Electrum ADF (CM Greek)\"\"\"\n    epigrafica = epigrafica\n    \"\"\" Epigrafica \"\"\"\n    fourier_utopia = fufug\n    \"\"\"Fourier Utopia (Fourier upright Greek)\"\"\"\n    french_cursive = fceg\n    \"\"\"French Cursive (Euler Greek)\"\"\"\n    gfs_bodoni = gfsbodoni\n    \"\"\"GFS Bodoni\"\"\"\n    gfs_didot = italicgfsdidot\n    \"\"\"GFS Didot (Italic)\"\"\"\n    gfs_neoHellenic = gfsneohellenic\n    \"\"\"GFS NeoHellenic\"\"\"\n    gnu_freesans_tx = gnufstx\n    \"\"\"GNU FreeSerif (and TX fonts symbols)\"\"\"\n    gnu_freeserif_freesans = gnufsfs\n    \"\"\"GNU FreeSerif and FreeSans\"\"\"\n    helvetica_fourier_it = italichelveticaf\n    \"\"\"Helvetica with Fourier (Italic)\"\"\"\n    latin_modern_tw_it = italiclmtpcm\n    \"\"\"Latin Modern Typewriter Proportional (CM Greek) (Italic)\"\"\"\n    latin_modern_tw = lmtp\n    \"\"\"Latin Modern Typewriter Proportional\"\"\"\n    libertine = libertine\n    \"\"\"Libertine\"\"\"\n    libris_adf_fourier = librisadff\n    \"\"\"Libris ADF with Fourier\"\"\"\n    minion_pro_myriad_pro = mpmptx\n    \"\"\"Minion Pro and Myriad Pro (and TX fonts symbols)\"\"\"\n    minion_pro_tx = mptx\n    \"\"\"Minion Pro (and TX fonts symbols)\"\"\"\n    new_century_schoolbook = ncssg\n    \"\"\"New Century Schoolbook (Symbol Greek)\"\"\"\n    new_century_schoolbook_px = ncssgpxm\n    \"\"\"New Century Schoolbook (Symbol Greek, PX math symbols)\"\"\"\n    noteworthy_light = noteworthylight\n    \"\"\"Noteworthy Light\"\"\"\n    palatino = palatinosg\n    \"\"\"Palatino (Symbol Greek)\"\"\"\n    papyrus = papyrus\n    \"\"\"Papyrus\"\"\"\n    romande_adf_fourier_it = italicromandeadff\n    \"\"\"Romande ADF with Fourier (Italic)\"\"\"\n    slitex = slitexeg\n    \"\"\"SliTeX (Euler Greek)\"\"\"\n    times_fourier_it = italictimesf\n    \"\"\"Times with Fourier (Italic)\"\"\"\n    urw_avant_garde = urwagsg\n    \"\"\"URW Avant Garde (Symbol Greek)\"\"\"\n    urw_zapf_chancery = urwzccmg\n    \"\"\"URW Zapf Chancery (CM Greek)\"\"\"\n    venturis_adf_fourier_it = italicvanturisadff\n    \"\"\"Venturis ADF with Fourier (Italic)\"\"\"\n    verdana_it = italicverdana\n    \"\"\"Verdana (Italic)\"\"\"\n    vollkorn_fourier_it = italicvollkornf\n    \"\"\"Vollkorn with Fourier (Italic)\"\"\"\n    vollkorn = vollkorntx\n    \"\"\"Vollkorn (TX fonts for Greek and math symbols)\"\"\"\n    zapf_chancery = zapfchancery\n    \"\"\"Zapf Chancery\"\"\""}, {"name": "Text", "code": "class Text(SVGMobject):\n    r\"\"\"Display (non-LaTeX) text rendered using `Pango <https://pango.org/>`_.\n\n    Text objects behave like a :class:`.VGroup`-like iterable of all characters\n    in the given text. In particular, slicing is possible.\n\n    Parameters\n    ----------\n    text\n        The text that needs to be created as a mobject.\n    font\n        The font family to be used to render the text. This is either a system font or\n        one loaded with `register_font()`. Note that font family names may be different\n        across operating systems.\n    warn_missing_font\n        If True (default), Manim will issue a warning if the font does not exist in the\n        (case-sensitive) list of fonts returned from `manimpango.list_fonts()`.\n\n    Returns\n    -------\n    :class:`Text`\n        The mobject-like :class:`.VGroup`.\n\n    Examples\n    ---------\n\n    .. manim:: Example1Text\n        :save_last_frame:\n\n        class Example1Text(Scene):\n            def construct(self):\n                text = Text('Hello world').scale(3)\n                self.add(text)\n\n    .. manim:: TextColorExample\n        :save_last_frame:\n\n        class TextColorExample(Scene):\n            def construct(self):\n                text1 = Text('Hello world', color=BLUE).scale(3)\n                text2 = Text('Hello world', gradient=(BLUE, GREEN)).scale(3).next_to(text1, DOWN)\n                self.add(text1, text2)\n\n    .. manim:: TextItalicAndBoldExample\n        :save_last_frame:\n\n        class TextItalicAndBoldExample(Scene):\n            def construct(self):\n                text1 = Text(\"Hello world\", slant=ITALIC)\n                text2 = Text(\"Hello world\", t2s={'world':ITALIC})\n                text3 = Text(\"Hello world\", weight=BOLD)\n                text4 = Text(\"Hello world\", t2w={'world':BOLD})\n                text5 = Text(\"Hello world\", t2c={'o':YELLOW}, disable_ligatures=True)\n                text6 = Text(\n                    \"Visit us at docs.manim.community\",\n                    t2c={\"docs.manim.community\": YELLOW},\n                    disable_ligatures=True,\n               )\n                text6.scale(1.3).shift(DOWN)\n                self.add(text1, text2, text3, text4, text5 , text6)\n                Group(*self.mobjects).arrange(DOWN, buff=.8).set(height=config.frame_height-LARGE_BUFF)\n\n    .. manim:: TextMoreCustomization\n            :save_last_frame:\n\n            class TextMoreCustomization(Scene):\n                def construct(self):\n                    text1 = Text(\n                        'Google',\n                        t2c={'[:1]': '#3174f0', '[1:2]': '#e53125',\n                             '[2:3]': '#fbb003', '[3:4]': '#3174f0',\n                             '[4:5]': '#269a43', '[5:]': '#e53125'}, font_size=58).scale(3)\n                    self.add(text1)\n\n    As :class:`Text` uses Pango to render text, rendering non-English\n    characters is easily possible:\n\n    .. manim:: MultipleFonts\n        :save_last_frame:\n\n        class MultipleFonts(Scene):\n            def construct(self):\n                morning = Text(\"\u0bb5\u0ba3\u0b95\u0bcd\u0b95\u0bae\u0bcd\", font=\"sans-serif\")\n                japanese = Text(\n                    \"\u65e5\u672c\u3078\u3088\u3046\u3053\u305d\", t2c={\"\u65e5\u672c\": BLUE}\n                )  # works same as ``Text``.\n                mess = Text(\"Multi-Language\", weight=BOLD)\n                russ = Text(\"\u0417\u0434\u0440\u0430\u0432\u0441\u0442\u0432\u0443\u0439\u0442\u0435 \u092e\u0938 \u0928\u092e \u092e \", font=\"sans-serif\")\n                hin = Text(\"\u0928\u092e\u0938\u094d\u0924\u0947\", font=\"sans-serif\")\n                arb = Text(\n                    \"\u0635\u0628\u0627\u062d \u0627\u0644\u062e\u064a\u0631 \\n \u062a\u0634\u0631\u0641\u062a \u0628\u0645\u0642\u0627\u0628\u0644\u062a\u0643\", font=\"sans-serif\"\n                )  # don't mix RTL and LTR languages nothing shows up then ;-)\n                chinese = Text(\"\u81c2\u733f\u300c\u9edb\u6bd4\u300d\u5e36\u8457\u5b69\u5b50\", font=\"sans-serif\")\n                self.add(morning, japanese, mess, russ, hin, arb, chinese)\n                for i,mobj in enumerate(self.mobjects):\n                    mobj.shift(DOWN*(i-3))\n\n\n    .. manim:: PangoRender\n        :quality: low\n\n        class PangoRender(Scene):\n            def construct(self):\n                morning = Text(\"\u0bb5\u0ba3\u0b95\u0bcd\u0b95\u0bae\u0bcd\", font=\"sans-serif\")\n                self.play(Write(morning))\n                self.wait(2)\n\n    Tests\n    -----\n\n    Check that the creation of :class:`~.Text` works::\n\n        >>> Text('The horse does not eat cucumber salad.')\n        Text('The horse does not eat cucumber salad.')\n\n    \"\"\"\n\n    @staticmethod\n    @functools.cache\n    def font_list() -> list[str]:\n        return manimpango.list_fonts()\n\n    def __init__(\n        self,\n        text: str,\n        fill_opacity: float = 1.0,\n        stroke_width: float = 0,\n        color: ParsableManimColor | None = None,\n        font_size: float = DEFAULT_FONT_SIZE,\n        line_spacing: float = -1,\n        font: str = \"\",\n        slant: str = NORMAL,\n        weight: str = NORMAL,\n        t2c: dict[str, str] = None,\n        t2f: dict[str, str] = None,\n        t2g: dict[str, tuple] = None,\n        t2s: dict[str, str] = None,\n        t2w: dict[str, str] = None,\n        gradient: tuple = None,\n        tab_width: int = 4,\n        warn_missing_font: bool = True,\n        # Mobject\n        height: float = None,\n        width: float = None,\n        should_center: bool = True,\n        disable_ligatures: bool = False,\n        use_svg_cache: bool = False,\n        **kwargs,\n    ) -> None:\n        self.line_spacing = line_spacing\n        if font and warn_missing_font:\n            fonts_list = Text.font_list()\n            # handle special case of sans/sans-serif\n            if font.lower() == \"sans-serif\":\n                font = \"sans\"\n            if font not in fonts_list:\n                # check if the capitalized version is in the supported fonts\n                if font.capitalize() in fonts_list:\n                    font = font.capitalize()\n                elif font.lower() in fonts_list:\n                    font = font.lower()\n                elif font.title() in fonts_list:\n                    font = font.title()\n                else:\n                    logger.warning(f\"Font {font} not in {fonts_list}.\")\n        self.font = font\n        self._font_size = float(font_size)\n        # needs to be a float or else size is inflated when font_size = 24\n        # (unknown cause)\n        self.slant = slant\n        self.weight = weight\n        self.gradient = gradient\n        self.tab_width = tab_width\n        if t2c is None:\n            t2c = {}\n        if t2f is None:\n            t2f = {}\n        if t2g is None:\n            t2g = {}\n        if t2s is None:\n            t2s = {}\n        if t2w is None:\n            t2w = {}\n        # If long form arguments are present, they take precedence\n        t2c = kwargs.pop(\"text2color\", t2c)\n        t2f = kwargs.pop(\"text2font\", t2f)\n        t2g = kwargs.pop(\"text2gradient\", t2g)\n        t2s = kwargs.pop(\"text2slant\", t2s)\n        t2w = kwargs.pop(\"text2weight\", t2w)\n        self.t2c = {k: ManimColor(v).to_hex() for k, v in t2c.items()}\n        self.t2f = t2f\n        self.t2g = t2g\n        self.t2s = t2s\n        self.t2w = t2w\n\n        self.original_text = text\n        self.disable_ligatures = disable_ligatures\n        text_without_tabs = text\n        if text.find(\"\\t\") != -1:\n            text_without_tabs = text.replace(\"\\t\", \" \" * self.tab_width)\n        self.text = text_without_tabs\n        if self.line_spacing == -1:\n            self.line_spacing = (\n                self._font_size + self._font_size * DEFAULT_LINE_SPACING_SCALE\n            )\n        else:\n            self.line_spacing = self._font_size + self._font_size * self.line_spacing\n\n        color: ManimColor = ManimColor(color) if color else VMobject().color\n        file_name = self._text2svg(color.to_hex())\n        PangoUtils.remove_last_M(file_name)\n        super().__init__(\n            file_name,\n            fill_opacity=fill_opacity,\n            stroke_width=stroke_width,\n            height=height,\n            width=width,\n            should_center=should_center,\n            use_svg_cache=use_svg_cache,\n            **kwargs,\n        )\n        self.text = text\n        if self.disable_ligatures:\n            self.submobjects = [*self._gen_chars()]\n        self.chars = self.get_group_class()(*self.submobjects)\n        self.text = text_without_tabs.replace(\" \", \"\").replace(\"\\n\", \"\")\n        nppc = self.n_points_per_curve\n        for each in self:\n            if len(each.points) == 0:\n                continue\n            points = each.points\n            curve_start = points[0]\n            assert len(curve_start) == self.dim, curve_start\n            # Some of the glyphs in this text might not be closed,\n            # so we close them by identifying when one curve ends\n            # but it is not where the next curve starts.\n            # It is more efficient to temporarily create a list\n            # of points and add them one at a time, then turn them\n            # into a numpy array at the end, rather than creating\n            # new numpy arrays every time a point or fixing line\n            # is added (which is O(n^2) for numpy arrays).\n            closed_curve_points = []\n            # OpenGL has points be part of quadratic Bezier curves;\n            # Cairo uses cubic Bezier curves.\n            if nppc == 3:  # RendererType.OPENGL\n\n                def add_line_to(end):\n                    nonlocal closed_curve_points\n                    start = closed_curve_points[-1]\n                    closed_curve_points += [\n                        start,\n                        (start + end) / 2,\n                        end,\n                    ]\n\n            else:  # RendererType.CAIRO\n\n                def add_line_to(end):\n                    nonlocal closed_curve_points\n                    start = closed_curve_points[-1]\n                    closed_curve_points += [\n                        start,\n                        (start + start + end) / 3,\n                        (start + end + end) / 3,\n                        end,\n                    ]\n\n            for index, point in enumerate(points):\n                closed_curve_points.append(point)\n                if (\n                    index != len(points) - 1\n                    and (index + 1) % nppc == 0\n                    and any(point != points[index + 1])\n                ):\n                    # Add straight line from last point on this curve to the\n                    # start point on the next curve. We represent the line\n                    # as a cubic bezier curve where the two control points\n                    # are half-way between the start and stop point.\n                    add_line_to(curve_start)\n                    curve_start = points[index + 1]\n            # Make sure last curve is closed\n            add_line_to(curve_start)\n            each.points = np.array(closed_curve_points, ndmin=2)\n        # anti-aliasing\n        if height is None and width is None:\n            self.scale(TEXT_MOB_SCALE_FACTOR)\n        self.initial_height = self.height\n\n    def __repr__(self):\n        return f\"Text({repr(self.original_text)})\"\n\n    @property\n    def font_size(self):\n        return (\n            self.height\n            / self.initial_height\n            / TEXT_MOB_SCALE_FACTOR\n            * 2.4\n            * self._font_size\n            / DEFAULT_FONT_SIZE\n        )\n\n    @font_size.setter\n    def font_size(self, font_val):\n        # TODO: use pango's font size scaling.\n        if font_val <= 0:\n            raise ValueError(\"font_size must be greater than 0.\")\n        else:\n            self.scale(font_val / self.font_size)\n\n    def _gen_chars(self):\n        chars = self.get_group_class()()\n        submobjects_char_index = 0\n        for char_index in range(len(self.text)):\n            if self.text[char_index].isspace():\n                space = Dot(radius=0, fill_opacity=0, stroke_opacity=0)\n                if char_index == 0:\n                    space.move_to(self.submobjects[submobjects_char_index].get_center())\n                else:\n                    space.move_to(\n                        self.submobjects[submobjects_char_index - 1].get_center(),\n                    )\n                chars.add(space)\n            else:\n                chars.add(self.submobjects[submobjects_char_index])\n                submobjects_char_index += 1\n        return chars\n\n    def _find_indexes(self, word: str, text: str):\n        \"\"\"Finds the indexes of ``text`` in ``word``.\"\"\"\n        temp = re.match(r\"\\[([0-9\\-]{0,}):([0-9\\-]{0,})\\]\", word)\n        if temp:\n            start = int(temp.group(1)) if temp.group(1) != \"\" else 0\n            end = int(temp.group(2)) if temp.group(2) != \"\" else len(text)\n            start = len(text) + start if start < 0 else start\n            end = len(text) + end if end < 0 else end\n            return [(start, end)]\n        indexes = []\n        index = text.find(word)\n        while index != -1:\n            indexes.append((index, index + len(word)))\n            index = text.find(word, index + len(word))\n        return indexes\n\n    @deprecated(\n        since=\"v0.14.0\",\n        until=\"v0.15.0\",\n        message=\"This was internal function, you shouldn't be using it anyway.\",\n    )\n    def _set_color_by_t2c(self, t2c=None):\n        \"\"\"Sets color for specified strings.\"\"\"\n        t2c = t2c if t2c else self.t2c\n        for word, color in list(t2c.items()):\n            for start, end in self._find_indexes(word, self.text):\n                self.chars[start:end].set_color(color)\n\n    @deprecated(\n        since=\"v0.14.0\",\n        until=\"v0.15.0\",\n        message=\"This was internal function, you shouldn't be using it anyway.\",\n    )\n    def _set_color_by_t2g(self, t2g=None):\n        \"\"\"Sets gradient colors for specified\n        strings. Behaves similarly to ``set_color_by_t2c``.\n        \"\"\"\n        t2g = t2g if t2g else self.t2g\n        for word, gradient in list(t2g.items()):\n            for start, end in self._find_indexes(word, self.text):\n                self.chars[start:end].set_color_by_gradient(*gradient)\n\n    def _text2hash(self, color: ManimColor):\n        \"\"\"Generates ``sha256`` hash for file name.\"\"\"\n        settings = (\n            \"PANGO\" + self.font + self.slant + self.weight + str(color)\n        )  # to differentiate Text and CairoText\n        settings += str(self.t2f) + str(self.t2s) + str(self.t2w) + str(self.t2c)\n        settings += str(self.line_spacing) + str(self._font_size)\n        settings += str(self.disable_ligatures)\n        id_str = self.text + settings\n        hasher = hashlib.sha256()\n        hasher.update(id_str.encode())\n        return hasher.hexdigest()[:16]\n\n    def _merge_settings(\n        self,\n        left_setting: TextSetting,\n        right_setting: TextSetting,\n        default_args: dict[str, Iterable[str]],\n    ) -> TextSetting:\n        contained = right_setting.end < left_setting.end\n        new_setting = copy.copy(left_setting) if contained else copy.copy(right_setting)\n\n        new_setting.start = right_setting.end if contained else left_setting.end\n        left_setting.end = right_setting.start\n        if not contained:\n            right_setting.end = new_setting.start\n\n        for arg in default_args:\n            left = getattr(left_setting, arg)\n            right = getattr(right_setting, arg)\n            default = default_args[arg]\n            if left != default and getattr(right_setting, arg) != default:\n                raise ValueError(\n                    f\"Ambiguous style for text '{self.text[right_setting.start : right_setting.end]}':\"\n                    + f\"'{arg}' cannot be both '{left}' and '{right}'.\"\n                )\n            setattr(right_setting, arg, left if left != default else right)\n        return new_setting\n\n    def _get_settings_from_t2xs(\n        self,\n        t2xs: Sequence[tuple[dict[str, str], str]],\n        default_args: dict[str, Iterable[str]],\n    ) -> Sequence[TextSetting]:\n        settings = []\n        t2xwords = set(chain(*([*t2x.keys()] for t2x, _ in t2xs)))\n        for word in t2xwords:\n            setting_args = {\n                arg: str(t2x[word]) if word in t2x else default_args[arg]\n                # NOTE: when t2x[word] is a ManimColor, str will yield the\n                # hex representation\n                for t2x, arg in t2xs\n            }\n\n            for start, end in self._find_indexes(word, self.text):\n                settings.append(TextSetting(start, end, **setting_args))\n        return settings\n\n    def _get_settings_from_gradient(\n        self, default_args: dict[str, Iterable[str]]\n    ) -> Sequence[TextSetting]:\n        settings = []\n        args = copy.copy(default_args)\n        if self.gradient:\n            colors = color_gradient(self.gradient, len(self.text))\n            for i in range(len(self.text)):\n                args[\"color\"] = colors[i].to_hex()\n                settings.append(TextSetting(i, i + 1, **args))\n\n        for word, gradient in self.t2g.items():\n            if isinstance(gradient, str) or len(gradient) == 1:\n                color = gradient if isinstance(gradient, str) else gradient[0]\n                gradient = [ManimColor(color)]\n            colors = (\n                color_gradient(gradient, len(word))\n                if len(gradient) != 1\n                else len(word) * gradient\n            )\n            for start, end in self._find_indexes(word, self.text):\n                for i in range(start, end):\n                    args[\"color\"] = colors[i - start].to_hex()\n                    settings.append(TextSetting(i, i + 1, **args))\n        return settings\n\n    def _text2settings(self, color: str):\n        \"\"\"Converts the texts and styles to a setting for parsing.\"\"\"\n        t2xs = [\n            (self.t2f, \"font\"),\n            (self.t2s, \"slant\"),\n            (self.t2w, \"weight\"),\n            (self.t2c, \"color\"),\n        ]\n        # setting_args requires values to be strings\n\n        default_args = {\n            arg: getattr(self, arg) if arg != \"color\" else color for _, arg in t2xs\n        }\n\n        settings = self._get_settings_from_t2xs(t2xs, default_args)\n        settings.extend(self._get_settings_from_gradient(default_args))\n\n        # Handle overlaps\n\n        settings.sort(key=lambda setting: setting.start)\n        for index, setting in enumerate(settings):\n            if index + 1 == len(settings):\n                break\n\n            next_setting = settings[index + 1]\n            if setting.end > next_setting.start:\n                new_setting = self._merge_settings(setting, next_setting, default_args)\n                new_index = index + 1\n                while (\n                    new_index < len(settings)\n                    and settings[new_index].start < new_setting.start\n                ):\n                    new_index += 1\n                settings.insert(new_index, new_setting)\n\n        # Set all text settings (default font, slant, weight)\n        temp_settings = settings.copy()\n        start = 0\n        for setting in settings:\n            if setting.start != start:\n                temp_settings.append(TextSetting(start, setting.start, **default_args))\n            start = setting.end\n        if start != len(self.text):\n            temp_settings.append(TextSetting(start, len(self.text), **default_args))\n        settings = sorted(temp_settings, key=lambda setting: setting.start)\n\n        line_num = 0\n        if re.search(r\"\\n\", self.text):\n            for start, end in self._find_indexes(\"\\n\", self.text):\n                for setting in settings:\n                    if setting.line_num == -1:\n                        setting.line_num = line_num\n                    if start < setting.end:\n                        line_num += 1\n                        new_setting = copy.copy(setting)\n                        setting.end = end\n                        new_setting.start = end\n                        new_setting.line_num = line_num\n                        settings.append(new_setting)\n                        settings.sort(key=lambda setting: setting.start)\n                        break\n        for setting in settings:\n            if setting.line_num == -1:\n                setting.line_num = line_num\n\n        return settings\n\n    def _text2svg(self, color: ManimColor):\n        \"\"\"Convert the text to SVG using Pango.\"\"\"\n        size = self._font_size\n        line_spacing = self.line_spacing\n        size /= TEXT2SVG_ADJUSTMENT_FACTOR\n        line_spacing /= TEXT2SVG_ADJUSTMENT_FACTOR\n\n        dir_name = config.get_dir(\"text_dir\")\n        if not dir_name.is_dir():\n            dir_name.mkdir(parents=True)\n        hash_name = self._text2hash(color)\n        file_name = dir_name / (hash_name + \".svg\")\n\n        if file_name.exists():\n            svg_file = str(file_name.resolve())\n        else:\n            settings = self._text2settings(color)\n            width = config[\"pixel_width\"]\n            height = config[\"pixel_height\"]\n\n            svg_file = manimpango.text2svg(\n                settings,\n                size,\n                line_spacing,\n                self.disable_ligatures,\n                str(file_name.resolve()),\n                START_X,\n                START_Y,\n                width,\n                height,\n                self.text,\n            )\n\n        return svg_file\n\n    def init_colors(self, propagate_colors=True):\n        if config.renderer == RendererType.OPENGL:\n            super().init_colors()\n        elif config.renderer == RendererType.CAIRO:\n            super().init_colors(propagate_colors=propagate_colors)"}, {"name": "TexTemplate", "code": "class TexTemplate:\n    \"\"\"TeX templates are used to create ``Tex`` and ``MathTex`` objects.\"\"\"\n\n    _body: str = field(default=\"\", init=False)\n    \"\"\"A custom body, can be set from a file.\"\"\"\n\n    tex_compiler: str = \"latex\"\n    \"\"\"The TeX compiler to be used, e.g. ``latex``, ``pdflatex`` or ``lualatex``.\"\"\"\n\n    description: str = \"\"\n    \"\"\"A description of the template\"\"\"\n\n    output_format: str = \".dvi\"\n    \"\"\"The output format resulting from compilation, e.g. ``.dvi`` or ``.pdf``.\"\"\"\n\n    documentclass: str = r\"\\documentclass[preview]{standalone}\"\n    r\"\"\"The command defining the documentclass, e.g. ``\\documentclass[preview]{standalone}``.\"\"\"\n\n    preamble: str = _DEFAULT_PREAMBLE\n    r\"\"\"The document's preamble, i.e. the part between ``\\documentclass`` and ``\\begin{document}``.\"\"\"\n\n    placeholder_text: str = \"YourTextHere\"\n    \"\"\"Text in the document that will be replaced by the expression to be rendered.\"\"\"\n\n    post_doc_commands: str = \"\"\n    r\"\"\"Text (definitions, commands) to be inserted at right after ``\\begin{document}``, e.g. ``\\boldmath``.\"\"\"\n\n    @property\n    def body(self) -> str:\n        \"\"\"The entire TeX template.\"\"\"\n        return self._body or \"\\n\".join(\n            filter(\n                None,\n                [\n                    self.documentclass,\n                    self.preamble,\n                    _BEGIN_DOCUMENT,\n                    self.post_doc_commands,\n                    self.placeholder_text,\n                    _END_DOCUMENT,\n                ],\n            )\n        )\n\n    @body.setter\n    def body(self, value: str) -> None:\n        self._body = value\n\n    @classmethod\n    def from_file(cls, file: StrPath = \"tex_template.tex\", **kwargs: Any) -> Self:\n        \"\"\"Create an instance by reading the content of a file.\n\n        Using the ``add_to_preamble`` and ``add_to_document`` methods on this instance\n        will have no effect, as the body is read from the file.\n        \"\"\"\n        instance = cls(**kwargs)\n        instance.body = Path(file).read_text(encoding=\"utf-8\")\n        return instance\n\n    def add_to_preamble(self, txt: str, prepend: bool = False) -> Self:\n        r\"\"\"Adds text to the TeX template's preamble (e.g. definitions, packages). Text can be inserted at the beginning or at the end of the preamble.\n\n        Parameters\n        ----------\n        txt\n            String containing the text to be added, e.g. ``\\usepackage{hyperref}``.\n        prepend\n            Whether the text should be added at the beginning of the preamble, i.e. right after ``\\documentclass``.\n            Default is to add it at the end of the preamble, i.e. right before ``\\begin{document}``.\n        \"\"\"\n        if self._body:\n            warnings.warn(\n                \"This TeX template was created with a fixed body, trying to add text the preamble will have no effect.\",\n                UserWarning,\n                stacklevel=2,\n            )\n        if prepend:\n            self.preamble = txt + \"\\n\" + self.preamble\n        else:\n            self.preamble += \"\\n\" + txt\n        return self\n\n    def add_to_document(self, txt: str) -> Self:\n        r\"\"\"Adds text to the TeX template just after \\begin{document}, e.g. ``\\boldmath``.\n\n        Parameters\n        ----------\n        txt\n            String containing the text to be added.\n        \"\"\"\n        if self._body:\n            warnings.warn(\n                \"This TeX template was created with a fixed body, trying to add text the document will have no effect.\",\n                UserWarning,\n                stacklevel=2,\n            )\n        self.post_doc_commands += txt\n        return self\n\n    def get_texcode_for_expression(self, expression: str) -> str:\n        r\"\"\"Inserts expression verbatim into TeX template.\n\n        Parameters\n        ----------\n        expression\n            The string containing the expression to be typeset, e.g. ``$\\sqrt{2}$``\n\n        Returns\n        -------\n        :class:`str`\n            LaTeX code based on current template, containing the given ``expression`` and ready for typesetting\n        \"\"\"\n        return self.body.replace(self.placeholder_text, expression)\n\n    def get_texcode_for_expression_in_env(\n        self, expression: str, environment: str\n    ) -> str:\n        r\"\"\"Inserts expression into TeX template wrapped in ``\\begin{environment}`` and ``\\end{environment}``.\n\n        Parameters\n        ----------\n        expression\n            The string containing the expression to be typeset, e.g. ``$\\sqrt{2}$``.\n        environment\n            The string containing the environment in which the expression should be typeset, e.g. ``align*``.\n\n        Returns\n        -------\n        :class:`str`\n            LaTeX code based on template, containing the given expression inside its environment, ready for typesetting\n        \"\"\"\n        begin, end = _texcode_for_environment(environment)\n        return self.body.replace(\n            self.placeholder_text, \"\\n\".join([begin, expression, end])\n        )\n\n    def copy(self) -> Self:\n        \"\"\"Create a deep copy of the TeX template instance.\"\"\"\n        return copy.deepcopy(self)"}, {"name": "TexTemplateLibrary", "code": "class TexTemplateLibrary:\n    \"\"\"\n    A collection of basic TeX template objects\n\n    Examples\n    --------\n    Normal usage as a value for the keyword argument tex_template of Tex() and MathTex() mobjects::\n\n        ``Tex(\"My TeX code\", tex_template=TexTemplateLibrary.ctex)``\n\n    \"\"\"\n\n    default = TexTemplate(preamble=_3b1b_preamble)\n    \"\"\"An instance of the default TeX template in manim\"\"\"\n\n    threeb1b = TexTemplate(preamble=_3b1b_preamble)\n    \"\"\" An instance of the default TeX template used by 3b1b \"\"\"\n\n    ctex = TexTemplate(\n        tex_compiler=\"xelatex\",\n        output_format=\".xdv\",\n        preamble=_3b1b_preamble.replace(\n            r\"\\DisableLigatures{encoding = *, family = * }\",\n            r\"\\usepackage[UTF8]{ctex}\",\n        ),\n    )\n    \"\"\"An instance of the TeX template used by 3b1b when using the use_ctex flag\"\"\"\n\n    simple = _new_ams_template()\n    \"\"\"An instance of a simple TeX template with only basic AMS packages loaded\"\"\""}, {"name": "there_and_back", "code": "def there_and_back(t: float, inflection: float = 10.0) -> float:\n    new_t = 2 * t if t < 0.5 else 2 * (1 - t)\n    return smooth(new_t, inflection)"}, {"name": "there_and_back_with_pause", "code": "def there_and_back_with_pause(t: float, pause_ratio: float = 1.0 / 3) -> float:\n    a = 2.0 / (1.0 - pause_ratio)\n    if t < 0.5 - pause_ratio / 2:\n        return smooth(a * t)\n    elif t < 0.5 + pause_ratio / 2:\n        return 1\n    else:\n        return smooth(a - a * t)"}, {"name": "thick_diagonal", "code": "def thick_diagonal(dim: int, thickness: int = 2) -> MatrixMN:\n    row_indices = np.arange(dim).repeat(dim).reshape((dim, dim))\n    col_indices = np.transpose(row_indices)\n    return (np.abs(row_indices - col_indices) < thickness).astype(\"uint8\")"}, {"name": "ThreeDAxes", "code": "class ThreeDAxes(Axes):\n    \"\"\"A 3-dimensional set of axes.\n\n    Parameters\n    ----------\n    x_range\n        The ``[x_min, x_max, x_step]`` values of the x-axis.\n    y_range\n        The ``[y_min, y_max, y_step]`` values of the y-axis.\n    z_range\n        The ``[z_min, z_max, z_step]`` values of the z-axis.\n    x_length\n        The length of the x-axis.\n    y_length\n        The length of the y-axis.\n    z_length\n        The length of the z-axis.\n    z_axis_config\n        Arguments to be passed to :class:`~.NumberLine` that influence the z-axis.\n    z_normal\n        The direction of the normal.\n    num_axis_pieces\n        The number of pieces used to construct the axes.\n    light_source\n        The direction of the light source.\n    depth\n        Currently non-functional.\n    gloss\n        Currently non-functional.\n    kwargs\n        Additional arguments to be passed to :class:`Axes`.\n    \"\"\"\n\n    def __init__(\n        self,\n        x_range: Sequence[float] | None = (-6, 6, 1),\n        y_range: Sequence[float] | None = (-5, 5, 1),\n        z_range: Sequence[float] | None = (-4, 4, 1),\n        x_length: float | None = config.frame_height + 2.5,\n        y_length: float | None = config.frame_height + 2.5,\n        z_length: float | None = config.frame_height - 1.5,\n        z_axis_config: dict[str, Any] | None = None,\n        z_normal: Vector3D = DOWN,\n        num_axis_pieces: int = 20,\n        light_source: Sequence[float] = 9 * DOWN + 7 * LEFT + 10 * OUT,\n        # opengl stuff (?)\n        depth=None,\n        gloss=0.5,\n        **kwargs: dict[str, Any],\n    ) -> None:\n        super().__init__(\n            x_range=x_range,\n            x_length=x_length,\n            y_range=y_range,\n            y_length=y_length,\n            **kwargs,\n        )\n\n        self.z_range = z_range\n        self.z_length = z_length\n\n        self.z_axis_config = {}\n        self._update_default_configs((self.z_axis_config,), (z_axis_config,))\n        self.z_axis_config = merge_dicts_recursively(\n            self.axis_config,\n            self.z_axis_config,\n        )\n\n        self.z_normal = z_normal\n        self.num_axis_pieces = num_axis_pieces\n\n        self.light_source = light_source\n\n        self.dimension = 3\n\n        if self.z_axis_config.get(\"scaling\") is None or isinstance(\n            self.z_axis_config.get(\"scaling\"), LinearBase\n        ):\n            self.z_axis_config[\"exclude_origin_tick\"] = True\n        else:\n            self.z_axis_config[\"exclude_origin_tick\"] = False\n\n        z_axis = self._create_axis(self.z_range, self.z_axis_config, self.z_length)\n\n        # [ax.x_min, ax.x_max] used to account for LogBase() scaling\n        # where ax.x_range[0] != ax.x_min\n        z_origin = self._origin_shift([z_axis.x_min, z_axis.x_max])\n\n        z_axis.rotate_about_number(z_origin, -PI / 2, UP)\n        z_axis.rotate_about_number(z_origin, angle_of_vector(self.z_normal))\n        z_axis.shift(-z_axis.number_to_point(z_origin))\n        z_axis.shift(\n            self.x_axis.number_to_point(\n                self._origin_shift([self.x_axis.x_min, self.x_axis.x_max]),\n            ),\n        )\n\n        self.axes.add(z_axis)\n        self.add(z_axis)\n        self.z_axis = z_axis\n\n        if config.renderer == RendererType.CAIRO:\n            self._add_3d_pieces()\n            self._set_axis_shading()\n\n    def _add_3d_pieces(self) -> None:\n        for axis in self.axes:\n            axis.pieces = VGroup(*axis.get_pieces(self.num_axis_pieces))\n            axis.add(axis.pieces)\n            axis.set_stroke(width=0, family=False)\n            axis.set_shade_in_3d(True)\n\n    def _set_axis_shading(self) -> None:\n        def make_func(axis):\n            vect = self.light_source\n            return lambda: (\n                axis.get_edge_center(-vect),\n                axis.get_edge_center(vect),\n            )\n\n        for axis in self:\n            for submob in axis.family_members_with_points():\n                submob.get_gradient_start_and_end_points = make_func(axis)\n                submob.get_unit_normal = lambda a: np.ones(3)\n                submob.set_sheen(0.2)\n\n    def get_y_axis_label(\n        self,\n        label: float | str | Mobject,\n        edge: Sequence[float] = UR,\n        direction: Sequence[float] = UR,\n        buff: float = SMALL_BUFF,\n        rotation: float = PI / 2,\n        rotation_axis: Vector3D = OUT,\n        **kwargs,\n    ) -> Mobject:\n        \"\"\"Generate a y-axis label.\n\n        Parameters\n        ----------\n        label\n            The label. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n        edge\n            The edge of the y-axis to which the label will be added, by default ``UR``.\n        direction\n            Allows for further positioning of the label from an edge, by default ``UR``.\n        buff\n            The distance of the label from the line, by default ``SMALL_BUFF``.\n        rotation\n            The angle at which to rotate the label, by default ``PI/2``.\n        rotation_axis\n            The axis about which to rotate the label, by default ``OUT``.\n\n        Returns\n        -------\n        :class:`~.Mobject`\n            The positioned label.\n\n        Examples\n        --------\n        .. manim:: GetYAxisLabelExample\n            :save_last_frame:\n\n            class GetYAxisLabelExample(ThreeDScene):\n                def construct(self):\n                    ax = ThreeDAxes()\n                    lab = ax.get_y_axis_label(Tex(\"$y$-label\"))\n                    self.set_camera_orientation(phi=2*PI/5, theta=PI/5)\n                    self.add(ax, lab)\n        \"\"\"\n        positioned_label = self._get_axis_label(\n            label, self.get_y_axis(), edge, direction, buff=buff, **kwargs\n        )\n        positioned_label.rotate(rotation, axis=rotation_axis)\n        return positioned_label\n\n    def get_z_axis_label(\n        self,\n        label: float | str | Mobject,\n        edge: Vector3D = OUT,\n        direction: Vector3D = RIGHT,\n        buff: float = SMALL_BUFF,\n        rotation: float = PI / 2,\n        rotation_axis: Vector3D = RIGHT,\n        **kwargs: Any,\n    ) -> Mobject:\n        \"\"\"Generate a z-axis label.\n\n        Parameters\n        ----------\n        label\n            The label. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n        edge\n            The edge of the z-axis to which the label will be added, by default ``OUT``.\n        direction\n            Allows for further positioning of the label from an edge, by default ``RIGHT``.\n        buff\n            The distance of the label from the line, by default ``SMALL_BUFF``.\n        rotation\n            The angle at which to rotate the label, by default ``PI/2``.\n        rotation_axis\n            The axis about which to rotate the label, by default ``RIGHT``.\n\n        Returns\n        -------\n        :class:`~.Mobject`\n            The positioned label.\n\n        Examples\n        --------\n        .. manim:: GetZAxisLabelExample\n            :save_last_frame:\n\n            class GetZAxisLabelExample(ThreeDScene):\n                def construct(self):\n                    ax = ThreeDAxes()\n                    lab = ax.get_z_axis_label(Tex(\"$z$-label\"))\n                    self.set_camera_orientation(phi=2*PI/5, theta=PI/5)\n                    self.add(ax, lab)\n        \"\"\"\n        positioned_label = self._get_axis_label(\n            label, self.get_z_axis(), edge, direction, buff=buff, **kwargs\n        )\n        positioned_label.rotate(rotation, axis=rotation_axis)\n        return positioned_label\n\n    def get_axis_labels(\n        self,\n        x_label: float | str | Mobject = \"x\",\n        y_label: float | str | Mobject = \"y\",\n        z_label: float | str | Mobject = \"z\",\n    ) -> VGroup:\n        \"\"\"Defines labels for the x_axis and y_axis of the graph.\n\n        For increased control over the position of the labels,\n        use :meth:`~.CoordinateSystem.get_x_axis_label`,\n        :meth:`~.ThreeDAxes.get_y_axis_label`, and\n        :meth:`~.ThreeDAxes.get_z_axis_label`.\n\n        Parameters\n        ----------\n        x_label\n            The label for the x_axis. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n        y_label\n            The label for the y_axis. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n        z_label\n            The label for the z_axis. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.\n\n        Returns\n        -------\n        :class:`~.VGroup`\n            A :class:`~.VGroup` of the labels for the x_axis, y_axis, and z_axis.\n\n\n        .. seealso::\n            :meth:`~.CoordinateSystem.get_x_axis_label`\n            :meth:`~.ThreeDAxes.get_y_axis_label`\n            :meth:`~.ThreeDAxes.get_z_axis_label`\n\n        Examples\n        --------\n        .. manim:: GetAxisLabelsExample\n            :save_last_frame:\n\n            class GetAxisLabelsExample(ThreeDScene):\n                def construct(self):\n                    self.set_camera_orientation(phi=2*PI/5, theta=PI/5)\n                    axes = ThreeDAxes()\n                    labels = axes.get_axis_labels(\n                        Text(\"x-axis\").scale(0.7), Text(\"y-axis\").scale(0.45), Text(\"z-axis\").scale(0.45)\n                    )\n                    self.add(axes, labels)\n        \"\"\"\n        self.axis_labels = VGroup(\n            self.get_x_axis_label(x_label),\n            self.get_y_axis_label(y_label),\n            self.get_z_axis_label(z_label),\n        )\n        return self.axis_labels"}, {"name": "ThreeDCamera", "code": "class ThreeDCamera(Camera):\n    def __init__(\n        self,\n        focal_distance=20.0,\n        shading_factor=0.2,\n        default_distance=5.0,\n        light_source_start_point=9 * DOWN + 7 * LEFT + 10 * OUT,\n        should_apply_shading=True,\n        exponential_projection=False,\n        phi=0,\n        theta=-90 * DEGREES,\n        gamma=0,\n        zoom=1,\n        **kwargs,\n    ):\n        \"\"\"Initializes the ThreeDCamera\n\n        Parameters\n        ----------\n        *kwargs\n            Any keyword argument of Camera.\n        \"\"\"\n        self._frame_center = Point(kwargs.get(\"frame_center\", ORIGIN), stroke_width=0)\n        super().__init__(**kwargs)\n        self.focal_distance = focal_distance\n        self.phi = phi\n        self.theta = theta\n        self.gamma = gamma\n        self.zoom = zoom\n        self.shading_factor = shading_factor\n        self.default_distance = default_distance\n        self.light_source_start_point = light_source_start_point\n        self.light_source = Point(self.light_source_start_point)\n        self.should_apply_shading = should_apply_shading\n        self.exponential_projection = exponential_projection\n        self.max_allowable_norm = 3 * config[\"frame_width\"]\n        self.phi_tracker = ValueTracker(self.phi)\n        self.theta_tracker = ValueTracker(self.theta)\n        self.focal_distance_tracker = ValueTracker(self.focal_distance)\n        self.gamma_tracker = ValueTracker(self.gamma)\n        self.zoom_tracker = ValueTracker(self.zoom)\n        self.fixed_orientation_mobjects = {}\n        self.fixed_in_frame_mobjects = set()\n        self.reset_rotation_matrix()\n\n    @property\n    def frame_center(self):\n        return self._frame_center.points[0]\n\n    @frame_center.setter\n    def frame_center(self, point):\n        self._frame_center.move_to(point)\n\n    def capture_mobjects(self, mobjects, **kwargs):\n        self.reset_rotation_matrix()\n        super().capture_mobjects(mobjects, **kwargs)\n\n    def get_value_trackers(self):\n        \"\"\"A list of :class:`ValueTrackers <.ValueTracker>` of phi, theta, focal_distance,\n        gamma and zoom.\n\n        Returns\n        -------\n        list\n            list of ValueTracker objects\n        \"\"\"\n        return [\n            self.phi_tracker,\n            self.theta_tracker,\n            self.focal_distance_tracker,\n            self.gamma_tracker,\n            self.zoom_tracker,\n        ]\n\n    def modified_rgbas(self, vmobject, rgbas):\n        if not self.should_apply_shading:\n            return rgbas\n        if vmobject.shade_in_3d and (vmobject.get_num_points() > 0):\n            light_source_point = self.light_source.points[0]\n            if len(rgbas) < 2:\n                shaded_rgbas = rgbas.repeat(2, axis=0)\n            else:\n                shaded_rgbas = np.array(rgbas[:2])\n            shaded_rgbas[0, :3] = get_shaded_rgb(\n                shaded_rgbas[0, :3],\n                get_3d_vmob_start_corner(vmobject),\n                get_3d_vmob_start_corner_unit_normal(vmobject),\n                light_source_point,\n            )\n            shaded_rgbas[1, :3] = get_shaded_rgb(\n                shaded_rgbas[1, :3],\n                get_3d_vmob_end_corner(vmobject),\n                get_3d_vmob_end_corner_unit_normal(vmobject),\n                light_source_point,\n            )\n            return shaded_rgbas\n        return rgbas\n\n    def get_stroke_rgbas(\n        self,\n        vmobject,\n        background=False,\n    ):  # NOTE : DocStrings From parent\n        return self.modified_rgbas(vmobject, vmobject.get_stroke_rgbas(background))\n\n    def get_fill_rgbas(self, vmobject):  # NOTE : DocStrings From parent\n        return self.modified_rgbas(vmobject, vmobject.get_fill_rgbas())\n\n    def get_mobjects_to_display(self, *args, **kwargs):  # NOTE : DocStrings From parent\n        mobjects = super().get_mobjects_to_display(*args, **kwargs)\n        rot_matrix = self.get_rotation_matrix()\n\n        def z_key(mob):\n            if not (hasattr(mob, \"shade_in_3d\") and mob.shade_in_3d):\n                return np.inf\n            # Assign a number to a three dimensional mobjects\n            # based on how close it is to the camera\n            return np.dot(mob.get_z_index_reference_point(), rot_matrix.T)[2]\n\n        return sorted(mobjects, key=z_key)\n\n    def get_phi(self):\n        \"\"\"Returns the Polar angle (the angle off Z_AXIS) phi.\n\n        Returns\n        -------\n        float\n            The Polar angle in radians.\n        \"\"\"\n        return self.phi_tracker.get_value()\n\n    def get_theta(self):\n        \"\"\"Returns the Azimuthal i.e the angle that spins the camera around the Z_AXIS.\n\n        Returns\n        -------\n        float\n            The Azimuthal angle in radians.\n        \"\"\"\n        return self.theta_tracker.get_value()\n\n    def get_focal_distance(self):\n        \"\"\"Returns focal_distance of the Camera.\n\n        Returns\n        -------\n        float\n            The focal_distance of the Camera in MUnits.\n        \"\"\"\n        return self.focal_distance_tracker.get_value()\n\n    def get_gamma(self):\n        \"\"\"Returns the rotation of the camera about the vector from the ORIGIN to the Camera.\n\n        Returns\n        -------\n        float\n            The angle of rotation of the camera about the vector\n            from the ORIGIN to the Camera in radians\n        \"\"\"\n        return self.gamma_tracker.get_value()\n\n    def get_zoom(self):\n        \"\"\"Returns the zoom amount of the camera.\n\n        Returns\n        -------\n        float\n            The zoom amount of the camera.\n        \"\"\"\n        return self.zoom_tracker.get_value()\n\n    def set_phi(self, value: float):\n        \"\"\"Sets the polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians.\n\n        Parameters\n        ----------\n        value\n            The new value of the polar angle in radians.\n        \"\"\"\n        self.phi_tracker.set_value(value)\n\n    def set_theta(self, value: float):\n        \"\"\"Sets the azimuthal angle i.e the angle that spins the camera around Z_AXIS in radians.\n\n        Parameters\n        ----------\n        value\n            The new value of the azimuthal angle in radians.\n        \"\"\"\n        self.theta_tracker.set_value(value)\n\n    def set_focal_distance(self, value: float):\n        \"\"\"Sets the focal_distance of the Camera.\n\n        Parameters\n        ----------\n        value\n            The focal_distance of the Camera.\n        \"\"\"\n        self.focal_distance_tracker.set_value(value)\n\n    def set_gamma(self, value: float):\n        \"\"\"Sets the angle of rotation of the camera about the vector from the ORIGIN to the Camera.\n\n        Parameters\n        ----------\n        value\n            The new angle of rotation of the camera.\n        \"\"\"\n        self.gamma_tracker.set_value(value)\n\n    def set_zoom(self, value: float):\n        \"\"\"Sets the zoom amount of the camera.\n\n        Parameters\n        ----------\n        value\n            The zoom amount of the camera.\n        \"\"\"\n        self.zoom_tracker.set_value(value)\n\n    def reset_rotation_matrix(self):\n        \"\"\"Sets the value of self.rotation_matrix to\n        the matrix corresponding to the current position of the camera\n        \"\"\"\n        self.rotation_matrix = self.generate_rotation_matrix()\n\n    def get_rotation_matrix(self):\n        \"\"\"Returns the matrix corresponding to the current position of the camera.\n\n        Returns\n        -------\n        np.array\n            The matrix corresponding to the current position of the camera.\n        \"\"\"\n        return self.rotation_matrix\n\n    def generate_rotation_matrix(self):\n        \"\"\"Generates a rotation matrix based off the current position of the camera.\n\n        Returns\n        -------\n        np.array\n            The matrix corresponding to the current position of the camera.\n        \"\"\"\n        phi = self.get_phi()\n        theta = self.get_theta()\n        gamma = self.get_gamma()\n        matrices = [\n            rotation_about_z(-theta - 90 * DEGREES),\n            rotation_matrix(-phi, RIGHT),\n            rotation_about_z(gamma),\n        ]\n        result = np.identity(3)\n        for matrix in matrices:\n            result = np.dot(matrix, result)\n        return result\n\n    def project_points(self, points: np.ndarray | list):\n        \"\"\"Applies the current rotation_matrix as a projection\n        matrix to the passed array of points.\n\n        Parameters\n        ----------\n        points\n            The list of points to project.\n\n        Returns\n        -------\n        np.array\n            The points after projecting.\n        \"\"\"\n        frame_center = self.frame_center\n        focal_distance = self.get_focal_distance()\n        zoom = self.get_zoom()\n        rot_matrix = self.get_rotation_matrix()\n\n        points = points - frame_center\n        points = np.dot(points, rot_matrix.T)\n        zs = points[:, 2]\n        for i in 0, 1:\n            if self.exponential_projection:\n                # Proper projection would involve multiplying\n                # x and y by d / (d-z).  But for points with high\n                # z value that causes weird artifacts, and applying\n                # the exponential helps smooth it out.\n                factor = np.exp(zs / focal_distance)\n                lt0 = zs < 0\n                factor[lt0] = focal_distance / (focal_distance - zs[lt0])\n            else:\n                factor = focal_distance / (focal_distance - zs)\n                factor[(focal_distance - zs) < 0] = 10**6\n            points[:, i] *= factor * zoom\n        return points\n\n    def project_point(self, point: list | np.ndarray):\n        \"\"\"Applies the current rotation_matrix as a projection\n        matrix to the passed point.\n\n        Parameters\n        ----------\n        point\n            The point to project.\n\n        Returns\n        -------\n        np.array\n            The point after projection.\n        \"\"\"\n        return self.project_points(point.reshape((1, 3)))[0, :]\n\n    def transform_points_pre_display(\n        self,\n        mobject,\n        points,\n    ):  # TODO: Write Docstrings for this Method.\n        points = super().transform_points_pre_display(mobject, points)\n        fixed_orientation = mobject in self.fixed_orientation_mobjects\n        fixed_in_frame = mobject in self.fixed_in_frame_mobjects\n\n        if fixed_in_frame:\n            return points\n        if fixed_orientation:\n            center_func = self.fixed_orientation_mobjects[mobject]\n            center = center_func()\n            new_center = self.project_point(center)\n            return points + (new_center - center)\n        else:\n            return self.project_points(points)\n\n    def add_fixed_orientation_mobjects(\n        self,\n        *mobjects: Mobject,\n        use_static_center_func: bool = False,\n        center_func: Callable[[], np.ndarray] | None = None,\n    ):\n        \"\"\"This method allows the mobject to have a fixed orientation,\n        even when the camera moves around.\n        E.G If it was passed through this method, facing the camera, it\n        will continue to face the camera even as the camera moves.\n        Highly useful when adding labels to graphs and the like.\n\n        Parameters\n        ----------\n        *mobjects\n            The mobject whose orientation must be fixed.\n        use_static_center_func\n            Whether or not to use the function that takes the mobject's\n            center as centerpoint, by default False\n        center_func\n            The function which returns the centerpoint\n            with respect to which the mobject will be oriented, by default None\n        \"\"\"\n\n        # This prevents the computation of mobject.get_center\n        # every single time a projection happens\n        def get_static_center_func(mobject):\n            point = mobject.get_center()\n            return lambda: point\n\n        for mobject in mobjects:\n            if center_func:\n                func = center_func\n            elif use_static_center_func:\n                func = get_static_center_func(mobject)\n            else:\n                func = mobject.get_center\n            for submob in mobject.get_family():\n                self.fixed_orientation_mobjects[submob] = func\n\n    def add_fixed_in_frame_mobjects(self, *mobjects: Mobject):\n        \"\"\"This method allows the mobject to have a fixed position,\n        even when the camera moves around.\n        E.G If it was passed through this method, at the top of the frame, it\n        will continue to be displayed at the top of the frame.\n\n        Highly useful when displaying Titles or formulae or the like.\n\n        Parameters\n        ----------\n        **mobjects\n            The mobject to fix in frame.\n        \"\"\"\n        for mobject in extract_mobject_family_members(mobjects):\n            self.fixed_in_frame_mobjects.add(mobject)\n\n    def remove_fixed_orientation_mobjects(self, *mobjects: Mobject):\n        \"\"\"If a mobject was fixed in its orientation by passing it through\n        :meth:`.add_fixed_orientation_mobjects`, then this undoes that fixing.\n        The Mobject will no longer have a fixed orientation.\n\n        Parameters\n        ----------\n        mobjects\n            The mobjects whose orientation need not be fixed any longer.\n        \"\"\"\n        for mobject in extract_mobject_family_members(mobjects):\n            if mobject in self.fixed_orientation_mobjects:\n                del self.fixed_orientation_mobjects[mobject]\n\n    def remove_fixed_in_frame_mobjects(self, *mobjects: Mobject):\n        \"\"\"If a mobject was fixed in frame by passing it through\n        :meth:`.add_fixed_in_frame_mobjects`, then this undoes that fixing.\n        The Mobject will no longer be fixed in frame.\n\n        Parameters\n        ----------\n        mobjects\n            The mobjects which need not be fixed in frame any longer.\n        \"\"\"\n        for mobject in extract_mobject_family_members(mobjects):\n            if mobject in self.fixed_in_frame_mobjects:\n                self.fixed_in_frame_mobjects.remove(mobject)"}, {"name": "ThreeDScene", "code": "class ThreeDScene(Scene):\n    \"\"\"\n    This is a Scene, with special configurations and properties that\n    make it suitable for Three Dimensional Scenes.\n    \"\"\"\n\n    def __init__(\n        self,\n        camera_class=ThreeDCamera,\n        ambient_camera_rotation=None,\n        default_angled_camera_orientation_kwargs=None,\n        **kwargs,\n    ):\n        self.ambient_camera_rotation = ambient_camera_rotation\n        if default_angled_camera_orientation_kwargs is None:\n            default_angled_camera_orientation_kwargs = {\n                \"phi\": 70 * DEGREES,\n                \"theta\": -135 * DEGREES,\n            }\n        self.default_angled_camera_orientation_kwargs = (\n            default_angled_camera_orientation_kwargs\n        )\n        super().__init__(camera_class=camera_class, **kwargs)\n\n    def set_camera_orientation(\n        self,\n        phi: float | None = None,\n        theta: float | None = None,\n        gamma: float | None = None,\n        zoom: float | None = None,\n        focal_distance: float | None = None,\n        frame_center: Mobject | Sequence[float] | None = None,\n        **kwargs,\n    ):\n        \"\"\"\n        This method sets the orientation of the camera in the scene.\n\n        Parameters\n        ----------\n        phi\n            The polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians.\n\n        theta\n            The azimuthal angle i.e the angle that spins the camera around the Z_AXIS.\n\n        focal_distance\n            The focal_distance of the Camera.\n\n        gamma\n            The rotation of the camera about the vector from the ORIGIN to the Camera.\n\n        zoom\n            The zoom factor of the scene.\n\n        frame_center\n            The new center of the camera frame in cartesian coordinates.\n\n        \"\"\"\n        if phi is not None:\n            self.renderer.camera.set_phi(phi)\n        if theta is not None:\n            self.renderer.camera.set_theta(theta)\n        if focal_distance is not None:\n            self.renderer.camera.set_focal_distance(focal_distance)\n        if gamma is not None:\n            self.renderer.camera.set_gamma(gamma)\n        if zoom is not None:\n            self.renderer.camera.set_zoom(zoom)\n        if frame_center is not None:\n            self.renderer.camera._frame_center.move_to(frame_center)\n\n    def begin_ambient_camera_rotation(self, rate: float = 0.02, about: str = \"theta\"):\n        \"\"\"\n        This method begins an ambient rotation of the camera about the Z_AXIS,\n        in the anticlockwise direction\n\n        Parameters\n        ----------\n        rate\n            The rate at which the camera should rotate about the Z_AXIS.\n            Negative rate means clockwise rotation.\n        about\n            one of 3 options: [\"theta\", \"phi\", \"gamma\"]. defaults to theta.\n        \"\"\"\n        # TODO, use a ValueTracker for rate, so that it\n        # can begin and end smoothly\n        about: str = about.lower()\n        try:\n            if config.renderer == RendererType.CAIRO:\n                trackers = {\n                    \"theta\": self.camera.theta_tracker,\n                    \"phi\": self.camera.phi_tracker,\n                    \"gamma\": self.camera.gamma_tracker,\n                }\n                x: ValueTracker = trackers[about]\n                x.add_updater(lambda m, dt: x.increment_value(rate * dt))\n                self.add(x)\n            elif config.renderer == RendererType.OPENGL:\n                cam: OpenGLCamera = self.camera\n                methods = {\n                    \"theta\": cam.increment_theta,\n                    \"phi\": cam.increment_phi,\n                    \"gamma\": cam.increment_gamma,\n                }\n                cam.add_updater(lambda m, dt: methods[about](rate * dt))\n                self.add(self.camera)\n        except Exception as e:\n            raise ValueError(\"Invalid ambient rotation angle.\") from e\n\n    def stop_ambient_camera_rotation(self, about=\"theta\"):\n        \"\"\"This method stops all ambient camera rotation.\"\"\"\n        about: str = about.lower()\n        try:\n            if config.renderer == RendererType.CAIRO:\n                trackers = {\n                    \"theta\": self.camera.theta_tracker,\n                    \"phi\": self.camera.phi_tracker,\n                    \"gamma\": self.camera.gamma_tracker,\n                }\n                x: ValueTracker = trackers[about]\n                x.clear_updaters()\n                self.remove(x)\n            elif config.renderer == RendererType.OPENGL:\n                self.camera.clear_updaters()\n        except Exception as e:\n            raise ValueError(\"Invalid ambient rotation angle.\") from e\n\n    def begin_3dillusion_camera_rotation(\n        self,\n        rate: float = 1,\n        origin_phi: float | None = None,\n        origin_theta: float | None = None,\n    ):\n        \"\"\"\n        This method creates a 3D camera rotation illusion around\n        the current camera orientation.\n\n        Parameters\n        ----------\n        rate\n            The rate at which the camera rotation illusion should operate.\n        origin_phi\n            The polar angle the camera should move around. Defaults\n            to the current phi angle.\n        origin_theta\n            The azimutal angle the camera should move around. Defaults\n            to the current theta angle.\n        \"\"\"\n        if origin_theta is None:\n            origin_theta = self.renderer.camera.theta_tracker.get_value()\n        if origin_phi is None:\n            origin_phi = self.renderer.camera.phi_tracker.get_value()\n\n        val_tracker_theta = ValueTracker(0)\n\n        def update_theta(m, dt):\n            val_tracker_theta.increment_value(dt * rate)\n            val_for_left_right = 0.2 * np.sin(val_tracker_theta.get_value())\n            return m.set_value(origin_theta + val_for_left_right)\n\n        self.renderer.camera.theta_tracker.add_updater(update_theta)\n        self.add(self.renderer.camera.theta_tracker)\n\n        val_tracker_phi = ValueTracker(0)\n\n        def update_phi(m, dt):\n            val_tracker_phi.increment_value(dt * rate)\n            val_for_up_down = 0.1 * np.cos(val_tracker_phi.get_value()) - 0.1\n            return m.set_value(origin_phi + val_for_up_down)\n\n        self.renderer.camera.phi_tracker.add_updater(update_phi)\n        self.add(self.renderer.camera.phi_tracker)\n\n    def stop_3dillusion_camera_rotation(self):\n        \"\"\"This method stops all illusion camera rotations.\"\"\"\n        self.renderer.camera.theta_tracker.clear_updaters()\n        self.remove(self.renderer.camera.theta_tracker)\n        self.renderer.camera.phi_tracker.clear_updaters()\n        self.remove(self.renderer.camera.phi_tracker)\n\n    def move_camera(\n        self,\n        phi: float | None = None,\n        theta: float | None = None,\n        gamma: float | None = None,\n        zoom: float | None = None,\n        focal_distance: float | None = None,\n        frame_center: Mobject | Sequence[float] | None = None,\n        added_anims: Iterable[Animation] = [],\n        **kwargs,\n    ):\n        \"\"\"\n        This method animates the movement of the camera\n        to the given spherical coordinates.\n\n        Parameters\n        ----------\n        phi\n            The polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians.\n\n        theta\n            The azimuthal angle i.e the angle that spins the camera around the Z_AXIS.\n\n        focal_distance\n            The radial focal_distance between ORIGIN and Camera.\n\n        gamma\n            The rotation of the camera about the vector from the ORIGIN to the Camera.\n\n        zoom\n            The zoom factor of the camera.\n\n        frame_center\n            The new center of the camera frame in cartesian coordinates.\n\n        added_anims\n            Any other animations to be played at the same time.\n\n        \"\"\"\n        anims = []\n\n        if config.renderer == RendererType.CAIRO:\n            self.camera: ThreeDCamera\n            value_tracker_pairs = [\n                (phi, self.camera.phi_tracker),\n                (theta, self.camera.theta_tracker),\n                (focal_distance, self.camera.focal_distance_tracker),\n                (gamma, self.camera.gamma_tracker),\n                (zoom, self.camera.zoom_tracker),\n            ]\n            for value, tracker in value_tracker_pairs:\n                if value is not None:\n                    anims.append(tracker.animate.set_value(value))\n            if frame_center is not None:\n                anims.append(self.camera._frame_center.animate.move_to(frame_center))\n        elif config.renderer == RendererType.OPENGL:\n            cam: OpenGLCamera = self.camera\n            cam2 = cam.copy()\n            methods = {\n                \"theta\": cam2.set_theta,\n                \"phi\": cam2.set_phi,\n                \"gamma\": cam2.set_gamma,\n                \"zoom\": cam2.scale,\n                \"frame_center\": cam2.move_to,\n            }\n            if frame_center is not None:\n                if isinstance(frame_center, OpenGLMobject):\n                    frame_center = frame_center.get_center()\n                frame_center = list(frame_center)\n\n            zoom_value = None\n            if zoom is not None:\n                zoom_value = config.frame_height / (zoom * cam.height)\n\n            for value, method in [\n                [theta, \"theta\"],\n                [phi, \"phi\"],\n                [gamma, \"gamma\"],\n                [zoom_value, \"zoom\"],\n                [frame_center, \"frame_center\"],\n            ]:\n                if value is not None:\n                    methods[method](value)\n\n            if focal_distance is not None:\n                warnings.warn(\n                    \"focal distance of OpenGLCamera can not be adjusted.\",\n                    stacklevel=2,\n                )\n\n            anims += [Transform(cam, cam2)]\n\n        self.play(*anims + added_anims, **kwargs)\n\n        # These lines are added to improve performance. If manim thinks that frame_center is moving,\n        # it is required to redraw every object. These lines remove frame_center from the Scene once\n        # its animation is done, ensuring that manim does not think that it is moving. Since the\n        # frame_center is never actually drawn, this shouldn't break anything.\n        if frame_center is not None and config.renderer == RendererType.CAIRO:\n            self.remove(self.camera._frame_center)\n\n    def get_moving_mobjects(self, *animations: Animation):\n        \"\"\"\n        This method returns a list of all of the Mobjects in the Scene that\n        are moving, that are also in the animations passed.\n\n        Parameters\n        ----------\n        *animations\n            The animations whose mobjects will be checked.\n        \"\"\"\n        moving_mobjects = super().get_moving_mobjects(*animations)\n        camera_mobjects = self.renderer.camera.get_value_trackers() + [\n            self.renderer.camera._frame_center,\n        ]\n        if any(cm in moving_mobjects for cm in camera_mobjects):\n            return self.mobjects\n        return moving_mobjects\n\n    def add_fixed_orientation_mobjects(self, *mobjects: Mobject, **kwargs):\n        \"\"\"\n        This method is used to prevent the rotation and tilting\n        of mobjects as the camera moves around. The mobject can\n        still move in the x,y,z directions, but will always be\n        at the angle (relative to the camera) that it was at\n        when it was passed through this method.)\n\n        Parameters\n        ----------\n        *mobjects\n            The Mobject(s) whose orientation must be fixed.\n\n        **kwargs\n            Some valid kwargs are\n                use_static_center_func : bool\n                center_func : function\n        \"\"\"\n        if config.renderer == RendererType.CAIRO:\n            self.add(*mobjects)\n            self.renderer.camera.add_fixed_orientation_mobjects(*mobjects, **kwargs)\n        elif config.renderer == RendererType.OPENGL:\n            for mob in mobjects:\n                mob: OpenGLMobject\n                mob.fix_orientation()\n                self.add(mob)\n\n    def add_fixed_in_frame_mobjects(self, *mobjects: Mobject):\n        \"\"\"\n        This method is used to prevent the rotation and movement\n        of mobjects as the camera moves around. The mobject is\n        essentially overlaid, and is not impacted by the camera's\n        movement in any way.\n\n        Parameters\n        ----------\n        *mobjects\n            The Mobjects whose orientation must be fixed.\n        \"\"\"\n        if config.renderer == RendererType.CAIRO:\n            self.add(*mobjects)\n            self.camera: ThreeDCamera\n            self.camera.add_fixed_in_frame_mobjects(*mobjects)\n        elif config.renderer == RendererType.OPENGL:\n            for mob in mobjects:\n                mob: OpenGLMobject\n                mob.fix_in_frame()\n                self.add(mob)\n\n    def remove_fixed_orientation_mobjects(self, *mobjects: Mobject):\n        \"\"\"\n        This method \"unfixes\" the orientation of the mobjects\n        passed, meaning they will no longer be at the same angle\n        relative to the camera. This only makes sense if the\n        mobject was passed through add_fixed_orientation_mobjects first.\n\n        Parameters\n        ----------\n        *mobjects\n            The Mobjects whose orientation must be unfixed.\n        \"\"\"\n        if config.renderer == RendererType.CAIRO:\n            self.renderer.camera.remove_fixed_orientation_mobjects(*mobjects)\n        elif config.renderer == RendererType.OPENGL:\n            for mob in mobjects:\n                mob: OpenGLMobject\n                mob.unfix_orientation()\n                self.remove(mob)\n\n    def remove_fixed_in_frame_mobjects(self, *mobjects: Mobject):\n        \"\"\"\n         This method undoes what add_fixed_in_frame_mobjects does.\n         It allows the mobject to be affected by the movement of\n         the camera.\n\n        Parameters\n        ----------\n        *mobjects\n            The Mobjects whose position and orientation must be unfixed.\n        \"\"\"\n        if config.renderer == RendererType.CAIRO:\n            self.renderer.camera.remove_fixed_in_frame_mobjects(*mobjects)\n        elif config.renderer == RendererType.OPENGL:\n            for mob in mobjects:\n                mob: OpenGLMobject\n                mob.unfix_from_frame()\n                self.remove(mob)\n\n    ##\n    def set_to_default_angled_camera_orientation(self, **kwargs):\n        \"\"\"\n        This method sets the default_angled_camera_orientation to the\n        keyword arguments passed, and sets the camera to that orientation.\n\n        Parameters\n        ----------\n        **kwargs\n            Some recognised kwargs are phi, theta, focal_distance, gamma,\n            which have the same meaning as the parameters in set_camera_orientation.\n        \"\"\"\n        config = dict(\n            self.default_camera_orientation_kwargs,\n        )  # Where doe this come from?\n        config.update(kwargs)\n        self.set_camera_orientation(**config)"}, {"name": "ThreeDVMobject", "code": "class ThreeDVMobject(VMobject, metaclass=ConvertToOpenGL):\n    def __init__(self, shade_in_3d: bool = True, **kwargs):\n        super().__init__(shade_in_3d=shade_in_3d, **kwargs)"}, {"name": "TipableVMobject", "code": "class TipableVMobject(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"Meant for shared functionality between Arc and Line.\n    Functionality can be classified broadly into these groups:\n\n        * Adding, Creating, Modifying tips\n            - add_tip calls create_tip, before pushing the new tip\n                into the TipableVMobject's list of submobjects\n            - stylistic and positional configuration\n\n        * Checking for tips\n            - Boolean checks for whether the TipableVMobject has a tip\n                and a starting tip\n\n        * Getters\n            - Straightforward accessors, returning information pertaining\n                to the TipableVMobject instance's tip(s), its length etc\n    \"\"\"\n\n    def __init__(\n        self,\n        tip_length: float = DEFAULT_ARROW_TIP_LENGTH,\n        normal_vector: Vector3D = OUT,\n        tip_style: dict = {},\n        **kwargs: Any,\n    ) -> None:\n        self.tip_length: float = tip_length\n        self.normal_vector: Vector3D = normal_vector\n        self.tip_style: dict = tip_style\n        super().__init__(**kwargs)\n\n    # Adding, Creating, Modifying tips\n\n    def add_tip(\n        self,\n        tip: tips.ArrowTip | None = None,\n        tip_shape: type[tips.ArrowTip] | None = None,\n        tip_length: float | None = None,\n        tip_width: float | None = None,\n        at_start: bool = False,\n    ) -> Self:\n        \"\"\"Adds a tip to the TipableVMobject instance, recognising\n        that the endpoints might need to be switched if it's\n        a 'starting tip' or not.\n        \"\"\"\n        if tip is None:\n            tip = self.create_tip(tip_shape, tip_length, tip_width, at_start)\n        else:\n            self.position_tip(tip, at_start)\n        self.reset_endpoints_based_on_tip(tip, at_start)\n        self.asign_tip_attr(tip, at_start)\n        self.add(tip)\n        return self\n\n    def create_tip(\n        self,\n        tip_shape: type[tips.ArrowTip] | None = None,\n        tip_length: float | None = None,\n        tip_width: float | None = None,\n        at_start: bool = False,\n    ) -> tips.ArrowTip:\n        \"\"\"Stylises the tip, positions it spatially, and returns\n        the newly instantiated tip to the caller.\n        \"\"\"\n        tip = self.get_unpositioned_tip(tip_shape, tip_length, tip_width)\n        self.position_tip(tip, at_start)\n        return tip\n\n    def get_unpositioned_tip(\n        self,\n        tip_shape: type[tips.ArrowTip] | None = None,\n        tip_length: float | None = None,\n        tip_width: float | None = None,\n    ) -> tips.ArrowTip | tips.ArrowTriangleFilledTip:\n        \"\"\"Returns a tip that has been stylistically configured,\n        but has not yet been given a position in space.\n        \"\"\"\n        from manim.mobject.geometry.tips import ArrowTriangleFilledTip\n\n        style: dict[str, Any] = {}\n\n        if tip_shape is None:\n            tip_shape = ArrowTriangleFilledTip\n\n        if tip_shape is ArrowTriangleFilledTip:\n            if tip_width is None:\n                tip_width = self.get_default_tip_length()\n            style.update({\"width\": tip_width})\n        if tip_length is None:\n            tip_length = self.get_default_tip_length()\n\n        color = self.get_color()\n        style.update({\"fill_color\": color, \"stroke_color\": color})\n        style.update(self.tip_style)\n        tip = tip_shape(length=tip_length, **style)\n        return tip\n\n    def position_tip(self, tip: tips.ArrowTip, at_start: bool = False) -> tips.ArrowTip:\n        # Last two control points, defining both\n        # the end, and the tangency direction\n        if at_start:\n            anchor = self.get_start()\n            handle = self.get_first_handle()\n        else:\n            handle = self.get_last_handle()\n            anchor = self.get_end()\n        angles = cartesian_to_spherical((handle - anchor).tolist())\n        tip.rotate(\n            angles[1] - PI - tip.tip_angle,\n        )  # Rotates the tip along the azimuthal\n        if not hasattr(self, \"_init_positioning_axis\"):\n            axis = np.array(\n                [\n                    np.sin(angles[1]),\n                    -np.cos(angles[1]),\n                    0,\n                ]\n            )  # Obtains the perpendicular of the tip\n            tip.rotate(\n                -angles[2] + PI / 2,\n                axis=axis,\n            )  # Rotates the tip along the vertical wrt the axis\n            self._init_positioning_axis = axis\n        tip.shift(anchor - tip.tip_point)\n        return tip\n\n    def reset_endpoints_based_on_tip(self, tip: tips.ArrowTip, at_start: bool) -> Self:\n        if self.get_length() == 0:\n            # Zero length, put_start_and_end_on wouldn't work\n            return self\n\n        if at_start:\n            self.put_start_and_end_on(tip.base, self.get_end())\n        else:\n            self.put_start_and_end_on(self.get_start(), tip.base)\n        return self\n\n    def asign_tip_attr(self, tip: tips.ArrowTip, at_start: bool) -> Self:\n        if at_start:\n            self.start_tip = tip\n        else:\n            self.tip = tip\n        return self\n\n    # Checking for tips\n\n    def has_tip(self) -> bool:\n        return hasattr(self, \"tip\") and self.tip in self\n\n    def has_start_tip(self) -> bool:\n        return hasattr(self, \"start_tip\") and self.start_tip in self\n\n    # Getters\n\n    def pop_tips(self) -> VGroup:\n        start, end = self.get_start_and_end()\n        result = self.get_group_class()()\n        if self.has_tip():\n            result.add(self.tip)\n            self.remove(self.tip)\n        if self.has_start_tip():\n            result.add(self.start_tip)\n            self.remove(self.start_tip)\n        self.put_start_and_end_on(start, end)\n        return result\n\n    def get_tips(self) -> VGroup:\n        \"\"\"Returns a VGroup (collection of VMobjects) containing\n        the TipableVMObject instance's tips.\n        \"\"\"\n        result = self.get_group_class()()\n        if hasattr(self, \"tip\"):\n            result.add(self.tip)\n        if hasattr(self, \"start_tip\"):\n            result.add(self.start_tip)\n        return result\n\n    def get_tip(self) -> VMobject:\n        \"\"\"Returns the TipableVMobject instance's (first) tip,\n        otherwise throws an exception.\n        \"\"\"\n        tips = self.get_tips()\n        if len(tips) == 0:\n            raise Exception(\"tip not found\")\n        else:\n            tip: VMobject = tips[0]\n            return tip\n\n    def get_default_tip_length(self) -> float:\n        return self.tip_length\n\n    def get_first_handle(self) -> Point3D:\n        # Type inference of extracting an element from a list, is not\n        # supported by numpy, see this numpy issue\n        # https://github.com/numpy/numpy/issues/16544\n        first_handle: Point3D = self.points[1]\n        return first_handle\n\n    def get_last_handle(self) -> Point3D:\n        # Type inference of extracting an element from a list, is not\n        # supported by numpy, see this numpy issue\n        # https://github.com/numpy/numpy/issues/16544\n        last_handle: Point3D = self.points[-2]\n        return last_handle\n\n    def get_end(self) -> Point3D:\n        if self.has_tip():\n            return self.tip.get_start()\n        else:\n            return super().get_end()\n\n    def get_start(self) -> Point3D:\n        if self.has_start_tip():\n            return self.start_tip.get_start()\n        else:\n            return super().get_start()\n\n    def get_length(self) -> float:\n        start, end = self.get_start_and_end()\n        return float(np.linalg.norm(start - end))"}, {"name": "Title", "code": "class Title(Tex):\n    \"\"\"A mobject representing an underlined title.\n\n    Examples\n    --------\n    .. manim:: TitleExample\n        :save_last_frame:\n\n        import manim\n\n        class TitleExample(Scene):\n            def construct(self):\n                banner = ManimBanner()\n                title = Title(f\"Manim version {manim.__version__}\")\n                self.add(banner, title)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        *text_parts,\n        include_underline=True,\n        match_underline_width_to_text=False,\n        underline_buff=MED_SMALL_BUFF,\n        **kwargs,\n    ):\n        self.include_underline = include_underline\n        self.match_underline_width_to_text = match_underline_width_to_text\n        self.underline_buff = underline_buff\n        super().__init__(*text_parts, **kwargs)\n        self.to_edge(UP)\n        if self.include_underline:\n            underline_width = config[\"frame_width\"] - 2\n            underline = Line(LEFT, RIGHT)\n            underline.next_to(self, DOWN, buff=self.underline_buff)\n            if self.match_underline_width_to_text:\n                underline.match_width(self)\n            else:\n                underline.width = underline_width\n            self.add(underline)\n            self.underline = underline"}, {"name": "to_av_frame_rate", "code": "def to_av_frame_rate(fps):\n    epsilon1 = 1e-4\n    epsilon2 = 0.02\n\n    if isinstance(fps, int):\n        (num, denom) = (fps, 1)\n    elif abs(fps - round(fps)) < epsilon1:\n        (num, denom) = (round(fps), 1)\n    else:\n        denom = 1001\n        num = round(fps * denom / 1000) * 1000\n        if abs(fps - num / denom) >= epsilon2:\n            raise ValueError(\"invalid frame rate\")\n\n    return Fraction(num, denom)"}, {"name": "Torus", "code": "class Torus(Surface):\n    \"\"\"A torus.\n\n    Parameters\n    ----------\n    major_radius\n        Distance from the center of the tube to the center of the torus.\n    minor_radius\n        Radius of the tube.\n    u_range\n        The range of the ``u`` variable: ``(u_min, u_max)``.\n    v_range\n        The range of the ``v`` variable: ``(v_min, v_max)``.\n    resolution\n        The number of samples taken of the :class:`Torus`. A tuple can be\n        used to define different resolutions for ``u`` and ``v`` respectively.\n\n    Examples\n    --------\n    .. manim :: ExampleTorus\n        :save_last_frame:\n\n        class ExampleTorus(ThreeDScene):\n            def construct(self):\n                axes = ThreeDAxes()\n                torus = Torus()\n                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n                self.add(axes, torus)\n    \"\"\"\n\n    def __init__(\n        self,\n        major_radius: float = 3,\n        minor_radius: float = 1,\n        u_range: Sequence[float] = (0, TAU),\n        v_range: Sequence[float] = (0, TAU),\n        resolution: tuple[int, int] | None = None,\n        **kwargs,\n    ) -> None:\n        if config.renderer == RendererType.OPENGL:\n            res_value = (101, 101)\n        elif config.renderer == RendererType.CAIRO:\n            res_value = (24, 24)\n\n        resolution = resolution if resolution is not None else res_value\n\n        self.R = major_radius\n        self.r = minor_radius\n        super().__init__(\n            self.func,\n            u_range=u_range,\n            v_range=v_range,\n            resolution=resolution,\n            **kwargs,\n        )\n\n    def func(self, u: float, v: float) -> np.ndarray:\n        \"\"\"The z values defining the :class:`Torus` being plotted.\n\n        Returns\n        -------\n        :class:`numpy.ndarray`\n            The z values defining the :class:`Torus`.\n        \"\"\"\n        P = np.array([np.cos(u), np.sin(u), 0])\n        return (self.R - self.r * np.cos(v)) * P - self.r * np.sin(v) * OUT"}, {"name": "TracedPath", "code": "class TracedPath(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"Traces the path of a point returned by a function call.\n\n    Parameters\n    ----------\n    traced_point_func\n        The function to be traced.\n    stroke_width\n        The width of the trace.\n    stroke_color\n        The color of the trace.\n    dissipating_time\n        The time taken for the path to dissipate. Default set to ``None``\n        which disables dissipation.\n\n    Examples\n    --------\n    .. manim:: TracedPathExample\n\n        class TracedPathExample(Scene):\n            def construct(self):\n                circ = Circle(color=RED).shift(4*LEFT)\n                dot = Dot(color=RED).move_to(circ.get_start())\n                rolling_circle = VGroup(circ, dot)\n                trace = TracedPath(circ.get_start)\n                rolling_circle.add_updater(lambda m: m.rotate(-0.3))\n                self.add(trace, rolling_circle)\n                self.play(rolling_circle.animate.shift(8*RIGHT), run_time=4, rate_func=linear)\n\n    .. manim:: DissipatingPathExample\n\n        class DissipatingPathExample(Scene):\n            def construct(self):\n                a = Dot(RIGHT * 2)\n                b = TracedPath(a.get_center, dissipating_time=0.5, stroke_opacity=[0, 1])\n                self.add(a, b)\n                self.play(a.animate(path_arc=PI / 4).shift(LEFT * 2))\n                self.play(a.animate(path_arc=-PI / 4).shift(LEFT * 2))\n                self.wait()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        traced_point_func: Callable,\n        stroke_width: float = 2,\n        stroke_color: ParsableManimColor | None = WHITE,\n        dissipating_time: float | None = None,\n        **kwargs,\n    ):\n        super().__init__(stroke_color=stroke_color, stroke_width=stroke_width, **kwargs)\n        self.traced_point_func = traced_point_func\n        self.dissipating_time = dissipating_time\n        self.time = 1 if self.dissipating_time else None\n        self.add_updater(self.update_path)\n\n    def update_path(self, mob, dt):\n        new_point = self.traced_point_func()\n        if not self.has_points():\n            self.start_new_path(new_point)\n        self.add_line_to(new_point)\n        if self.dissipating_time:\n            self.time += dt\n            if self.time - 1 > self.dissipating_time:\n                nppcc = self.n_points_per_curve\n                self.set_points(self.points[nppcc:])"}, {"name": "Transform", "code": "class Transform(Animation):\n    \"\"\"A Transform transforms a Mobject into a target Mobject.\n\n    Parameters\n    ----------\n    mobject\n        The :class:`.Mobject` to be transformed. It will be mutated to become the ``target_mobject``.\n    target_mobject\n        The target of the transformation.\n    path_func\n        A function defining the path that the points of the ``mobject`` are being moved\n        along until they match the points of the ``target_mobject``, see :mod:`.utils.paths`.\n    path_arc\n        The arc angle (in radians) that the points of ``mobject`` will follow to reach\n        the points of the target if using a circular path arc, see ``path_arc_centers``.\n        See also :func:`manim.utils.paths.path_along_arc`.\n    path_arc_axis\n        The axis to rotate along if using a circular path arc, see ``path_arc_centers``.\n    path_arc_centers\n        The center of the circular arcs along which the points of ``mobject`` are\n        moved by the transformation.\n\n        If this is set and ``path_func`` is not set, then a ``path_along_circles`` path will be generated\n        using the ``path_arc`` parameters and stored in ``path_func``. If ``path_func`` is set, this and the\n        other ``path_arc`` fields are set as attributes, but a ``path_func`` is not generated from it.\n    replace_mobject_with_target_in_scene\n        Controls which mobject is replaced when the transformation is complete.\n\n        If set to True, ``mobject`` will be removed from the scene and ``target_mobject`` will\n        replace it. Otherwise, ``target_mobject`` is never added and ``mobject`` just takes its shape.\n\n    Examples\n    --------\n\n    .. manim :: TransformPathArc\n\n        class TransformPathArc(Scene):\n            def construct(self):\n                def make_arc_path(start, end, arc_angle):\n                    points = []\n                    p_fn = path_along_arc(arc_angle)\n                    # alpha animates between 0.0 and 1.0, where 0.0\n                    # is the beginning of the animation and 1.0 is the end.\n                    for alpha in range(0, 11):\n                        points.append(p_fn(start, end, alpha / 10.0))\n                    path = VMobject(stroke_color=YELLOW)\n                    path.set_points_smoothly(points)\n                    return path\n\n                left = Circle(stroke_color=BLUE_E, fill_opacity=1.0, radius=0.5).move_to(LEFT * 2)\n                colors = [TEAL_A, TEAL_B, TEAL_C, TEAL_D, TEAL_E, GREEN_A]\n                # Positive angles move counter-clockwise, negative angles move clockwise.\n                examples = [-90, 0, 30, 90, 180, 270]\n                anims = []\n                for idx, angle in enumerate(examples):\n                    left_c = left.copy().shift((3 - idx) * UP)\n                    left_c.fill_color = colors[idx]\n                    right_c = left_c.copy().shift(4 * RIGHT)\n                    path_arc = make_arc_path(left_c.get_center(), right_c.get_center(),\n                                             arc_angle=angle * DEGREES)\n                    desc = Text('%d\u00b0' % examples[idx]).next_to(left_c, LEFT)\n                    # Make the circles in front of the text in front of the arcs.\n                    self.add(\n                        path_arc.set_z_index(1),\n                        desc.set_z_index(2),\n                        left_c.set_z_index(3),\n                    )\n                    anims.append(Transform(left_c, right_c, path_arc=angle * DEGREES))\n\n                self.play(*anims, run_time=2)\n                self.wait()\n\n    See also\n    --------\n    :class:`~.ReplacementTransform`, :meth:`~.Mobject.interpolate`, :meth:`~.Mobject.align_data`\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject | None,\n        target_mobject: Mobject | None = None,\n        path_func: Callable | None = None,\n        path_arc: float = 0,\n        path_arc_axis: np.ndarray = OUT,\n        path_arc_centers: np.ndarray = None,\n        replace_mobject_with_target_in_scene: bool = False,\n        **kwargs,\n    ) -> None:\n        self.path_arc_axis: np.ndarray = path_arc_axis\n        self.path_arc_centers: np.ndarray = path_arc_centers\n        self.path_arc: float = path_arc\n\n        # path_func is a property a few lines below so it doesn't need to be set in any case\n        if path_func is not None:\n            self.path_func: Callable = path_func\n        elif self.path_arc_centers is not None:\n            self.path_func = path_along_circles(\n                path_arc,\n                self.path_arc_centers,\n                self.path_arc_axis,\n            )\n\n        self.replace_mobject_with_target_in_scene: bool = (\n            replace_mobject_with_target_in_scene\n        )\n        self.target_mobject: Mobject = (\n            target_mobject if target_mobject is not None else Mobject()\n        )\n        super().__init__(mobject, **kwargs)\n\n    @property\n    def path_arc(self) -> float:\n        return self._path_arc\n\n    @path_arc.setter\n    def path_arc(self, path_arc: float) -> None:\n        self._path_arc = path_arc\n        self._path_func = path_along_arc(\n            arc_angle=self._path_arc,\n            axis=self.path_arc_axis,\n        )\n\n    @property\n    def path_func(\n        self,\n    ) -> Callable[\n        [Iterable[np.ndarray], Iterable[np.ndarray], float],\n        Iterable[np.ndarray],\n    ]:\n        return self._path_func\n\n    @path_func.setter\n    def path_func(\n        self,\n        path_func: Callable[\n            [Iterable[np.ndarray], Iterable[np.ndarray], float],\n            Iterable[np.ndarray],\n        ],\n    ) -> None:\n        if path_func is not None:\n            self._path_func = path_func\n\n    def begin(self) -> None:\n        # Use a copy of target_mobject for the align_data\n        # call so that the actual target_mobject stays\n        # preserved.\n        self.target_mobject = self.create_target()\n        self.target_copy = self.target_mobject.copy()\n        # Note, this potentially changes the structure\n        # of both mobject and target_mobject\n        if config.renderer == RendererType.OPENGL:\n            self.mobject.align_data_and_family(self.target_copy)\n        else:\n            self.mobject.align_data(self.target_copy)\n        super().begin()\n\n    def create_target(self) -> Mobject:\n        # Has no meaningful effect here, but may be useful\n        # in subclasses\n        return self.target_mobject\n\n    def clean_up_from_scene(self, scene: Scene) -> None:\n        super().clean_up_from_scene(scene)\n        if self.replace_mobject_with_target_in_scene:\n            scene.replace(self.mobject, self.target_mobject)\n\n    def get_all_mobjects(self) -> Sequence[Mobject]:\n        return [\n            self.mobject,\n            self.starting_mobject,\n            self.target_mobject,\n            self.target_copy,\n        ]\n\n    def get_all_families_zipped(self) -> Iterable[tuple]:  # more precise typing?\n        mobs = [\n            self.mobject,\n            self.starting_mobject,\n            self.target_copy,\n        ]\n        if config.renderer == RendererType.OPENGL:\n            return zip(*(mob.get_family() for mob in mobs))\n        return zip(*(mob.family_members_with_points() for mob in mobs))\n\n    def interpolate_submobject(\n        self,\n        submobject: Mobject,\n        starting_submobject: Mobject,\n        target_copy: Mobject,\n        alpha: float,\n    ) -> Transform:\n        submobject.interpolate(starting_submobject, target_copy, alpha, self.path_func)\n        return self"}, {"name": "TransformAnimations", "code": "class TransformAnimations(Transform):\n    def __init__(\n        self,\n        start_anim: Animation,\n        end_anim: Animation,\n        rate_func: Callable = squish_rate_func(smooth),\n        **kwargs,\n    ) -> None:\n        self.start_anim = start_anim\n        self.end_anim = end_anim\n        if \"run_time\" in kwargs:\n            self.run_time = kwargs.pop(\"run_time\")\n        else:\n            self.run_time = max(start_anim.run_time, end_anim.run_time)\n        for anim in start_anim, end_anim:\n            anim.set_run_time(self.run_time)\n        if (\n            start_anim.starting_mobject is not None\n            and end_anim.starting_mobject is not None\n            and start_anim.starting_mobject.get_num_points()\n            != end_anim.starting_mobject.get_num_points()\n        ):\n            start_anim.starting_mobject.align_data(end_anim.starting_mobject)\n            for anim in start_anim, end_anim:\n                if isinstance(anim, Transform) and anim.starting_mobject is not None:\n                    anim.starting_mobject.align_data(anim.target_mobject)\n\n        super().__init__(\n            start_anim.mobject, end_anim.mobject, rate_func=rate_func, **kwargs\n        )\n        # Rewire starting and ending mobjects\n        start_anim.mobject = self.starting_mobject\n        end_anim.mobject = self.target_mobject\n\n    def interpolate(self, alpha: float) -> None:\n        self.start_anim.interpolate(alpha)\n        self.end_anim.interpolate(alpha)\n        super().interpolate(alpha)"}, {"name": "TransformFromCopy", "code": "class TransformFromCopy(Transform):\n    \"\"\"Performs a reversed Transform\"\"\"\n\n    def __init__(self, mobject: Mobject, target_mobject: Mobject, **kwargs) -> None:\n        super().__init__(target_mobject, mobject, **kwargs)\n\n    def interpolate(self, alpha: float) -> None:\n        super().interpolate(1 - alpha)"}, {"name": "TransformMatchingAbstractBase", "code": "class TransformMatchingAbstractBase(AnimationGroup):\n    \"\"\"Abstract base class for transformations that keep track of matching parts.\n\n    Subclasses have to implement the two static methods\n    :meth:`~.TransformMatchingAbstractBase.get_mobject_parts` and\n    :meth:`~.TransformMatchingAbstractBase.get_mobject_key`.\n\n    Basically, this transformation first maps all submobjects returned\n    by the ``get_mobject_parts`` method to certain keys by applying the\n    ``get_mobject_key`` method. Then, submobjects with matching keys\n    are transformed into each other.\n\n    Parameters\n    ----------\n    mobject\n        The starting :class:`~.Mobject`.\n    target_mobject\n        The target :class:`~.Mobject`.\n    transform_mismatches\n        Controls whether submobjects without a matching key are transformed\n        into each other by using :class:`~.Transform`. Default: ``False``.\n    fade_transform_mismatches\n        Controls whether submobjects without a matching key are transformed\n        into each other by using :class:`~.FadeTransform`. Default: ``False``.\n    key_map\n        Optional. A dictionary mapping keys belonging to some of the starting mobject's\n        submobjects (i.e., the return values of the ``get_mobject_key`` method)\n        to some keys belonging to the target mobject's submobjects that should\n        be transformed although the keys don't match.\n    kwargs\n        All further keyword arguments are passed to the submobject transformations.\n\n\n    Note\n    ----\n    If neither ``transform_mismatches`` nor ``fade_transform_mismatches``\n    are set to ``True``, submobjects without matching keys in the starting\n    mobject are faded out in the direction of the unmatched submobjects in\n    the target mobject, and unmatched submobjects in the target mobject\n    are faded in from the direction of the unmatched submobjects in the\n    start mobject.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        target_mobject: Mobject,\n        transform_mismatches: bool = False,\n        fade_transform_mismatches: bool = False,\n        key_map: dict | None = None,\n        **kwargs,\n    ):\n        if isinstance(mobject, OpenGLVMobject):\n            group_type = OpenGLVGroup\n        elif isinstance(mobject, OpenGLMobject):\n            group_type = OpenGLGroup\n        elif isinstance(mobject, VMobject):\n            group_type = VGroup\n        else:\n            group_type = Group\n\n        source_map = self.get_shape_map(mobject)\n        target_map = self.get_shape_map(target_mobject)\n\n        if key_map is None:\n            key_map = {}\n\n        # Create two mobjects whose submobjects all match each other\n        # according to whatever keys are used for source_map and\n        # target_map\n        transform_source = group_type()\n        transform_target = group_type()\n        for key in set(source_map).intersection(target_map):\n            transform_source.add(source_map[key])\n            transform_target.add(target_map[key])\n        anims = [Transform(transform_source, transform_target, **kwargs)]\n        # User can manually specify when one part should transform\n        # into another despite not matching by using key_map\n        key_mapped_source = group_type()\n        key_mapped_target = group_type()\n        for key1, key2 in key_map.items():\n            if key1 in source_map and key2 in target_map:\n                key_mapped_source.add(source_map[key1])\n                key_mapped_target.add(target_map[key2])\n                source_map.pop(key1, None)\n                target_map.pop(key2, None)\n        if len(key_mapped_source) > 0:\n            anims.append(\n                FadeTransformPieces(key_mapped_source, key_mapped_target, **kwargs),\n            )\n\n        fade_source = group_type()\n        fade_target = group_type()\n        for key in set(source_map).difference(target_map):\n            fade_source.add(source_map[key])\n        for key in set(target_map).difference(source_map):\n            fade_target.add(target_map[key])\n        fade_target_copy = fade_target.copy()\n\n        if transform_mismatches:\n            if \"replace_mobject_with_target_in_scene\" not in kwargs:\n                kwargs[\"replace_mobject_with_target_in_scene\"] = True\n            anims.append(Transform(fade_source, fade_target, **kwargs))\n        elif fade_transform_mismatches:\n            anims.append(FadeTransformPieces(fade_source, fade_target, **kwargs))\n        else:\n            anims.append(FadeOut(fade_source, target_position=fade_target, **kwargs))\n            anims.append(\n                FadeIn(fade_target_copy, target_position=fade_target, **kwargs),\n            )\n\n        super().__init__(*anims)\n\n        self.to_remove = [mobject, fade_target_copy]\n        self.to_add = target_mobject\n\n    def get_shape_map(self, mobject: Mobject) -> dict:\n        shape_map = {}\n        for sm in self.get_mobject_parts(mobject):\n            key = self.get_mobject_key(sm)\n            if key not in shape_map:\n                if config[\"renderer\"] == RendererType.OPENGL:\n                    shape_map[key] = OpenGLVGroup()\n                else:\n                    shape_map[key] = VGroup()\n            shape_map[key].add(sm)\n        return shape_map\n\n    def clean_up_from_scene(self, scene: Scene) -> None:\n        # Interpolate all animations back to 0 to ensure source mobjects remain unchanged.\n        for anim in self.animations:\n            anim.interpolate(0)\n        scene.remove(self.mobject)\n        scene.remove(*self.to_remove)\n        scene.add(self.to_add)\n\n    @staticmethod\n    def get_mobject_parts(mobject: Mobject):\n        raise NotImplementedError(\"To be implemented in subclass.\")\n\n    @staticmethod\n    def get_mobject_key(mobject: Mobject):\n        raise NotImplementedError(\"To be implemented in subclass.\")"}, {"name": "TransformMatchingShapes", "code": "class TransformMatchingShapes(TransformMatchingAbstractBase):\n    \"\"\"An animation trying to transform groups by matching the shape\n    of their submobjects.\n\n    Two submobjects match if the hash of their point coordinates after\n    normalization (i.e., after translation to the origin, fixing the submobject\n    height at 1 unit, and rounding the coordinates to three decimal places)\n    matches.\n\n    See also\n    --------\n    :class:`~.TransformMatchingAbstractBase`\n\n    Examples\n    --------\n\n    .. manim:: Anagram\n\n        class Anagram(Scene):\n            def construct(self):\n                src = Text(\"the morse code\")\n                tar = Text(\"here come dots\")\n                self.play(Write(src))\n                self.wait(0.5)\n                self.play(TransformMatchingShapes(src, tar, path_arc=PI/2))\n                self.wait(0.5)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        target_mobject: Mobject,\n        transform_mismatches: bool = False,\n        fade_transform_mismatches: bool = False,\n        key_map: dict | None = None,\n        **kwargs,\n    ):\n        super().__init__(\n            mobject,\n            target_mobject,\n            transform_mismatches=transform_mismatches,\n            fade_transform_mismatches=fade_transform_mismatches,\n            key_map=key_map,\n            **kwargs,\n        )\n\n    @staticmethod\n    def get_mobject_parts(mobject: Mobject) -> list[Mobject]:\n        return mobject.family_members_with_points()\n\n    @staticmethod\n    def get_mobject_key(mobject: Mobject) -> int:\n        mobject.save_state()\n        mobject.center()\n        mobject.set(height=1)\n        result = hash(np.round(mobject.points, 3).tobytes())\n        mobject.restore()\n        return result"}, {"name": "TransformMatchingTex", "code": "class TransformMatchingTex(TransformMatchingAbstractBase):\n    \"\"\"A transformation trying to transform rendered LaTeX strings.\n\n    Two submobjects match if their ``tex_string`` matches.\n\n    See also\n    --------\n    :class:`~.TransformMatchingAbstractBase`\n\n    Examples\n    --------\n\n    .. manim:: MatchingEquationParts\n\n        class MatchingEquationParts(Scene):\n            def construct(self):\n                variables = VGroup(MathTex(\"a\"), MathTex(\"b\"), MathTex(\"c\")).arrange_submobjects().shift(UP)\n\n                eq1 = MathTex(\"{{x}}^2\", \"+\", \"{{y}}^2\", \"=\", \"{{z}}^2\")\n                eq2 = MathTex(\"{{a}}^2\", \"+\", \"{{b}}^2\", \"=\", \"{{c}}^2\")\n                eq3 = MathTex(\"{{a}}^2\", \"=\", \"{{c}}^2\", \"-\", \"{{b}}^2\")\n\n                self.add(eq1)\n                self.wait(0.5)\n                self.play(TransformMatchingTex(Group(eq1, variables), eq2))\n                self.wait(0.5)\n                self.play(TransformMatchingTex(eq2, eq3))\n                self.wait(0.5)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        target_mobject: Mobject,\n        transform_mismatches: bool = False,\n        fade_transform_mismatches: bool = False,\n        key_map: dict | None = None,\n        **kwargs,\n    ):\n        super().__init__(\n            mobject,\n            target_mobject,\n            transform_mismatches=transform_mismatches,\n            fade_transform_mismatches=fade_transform_mismatches,\n            key_map=key_map,\n            **kwargs,\n        )\n\n    @staticmethod\n    def get_mobject_parts(mobject: Mobject) -> list[Mobject]:\n        if isinstance(mobject, (Group, VGroup, OpenGLGroup, OpenGLVGroup)):\n            return [\n                p\n                for s in mobject.submobjects\n                for p in TransformMatchingTex.get_mobject_parts(s)\n            ]\n        else:\n            assert hasattr(mobject, \"tex_string\")\n            return mobject.submobjects\n\n    @staticmethod\n    def get_mobject_key(mobject: Mobject) -> str:\n        return mobject.tex_string"}, {"name": "translation_matrix", "code": "def translation_matrix(x: float = 0, y: float = 0, z: float = 0) -> MatrixMN:\n    return np.array(\n        [\n            [1, 0, 0, x],\n            [0, 1, 0, y],\n            [0, 0, 1, z],\n            [0, 0, 0, 1],\n        ],\n        dtype=ManimFloat,\n    )"}, {"name": "Triangle", "code": "class Triangle(RegularPolygon):\n    \"\"\"An equilateral triangle.\n\n    Parameters\n    ----------\n    kwargs\n        Additional arguments to be passed to :class:`RegularPolygon`\n\n    Examples\n    --------\n    .. manim:: TriangleExample\n        :save_last_frame:\n\n        class TriangleExample(Scene):\n            def construct(self):\n                triangle_1 = Triangle()\n                triangle_2 = Triangle().scale(2).rotate(60*DEGREES)\n                tri_group = Group(triangle_1, triangle_2).arrange(buff=1)\n                self.add(tri_group)\n    \"\"\"\n\n    def __init__(self, **kwargs: Any) -> None:\n        super().__init__(n=3, **kwargs)"}, {"name": "triangulate_mobject", "code": "def triangulate_mobject(mob):\n    if not mob.needs_new_triangulation:\n        return mob.triangulation\n\n    # Figure out how to triangulate the interior to know\n    # how to send the points as to the vertex shader.\n    # First triangles come directly from the points\n    # normal_vector = mob.get_unit_normal()\n    points = mob.points\n\n    b0s = points[0::3]\n    b1s = points[1::3]\n    b2s = points[2::3]\n    v01s = b1s - b0s\n    v12s = b2s - b1s\n\n    crosses = cross2d(v01s, v12s)\n    convexities = np.sign(crosses)\n    if mob.orientation == 1:\n        concave_parts = convexities > 0\n        convex_parts = convexities <= 0\n    else:\n        concave_parts = convexities < 0\n        convex_parts = convexities >= 0\n\n    # These are the vertices to which we'll apply a polygon triangulation\n    atol = mob.tolerance_for_point_equality\n    end_of_loop = np.zeros(len(b0s), dtype=bool)\n    end_of_loop[:-1] = (np.abs(b2s[:-1] - b0s[1:]) > atol).any(1)\n    end_of_loop[-1] = True\n\n    indices = np.arange(len(points), dtype=int)\n    inner_vert_indices = np.hstack(\n        [\n            indices[0::3],\n            indices[1::3][concave_parts],\n            indices[2::3][end_of_loop],\n        ],\n    )\n    inner_vert_indices.sort()\n    rings = np.arange(1, len(inner_vert_indices) + 1)[inner_vert_indices % 3 == 2]\n\n    # Triangulate\n    inner_verts = points[inner_vert_indices]\n    inner_tri_indices = inner_vert_indices[earclip_triangulation(inner_verts, rings)]\n\n    bezier_triangle_indices = np.reshape(indices, (-1, 3))\n    concave_triangle_indices = np.reshape(bezier_triangle_indices[concave_parts], (-1))\n    convex_triangle_indices = np.reshape(bezier_triangle_indices[convex_parts], (-1))\n\n    points = points[\n        np.hstack(\n            [\n                concave_triangle_indices,\n                convex_triangle_indices,\n                inner_tri_indices,\n            ],\n        )\n    ]\n    texture_coords = np.tile(\n        [\n            [0.0, 0.0],\n            [0.5, 0.0],\n            [1.0, 1.0],\n        ],\n        (points.shape[0] // 3, 1),\n    )\n    texture_mode = np.hstack(\n        (\n            np.ones(concave_triangle_indices.shape[0]),\n            -1 * np.ones(convex_triangle_indices.shape[0]),\n            np.zeros(inner_tri_indices.shape[0]),\n        ),\n    )\n\n    attributes = np.zeros(\n        points.shape[0],\n        dtype=[\n            (\"in_vert\", np.float32, (3,)),\n            (\"in_color\", np.float32, (4,)),\n            (\"texture_coords\", np.float32, (2,)),\n            (\"texture_mode\", np.int32),\n        ],\n    )\n    attributes[\"in_vert\"] = points\n    attributes[\"texture_coords\"] = texture_coords\n    attributes[\"texture_mode\"] = texture_mode\n\n    mob.triangulation = attributes\n    mob.needs_new_triangulation = False\n\n    return attributes"}, {"name": "triggers_refreshed_triangulation", "code": "def triggers_refreshed_triangulation(func):\n    @wraps(func)\n    def wrapper(self, *args, **kwargs):\n        old_points = np.empty((0, 3))\n        for mob in self.family_members_with_points():\n            old_points = np.concatenate((old_points, mob.points), axis=0)\n        func(self, *args, **kwargs)\n        new_points = np.empty((0, 3))\n        for mob in self.family_members_with_points():\n            new_points = np.concatenate((new_points, mob.points), axis=0)\n        if not np.array_equal(new_points, old_points):\n            self.refresh_triangulation()\n            self.refresh_unit_normal()\n        return self\n\n    return wrapper"}, {"name": "TrueDot", "code": "class TrueDot(DotCloud):\n    def __init__(self, center=ORIGIN, stroke_width=2.0, **kwargs):\n        self.radius = stroke_width\n        super().__init__(points=[center], stroke_width=stroke_width, **kwargs)"}, {"name": "tuplify", "code": "def tuplify(obj: str | Iterable[T] | T) -> tuple[str] | tuple[T]:\n    \"\"\"Converts obj to a tuple intelligently.\n\n    Examples\n    --------\n    .. code-block:: pycon\n\n        >>> tuplify(\"str\")\n        ('str',)\n        >>> tuplify([1, 2])\n        (1, 2)\n        >>> tuplify(len)\n        (<built-in function len>,)\n    \"\"\"\n    if isinstance(obj, str):\n        return (obj,)\n    if isinstance(obj, Iterable):\n        return tuple(obj)\n    else:\n        return (obj,)"}, {"name": "turn_animation_into_updater", "code": "def turn_animation_into_updater(\n    animation: Animation, cycle: bool = False, delay: float = 0, **kwargs\n) -> Mobject:\n    \"\"\"\n    Add an updater to the animation's mobject which applies\n    the interpolation and update functions of the animation\n\n    If cycle is True, this repeats over and over.  Otherwise,\n    the updater will be popped upon completion\n\n    The ``delay`` parameter is the delay (in seconds) before the animation starts..\n\n    Examples\n    --------\n\n    .. manim:: WelcomeToManim\n\n        class WelcomeToManim(Scene):\n            def construct(self):\n                words = Text(\"Welcome to\")\n                banner = ManimBanner().scale(0.5)\n                VGroup(words, banner).arrange(DOWN)\n\n                turn_animation_into_updater(Write(words, run_time=0.9))\n                self.add(words)\n                self.wait(0.5)\n                self.play(banner.expand(), run_time=0.5)\n    \"\"\"\n    mobject = animation.mobject\n    animation.suspend_mobject_updating = False\n    animation.begin()\n    animation.total_time = -delay\n\n    def update(m: Mobject, dt: float):\n        if animation.total_time >= 0:\n            run_time = animation.get_run_time()\n            time_ratio = animation.total_time / run_time\n            if cycle:\n                alpha = time_ratio % 1\n            else:\n                alpha = np.clip(time_ratio, 0, 1)\n                if alpha >= 1:\n                    animation.finish()\n                    m.remove_updater(update)\n                    return\n            animation.interpolate(alpha)\n            animation.update_mobjects(dt)\n        animation.total_time += dt\n\n    mobject.add_updater(update)\n    return mobject"}, {"name": "TypeWithCursor", "code": "class TypeWithCursor(AddTextLetterByLetter):\n    \"\"\"Similar to :class:`~.AddTextLetterByLetter` , but with an additional cursor mobject at the end.\n\n    Parameters\n    ----------\n    time_per_char\n        Frequency of appearance of the letters.\n    cursor\n        :class:`~.Mobject` shown after the last added letter.\n    buff\n        Controls how far away the cursor is to the right of the last added letter.\n    keep_cursor_y\n        If ``True``, the cursor's y-coordinate is set to the center of the ``Text`` and remains the same throughout the animation. Otherwise, it is set to the center of the last added letter.\n    leave_cursor_on\n        Whether to show the cursor after the animation.\n\n    .. tip::\n        This is currently only possible for class:`~.Text` and not for class:`~.MathTex`.\n\n\n    Examples\n    --------\n\n    .. manim:: InsertingTextExample\n        :ref_classes: Blink\n\n        class InsertingTextExample(Scene):\n            def construct(self):\n                text = Text(\"Inserting\", color=PURPLE).scale(1.5).to_edge(LEFT)\n                cursor = Rectangle(\n                    color = GREY_A,\n                    fill_color = GREY_A,\n                    fill_opacity = 1.0,\n                    height = 1.1,\n                    width = 0.5,\n                ).move_to(text[0]) # Position the cursor\n\n                self.play(TypeWithCursor(text, cursor))\n                self.play(Blink(cursor, blinks=2))\n\n    \"\"\"\n\n    def __init__(\n        self,\n        text: Text,\n        cursor: Mobject,\n        buff: float = 0.1,\n        keep_cursor_y: bool = True,\n        leave_cursor_on: bool = True,\n        time_per_char: float = 0.1,\n        reverse_rate_function=False,\n        introducer=True,\n        **kwargs,\n    ) -> None:\n        self.cursor = cursor\n        self.buff = buff\n        self.keep_cursor_y = keep_cursor_y\n        self.leave_cursor_on = leave_cursor_on\n        super().__init__(\n            text,\n            time_per_char=time_per_char,\n            reverse_rate_function=reverse_rate_function,\n            introducer=introducer,\n            **kwargs,\n        )\n\n    def begin(self) -> None:\n        self.y_cursor = self.cursor.get_y()\n        self.cursor.initial_position = self.mobject.get_center()\n        if self.keep_cursor_y:\n            self.cursor.set_y(self.y_cursor)\n\n        self.cursor.set_opacity(0)\n        self.mobject.add(self.cursor)\n        super().begin()\n\n    def finish(self) -> None:\n        if self.leave_cursor_on:\n            self.cursor.set_opacity(1)\n        else:\n            self.cursor.set_opacity(0)\n            self.mobject.remove(self.cursor)\n        super().finish()\n\n    def clean_up_from_scene(self, scene: Scene) -> None:\n        if not self.leave_cursor_on:\n            scene.remove(self.cursor)\n        super().clean_up_from_scene(scene)\n\n    def update_submobject_list(self, index: int) -> None:\n        for mobj in self.all_submobs[:index]:\n            mobj.set_opacity(1)\n\n        for mobj in self.all_submobs[index:]:\n            mobj.set_opacity(0)\n\n        if index != 0:\n            self.cursor.next_to(\n                self.all_submobs[index - 1], RIGHT, buff=self.buff\n            ).set_y(self.cursor.initial_position[1])\n        else:\n            self.cursor.move_to(self.all_submobs[0]).set_y(\n                self.cursor.initial_position[1]\n            )\n\n        if self.keep_cursor_y:\n            self.cursor.set_y(self.y_cursor)\n        self.cursor.set_opacity(1)"}, {"name": "Uncreate", "code": "class Uncreate(Create):\n    \"\"\"Like :class:`Create` but in reverse.\n\n    Examples\n    --------\n    .. manim:: ShowUncreate\n\n        class ShowUncreate(Scene):\n            def construct(self):\n                self.play(Uncreate(Square()))\n\n    See Also\n    --------\n    :class:`Create`\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: VMobject | OpenGLVMobject,\n        reverse_rate_function: bool = True,\n        remover: bool = True,\n        **kwargs,\n    ) -> None:\n        super().__init__(\n            mobject,\n            reverse_rate_function=reverse_rate_function,\n            introducer=False,\n            remover=remover,\n            **kwargs,\n        )"}, {"name": "Underline", "code": "class Underline(Line):\n    \"\"\"Creates an underline.\n\n    Examples\n    --------\n    .. manim:: UnderLine\n        :save_last_frame:\n\n        class UnderLine(Scene):\n            def construct(self):\n                man = Tex(\"Manim\")  # Full Word\n                ul = Underline(man)  # Underlining the word\n                self.add(man, ul)\n    \"\"\"\n\n    def __init__(\n        self, mobject: Mobject, buff: float = SMALL_BUFF, **kwargs: Any\n    ) -> None:\n        super().__init__(LEFT, RIGHT, buff=buff, **kwargs)\n        self.match_width(mobject)\n        self.next_to(mobject, DOWN, buff=self.buff)"}, {"name": "Union", "code": "class Union(_BooleanOps):\n    \"\"\"Union of two or more :class:`~.VMobject` s. This returns the common region of\n    the :class:`~VMobject` s.\n\n    Parameters\n    ----------\n    vmobjects\n        The :class:`~.VMobject` s to find the union of.\n\n    Raises\n    ------\n    ValueError\n        If less than 2 :class:`~.VMobject` s are passed.\n\n    Example\n    -------\n    .. manim:: UnionExample\n        :save_last_frame:\n\n        class UnionExample(Scene):\n            def construct(self):\n                sq = Square(color=RED, fill_opacity=1)\n                sq.move_to([-2, 0, 0])\n                cr = Circle(color=BLUE, fill_opacity=1)\n                cr.move_to([-1.3, 0.7, 0])\n                un = Union(sq, cr, color=GREEN, fill_opacity=1)\n                un.move_to([1.5, 0.3, 0])\n                self.add(sq, cr, un)\n\n    \"\"\"\n\n    def __init__(self, *vmobjects: VMobject, **kwargs: Any) -> None:\n        if len(vmobjects) < 2:\n            raise ValueError(\"At least 2 mobjects needed for Union.\")\n        super().__init__(**kwargs)\n        paths = []\n        for vmobject in vmobjects:\n            paths.append(self._convert_vmobject_to_skia_path(vmobject))\n        outpen = SkiaPath()\n        union(paths, outpen.getPen())\n        self._convert_skia_path_to_vmobject(outpen)"}, {"name": "uniq_chain", "code": "def uniq_chain(*args: Iterable[T]) -> Generator[T, None, None]:\n    \"\"\"Returns a generator that yields all unique elements of the Iterables\n        provided via args in the order provided.\n\n    Examples\n    --------\n    .. code-block:: pycon\n\n        >>> gen = uniq_chain([1, 2], [2, 3], [1, 4, 4])\n        >>> from collections.abc import Generator\n        >>> isinstance(gen, Generator)\n        True\n        >>> tuple(gen)\n        (1, 2, 3, 4)\n    \"\"\"\n    unique_items = set()\n    for x in it.chain(*args):\n        if x in unique_items:\n            continue\n        unique_items.add(x)\n        yield x"}, {"name": "unit_interval", "code": "def unit_interval(function: RateFunction) -> RateFunction:\n    @wraps(function)\n    def wrapper(t: float, *args: Any, **kwargs: Any) -> float:\n        if 0 <= t <= 1:\n            return function(t, *args, **kwargs)\n        elif t < 0:\n            return 0\n        else:\n            return 1\n\n    return wrapper"}, {"name": "UnitInterval", "code": "class UnitInterval(NumberLine):\n    def __init__(\n        self,\n        unit_size=10,\n        numbers_with_elongated_ticks=None,\n        decimal_number_config=None,\n        **kwargs,\n    ):\n        numbers_with_elongated_ticks = (\n            [0, 1]\n            if numbers_with_elongated_ticks is None\n            else numbers_with_elongated_ticks\n        )\n\n        decimal_number_config = (\n            {\n                \"num_decimal_places\": 1,\n            }\n            if decimal_number_config is None\n            else decimal_number_config\n        )\n\n        super().__init__(\n            x_range=(0, 1, 0.1),\n            unit_size=unit_size,\n            numbers_with_elongated_ticks=numbers_with_elongated_ticks,\n            decimal_number_config=decimal_number_config,\n            **kwargs,\n        )"}, {"name": "UntypeWithCursor", "code": "class UntypeWithCursor(TypeWithCursor):\n    \"\"\"Similar to :class:`~.RemoveTextLetterByLetter` , but with an additional cursor mobject at the end.\n\n    Parameters\n    ----------\n    time_per_char\n        Frequency of appearance of the letters.\n    cursor\n        :class:`~.Mobject` shown after the last added letter.\n    buff\n        Controls how far away the cursor is to the right of the last added letter.\n    keep_cursor_y\n        If ``True``, the cursor's y-coordinate is set to the center of the ``Text`` and remains the same throughout the animation. Otherwise, it is set to the center of the last added letter.\n    leave_cursor_on\n        Whether to show the cursor after the animation.\n\n    .. tip::\n        This is currently only possible for class:`~.Text` and not for class:`~.MathTex`.\n\n\n    Examples\n    --------\n\n    .. manim:: DeletingTextExample\n        :ref_classes: Blink\n\n        class DeletingTextExample(Scene):\n            def construct(self):\n                text = Text(\"Deleting\", color=PURPLE).scale(1.5).to_edge(LEFT)\n                cursor = Rectangle(\n                    color = GREY_A,\n                    fill_color = GREY_A,\n                    fill_opacity = 1.0,\n                    height = 1.1,\n                    width = 0.5,\n                ).move_to(text[0]) # Position the cursor\n\n                self.play(UntypeWithCursor(text, cursor))\n                self.play(Blink(cursor, blinks=2))\n\n    \"\"\"\n\n    def __init__(\n        self,\n        text: Text,\n        cursor: VMobject | None = None,\n        time_per_char: float = 0.1,\n        reverse_rate_function=True,\n        introducer=False,\n        remover=True,\n        **kwargs,\n    ) -> None:\n        super().__init__(\n            text,\n            cursor=cursor,\n            time_per_char=time_per_char,\n            reverse_rate_function=reverse_rate_function,\n            introducer=introducer,\n            remover=remover,\n            **kwargs,\n        )"}, {"name": "Unwrite", "code": "class Unwrite(Write):\n    \"\"\"Simulate erasing by hand a :class:`~.Text` or a :class:`~.VMobject`.\n\n    Parameters\n    ----------\n    reverse\n        Set True to have the animation start erasing from the last submobject first.\n\n    Examples\n    --------\n\n    .. manim :: UnwriteReverseTrue\n\n        class UnwriteReverseTrue(Scene):\n            def construct(self):\n                text = Tex(\"Alice and Bob\").scale(3)\n                self.add(text)\n                self.play(Unwrite(text))\n\n    .. manim:: UnwriteReverseFalse\n\n        class UnwriteReverseFalse(Scene):\n            def construct(self):\n                text = Tex(\"Alice and Bob\").scale(3)\n                self.add(text)\n                self.play(Unwrite(text, reverse=False))\n    \"\"\"\n\n    def __init__(\n        self,\n        vmobject: VMobject,\n        rate_func: Callable[[float], float] = linear,\n        reverse: bool = True,\n        **kwargs,\n    ) -> None:\n        run_time: float | None = kwargs.pop(\"run_time\", None)\n        lag_ratio: float | None = kwargs.pop(\"lag_ratio\", None)\n        run_time, lag_ratio = self._set_default_config_from_length(\n            vmobject,\n            run_time,\n            lag_ratio,\n        )\n        super().__init__(\n            vmobject,\n            run_time=run_time,\n            lag_ratio=lag_ratio,\n            reverse_rate_function=True,\n            reverse=reverse,\n            **kwargs,\n        )"}, {"name": "update_cfg", "code": "def update_cfg(cfg_dict: dict[str, Any], project_cfg_path: Path) -> None:\n    \"\"\"Update the ``manim.cfg`` file after reading it from the specified\n    ``project_cfg_path``.\n\n    Parameters\n    ----------\n    cfg_dict\n        Values used to update ``manim.cfg`` which is found in\n        ``project_cfg_path``.\n    project_cfg_path\n        Path of the ``manim.cfg`` file.\n    \"\"\"\n    config = configparser.ConfigParser()\n    config.read(project_cfg_path)\n    cli_config = config[\"CLI\"]\n    for key, value in cfg_dict.items():\n        if key == \"resolution\":\n            cli_config[\"pixel_height\"] = str(value[0])\n            cli_config[\"pixel_width\"] = str(value[1])\n        else:\n            cli_config[key] = str(value)\n\n    with project_cfg_path.open(\"w\") as conf:\n        config.write(conf)"}, {"name": "update_dict_recursively", "code": "def update_dict_recursively(\n    current_dict: dict[Any, Any], *others: dict[Any, Any]\n) -> None:\n    updated_dict = merge_dicts_recursively(current_dict, *others)\n    current_dict.update(updated_dict)"}, {"name": "UpdateFromAlphaFunc", "code": "class UpdateFromAlphaFunc(UpdateFromFunc):\n    def interpolate_mobject(self, alpha: float) -> None:\n        self.update_function(self.mobject, self.rate_func(alpha))"}, {"name": "UpdateFromFunc", "code": "class UpdateFromFunc(Animation):\n    \"\"\"\n    update_function of the form func(mobject), presumably\n    to be used when the state of one mobject is dependent\n    on another simultaneously animated mobject\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        update_function: typing.Callable[[Mobject], typing.Any],\n        suspend_mobject_updating: bool = False,\n        **kwargs,\n    ) -> None:\n        self.update_function = update_function\n        super().__init__(\n            mobject, suspend_mobject_updating=suspend_mobject_updating, **kwargs\n        )\n\n    def interpolate_mobject(self, alpha: float) -> None:\n        self.update_function(self.mobject)"}, {"name": "validate_gui_location", "code": "def validate_gui_location(\n    ctx: Context, param: Option, value: str | None\n) -> tuple[int, int] | None:\n    \"\"\"If the ``value`` string is given, extract from it the GUI location,\n    which should be in any of these formats: 'x;y', 'x,y' or 'x-y'.\n\n    Parameters\n    ----------\n    ctx\n        The Click context.\n    param\n        A Click option.\n    value\n        The optional string which will be parsed.\n\n    Returns\n    -------\n    tuple[int, int] | None\n        If ``value`` is ``None``, the return value is ``None``. Otherwise, it's\n        the ``(x, y)`` location for the GUI.\n\n    Raises\n    ------\n    ValueError\n        If ``value`` has an invalid format.\n    \"\"\"\n    if value is None:\n        return None\n\n    try:\n        x_offset, y_offset = map(int, re.split(r\"[;,\\-]\", value))\n    except Exception:\n        logger.error(\"GUI location option is invalid.\")\n        sys.exit()\n\n    return (x_offset, y_offset)"}, {"name": "validate_resolution", "code": "def validate_resolution(\n    ctx: Context, param: Option, value: str | None\n) -> tuple[int, int] | None:\n    \"\"\"If the ``value`` string is given, extract from it the resolution, which\n    should be in any of these formats: 'W;H', 'W,H' or 'W-H'. Otherwise, return\n    ``None``.\n\n    Parameters\n    ----------\n    ctx\n        The Click context.\n    param\n        A Click option.\n    value\n        The optional string which will be parsed.\n\n    Returns\n    -------\n    tuple[int, int] | None\n        If ``value`` is ``None``, the return value is ``None``. Otherwise, it's\n        the resolution as a ``(W, H)`` tuple.\n\n    Raises\n    ------\n    ValueError\n        If ``value`` has an invalid format.\n    \"\"\"\n    if value is None:\n        return None\n\n    try:\n        width, height = map(int, re.split(r\"[;,\\-]\", value))\n    except Exception:\n        logger.error(\"Resolution option is invalid.\")\n        sys.exit()\n\n    return width, height"}, {"name": "validate_scene_range", "code": "def validate_scene_range(\n    ctx: Context, param: Option, value: str | None\n) -> tuple[int] | tuple[int, int] | None:\n    \"\"\"If the ``value`` string is given, extract from it the scene range, which\n    should be in any of these formats: 'start', 'start;end', 'start,end' or\n    'start-end'. Otherwise, return ``None``.\n\n    Parameters\n    ----------\n    ctx\n        The Click context.\n    param\n        A Click option.\n    value\n        The optional string which will be parsed.\n\n    Returns\n    -------\n    tuple[int] | tuple[int, int] | None\n        If ``value`` is ``None``, the return value is ``None``. Otherwise, it's\n        the scene range, given by a tuple which may contain a single value\n        ``start`` or two values ``start`` and ``end``.\n\n    Raises\n    ------\n    ValueError\n        If ``value`` has an invalid format.\n    \"\"\"\n    if value is None:\n        return None\n\n    try:\n        start = int(value)\n        return (start,)\n    except Exception:\n        pass\n\n    try:\n        start, end = map(int, re.split(r\"[;,\\-]\", value))\n    except Exception:\n        logger.error(\"Couldn't determine a range for -n option.\")\n        sys.exit()\n\n    return start, end"}, {"name": "value_from_string", "code": "def value_from_string(value: str) -> str | int | bool:\n    \"\"\"Extract the literal of proper datatype from a ``value`` string.\n\n    Parameters\n    ----------\n    value\n        The value to check get the literal from.\n\n    Returns\n    -------\n    :class:`str` | :class:`int` | :class:`bool`\n        The literal of appropriate datatype.\n    \"\"\"\n    with contextlib.suppress(SyntaxError, ValueError):\n        value = literal_eval(value)\n    return value"}, {"name": "ValueTracker", "code": "class ValueTracker(Mobject, metaclass=ConvertToOpenGL):\n    \"\"\"A mobject that can be used for tracking (real-valued) parameters.\n    Useful for animating parameter changes.\n\n    Not meant to be displayed.  Instead the position encodes some\n    number, often one which another animation or continual_animation\n    uses for its update function, and by treating it as a mobject it can\n    still be animated and manipulated just like anything else.\n\n    This value changes continuously when animated using the :attr:`animate` syntax.\n\n    Examples\n    --------\n    .. manim:: ValueTrackerExample\n\n        class ValueTrackerExample(Scene):\n            def construct(self):\n                number_line = NumberLine()\n                pointer = Vector(DOWN)\n                label = MathTex(\"x\").add_updater(lambda m: m.next_to(pointer, UP))\n\n                tracker = ValueTracker(0)\n                pointer.add_updater(\n                    lambda m: m.next_to(\n                                number_line.n2p(tracker.get_value()),\n                                UP\n                            )\n                )\n                self.add(number_line, pointer,label)\n                tracker += 1.5\n                self.wait(1)\n                tracker -= 4\n                self.wait(0.5)\n                self.play(tracker.animate.set_value(5))\n                self.wait(0.5)\n                self.play(tracker.animate.set_value(3))\n                self.play(tracker.animate.increment_value(-2))\n                self.wait(0.5)\n\n    .. note::\n\n        You can also link ValueTrackers to updaters. In this case, you have to make sure that the\n        ValueTracker is added to the scene by ``add``\n\n    .. manim:: ValueTrackerExample\n\n        class ValueTrackerExample(Scene):\n            def construct(self):\n                tracker = ValueTracker(0)\n                label = Dot(radius=3).add_updater(lambda x : x.set_x(tracker.get_value()))\n                self.add(label)\n                self.add(tracker)\n                tracker.add_updater(lambda mobject, dt: mobject.increment_value(dt))\n                self.wait(2)\n\n    \"\"\"\n\n    def __init__(self, value=0, **kwargs):\n        super().__init__(**kwargs)\n        self.set(points=np.zeros((1, 3)))\n        self.set_value(value)\n\n    def get_value(self) -> float:\n        \"\"\"Get the current value of this ValueTracker.\"\"\"\n        return self.points[0, 0]\n\n    def set_value(self, value: float):\n        \"\"\"Sets a new scalar value to the ValueTracker\"\"\"\n        self.points[0, 0] = value\n        return self\n\n    def increment_value(self, d_value: float):\n        \"\"\"Increments (adds) a scalar value  to the ValueTracker\"\"\"\n        self.set_value(self.get_value() + d_value)\n        return self\n\n    def __bool__(self):\n        \"\"\"Return whether the value of this value tracker evaluates as true.\"\"\"\n        return bool(self.get_value())\n\n    def __iadd__(self, d_value: float):\n        \"\"\"adds ``+=`` syntax to increment the value of the ValueTracker\"\"\"\n        self.increment_value(d_value)\n        return self\n\n    def __ifloordiv__(self, d_value: float):\n        \"\"\"Set the value of this value tracker to the floor division of the current value by ``d_value``.\"\"\"\n        self.set_value(self.get_value() // d_value)\n        return self\n\n    def __imod__(self, d_value: float):\n        \"\"\"Set the value of this value tracker to the current value modulo ``d_value``.\"\"\"\n        self.set_value(self.get_value() % d_value)\n        return self\n\n    def __imul__(self, d_value: float):\n        \"\"\"Set the value of this value tracker to the product of the current value and ``d_value``.\"\"\"\n        self.set_value(self.get_value() * d_value)\n        return self\n\n    def __ipow__(self, d_value: float):\n        \"\"\"Set the value of this value tracker to the current value raised to the power of ``d_value``.\"\"\"\n        self.set_value(self.get_value() ** d_value)\n        return self\n\n    def __isub__(self, d_value: float):\n        \"\"\"adds ``-=`` syntax to decrement the value of the ValueTracker\"\"\"\n        self.increment_value(-d_value)\n        return self\n\n    def __itruediv__(self, d_value: float):\n        \"\"\"Sets the value of this value tracker to the current value divided by ``d_value``.\"\"\"\n        self.set_value(self.get_value() / d_value)\n        return self\n\n    def interpolate(self, mobject1, mobject2, alpha, path_func=straight_path()):\n        \"\"\"\n        Turns self into an interpolation between mobject1\n        and mobject2.\n        \"\"\"\n        self.set(points=path_func(mobject1.points, mobject2.points, alpha))\n        return self"}, {"name": "Variable", "code": "class Variable(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A class for displaying text that shows \"label = value\" with\n    the value continuously updated from a :class:`~.ValueTracker`.\n\n    Parameters\n    ----------\n    var\n        The initial value you need to keep track of and display.\n    label\n        The label for your variable. Raw strings are convertex to :class:`~.MathTex` objects.\n    var_type\n        The class used for displaying the number. Defaults to :class:`DecimalNumber`.\n    num_decimal_places\n        The number of decimal places to display in your variable. Defaults to 2.\n        If `var_type` is an :class:`Integer`, this parameter is ignored.\n    kwargs\n            Other arguments to be passed to `~.Mobject`.\n\n    Attributes\n    ----------\n    label : Union[:class:`str`, :class:`~.Tex`, :class:`~.MathTex`, :class:`~.Text`, :class:`~.SingleStringMathTex`]\n        The label for your variable, for example ``x = ...``.\n    tracker : :class:`~.ValueTracker`\n        Useful in updating the value of your variable on-screen.\n    value : Union[:class:`DecimalNumber`, :class:`Integer`]\n        The tex for the value of your variable.\n\n    Examples\n    --------\n    Normal usage::\n\n        # DecimalNumber type\n        var = 0.5\n        on_screen_var = Variable(var, Text(\"var\"), num_decimal_places=3)\n        # Integer type\n        int_var = 0\n        on_screen_int_var = Variable(int_var, Text(\"int_var\"), var_type=Integer)\n        # Using math mode for the label\n        on_screen_int_var = Variable(int_var, \"{a}_{i}\", var_type=Integer)\n\n    .. manim:: VariablesWithValueTracker\n\n        class VariablesWithValueTracker(Scene):\n            def construct(self):\n                var = 0.5\n                on_screen_var = Variable(var, Text(\"var\"), num_decimal_places=3)\n\n                # You can also change the colours for the label and value\n                on_screen_var.label.set_color(RED)\n                on_screen_var.value.set_color(GREEN)\n\n                self.play(Write(on_screen_var))\n                # The above line will just display the variable with\n                # its initial value on the screen. If you also wish to\n                # update it, you can do so by accessing the `tracker` attribute\n                self.wait()\n                var_tracker = on_screen_var.tracker\n                var = 10.5\n                self.play(var_tracker.animate.set_value(var))\n                self.wait()\n\n                int_var = 0\n                on_screen_int_var = Variable(\n                    int_var, Text(\"int_var\"), var_type=Integer\n                ).next_to(on_screen_var, DOWN)\n                on_screen_int_var.label.set_color(RED)\n                on_screen_int_var.value.set_color(GREEN)\n\n                self.play(Write(on_screen_int_var))\n                self.wait()\n                var_tracker = on_screen_int_var.tracker\n                var = 10.5\n                self.play(var_tracker.animate.set_value(var))\n                self.wait()\n\n                # If you wish to have a somewhat more complicated label for your\n                # variable with subscripts, superscripts, etc. the default class\n                # for the label is MathTex\n                subscript_label_var = 10\n                on_screen_subscript_var = Variable(subscript_label_var, \"{a}_{i}\").next_to(\n                    on_screen_int_var, DOWN\n                )\n                self.play(Write(on_screen_subscript_var))\n                self.wait()\n\n    .. manim:: VariableExample\n\n        class VariableExample(Scene):\n            def construct(self):\n                start = 2.0\n\n                x_var = Variable(start, 'x', num_decimal_places=3)\n                sqr_var = Variable(start**2, 'x^2', num_decimal_places=3)\n                Group(x_var, sqr_var).arrange(DOWN)\n\n                sqr_var.add_updater(lambda v: v.tracker.set_value(x_var.tracker.get_value()**2))\n\n                self.add(x_var, sqr_var)\n                self.play(x_var.tracker.animate.set_value(5), run_time=2, rate_func=linear)\n                self.wait(0.1)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        var: float,\n        label: str | Tex | MathTex | Text | SingleStringMathTex,\n        var_type: DecimalNumber | Integer = DecimalNumber,\n        num_decimal_places: int = 2,\n        **kwargs,\n    ):\n        self.label = MathTex(label) if isinstance(label, str) else label\n        equals = MathTex(\"=\").next_to(self.label, RIGHT)\n        self.label.add(equals)\n\n        self.tracker = ValueTracker(var)\n\n        if var_type == DecimalNumber:\n            self.value = DecimalNumber(\n                self.tracker.get_value(),\n                num_decimal_places=num_decimal_places,\n            )\n        elif var_type == Integer:\n            self.value = Integer(self.tracker.get_value())\n\n        self.value.add_updater(lambda v: v.set_value(self.tracker.get_value())).next_to(\n            self.label,\n            RIGHT,\n        )\n\n        super().__init__(**kwargs)\n        self.add(self.label, self.value)"}, {"name": "VDict", "code": "class VDict(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A VGroup-like class, also offering submobject access by\n    key, like a python dict\n\n    Parameters\n    ----------\n    mapping_or_iterable\n            The parameter specifying the key-value mapping of keys and mobjects.\n    show_keys\n            Whether to also display the key associated with\n            the mobject. This might be useful when debugging,\n            especially when there are a lot of mobjects in the\n            :class:`VDict`. Defaults to False.\n    kwargs\n            Other arguments to be passed to `Mobject`.\n\n    Attributes\n    ----------\n    show_keys : :class:`bool`\n            Whether to also display the key associated with\n            the mobject. This might be useful when debugging,\n            especially when there are a lot of mobjects in the\n            :class:`VDict`. When displayed, the key is towards\n            the left of the mobject.\n            Defaults to False.\n    submob_dict : :class:`dict`\n            Is the actual python dictionary that is used to bind\n            the keys to the mobjects.\n\n    Examples\n    --------\n\n    .. manim:: ShapesWithVDict\n\n        class ShapesWithVDict(Scene):\n            def construct(self):\n                square = Square().set_color(RED)\n                circle = Circle().set_color(YELLOW).next_to(square, UP)\n\n                # create dict from list of tuples each having key-mobject pair\n                pairs = [(\"s\", square), (\"c\", circle)]\n                my_dict = VDict(pairs, show_keys=True)\n\n                # display it just like a VGroup\n                self.play(Create(my_dict))\n                self.wait()\n\n                text = Tex(\"Some text\").set_color(GREEN).next_to(square, DOWN)\n\n                # add a key-value pair by wrapping it in a single-element list of tuple\n                # after attrs branch is merged, it will be easier like `.add(t=text)`\n                my_dict.add([(\"t\", text)])\n                self.wait()\n\n                rect = Rectangle().next_to(text, DOWN)\n                # can also do key assignment like a python dict\n                my_dict[\"r\"] = rect\n\n                # access submobjects like a python dict\n                my_dict[\"t\"].set_color(PURPLE)\n                self.play(my_dict[\"t\"].animate.scale(3))\n                self.wait()\n\n                # also supports python dict styled reassignment\n                my_dict[\"t\"] = Tex(\"Some other text\").set_color(BLUE)\n                self.wait()\n\n                # remove submobject by key\n                my_dict.remove(\"t\")\n                self.wait()\n\n                self.play(Uncreate(my_dict[\"s\"]))\n                self.wait()\n\n                self.play(FadeOut(my_dict[\"c\"]))\n                self.wait()\n\n                self.play(FadeOut(my_dict[\"r\"], shift=DOWN))\n                self.wait()\n\n                # you can also make a VDict from an existing dict of mobjects\n                plain_dict = {\n                    1: Integer(1).shift(DOWN),\n                    2: Integer(2).shift(2 * DOWN),\n                    3: Integer(3).shift(3 * DOWN),\n                }\n\n                vdict_from_plain_dict = VDict(plain_dict)\n                vdict_from_plain_dict.shift(1.5 * (UP + LEFT))\n                self.play(Create(vdict_from_plain_dict))\n\n                # you can even use zip\n                vdict_using_zip = VDict(zip([\"s\", \"c\", \"r\"], [Square(), Circle(), Rectangle()]))\n                vdict_using_zip.shift(1.5 * RIGHT)\n                self.play(Create(vdict_using_zip))\n                self.wait()\n    \"\"\"\n\n    def __init__(\n        self,\n        mapping_or_iterable: (\n            Mapping[Hashable, VMobject] | Iterable[tuple[Hashable, VMobject]]\n        ) = {},\n        show_keys: bool = False,\n        **kwargs,\n    ) -> None:\n        super().__init__(**kwargs)\n        self.show_keys = show_keys\n        self.submob_dict = {}\n        self.add(mapping_or_iterable)\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({repr(self.submob_dict)})\"\n\n    def add(\n        self,\n        mapping_or_iterable: (\n            Mapping[Hashable, VMobject] | Iterable[tuple[Hashable, VMobject]]\n        ),\n    ) -> Self:\n        \"\"\"Adds the key-value pairs to the :class:`VDict` object.\n\n        Also, it internally adds the value to the `submobjects` :class:`list`\n        of :class:`~.Mobject`, which is responsible for actual on-screen display.\n\n        Parameters\n        ---------\n        mapping_or_iterable\n            The parameter specifying the key-value mapping of keys and mobjects.\n\n        Returns\n        -------\n        :class:`VDict`\n            Returns the :class:`VDict` object on which this method was called.\n\n        Examples\n        --------\n        Normal usage::\n\n            square_obj = Square()\n            my_dict.add([(\"s\", square_obj)])\n        \"\"\"\n        for key, value in dict(mapping_or_iterable).items():\n            self.add_key_value_pair(key, value)\n\n        return self\n\n    def remove(self, key: Hashable) -> Self:\n        \"\"\"Removes the mobject from the :class:`VDict` object having the key `key`\n\n        Also, it internally removes the mobject from the `submobjects` :class:`list`\n        of :class:`~.Mobject`, (which is responsible for removing it from the screen)\n\n        Parameters\n        ----------\n        key\n            The key of the submoject to be removed.\n\n        Returns\n        -------\n        :class:`VDict`\n            Returns the :class:`VDict` object on which this method was called.\n\n        Examples\n        --------\n        Normal usage::\n\n            my_dict.remove(\"square\")\n        \"\"\"\n        if key not in self.submob_dict:\n            raise KeyError(f\"The given key '{key!s}' is not present in the VDict\")\n        super().remove(self.submob_dict[key])\n        del self.submob_dict[key]\n        return self\n\n    def __getitem__(self, key: Hashable):\n        \"\"\"Override the [] operator for item retrieval.\n\n        Parameters\n        ----------\n        key\n           The key of the submoject to be accessed\n\n        Returns\n        -------\n        :class:`VMobject`\n           The submobject corresponding to the key `key`\n\n        Examples\n        --------\n        Normal usage::\n\n           self.play(Create(my_dict[\"s\"]))\n        \"\"\"\n        submob = self.submob_dict[key]\n        return submob\n\n    def __setitem__(self, key: Hashable, value: VMobject) -> None:\n        \"\"\"Override the [] operator for item assignment.\n\n        Parameters\n        ----------\n        key\n            The key of the submoject to be assigned\n        value\n            The submobject to bind the key to\n\n        Returns\n        -------\n        None\n\n        Examples\n        --------\n        Normal usage::\n\n            square_obj = Square()\n            my_dict[\"sq\"] = square_obj\n        \"\"\"\n        if key in self.submob_dict:\n            self.remove(key)\n        self.add([(key, value)])\n\n    def __delitem__(self, key: Hashable):\n        \"\"\"Override the del operator for deleting an item.\n\n        Parameters\n        ----------\n        key\n            The key of the submoject to be deleted\n\n        Returns\n        -------\n        None\n\n        Examples\n        --------\n        ::\n\n            >>> from manim import *\n            >>> my_dict = VDict({'sq': Square()})\n            >>> 'sq' in my_dict\n            True\n            >>> del my_dict['sq']\n            >>> 'sq' in my_dict\n            False\n\n        Notes\n        -----\n        Removing an item from a VDict does not remove that item from any Scene\n        that the VDict is part of.\n\n        \"\"\"\n        del self.submob_dict[key]\n\n    def __contains__(self, key: Hashable):\n        \"\"\"Override the in operator.\n\n        Parameters\n        ----------\n        key\n            The key to check membership of.\n\n        Returns\n        -------\n        :class:`bool`\n\n        Examples\n        --------\n        ::\n\n            >>> from manim import *\n            >>> my_dict = VDict({'sq': Square()})\n            >>> 'sq' in my_dict\n            True\n\n        \"\"\"\n        return key in self.submob_dict\n\n    def get_all_submobjects(self) -> list[list]:\n        \"\"\"To get all the submobjects associated with a particular :class:`VDict` object\n\n        Returns\n        -------\n        :class:`dict_values`\n            All the submobjects associated with the :class:`VDict` object\n\n        Examples\n        --------\n        Normal usage::\n\n            for submob in my_dict.get_all_submobjects():\n                self.play(Create(submob))\n        \"\"\"\n        submobjects = self.submob_dict.values()\n        return submobjects\n\n    def add_key_value_pair(self, key: Hashable, value: VMobject) -> None:\n        \"\"\"A utility function used by :meth:`add` to add the key-value pair\n        to :attr:`submob_dict`. Not really meant to be used externally.\n\n        Parameters\n        ----------\n        key\n            The key of the submobject to be added.\n        value\n            The mobject associated with the key\n\n        Returns\n        -------\n        None\n\n        Raises\n        ------\n        TypeError\n            If the value is not an instance of VMobject\n\n        Examples\n        --------\n        Normal usage::\n\n            square_obj = Square()\n            self.add_key_value_pair(\"s\", square_obj)\n\n        \"\"\"\n        self._assert_valid_submobjects([value])\n        mob = value\n        if self.show_keys:\n            # This import is here and not at the top to avoid circular import\n            from manim.mobject.text.tex_mobject import Tex\n\n            key_text = Tex(str(key)).next_to(value, LEFT)\n            mob.add(key_text)\n\n        self.submob_dict[key] = mob\n        super().add(value)"}, {"name": "Vector", "code": "class Vector(Arrow):\n    \"\"\"A vector specialized for use in graphs.\n\n    .. caution::\n        Do not confuse with the :class:`~.Vector2D`,\n        :class:`~.Vector3D` or :class:`~.VectorND` type aliases,\n        which are not Mobjects!\n\n    Parameters\n    ----------\n    direction\n        The direction of the arrow.\n    buff\n         The distance of the vector from its endpoints.\n    kwargs\n        Additional arguments to be passed to :class:`Arrow`\n\n    Examples\n    --------\n    .. manim:: VectorExample\n        :save_last_frame:\n\n        class VectorExample(Scene):\n            def construct(self):\n                plane = NumberPlane()\n                vector_1 = Vector([1,2])\n                vector_2 = Vector([-5,-2])\n                self.add(plane, vector_1, vector_2)\n    \"\"\"\n\n    def __init__(\n        self,\n        direction: Point2DLike | Point3DLike = RIGHT,\n        buff: float = 0,\n        **kwargs: Any,\n    ) -> None:\n        self.buff = buff\n        if len(direction) == 2:\n            direction = np.hstack([direction, 0])\n\n        super().__init__(ORIGIN, direction, buff=buff, **kwargs)\n\n    def coordinate_label(\n        self,\n        integer_labels: bool = True,\n        n_dim: int = 2,\n        color: ParsableManimColor | None = None,\n        **kwargs: Any,\n    ) -> Matrix:\n        \"\"\"Creates a label based on the coordinates of the vector.\n\n        Parameters\n        ----------\n        integer_labels\n            Whether or not to round the coordinates to integers.\n        n_dim\n            The number of dimensions of the vector.\n        color\n            Sets the color of label, optional.\n        kwargs\n            Additional arguments to be passed to :class:`~.Matrix`.\n\n        Returns\n        -------\n        :class:`~.Matrix`\n            The label.\n\n        Examples\n        --------\n        .. manim:: VectorCoordinateLabel\n            :save_last_frame:\n\n            class VectorCoordinateLabel(Scene):\n                def construct(self):\n                    plane = NumberPlane()\n\n                    vec_1 = Vector([1, 2])\n                    vec_2 = Vector([-3, -2])\n                    label_1 = vec_1.coordinate_label()\n                    label_2 = vec_2.coordinate_label(color=YELLOW)\n\n                    self.add(plane, vec_1, vec_2, label_1, label_2)\n        \"\"\"\n        # avoiding circular imports\n        from ..matrix import Matrix\n\n        vect = np.array(self.get_end())\n        if integer_labels:\n            vect = np.round(vect).astype(int)\n        vect = vect[:n_dim]\n        vect = vect.reshape((n_dim, 1))\n        label = Matrix(vect, **kwargs)\n        label.scale(LARGE_BUFF - 0.2)\n\n        shift_dir = np.array(self.get_end())\n        if shift_dir[0] >= 0:  # Pointing right\n            shift_dir -= label.get_left() + DEFAULT_MOBJECT_TO_MOBJECT_BUFFER * LEFT\n        else:  # Pointing left\n            shift_dir -= label.get_right() + DEFAULT_MOBJECT_TO_MOBJECT_BUFFER * RIGHT\n        label.shift(shift_dir)\n        if color is not None:\n            label.set_color(color)\n        return label"}, {"name": "VectorField", "code": "class VectorField(VGroup):\n    \"\"\"A vector field.\n\n    Vector fields are based on a function defining a vector at every position.\n    This class does by default not include any visible elements but provides\n    methods to move other :class:`~.Mobject` s along the vector field.\n\n    Parameters\n    ----------\n    func\n        The function defining the rate of change at every position of the `VectorField`.\n    color\n        The color of the vector field. If set, position-specific coloring is disabled.\n    color_scheme\n        A function mapping a vector to a single value. This value gives the position in the color gradient defined using `min_color_scheme_value`, `max_color_scheme_value` and `colors`.\n    min_color_scheme_value\n        The value of the color_scheme function to be mapped to the first color in `colors`. Lower values also result in the first color of the gradient.\n    max_color_scheme_value\n        The value of the color_scheme function to be mapped to the last color in `colors`. Higher values also result in the last color of the gradient.\n    colors\n        The colors defining the color gradient of the vector field.\n    kwargs\n        Additional arguments to be passed to the :class:`~.VGroup` constructor\n\n    \"\"\"\n\n    def __init__(\n        self,\n        func: Callable[[np.ndarray], np.ndarray],\n        color: ParsableManimColor | None = None,\n        color_scheme: Callable[[np.ndarray], float] | None = None,\n        min_color_scheme_value: float = 0,\n        max_color_scheme_value: float = 2,\n        colors: Sequence[ParsableManimColor] = DEFAULT_SCALAR_FIELD_COLORS,\n        **kwargs,\n    ):\n        super().__init__(**kwargs)\n        self.func = func\n        if color is None:\n            self.single_color = False\n            if color_scheme is None:\n\n                def color_scheme(p):\n                    return np.linalg.norm(p)\n\n            self.color_scheme = color_scheme  # TODO maybe other default for direction?\n            self.rgbs = np.array(list(map(color_to_rgb, colors)))\n\n            def pos_to_rgb(pos: np.ndarray) -> tuple[float, float, float, float]:\n                vec = self.func(pos)\n                color_value = np.clip(\n                    self.color_scheme(vec),\n                    min_color_scheme_value,\n                    max_color_scheme_value,\n                )\n                alpha = inverse_interpolate(\n                    min_color_scheme_value,\n                    max_color_scheme_value,\n                    color_value,\n                )\n                alpha *= len(self.rgbs) - 1\n                c1 = self.rgbs[int(alpha)]\n                c2 = self.rgbs[min(int(alpha + 1), len(self.rgbs) - 1)]\n                alpha %= 1\n                return interpolate(c1, c2, alpha)\n\n            self.pos_to_rgb = pos_to_rgb\n            self.pos_to_color = lambda pos: rgb_to_color(self.pos_to_rgb(pos))\n        else:\n            self.single_color = True\n            self.color = ManimColor.parse(color)\n        self.submob_movement_updater = None\n\n    @staticmethod\n    def shift_func(\n        func: Callable[[np.ndarray], np.ndarray],\n        shift_vector: np.ndarray,\n    ) -> Callable[[np.ndarray], np.ndarray]:\n        \"\"\"Shift a vector field function.\n\n        Parameters\n        ----------\n        func\n            The function defining a vector field.\n        shift_vector\n            The shift to be applied to the vector field.\n\n        Returns\n        -------\n        `Callable[[np.ndarray], np.ndarray]`\n            The shifted vector field function.\n\n        \"\"\"\n        return lambda p: func(p - shift_vector)\n\n    @staticmethod\n    def scale_func(\n        func: Callable[[np.ndarray], np.ndarray],\n        scalar: float,\n    ) -> Callable[[np.ndarray], np.ndarray]:\n        \"\"\"Scale a vector field function.\n\n        Parameters\n        ----------\n        func\n            The function defining a vector field.\n        scalar\n            The scalar to be applied to the vector field.\n\n        Examples\n        --------\n        .. manim:: ScaleVectorFieldFunction\n\n            class ScaleVectorFieldFunction(Scene):\n                def construct(self):\n                    func = lambda pos: np.sin(pos[1]) * RIGHT + np.cos(pos[0]) * UP\n                    vector_field = ArrowVectorField(func)\n                    self.add(vector_field)\n                    self.wait()\n\n                    func = VectorField.scale_func(func, 0.5)\n                    self.play(vector_field.animate.become(ArrowVectorField(func)))\n                    self.wait()\n\n        Returns\n        -------\n        `Callable[[np.ndarray], np.ndarray]`\n            The scaled vector field function.\n\n        \"\"\"\n        return lambda p: func(p * scalar)\n\n    def fit_to_coordinate_system(self, coordinate_system: CoordinateSystem):\n        \"\"\"Scale the vector field to fit a coordinate system.\n\n        This method is useful when the vector field is defined in a coordinate system\n        different from the one used to display the vector field.\n\n        This method can only be used once because it transforms the origin of each vector.\n\n        Parameters\n        ----------\n        coordinate_system\n            The coordinate system to fit the vector field to.\n\n        \"\"\"\n        self.apply_function(lambda pos: coordinate_system.coords_to_point(*pos))\n\n    def nudge(\n        self,\n        mob: Mobject,\n        dt: float = 1,\n        substeps: int = 1,\n        pointwise: bool = False,\n    ) -> VectorField:\n        \"\"\"Nudge a :class:`~.Mobject` along the vector field.\n\n        Parameters\n        ----------\n        mob\n            The mobject to move along the vector field\n        dt\n            A scalar to the amount the mobject is moved along the vector field.\n            The actual distance is based on the magnitude of the vector field.\n        substeps\n            The amount of steps the whole nudge is divided into. Higher values\n            give more accurate approximations.\n        pointwise\n            Whether to move the mobject along the vector field. If `False` the\n            vector field takes effect on the center of the given\n            :class:`~.Mobject`. If `True` the vector field takes effect on the\n            points of the individual points of the :class:`~.Mobject`,\n            potentially distorting it.\n\n        Returns\n        -------\n        VectorField\n            This vector field.\n\n        Examples\n        --------\n\n        .. manim:: Nudging\n\n            class Nudging(Scene):\n                def construct(self):\n                    func = lambda pos: np.sin(pos[1] / 2) * RIGHT + np.cos(pos[0] / 2) * UP\n                    vector_field = ArrowVectorField(\n                        func, x_range=[-7, 7, 1], y_range=[-4, 4, 1], length_func=lambda x: x / 2\n                    )\n                    self.add(vector_field)\n                    circle = Circle(radius=2).shift(LEFT)\n                    self.add(circle.copy().set_color(GRAY))\n                    dot = Dot().move_to(circle)\n\n                    vector_field.nudge(circle, -2, 60, True)\n                    vector_field.nudge(dot, -2, 60)\n\n                    circle.add_updater(vector_field.get_nudge_updater(pointwise=True))\n                    dot.add_updater(vector_field.get_nudge_updater())\n                    self.add(circle, dot)\n                    self.wait(6)\n\n        \"\"\"\n\n        def runge_kutta(self, p: Sequence[float], step_size: float) -> float:\n            \"\"\"Returns the change in position of a point along a vector field.\n            Parameters\n            ----------\n            p\n               The position of each point being moved along the vector field.\n            step_size\n               A scalar that is used to determine how much a point is shifted in a single step.\n\n            Returns\n            -------\n            float\n               How much the point is shifted.\n            \"\"\"\n            k_1 = self.func(p)\n            k_2 = self.func(p + step_size * (k_1 * 0.5))\n            k_3 = self.func(p + step_size * (k_2 * 0.5))\n            k_4 = self.func(p + step_size * k_3)\n            return step_size / 6.0 * (k_1 + 2.0 * k_2 + 2.0 * k_3 + k_4)\n\n        step_size = dt / substeps\n        for _ in range(substeps):\n            if pointwise:\n                mob.apply_function(lambda p: p + runge_kutta(self, p, step_size))\n            else:\n                mob.shift(runge_kutta(self, mob.get_center(), step_size))\n        return self\n\n    def nudge_submobjects(\n        self,\n        dt: float = 1,\n        substeps: int = 1,\n        pointwise: bool = False,\n    ) -> VectorField:\n        \"\"\"Apply a nudge along the vector field to all submobjects.\n\n        Parameters\n        ----------\n        dt\n            A scalar to the amount the mobject is moved along the vector field.\n            The actual distance is based on the magnitude of the vector field.\n        substeps\n            The amount of steps the whole nudge is divided into. Higher values\n            give more accurate approximations.\n        pointwise\n            Whether to move the mobject along the vector field. See :meth:`nudge` for details.\n\n        Returns\n        -------\n        VectorField\n            This vector field.\n\n        \"\"\"\n        for mob in self.submobjects:\n            self.nudge(mob, dt, substeps, pointwise)\n        return self\n\n    def get_nudge_updater(\n        self,\n        speed: float = 1,\n        pointwise: bool = False,\n    ) -> Callable[[Mobject, float], Mobject]:\n        \"\"\"Get an update function to move a :class:`~.Mobject` along the vector field.\n\n        When used with :meth:`~.Mobject.add_updater`, the mobject will move along the vector field, where its speed is determined by the magnitude of the vector field.\n\n        Parameters\n        ----------\n        speed\n            At `speed=1` the distance a mobject moves per second is equal to the magnitude of the vector field along its path. The speed value scales the speed of such a mobject.\n        pointwise\n            Whether to move the mobject along the vector field. See :meth:`nudge` for details.\n\n        Returns\n        -------\n        Callable[[Mobject, float], Mobject]\n            The update function.\n        \"\"\"\n        return lambda mob, dt: self.nudge(mob, dt * speed, pointwise=pointwise)\n\n    def start_submobject_movement(\n        self,\n        speed: float = 1,\n        pointwise: bool = False,\n    ) -> VectorField:\n        \"\"\"Start continuously moving all submobjects along the vector field.\n\n        Calling this method multiple times will result in removing the previous updater created by this method.\n\n        Parameters\n        ----------\n        speed\n            The speed at which to move the submobjects. See :meth:`get_nudge_updater` for details.\n        pointwise\n            Whether to move the mobject along the vector field. See :meth:`nudge` for details.\n\n        Returns\n        -------\n        VectorField\n            This vector field.\n\n        \"\"\"\n        self.stop_submobject_movement()\n        self.submob_movement_updater = lambda mob, dt: mob.nudge_submobjects(\n            dt * speed,\n            pointwise=pointwise,\n        )\n        self.add_updater(self.submob_movement_updater)\n        return self\n\n    def stop_submobject_movement(self) -> VectorField:\n        \"\"\"Stops the continuous movement started using :meth:`start_submobject_movement`.\n\n        Returns\n        -------\n        VectorField\n            This vector field.\n        \"\"\"\n        self.remove_updater(self.submob_movement_updater)\n        self.submob_movement_updater = None\n        return self\n\n    def get_colored_background_image(self, sampling_rate: int = 5) -> Image.Image:\n        \"\"\"Generate an image that displays the vector field.\n\n        The color at each position is calculated by passing the positing through a\n        series of steps:\n        Calculate the vector field function at that position, map that vector to a\n        single value using `self.color_scheme` and finally generate a color from\n        that value using the color gradient.\n\n        Parameters\n        ----------\n        sampling_rate\n            The stepsize at which pixels get included in the image. Lower values give\n            more accurate results, but may take a long time to compute.\n\n        Returns\n        -------\n        Image.Imgae\n            The vector field image.\n        \"\"\"\n        if self.single_color:\n            raise ValueError(\n                \"There is no point in generating an image if the vector field uses a single color.\",\n            )\n        ph = int(config[\"pixel_height\"] / sampling_rate)\n        pw = int(config[\"pixel_width\"] / sampling_rate)\n        fw = config[\"frame_width\"]\n        fh = config[\"frame_height\"]\n        points_array = np.zeros((ph, pw, 3))\n        x_array = np.linspace(-fw / 2, fw / 2, pw)\n        y_array = np.linspace(fh / 2, -fh / 2, ph)\n        x_array = x_array.reshape((1, len(x_array)))\n        y_array = y_array.reshape((len(y_array), 1))\n        x_array = x_array.repeat(ph, axis=0)\n        y_array.repeat(pw, axis=1)  # TODO why not y_array = y_array.repeat(...)?\n        points_array[:, :, 0] = x_array\n        points_array[:, :, 1] = y_array\n        rgbs = np.apply_along_axis(self.pos_to_rgb, 2, points_array)\n        return Image.fromarray((rgbs * 255).astype(\"uint8\"))\n\n    def get_vectorized_rgba_gradient_function(\n        self,\n        start: float,\n        end: float,\n        colors: Iterable[ParsableManimColor],\n    ):\n        \"\"\"\n        Generates a gradient of rgbas as a numpy array\n\n        Parameters\n        ----------\n        start\n            start value used for inverse interpolation at :func:`~.inverse_interpolate`\n        end\n            end value used for inverse interpolation at :func:`~.inverse_interpolate`\n        colors\n            list of colors to generate the gradient\n\n        Returns\n        -------\n            function to generate the gradients as numpy arrays representing rgba values\n        \"\"\"\n        rgbs = np.array([color_to_rgb(c) for c in colors])\n\n        def func(values, opacity=1):\n            alphas = inverse_interpolate(start, end, np.array(values))\n            alphas = np.clip(alphas, 0, 1)\n            scaled_alphas = alphas * (len(rgbs) - 1)\n            indices = scaled_alphas.astype(int)\n            next_indices = np.clip(indices + 1, 0, len(rgbs) - 1)\n            inter_alphas = scaled_alphas % 1\n            inter_alphas = inter_alphas.repeat(3).reshape((len(indices), 3))\n            result = interpolate(rgbs[indices], rgbs[next_indices], inter_alphas)\n            result = np.concatenate(\n                (result, np.full([len(result), 1], opacity)),\n                axis=1,\n            )\n            return result\n\n        return func"}, {"name": "VectorizedPoint", "code": "class VectorizedPoint(VMobject, metaclass=ConvertToOpenGL):\n    def __init__(\n        self,\n        location: Point3DLike = ORIGIN,\n        color: ManimColor = BLACK,\n        fill_opacity: float = 0,\n        stroke_width: float = 0,\n        artificial_width: float = 0.01,\n        artificial_height: float = 0.01,\n        **kwargs,\n    ) -> None:\n        self.artificial_width = artificial_width\n        self.artificial_height = artificial_height\n        super().__init__(\n            color=color,\n            fill_opacity=fill_opacity,\n            stroke_width=stroke_width,\n            **kwargs,\n        )\n        self.set_points(np.array([location]))\n\n    basecls = OpenGLVMobject if config.renderer == RendererType.OPENGL else VMobject\n\n    @basecls.width.getter\n    def width(self) -> float:\n        return self.artificial_width\n\n    @basecls.height.getter\n    def height(self) -> float:\n        return self.artificial_height\n\n    def get_location(self) -> Point3D:\n        return np.array(self.points[0])\n\n    def set_location(self, new_loc: Point3D):\n        self.set_points(np.array([new_loc]))"}, {"name": "VectorScene", "code": "class VectorScene(Scene):\n    def __init__(self, basis_vector_stroke_width=6, **kwargs):\n        super().__init__(**kwargs)\n        self.basis_vector_stroke_width = basis_vector_stroke_width\n\n    def add_plane(self, animate: bool = False, **kwargs):\n        \"\"\"\n        Adds a NumberPlane object to the background.\n\n        Parameters\n        ----------\n        animate\n            Whether or not to animate the addition of the plane via Create.\n        **kwargs\n            Any valid keyword arguments accepted by NumberPlane.\n\n        Returns\n        -------\n        NumberPlane\n            The NumberPlane object.\n        \"\"\"\n        plane = NumberPlane(**kwargs)\n        if animate:\n            self.play(Create(plane, lag_ratio=0.5))\n        self.add(plane)\n        return plane\n\n    def add_axes(self, animate: bool = False, color: bool = WHITE, **kwargs):\n        \"\"\"\n        Adds a pair of Axes to the Scene.\n\n        Parameters\n        ----------\n        animate\n            Whether or not to animate the addition of the axes through Create.\n        color\n            The color of the axes. Defaults to WHITE.\n        \"\"\"\n        axes = Axes(color=color, axis_config={\"unit_size\": 1})\n        if animate:\n            self.play(Create(axes))\n        self.add(axes)\n        return axes\n\n    def lock_in_faded_grid(self, dimness: float = 0.7, axes_dimness: float = 0.5):\n        \"\"\"\n        This method freezes the NumberPlane and Axes that were already\n        in the background, and adds new, manipulatable ones to the foreground.\n\n        Parameters\n        ----------\n        dimness\n            The required dimness of the NumberPlane\n\n        axes_dimness\n            The required dimness of the Axes.\n        \"\"\"\n        plane = self.add_plane()\n        axes = plane.get_axes()\n        plane.fade(dimness)\n        axes.set_color(WHITE)\n        axes.fade(axes_dimness)\n        self.add(axes)\n\n        self.renderer.update_frame()\n        self.renderer.camera = Camera(self.renderer.get_frame())\n        self.clear()\n\n    def get_vector(self, numerical_vector: np.ndarray | list | tuple, **kwargs):\n        \"\"\"\n        Returns an arrow on the Plane given an input numerical vector.\n\n        Parameters\n        ----------\n        numerical_vector\n            The Vector to plot.\n        **kwargs\n            Any valid keyword argument of Arrow.\n\n        Returns\n        -------\n        Arrow\n            The Arrow representing the Vector.\n        \"\"\"\n        return Arrow(\n            self.plane.coords_to_point(0, 0),\n            self.plane.coords_to_point(*numerical_vector[:2]),\n            buff=0,\n            **kwargs,\n        )\n\n    def add_vector(\n        self,\n        vector: Arrow | list | tuple | np.ndarray,\n        color: str = YELLOW,\n        animate: bool = True,\n        **kwargs,\n    ):\n        \"\"\"\n        Returns the Vector after adding it to the Plane.\n\n        Parameters\n        ----------\n        vector\n            It can be a pre-made graphical vector, or the\n            coordinates of one.\n\n        color\n            The string of the hex color of the vector.\n            This is only taken into consideration if\n            'vector' is not an Arrow. Defaults to YELLOW.\n\n        animate\n            Whether or not to animate the addition of the vector\n            by using GrowArrow\n\n        **kwargs\n            Any valid keyword argument of Arrow.\n            These are only considered if vector is not\n            an Arrow.\n\n        Returns\n        -------\n        Arrow\n            The arrow representing the vector.\n        \"\"\"\n        if not isinstance(vector, Arrow):\n            vector = Vector(vector, color=color, **kwargs)\n        if animate:\n            self.play(GrowArrow(vector))\n        self.add(vector)\n        return vector\n\n    def write_vector_coordinates(self, vector: Arrow, **kwargs):\n        \"\"\"\n        Returns a column matrix indicating the vector coordinates,\n        after writing them to the screen.\n\n        Parameters\n        ----------\n        vector\n            The arrow representing the vector.\n\n        **kwargs\n            Any valid keyword arguments of :meth:`~.Vector.coordinate_label`:\n\n        Returns\n        -------\n        :class:`.Matrix`\n            The column matrix representing the vector.\n        \"\"\"\n        coords = vector.coordinate_label(**kwargs)\n        self.play(Write(coords))\n        return coords\n\n    def get_basis_vectors(self, i_hat_color: str = X_COLOR, j_hat_color: str = Y_COLOR):\n        \"\"\"\n        Returns a VGroup of the Basis Vectors (1,0) and (0,1)\n\n        Parameters\n        ----------\n        i_hat_color\n            The hex colour to use for the basis vector in the x direction\n\n        j_hat_color\n            The hex colour to use for the basis vector in the y direction\n\n        Returns\n        -------\n        VGroup\n            VGroup of the Vector Mobjects representing the basis vectors.\n        \"\"\"\n        return VGroup(\n            *(\n                Vector(vect, color=color, stroke_width=self.basis_vector_stroke_width)\n                for vect, color in [([1, 0], i_hat_color), ([0, 1], j_hat_color)]\n            )\n        )\n\n    def get_basis_vector_labels(self, **kwargs):\n        \"\"\"\n        Returns naming labels for the basis vectors.\n\n        Parameters\n        ----------\n        **kwargs\n            Any valid keyword arguments of get_vector_label:\n                vector,\n                label (str,MathTex)\n                at_tip (bool=False),\n                direction (str=\"left\"),\n                rotate (bool),\n                color (str),\n                label_scale_factor=VECTOR_LABEL_SCALE_FACTOR (int, float),\n        \"\"\"\n        i_hat, j_hat = self.get_basis_vectors()\n        return VGroup(\n            *(\n                self.get_vector_label(\n                    vect, label, color=color, label_scale_factor=1, **kwargs\n                )\n                for vect, label, color in [\n                    (i_hat, \"\\\\hat{\\\\imath}\", X_COLOR),\n                    (j_hat, \"\\\\hat{\\\\jmath}\", Y_COLOR),\n                ]\n            )\n        )\n\n    def get_vector_label(\n        self,\n        vector: Vector,\n        label,\n        at_tip: bool = False,\n        direction: str = \"left\",\n        rotate: bool = False,\n        color: str | None = None,\n        label_scale_factor: float = LARGE_BUFF - 0.2,\n    ):\n        \"\"\"\n        Returns naming labels for the passed vector.\n\n        Parameters\n        ----------\n        vector\n            Vector Object for which to get the label.\n\n        at_tip\n            Whether or not to place the label at the tip of the vector.\n\n        direction\n            If the label should be on the \"left\" or right of the vector.\n        rotate\n            Whether or not to rotate it to align it with the vector.\n        color\n            The color to give the label.\n        label_scale_factor\n            How much to scale the label by.\n\n        Returns\n        -------\n        MathTex\n            The MathTex of the label.\n        \"\"\"\n        if not isinstance(label, MathTex):\n            if len(label) == 1:\n                label = \"\\\\vec{\\\\textbf{%s}}\" % label  # noqa: UP031\n            label = MathTex(label)\n            if color is None:\n                color = vector.get_color()\n            label.set_color(color)\n        label.scale(label_scale_factor)\n        label.add_background_rectangle()\n\n        if at_tip:\n            vect = vector.get_vector()\n            vect /= np.linalg.norm(vect)\n            label.next_to(vector.get_end(), vect, buff=SMALL_BUFF)\n        else:\n            angle = vector.get_angle()\n            if not rotate:\n                label.rotate(-angle, about_point=ORIGIN)\n            if direction == \"left\":\n                label.shift(-label.get_bottom() + 0.1 * UP)\n            else:\n                label.shift(-label.get_top() + 0.1 * DOWN)\n            label.rotate(angle, about_point=ORIGIN)\n            label.shift((vector.get_end() - vector.get_start()) / 2)\n        return label\n\n    def label_vector(\n        self, vector: Vector, label: MathTex | str, animate: bool = True, **kwargs\n    ):\n        \"\"\"\n        Shortcut method for creating, and animating the addition of\n        a label for the vector.\n\n        Parameters\n        ----------\n        vector\n            The vector for which the label must be added.\n\n        label\n            The MathTex/string of the label.\n\n        animate\n            Whether or not to animate the labelling w/ Write\n\n        **kwargs\n            Any valid keyword argument of get_vector_label\n\n        Returns\n        -------\n        :class:`~.MathTex`\n            The MathTex of the label.\n        \"\"\"\n        label = self.get_vector_label(vector, label, **kwargs)\n        if animate:\n            self.play(Write(label, run_time=1))\n        self.add(label)\n        return label\n\n    def position_x_coordinate(\n        self,\n        x_coord,\n        x_line,\n        vector,\n    ):  # TODO Write DocStrings for this.\n        x_coord.next_to(x_line, -np.sign(vector[1]) * UP)\n        x_coord.set_color(X_COLOR)\n        return x_coord\n\n    def position_y_coordinate(\n        self,\n        y_coord,\n        y_line,\n        vector,\n    ):  # TODO Write DocStrings for this.\n        y_coord.next_to(y_line, np.sign(vector[0]) * RIGHT)\n        y_coord.set_color(Y_COLOR)\n        return y_coord\n\n    def coords_to_vector(\n        self,\n        vector: np.ndarray | list | tuple,\n        coords_start: np.ndarray | list | tuple = 2 * RIGHT + 2 * UP,\n        clean_up: bool = True,\n    ):\n        \"\"\"\n        This method writes the vector as a column matrix (henceforth called the label),\n        takes the values in it one by one, and form the corresponding\n        lines that make up the x and y components of the vector. Then, an\n        Vector() based vector is created between the lines on the Screen.\n\n        Parameters\n        ----------\n        vector\n            The vector to show.\n\n        coords_start\n            The starting point of the location of\n            the label of the vector that shows it\n            numerically.\n            Defaults to 2 * RIGHT + 2 * UP or (2,2)\n\n        clean_up\n            Whether or not to remove whatever\n            this method did after it's done.\n\n        \"\"\"\n        starting_mobjects = list(self.mobjects)\n        array = Matrix(vector)\n        array.shift(coords_start)\n        arrow = Vector(vector)\n        x_line = Line(ORIGIN, vector[0] * RIGHT)\n        y_line = Line(x_line.get_end(), arrow.get_end())\n        x_line.set_color(X_COLOR)\n        y_line.set_color(Y_COLOR)\n        x_coord, y_coord = array.get_mob_matrix().flatten()\n\n        self.play(Write(array, run_time=1))\n        self.wait()\n        self.play(\n            ApplyFunction(\n                lambda x: self.position_x_coordinate(x, x_line, vector),\n                x_coord,\n            ),\n        )\n        self.play(Create(x_line))\n        animations = [\n            ApplyFunction(\n                lambda y: self.position_y_coordinate(y, y_line, vector),\n                y_coord,\n            ),\n            FadeOut(array.get_brackets()),\n        ]\n        self.play(*animations)\n        y_coord, _ = (anim.mobject for anim in animations)\n        self.play(Create(y_line))\n        self.play(Create(arrow))\n        self.wait()\n        if clean_up:\n            self.clear()\n            self.add(*starting_mobjects)\n\n    def vector_to_coords(\n        self,\n        vector: np.ndarray | list | tuple,\n        integer_labels: bool = True,\n        clean_up: bool = True,\n    ):\n        \"\"\"\n        This method displays vector as a Vector() based vector, and then shows\n        the corresponding lines that make up the x and y components of the vector.\n        Then, a column matrix (henceforth called the label) is created near the\n        head of the Vector.\n\n        Parameters\n        ----------\n        vector\n            The vector to show.\n\n        integer_labels\n            Whether or not to round the value displayed.\n            in the vector's label to the nearest integer\n\n        clean_up\n            Whether or not to remove whatever\n            this method did after it's done.\n\n        \"\"\"\n        starting_mobjects = list(self.mobjects)\n        show_creation = False\n        if isinstance(vector, Arrow):\n            arrow = vector\n            vector = arrow.get_end()[:2]\n        else:\n            arrow = Vector(vector)\n            show_creation = True\n        array = arrow.coordinate_label(integer_labels=integer_labels)\n        x_line = Line(ORIGIN, vector[0] * RIGHT)\n        y_line = Line(x_line.get_end(), arrow.get_end())\n        x_line.set_color(X_COLOR)\n        y_line.set_color(Y_COLOR)\n        x_coord, y_coord = array.get_entries()\n        x_coord_start = self.position_x_coordinate(x_coord.copy(), x_line, vector)\n        y_coord_start = self.position_y_coordinate(y_coord.copy(), y_line, vector)\n        brackets = array.get_brackets()\n\n        if show_creation:\n            self.play(Create(arrow))\n        self.play(Create(x_line), Write(x_coord_start), run_time=1)\n        self.play(Create(y_line), Write(y_coord_start), run_time=1)\n        self.wait()\n        self.play(\n            Transform(x_coord_start, x_coord, lag_ratio=0),\n            Transform(y_coord_start, y_coord, lag_ratio=0),\n            Write(brackets, run_time=1),\n        )\n        self.wait()\n\n        self.remove(x_coord_start, y_coord_start, brackets)\n        self.add(array)\n        if clean_up:\n            self.clear()\n            self.add(*starting_mobjects)\n        return array, x_line, y_line\n\n    def show_ghost_movement(self, vector: Arrow | list | tuple | np.ndarray):\n        \"\"\"\n        This method plays an animation that partially shows the entire plane moving\n        in the direction of a particular vector. This is useful when you wish to\n        convey the idea of mentally moving the entire plane in a direction, without\n        actually moving the plane.\n\n        Parameters\n        ----------\n        vector\n            The vector which indicates the direction of movement.\n        \"\"\"\n        if isinstance(vector, Arrow):\n            vector = vector.get_end() - vector.get_start()\n        elif len(vector) == 2:\n            vector = np.append(np.array(vector), 0.0)\n        x_max = int(config[\"frame_x_radius\"] + abs(vector[0]))\n        y_max = int(config[\"frame_y_radius\"] + abs(vector[1]))\n        dots = VMobject(\n            *(\n                Dot(x * RIGHT + y * UP)\n                for x in range(-x_max, x_max)\n                for y in range(-y_max, y_max)\n            )\n        )\n        dots.set_fill(BLACK, opacity=0)\n        dots_halfway = dots.copy().shift(vector / 2).set_fill(WHITE, 1)\n        dots_end = dots.copy().shift(vector)\n\n        self.play(Transform(dots, dots_halfway, rate_func=rush_into))\n        self.play(Transform(dots, dots_end, rate_func=rush_from))\n        self.remove(dots)"}, {"name": "VGroup", "code": "class VGroup(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A group of vectorized mobjects.\n\n    This can be used to group multiple :class:`~.VMobject` instances together\n    in order to scale, move, ... them together.\n\n    Notes\n    -----\n    When adding the same mobject more than once, repetitions are ignored.\n    Use :meth:`.Mobject.copy` to create a separate copy which can then\n    be added to the group.\n\n    Examples\n    --------\n\n    To add :class:`~.VMobject`s to a :class:`~.VGroup`, you can either use the\n    :meth:`~.VGroup.add` method, or use the `+` and `+=` operators. Similarly, you\n    can subtract elements of a VGroup via :meth:`~.VGroup.remove` method, or\n    `-` and `-=` operators:\n\n        >>> from manim import Triangle, Square, VGroup\n        >>> vg = VGroup()\n        >>> triangle, square = Triangle(), Square()\n        >>> vg.add(triangle)\n        VGroup(Triangle)\n        >>> vg + square  # a new VGroup is constructed\n        VGroup(Triangle, Square)\n        >>> vg  # not modified\n        VGroup(Triangle)\n        >>> vg += square\n        >>> vg  # modifies vg\n        VGroup(Triangle, Square)\n        >>> vg.remove(triangle)\n        VGroup(Square)\n        >>> vg - square  # a new VGroup is constructed\n        VGroup()\n        >>> vg  # not modified\n        VGroup(Square)\n        >>> vg -= square\n        >>> vg  # modifies vg\n        VGroup()\n\n    .. manim:: ArcShapeIris\n        :save_last_frame:\n\n        class ArcShapeIris(Scene):\n            def construct(self):\n                colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]\n                radius = [1 + rad * 0.1 for rad in range(len(colors))]\n\n                circles_group = VGroup()\n\n                # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]\n                circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)\n                                    for rad, col in zip(radius, colors)])\n                self.add(circles_group)\n\n    \"\"\"\n\n    def __init__(\n        self, *vmobjects: VMobject | Iterable[VMobject], **kwargs: Any\n    ) -> None:\n        super().__init__(**kwargs)\n        self.add(*vmobjects)\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({', '.join(str(mob) for mob in self.submobjects)})\"\n\n    def __str__(self) -> str:\n        return (\n            f\"{self.__class__.__name__} of {len(self.submobjects)} \"\n            f\"submobject{'s' if len(self.submobjects) > 0 else ''}\"\n        )\n\n    def add(\n        self,\n        *vmobjects: VMobject | Iterable[VMobject],\n    ) -> Self:\n        \"\"\"Checks if all passed elements are an instance, or iterables of VMobject and then adds them to submobjects\n\n        Parameters\n        ----------\n        vmobjects\n            List or iterable of VMobjects to add\n\n        Returns\n        -------\n        :class:`VGroup`\n\n        Raises\n        ------\n        TypeError\n            If one element of the list, or iterable is not an instance of VMobject\n\n        Examples\n        --------\n        The following example shows how to add individual or multiple `VMobject` instances through the `VGroup`\n        constructor and its `.add()` method.\n\n        .. manim:: AddToVGroup\n\n            class AddToVGroup(Scene):\n                def construct(self):\n                    circle_red = Circle(color=RED)\n                    circle_green = Circle(color=GREEN)\n                    circle_blue = Circle(color=BLUE)\n                    circle_red.shift(LEFT)\n                    circle_blue.shift(RIGHT)\n                    gr = VGroup(circle_red, circle_green)\n                    gr2 = VGroup(circle_blue) # Constructor uses add directly\n                    self.add(gr,gr2)\n                    self.wait()\n                    gr += gr2 # Add group to another\n                    self.play(\n                        gr.animate.shift(DOWN),\n                    )\n                    gr -= gr2 # Remove group\n                    self.play( # Animate groups separately\n                        gr.animate.shift(LEFT),\n                        gr2.animate.shift(UP),\n                    )\n                    self.play( #Animate groups without modification\n                        (gr+gr2).animate.shift(RIGHT)\n                    )\n                    self.play( # Animate group without component\n                        (gr-circle_red).animate.shift(RIGHT)\n                    )\n\n        A `VGroup` can be created using iterables as well. Keep in mind that all generated values from an\n        iterable must be an instance of `VMobject`. This is demonstrated below:\n\n        .. manim:: AddIterableToVGroupExample\n            :save_last_frame:\n\n            class AddIterableToVGroupExample(Scene):\n                def construct(self):\n                    v = VGroup(\n                        Square(),               # Singular VMobject instance\n                        [Circle(), Triangle()], # List of VMobject instances\n                        Dot(),\n                        (Dot() for _ in range(2)), # Iterable that generates VMobjects\n                    )\n                    v.arrange()\n                    self.add(v)\n\n        To facilitate this, the iterable is unpacked before its individual instances are added to the `VGroup`.\n        As a result, when you index a `VGroup`, you will never get back an iterable.\n        Instead, you will always receive `VMobject` instances, including those\n        that were part of the iterable/s that you originally added to the `VGroup`.\n        \"\"\"\n\n        def get_type_error_message(invalid_obj, invalid_indices):\n            return (\n                f\"Only values of type {vmobject_render_type.__name__} can be added \"\n                \"as submobjects of VGroup, but the value \"\n                f\"{repr(invalid_obj)} (at index {invalid_indices[1]} of \"\n                f\"parameter {invalid_indices[0]}) is of type \"\n                f\"{type(invalid_obj).__name__}.\"\n            )\n\n        vmobject_render_type = (\n            OpenGLVMobject if config.renderer == RendererType.OPENGL else VMobject\n        )\n        valid_vmobjects = []\n\n        for i, vmobject in enumerate(vmobjects):\n            if isinstance(vmobject, vmobject_render_type):\n                valid_vmobjects.append(vmobject)\n            elif isinstance(vmobject, Iterable) and not isinstance(\n                vmobject, (Mobject, OpenGLMobject)\n            ):\n                for j, subvmobject in enumerate(vmobject):\n                    if not isinstance(subvmobject, vmobject_render_type):\n                        raise TypeError(get_type_error_message(subvmobject, (i, j)))\n                    valid_vmobjects.append(subvmobject)\n            elif isinstance(vmobject, Iterable) and isinstance(\n                vmobject, (Mobject, OpenGLMobject)\n            ):\n                raise TypeError(\n                    f\"{get_type_error_message(vmobject, (i, 0))} \"\n                    \"You can try adding this value into a Group instead.\"\n                )\n            else:\n                raise TypeError(get_type_error_message(vmobject, (i, 0)))\n\n        return super().add(*valid_vmobjects)\n\n    def __add__(self, vmobject: VMobject) -> Self:\n        return VGroup(*self.submobjects, vmobject)\n\n    def __iadd__(self, vmobject: VMobject) -> Self:\n        return self.add(vmobject)\n\n    def __sub__(self, vmobject: VMobject) -> Self:\n        copy = VGroup(*self.submobjects)\n        copy.remove(vmobject)\n        return copy\n\n    def __isub__(self, vmobject: VMobject) -> Self:\n        return self.remove(vmobject)\n\n    def __setitem__(self, key: int, value: VMobject | Sequence[VMobject]) -> None:\n        \"\"\"Override the [] operator for item assignment.\n\n        Parameters\n        ----------\n        key\n            The index of the submobject to be assigned\n        value\n            The vmobject value to assign to the key\n\n        Returns\n        -------\n        None\n\n        Tests\n        -----\n        Check that item assignment does not raise error::\n            >>> vgroup = VGroup(VMobject())\n            >>> new_obj = VMobject()\n            >>> vgroup[0] = new_obj\n        \"\"\"\n        self._assert_valid_submobjects(tuplify(value))\n        self.submobjects[key] = value"}, {"name": "VideoMetadata", "code": "class VideoMetadata(TypedDict):\n    width: int\n    height: int\n    nb_frames: str\n    duration: str\n    avg_frame_rate: str\n    codec_name: str\n    pix_fmt: str"}, {"name": "view_matrix", "code": "def view_matrix(\n    translation: Point3D | None = None,\n    x_rotation: float = 0,\n    y_rotation: float = 0,\n    z_rotation: float = 0,\n) -> MatrixMN:\n    if translation is None:\n        translation = np.array([0, 0, depth / 2 + 1])\n    model_matrix = np.matmul(\n        np.matmul(\n            translation_matrix(*translation),\n            rotation_matrix(x=x_rotation, y=y_rotation, z=z_rotation),\n        ),\n        scale_matrix(),\n    )\n    return tuple(linalg.inv(model_matrix).T.ravel())"}, {"name": "visit", "code": "def visit(self: SkipManimNode, node: nodes.Element, name: str = \"\") -> None:\n    # TODO: Parent classes don't have a visit_admonition() method.\n    self.visit_admonition(node, name)  # type: ignore[attr-defined]\n    if not isinstance(node[0], nodes.title):\n        node.insert(0, nodes.title(\"skip-manim\", \"Example Placeholder\"))"}, {"name": "VMobject", "code": "class VMobject(Mobject):\n    \"\"\"A vectorized mobject.\n\n    Parameters\n    ----------\n    background_stroke_color\n        The purpose of background stroke is to have something\n        that won't overlap fill, e.g.  For text against some\n        textured background.\n    sheen_factor\n        When a color c is set, there will be a second color\n        computed based on interpolating c to WHITE by with\n        sheen_factor, and the display will gradient to this\n        secondary color in the direction of sheen_direction.\n    close_new_points\n        Indicates that it will not be displayed, but\n        that it should count in parent mobject's path\n    tolerance_for_point_equality\n        This is within a pixel\n    joint_type\n        The line joint type used to connect the curve segments\n        of this vectorized mobject. See :class:`.LineJointType`\n        for options.\n    \"\"\"\n\n    sheen_factor = 0.0\n\n    def __init__(\n        self,\n        fill_color: ParsableManimColor | None = None,\n        fill_opacity: float = 0.0,\n        stroke_color: ParsableManimColor | None = None,\n        stroke_opacity: float = 1.0,\n        stroke_width: float = DEFAULT_STROKE_WIDTH,\n        background_stroke_color: ParsableManimColor | None = BLACK,\n        background_stroke_opacity: float = 1.0,\n        background_stroke_width: float = 0,\n        sheen_factor: float = 0.0,\n        joint_type: LineJointType | None = None,\n        sheen_direction: Vector3D = UL,\n        close_new_points: bool = False,\n        pre_function_handle_to_anchor_scale_factor: float = 0.01,\n        make_smooth_after_applying_functions: bool = False,\n        background_image: Image | str | None = None,\n        shade_in_3d: bool = False,\n        # TODO, do we care about accounting for varying zoom levels?\n        tolerance_for_point_equality: float = 1e-6,\n        n_points_per_cubic_curve: int = 4,\n        cap_style: CapStyleType = CapStyleType.AUTO,\n        **kwargs: Any,\n    ):\n        self.fill_opacity = fill_opacity\n        self.stroke_opacity = stroke_opacity\n        self.stroke_width = stroke_width\n        if background_stroke_color is not None:\n            self.background_stroke_color: ManimColor = ManimColor(\n                background_stroke_color\n            )\n        self.background_stroke_opacity: float = background_stroke_opacity\n        self.background_stroke_width: float = background_stroke_width\n        self.sheen_factor: float = sheen_factor\n        self.joint_type: LineJointType = (\n            LineJointType.AUTO if joint_type is None else joint_type\n        )\n        self.sheen_direction: Vector3D = sheen_direction\n        self.close_new_points: bool = close_new_points\n        self.pre_function_handle_to_anchor_scale_factor: float = (\n            pre_function_handle_to_anchor_scale_factor\n        )\n        self.make_smooth_after_applying_functions: bool = (\n            make_smooth_after_applying_functions\n        )\n        self.background_image: Image | str | None = background_image\n        self.shade_in_3d: bool = shade_in_3d\n        self.tolerance_for_point_equality: float = tolerance_for_point_equality\n        self.n_points_per_cubic_curve: int = n_points_per_cubic_curve\n        self._bezier_t_values: npt.NDArray[float] = np.linspace(\n            0, 1, n_points_per_cubic_curve\n        )\n        self.cap_style: CapStyleType = cap_style\n        super().__init__(**kwargs)\n        self.submobjects: list[VMobject]\n\n        # TODO: Find where color overwrites are happening and remove the color doubling\n        # if \"color\" in kwargs:\n        #     fill_color = kwargs[\"color\"]\n        #     stroke_color = kwargs[\"color\"]\n        if fill_color is not None:\n            self.fill_color = ManimColor.parse(fill_color)\n        if stroke_color is not None:\n            self.stroke_color = ManimColor.parse(stroke_color)\n\n    def _assert_valid_submobjects(self, submobjects: Iterable[VMobject]) -> Self:\n        return self._assert_valid_submobjects_internal(submobjects, VMobject)\n\n    # OpenGL compatibility\n    @property\n    def n_points_per_curve(self) -> int:\n        return self.n_points_per_cubic_curve\n\n    def get_group_class(self) -> type[VGroup]:\n        return VGroup\n\n    @staticmethod\n    def get_mobject_type_class() -> type[VMobject]:\n        return VMobject\n\n    # Colors\n    def init_colors(self, propagate_colors: bool = True) -> Self:\n        self.set_fill(\n            color=self.fill_color,\n            opacity=self.fill_opacity,\n            family=propagate_colors,\n        )\n        self.set_stroke(\n            color=self.stroke_color,\n            width=self.stroke_width,\n            opacity=self.stroke_opacity,\n            family=propagate_colors,\n        )\n        self.set_background_stroke(\n            color=self.background_stroke_color,\n            width=self.background_stroke_width,\n            opacity=self.background_stroke_opacity,\n            family=propagate_colors,\n        )\n        self.set_sheen(\n            factor=self.sheen_factor,\n            direction=self.sheen_direction,\n            family=propagate_colors,\n        )\n\n        if not propagate_colors:\n            for submobject in self.submobjects:\n                submobject.init_colors(propagate_colors=False)\n\n        return self\n\n    def generate_rgbas_array(\n        self, color: ManimColor | list[ManimColor], opacity: float | Iterable[float]\n    ) -> RGBA_Array_Float:\n        \"\"\"\n        First arg can be either a color, or a tuple/list of colors.\n        Likewise, opacity can either be a float, or a tuple of floats.\n        If self.sheen_factor is not zero, and only\n        one color was passed in, a second slightly light color\n        will automatically be added for the gradient\n        \"\"\"\n        colors: list[ManimColor] = [\n            ManimColor(c) if (c is not None) else BLACK for c in tuplify(color)\n        ]\n        opacities: list[float] = [\n            o if (o is not None) else 0.0 for o in tuplify(opacity)\n        ]\n        rgbas: npt.NDArray[RGBA_Array_Float] = np.array(\n            [c.to_rgba_with_alpha(o) for c, o in zip(*make_even(colors, opacities))],\n        )\n\n        sheen_factor = self.get_sheen_factor()\n        if sheen_factor != 0 and len(rgbas) == 1:\n            light_rgbas = np.array(rgbas)\n            light_rgbas[:, :3] += sheen_factor\n            np.clip(light_rgbas, 0, 1, out=light_rgbas)\n            rgbas = np.append(rgbas, light_rgbas, axis=0)\n        return rgbas\n\n    def update_rgbas_array(\n        self,\n        array_name: str,\n        color: ManimColor | None = None,\n        opacity: float | None = None,\n    ) -> Self:\n        rgbas = self.generate_rgbas_array(color, opacity)\n        if not hasattr(self, array_name):\n            setattr(self, array_name, rgbas)\n            return self\n        # Match up current rgbas array with the newly calculated\n        # one. 99% of the time they'll be the same.\n        curr_rgbas = getattr(self, array_name)\n        if len(curr_rgbas) < len(rgbas):\n            curr_rgbas = stretch_array_to_length(curr_rgbas, len(rgbas))\n            setattr(self, array_name, curr_rgbas)\n        elif len(rgbas) < len(curr_rgbas):\n            rgbas = stretch_array_to_length(rgbas, len(curr_rgbas))\n        # Only update rgb if color was not None, and only\n        # update alpha channel if opacity was passed in\n        if color is not None:\n            curr_rgbas[:, :3] = rgbas[:, :3]\n        if opacity is not None:\n            curr_rgbas[:, 3] = rgbas[:, 3]\n        return self\n\n    def set_fill(\n        self,\n        color: ParsableManimColor | None = None,\n        opacity: float | None = None,\n        family: bool = True,\n    ) -> Self:\n        \"\"\"Set the fill color and fill opacity of a :class:`VMobject`.\n\n        Parameters\n        ----------\n        color\n            Fill color of the :class:`VMobject`.\n        opacity\n            Fill opacity of the :class:`VMobject`.\n        family\n            If ``True``, the fill color of all submobjects is also set.\n\n        Returns\n        -------\n        :class:`VMobject`\n            ``self``\n\n        Examples\n        --------\n        .. manim:: SetFill\n            :save_last_frame:\n\n            class SetFill(Scene):\n                def construct(self):\n                    square = Square().scale(2).set_fill(WHITE,1)\n                    circle1 = Circle().set_fill(GREEN,0.8)\n                    circle2 = Circle().set_fill(YELLOW) # No fill_opacity\n                    circle3 = Circle().set_fill(color = '#FF2135', opacity = 0.2)\n                    group = Group(circle1,circle2,circle3).arrange()\n                    self.add(square)\n                    self.add(group)\n\n        See Also\n        --------\n        :meth:`~.VMobject.set_style`\n        \"\"\"\n        if family:\n            for submobject in self.submobjects:\n                submobject.set_fill(color, opacity, family)\n        self.update_rgbas_array(\"fill_rgbas\", color, opacity)\n        self.fill_rgbas: RGBA_Array_Float\n        if opacity is not None:\n            self.fill_opacity = opacity\n        return self\n\n    def set_stroke(\n        self,\n        color: ParsableManimColor = None,\n        width: float | None = None,\n        opacity: float | None = None,\n        background=False,\n        family: bool = True,\n    ) -> Self:\n        if family:\n            for submobject in self.submobjects:\n                submobject.set_stroke(color, width, opacity, background, family)\n        if background:\n            array_name = \"background_stroke_rgbas\"\n            width_name = \"background_stroke_width\"\n            opacity_name = \"background_stroke_opacity\"\n        else:\n            array_name = \"stroke_rgbas\"\n            width_name = \"stroke_width\"\n            opacity_name = \"stroke_opacity\"\n        self.update_rgbas_array(array_name, color, opacity)\n        if width is not None:\n            setattr(self, width_name, width)\n        if opacity is not None:\n            setattr(self, opacity_name, opacity)\n        if color is not None and background:\n            if isinstance(color, (list, tuple)):\n                self.background_stroke_color = ManimColor.parse(color)\n            else:\n                self.background_stroke_color = ManimColor(color)\n        return self\n\n    def set_cap_style(self, cap_style: CapStyleType) -> Self:\n        \"\"\"\n        Sets the cap style of the :class:`VMobject`.\n\n        Parameters\n        ----------\n        cap_style\n            The cap style to be set. See :class:`.CapStyleType` for options.\n\n        Returns\n        -------\n        :class:`VMobject`\n            ``self``\n\n        Examples\n        --------\n        .. manim:: CapStyleExample\n            :save_last_frame:\n\n            class CapStyleExample(Scene):\n                def construct(self):\n                    line = Line(LEFT, RIGHT, color=YELLOW, stroke_width=20)\n                    line.set_cap_style(CapStyleType.ROUND)\n                    self.add(line)\n        \"\"\"\n        self.cap_style = cap_style\n        return self\n\n    def set_background_stroke(self, **kwargs) -> Self:\n        kwargs[\"background\"] = True\n        self.set_stroke(**kwargs)\n        return self\n\n    def set_style(\n        self,\n        fill_color: ParsableManimColor | None = None,\n        fill_opacity: float | None = None,\n        stroke_color: ParsableManimColor | None = None,\n        stroke_width: float | None = None,\n        stroke_opacity: float | None = None,\n        background_stroke_color: ParsableManimColor | None = None,\n        background_stroke_width: float | None = None,\n        background_stroke_opacity: float | None = None,\n        sheen_factor: float | None = None,\n        sheen_direction: Vector3D | None = None,\n        background_image: Image | str | None = None,\n        family: bool = True,\n    ) -> Self:\n        self.set_fill(color=fill_color, opacity=fill_opacity, family=family)\n        self.set_stroke(\n            color=stroke_color,\n            width=stroke_width,\n            opacity=stroke_opacity,\n            family=family,\n        )\n        self.set_background_stroke(\n            color=background_stroke_color,\n            width=background_stroke_width,\n            opacity=background_stroke_opacity,\n            family=family,\n        )\n        if sheen_factor:\n            self.set_sheen(\n                factor=sheen_factor,\n                direction=sheen_direction,\n                family=family,\n            )\n        if background_image:\n            self.color_using_background_image(background_image)\n        return self\n\n    def get_style(self, simple: bool = False) -> dict:\n        ret = {\n            \"stroke_opacity\": self.get_stroke_opacity(),\n            \"stroke_width\": self.get_stroke_width(),\n        }\n\n        # TODO: FIX COLORS HERE\n        if simple:\n            ret[\"fill_color\"] = self.get_fill_color()\n            ret[\"fill_opacity\"] = self.get_fill_opacity()\n            ret[\"stroke_color\"] = self.get_stroke_color()\n        else:\n            ret[\"fill_color\"] = self.get_fill_colors()\n            ret[\"fill_opacity\"] = self.get_fill_opacities()\n            ret[\"stroke_color\"] = self.get_stroke_colors()\n            ret[\"background_stroke_color\"] = self.get_stroke_colors(background=True)\n            ret[\"background_stroke_width\"] = self.get_stroke_width(background=True)\n            ret[\"background_stroke_opacity\"] = self.get_stroke_opacity(background=True)\n            ret[\"sheen_factor\"] = self.get_sheen_factor()\n            ret[\"sheen_direction\"] = self.get_sheen_direction()\n            ret[\"background_image\"] = self.get_background_image()\n\n        return ret\n\n    def match_style(self, vmobject: VMobject, family: bool = True) -> Self:\n        self.set_style(**vmobject.get_style(), family=False)\n\n        if family:\n            # Does its best to match up submobject lists, and\n            # match styles accordingly\n            submobs1, submobs2 = self.submobjects, vmobject.submobjects\n            if len(submobs1) == 0:\n                return self\n            elif len(submobs2) == 0:\n                submobs2 = [vmobject]\n            for sm1, sm2 in zip(*make_even(submobs1, submobs2)):\n                sm1.match_style(sm2)\n        return self\n\n    def set_color(self, color: ParsableManimColor, family: bool = True) -> Self:\n        self.set_fill(color, family=family)\n        self.set_stroke(color, family=family)\n        return self\n\n    def set_opacity(self, opacity: float, family: bool = True) -> Self:\n        self.set_fill(opacity=opacity, family=family)\n        self.set_stroke(opacity=opacity, family=family)\n        self.set_stroke(opacity=opacity, family=family, background=True)\n        return self\n\n    def scale(self, scale_factor: float, scale_stroke: bool = False, **kwargs) -> Self:\n        r\"\"\"Scale the size by a factor.\n\n        Default behavior is to scale about the center of the vmobject.\n\n        Parameters\n        ----------\n        scale_factor\n            The scaling factor :math:`\\alpha`. If :math:`0 < |\\alpha|\u00a0< 1`, the mobject\n            will shrink, and for :math:`|\\alpha| > 1` it will grow. Furthermore,\n            if :math:`\\alpha < 0`, the mobject is also flipped.\n        scale_stroke\n            Boolean determining if the object's outline is scaled when the object is scaled.\n            If enabled, and object with 2px outline is scaled by a factor of .5, it will have an outline of 1px.\n        kwargs\n            Additional keyword arguments passed to\n            :meth:`~.Mobject.scale`.\n\n        Returns\n        -------\n        :class:`VMobject`\n            ``self``\n\n        Examples\n        --------\n\n        .. manim:: MobjectScaleExample\n            :save_last_frame:\n\n            class MobjectScaleExample(Scene):\n                def construct(self):\n                    c1 = Circle(1, RED).set_x(-1)\n                    c2 = Circle(1, GREEN).set_x(1)\n\n                    vg = VGroup(c1, c2)\n                    vg.set_stroke(width=50)\n                    self.add(vg)\n\n                    self.play(\n                        c1.animate.scale(.25),\n                        c2.animate.scale(.25,\n                            scale_stroke=True)\n                    )\n\n        See also\n        --------\n        :meth:`move_to`\n\n        \"\"\"\n        if scale_stroke:\n            self.set_stroke(width=abs(scale_factor) * self.get_stroke_width())\n            self.set_stroke(\n                width=abs(scale_factor) * self.get_stroke_width(background=True),\n                background=True,\n            )\n        super().scale(scale_factor, **kwargs)\n        return self\n\n    def fade(self, darkness: float = 0.5, family: bool = True) -> Self:\n        factor = 1.0 - darkness\n        self.set_fill(opacity=factor * self.get_fill_opacity(), family=False)\n        self.set_stroke(opacity=factor * self.get_stroke_opacity(), family=False)\n        self.set_background_stroke(\n            opacity=factor * self.get_stroke_opacity(background=True),\n            family=False,\n        )\n        super().fade(darkness, family)\n        return self\n\n    def get_fill_rgbas(self) -> RGBA_Array_Float | Zeros:\n        try:\n            return self.fill_rgbas\n        except AttributeError:\n            return np.zeros((1, 4))\n\n    def get_fill_color(self) -> ManimColor:\n        \"\"\"\n        If there are multiple colors (for gradient)\n        this returns the first one\n        \"\"\"\n        return self.get_fill_colors()[0]\n\n    fill_color = property(get_fill_color, set_fill)\n\n    def get_fill_opacity(self) -> ManimFloat:\n        \"\"\"\n        If there are multiple opacities, this returns the\n        first\n        \"\"\"\n        return self.get_fill_opacities()[0]\n\n    # TODO: Does this just do a copy?\n    # TODO: I have the feeling that this function should not return None, does that have any usage ?\n    def get_fill_colors(self) -> list[ManimColor | None]:\n        return [\n            ManimColor(rgba[:3]) if rgba.any() else None\n            for rgba in self.get_fill_rgbas()\n        ]\n\n    def get_fill_opacities(self) -> npt.NDArray[ManimFloat]:\n        return self.get_fill_rgbas()[:, 3]\n\n    def get_stroke_rgbas(self, background: bool = False) -> RGBA_Array_float | Zeros:\n        try:\n            if background:\n                self.background_stroke_rgbas: RGBA_Array_Float\n                rgbas = self.background_stroke_rgbas\n            else:\n                self.stroke_rgbas: RGBA_Array_Float\n                rgbas = self.stroke_rgbas\n            return rgbas\n        except AttributeError:\n            return np.zeros((1, 4))\n\n    def get_stroke_color(self, background: bool = False) -> ManimColor | None:\n        return self.get_stroke_colors(background)[0]\n\n    stroke_color = property(get_stroke_color, set_stroke)\n\n    def get_stroke_width(self, background: bool = False) -> float:\n        if background:\n            self.background_stroke_width: float\n            width = self.background_stroke_width\n        else:\n            width = self.stroke_width\n            if isinstance(width, str):\n                width = int(width)\n        return max(0.0, width)\n\n    def get_stroke_opacity(self, background: bool = False) -> ManimFloat:\n        return self.get_stroke_opacities(background)[0]\n\n    def get_stroke_colors(self, background: bool = False) -> list[ManimColor | None]:\n        return [\n            ManimColor(rgba[:3]) if rgba.any() else None\n            for rgba in self.get_stroke_rgbas(background)\n        ]\n\n    def get_stroke_opacities(self, background: bool = False) -> npt.NDArray[ManimFloat]:\n        return self.get_stroke_rgbas(background)[:, 3]\n\n    def get_color(self) -> ManimColor:\n        if np.all(self.get_fill_opacities() == 0):\n            return self.get_stroke_color()\n        return self.get_fill_color()\n\n    color = property(get_color, set_color)\n\n    def set_sheen_direction(self, direction: Vector3D, family: bool = True) -> Self:\n        \"\"\"Sets the direction of the applied sheen.\n\n        Parameters\n        ----------\n        direction\n            Direction from where the gradient is applied.\n\n        Examples\n        --------\n        Normal usage::\n\n            Circle().set_sheen_direction(UP)\n\n        See Also\n        --------\n        :meth:`~.VMobject.set_sheen`\n        :meth:`~.VMobject.rotate_sheen_direction`\n        \"\"\"\n        direction = np.array(direction)\n        if family:\n            for submob in self.get_family():\n                submob.sheen_direction = direction\n        else:\n            self.sheen_direction: Vector3D = direction\n        return self\n\n    def rotate_sheen_direction(\n        self, angle: float, axis: Vector3D = OUT, family: bool = True\n    ) -> Self:\n        \"\"\"Rotates the direction of the applied sheen.\n\n        Parameters\n        ----------\n        angle\n            Angle by which the direction of sheen is rotated.\n        axis\n            Axis of rotation.\n\n        Examples\n        --------\n        Normal usage::\n\n            Circle().set_sheen_direction(UP).rotate_sheen_direction(PI)\n\n        See Also\n        --------\n        :meth:`~.VMobject.set_sheen_direction`\n        \"\"\"\n        if family:\n            for submob in self.get_family():\n                submob.sheen_direction = rotate_vector(\n                    submob.sheen_direction,\n                    angle,\n                    axis,\n                )\n        else:\n            self.sheen_direction = rotate_vector(self.sheen_direction, angle, axis)\n        return self\n\n    def set_sheen(\n        self, factor: float, direction: Vector3D | None = None, family: bool = True\n    ) -> Self:\n        \"\"\"Applies a color gradient from a direction.\n\n        Parameters\n        ----------\n        factor\n            The extent of lustre/gradient to apply. If negative, the gradient\n            starts from black, if positive the gradient starts from white and\n            changes to the current color.\n        direction\n            Direction from where the gradient is applied.\n\n        Examples\n        --------\n        .. manim:: SetSheen\n            :save_last_frame:\n\n            class SetSheen(Scene):\n                def construct(self):\n                    circle = Circle(fill_opacity=1).set_sheen(-0.3, DR)\n                    self.add(circle)\n        \"\"\"\n        if family:\n            for submob in self.submobjects:\n                submob.set_sheen(factor, direction, family)\n        self.sheen_factor: float = factor\n        if direction is not None:\n            # family set to false because recursion will\n            # already be handled above\n            self.set_sheen_direction(direction, family=False)\n        # Reset color to put sheen_factor into effect\n        if factor != 0:\n            self.set_stroke(self.get_stroke_color(), family=family)\n            self.set_fill(self.get_fill_color(), family=family)\n        return self\n\n    def get_sheen_direction(self) -> Vector3D:\n        return np.array(self.sheen_direction)\n\n    def get_sheen_factor(self) -> float:\n        return self.sheen_factor\n\n    def get_gradient_start_and_end_points(self) -> tuple[Point3D, Point3D]:\n        if self.shade_in_3d:\n            return get_3d_vmob_gradient_start_and_end_points(self)\n        else:\n            direction = self.get_sheen_direction()\n            c = self.get_center()\n            bases = np.array(\n                [self.get_edge_center(vect) - c for vect in [RIGHT, UP, OUT]],\n            ).transpose()\n            offset = np.dot(bases, direction)\n            return (c - offset, c + offset)\n\n    def color_using_background_image(self, background_image: Image | str) -> Self:\n        self.background_image: Image | str = background_image\n        self.set_color(WHITE)\n        for submob in self.submobjects:\n            submob.color_using_background_image(background_image)\n        return self\n\n    def get_background_image(self) -> Image | str:\n        return self.background_image\n\n    def match_background_image(self, vmobject: VMobject) -> Self:\n        self.color_using_background_image(vmobject.get_background_image())\n        return self\n\n    def set_shade_in_3d(\n        self, value: bool = True, z_index_as_group: bool = False\n    ) -> Self:\n        for submob in self.get_family():\n            submob.shade_in_3d = value\n            if z_index_as_group:\n                submob.z_index_group = self\n        return self\n\n    def set_points(self, points: Point3DLike_Array) -> Self:\n        self.points: Point3D_Array = np.array(points)\n        return self\n\n    def resize_points(\n        self,\n        new_length: int,\n        resize_func: Callable[[Point3D_Array, int], Point3D_Array] = resize_array,\n    ) -> Self:\n        \"\"\"Resize the array of anchor points and handles to have\n        the specified size.\n\n        Parameters\n        ----------\n        new_length\n            The new (total) number of points.\n        resize_func\n            A function mapping a Numpy array (the points) and an integer\n            (the target size) to a Numpy array. The default implementation\n            is based on Numpy's ``resize`` function.\n        \"\"\"\n        if new_length != len(self.points):\n            self.points = resize_func(self.points, new_length)\n        return self\n\n    def set_anchors_and_handles(\n        self,\n        anchors1: Point3DLike_Array,\n        handles1: Point3DLike_Array,\n        handles2: Point3DLike_Array,\n        anchors2: Point3DLike_Array,\n    ) -> Self:\n        \"\"\"Given two sets of anchors and handles, process them to set them as anchors\n        and handles of the VMobject.\n\n        anchors1[i], handles1[i], handles2[i] and anchors2[i] define the i-th bezier\n        curve of the vmobject. There are four hardcoded parameters and this is a\n        problem as it makes the number of points per cubic curve unchangeable from 4\n        (two anchors and two handles).\n\n        Returns\n        -------\n        :class:`VMobject`\n            ``self``\n        \"\"\"\n        assert len(anchors1) == len(handles1) == len(handles2) == len(anchors2)\n        nppcc = self.n_points_per_cubic_curve  # 4\n        total_len = nppcc * len(anchors1)\n        self.points = np.empty((total_len, self.dim))\n        # the following will, from the four sets, dispatch them in points such that\n        # self.points = [\n        #     anchors1[0], handles1[0], handles2[0], anchors1[0], anchors1[1],\n        #     handles1[1], ...\n        # ]\n        arrays = [anchors1, handles1, handles2, anchors2]\n        for index, array in enumerate(arrays):\n            self.points[index::nppcc] = array\n        return self\n\n    def clear_points(self) -> None:\n        # TODO: shouldn't this return self instead of None?\n        self.points = np.zeros((0, self.dim))\n\n    def append_points(self, new_points: Point3DLike_Array) -> Self:\n        \"\"\"Append the given ``new_points`` to the end of\n        :attr:`VMobject.points`.\n\n        Parameters\n        ----------\n        new_points\n            An array of 3D points to append.\n\n        Returns\n        -------\n        :class:`VMobject`\n            The VMobject itself, after appending ``new_points``.\n        \"\"\"\n        # TODO, check that number new points is a multiple of 4?\n        # or else that if len(self.points) % 4 == 1, then\n        # len(new_points) % 4 == 3?\n        n = len(self.points)\n        points = np.empty((n + len(new_points), self.dim))\n        points[:n] = self.points\n        points[n:] = new_points\n        self.points = points\n        return self\n\n    def start_new_path(self, point: Point3DLike) -> Self:\n        \"\"\"Append a ``point`` to the :attr:`VMobject.points`, which will be the\n        beginning of a new B\u00e9zier curve in the path given by the points. If\n        there's an unfinished curve at the end of :attr:`VMobject.points`,\n        complete it by appending the last B\u00e9zier curve's start anchor as many\n        times as needed.\n\n        Parameters\n        ----------\n        point\n            A 3D point to append to :attr:`VMobject.points`.\n\n        Returns\n        -------\n        :class:`VMobject`\n            The VMobject itself, after appending ``point`` and starting a new\n            curve.\n        \"\"\"\n        n_points = len(self.points)\n        nppc = self.n_points_per_curve\n        if n_points % nppc != 0:\n            # close the open path by appending the last\n            # start anchor sufficiently often\n            last_anchor = self.get_start_anchors()[-1]\n            closure = [last_anchor] * (nppc - (n_points % nppc))\n            self.append_points(closure + [point])\n        else:\n            self.append_points([point])\n        return self\n\n    def add_cubic_bezier_curve(\n        self,\n        anchor1: Point3DLike,\n        handle1: Point3DLike,\n        handle2: Point3DLike,\n        anchor2: Point3DLike,\n    ) -> None:\n        # TODO, check the len(self.points) % 4 == 0?\n        self.append_points([anchor1, handle1, handle2, anchor2])\n\n    # what type is curves?\n    def add_cubic_bezier_curves(self, curves) -> None:\n        self.append_points(curves.flatten())\n\n    def add_cubic_bezier_curve_to(\n        self,\n        handle1: Point3DLike,\n        handle2: Point3DLike,\n        anchor: Point3DLike,\n    ) -> Self:\n        \"\"\"Add cubic bezier curve to the path.\n\n        NOTE : the first anchor is not a parameter as by default the end of the last sub-path!\n\n        Parameters\n        ----------\n        handle1\n            first handle\n        handle2\n            second handle\n        anchor\n            anchor\n\n        Returns\n        -------\n        :class:`VMobject`\n            ``self``\n        \"\"\"\n        self.throw_error_if_no_points()\n        new_points = [handle1, handle2, anchor]\n        if self.has_new_path_started():\n            self.append_points(new_points)\n        else:\n            self.append_points([self.get_last_point()] + new_points)\n        return self\n\n    def add_quadratic_bezier_curve_to(\n        self,\n        handle: Point3DLike,\n        anchor: Point3DLike,\n    ) -> Self:\n        \"\"\"Add Quadratic bezier curve to the path.\n\n        Returns\n        -------\n        :class:`VMobject`\n            ``self``\n        \"\"\"\n        # How does one approximate a quadratic with a cubic?\n        # refer to the Wikipedia page on Bezier curves\n        # https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Degree_elevation, accessed Jan 20, 2021\n        # 1. Copy the end points, and then\n        # 2. Place the 2 middle control points 2/3 along the line segments\n        # from the end points to the quadratic curve's middle control point.\n        # I think that's beautiful.\n        self.add_cubic_bezier_curve_to(\n            2 / 3 * handle + 1 / 3 * self.get_last_point(),\n            2 / 3 * handle + 1 / 3 * anchor,\n            anchor,\n        )\n        return self\n\n    def add_line_to(self, point: Point3DLike) -> Self:\n        \"\"\"Add a straight line from the last point of VMobject to the given point.\n\n        Parameters\n        ----------\n\n        point\n            The end of the straight line.\n\n        Returns\n        -------\n        :class:`VMobject`\n            ``self``\n        \"\"\"\n        self.add_cubic_bezier_curve_to(\n            *(\n                interpolate(self.get_last_point(), point, t)\n                for t in self._bezier_t_values[1:]\n            )\n        )\n        return self\n\n    def add_smooth_curve_to(self, *points: Point3DLike) -> Self:\n        \"\"\"Creates a smooth curve from given points and add it to the VMobject. If two points are passed in, the first is interpreted\n        as a handle, the second as an anchor.\n\n        Parameters\n        ----------\n        points\n            Points (anchor and handle, or just anchor) to add a smooth curve from\n\n        Returns\n        -------\n        :class:`VMobject`\n            ``self``\n\n        Raises\n        ------\n        ValueError\n            If 0 or more than 2 points are given.\n        \"\"\"\n        # TODO remove the value error and just add two parameters with one optional\n        if len(points) == 1:\n            handle2 = None\n            new_anchor = points[0]\n        elif len(points) == 2:\n            handle2, new_anchor = points\n        else:\n            name = sys._getframe(0).f_code.co_name\n            raise ValueError(f\"Only call {name} with 1 or 2 points\")\n\n        if self.has_new_path_started():\n            self.add_line_to(new_anchor)\n        else:\n            self.throw_error_if_no_points()\n            last_h2, last_a2 = self.points[-2:]\n            last_tangent = last_a2 - last_h2\n            handle1 = last_a2 + last_tangent\n            if handle2 is None:\n                to_anchor_vect = new_anchor - last_a2\n                new_tangent = rotate_vector(last_tangent, PI, axis=to_anchor_vect)\n                handle2 = new_anchor - new_tangent\n            self.append_points([last_a2, handle1, handle2, new_anchor])\n        return self\n\n    def has_new_path_started(self) -> bool:\n        nppcc = self.n_points_per_cubic_curve  # 4\n        # A new path starting is defined by a control point which is not part of a bezier subcurve.\n        return len(self.points) % nppcc == 1\n\n    def get_last_point(self) -> Point3D:\n        return self.points[-1]\n\n    def is_closed(self) -> bool:\n        # TODO use consider_points_equals_2d ?\n        return self.consider_points_equals(self.points[0], self.points[-1])\n\n    def close_path(self) -> None:\n        if not self.is_closed():\n            self.add_line_to(self.get_subpaths()[-1][0])\n\n    def add_points_as_corners(self, points: Point3DLike_Array) -> Self:\n        \"\"\"Append multiple straight lines at the end of\n        :attr:`VMobject.points`, which connect the given ``points`` in order\n        starting from the end of the current path. These ``points`` would be\n        therefore the corners of the new polyline appended to the path.\n\n        Parameters\n        ----------\n        points\n            An array of 3D points representing the corners of the polyline to\n            append to :attr:`VMobject.points`.\n\n        Returns\n        -------\n        :class:`VMobject`\n            The VMobject itself, after appending the straight lines to its\n            path.\n        \"\"\"\n        self.throw_error_if_no_points()\n\n        points = np.asarray(points).reshape(-1, self.dim)\n        num_points = points.shape[0]\n        if num_points == 0:\n            return self\n\n        start_corners = np.empty((num_points, self.dim))\n        start_corners[0] = self.points[-1]\n        start_corners[1:] = points[:-1]\n        end_corners = points\n\n        if self.has_new_path_started():\n            # Remove the last point from the new path\n            self.points = self.points[:-1]\n\n        nppcc = self.n_points_per_cubic_curve\n        new_points = np.empty((nppcc * start_corners.shape[0], self.dim))\n        new_points[::nppcc] = start_corners\n        new_points[nppcc - 1 :: nppcc] = end_corners\n        for i, t in enumerate(self._bezier_t_values):\n            new_points[i::nppcc] = interpolate(start_corners, end_corners, t)\n\n        self.append_points(new_points)\n        return self\n\n    def set_points_as_corners(self, points: Point3DLike_Array) -> Self:\n        \"\"\"Given an array of points, set them as corners of the\n        :class:`VMobject`.\n\n        To achieve that, this algorithm sets handles aligned with the anchors\n        such that the resultant B\u00e9zier curve will be the segment between the\n        two anchors.\n\n        Parameters\n        ----------\n        points\n            Array of points that will be set as corners.\n\n        Returns\n        -------\n        :class:`VMobject`\n            The VMobject itself, after setting the new points as corners.\n\n\n        Examples\n        --------\n        .. manim:: PointsAsCornersExample\n            :save_last_frame:\n\n            class PointsAsCornersExample(Scene):\n                def construct(self):\n                    corners = (\n                        # create square\n                        UR, UL,\n                        DL, DR,\n                        UR,\n                        # create crosses\n                        DL, UL,\n                        DR\n                    )\n                    vmob = VMobject(stroke_color=RED)\n                    vmob.set_points_as_corners(corners).scale(2)\n                    self.add(vmob)\n        \"\"\"\n        points = np.array(points)\n        # This will set the handles aligned with the anchors.\n        # Id est, a bezier curve will be the segment from the two anchors such that the handles belongs to this segment.\n        self.set_anchors_and_handles(\n            *(interpolate(points[:-1], points[1:], t) for t in self._bezier_t_values)\n        )\n        return self\n\n    def set_points_smoothly(self, points: Point3DLike_Array) -> Self:\n        self.set_points_as_corners(points)\n        self.make_smooth()\n        return self\n\n    def change_anchor_mode(self, mode: Literal[\"jagged\", \"smooth\"]) -> Self:\n        \"\"\"Changes the anchor mode of the bezier curves. This will modify the handles.\n\n        There can be only two modes, \"jagged\", and \"smooth\".\n\n        Returns\n        -------\n        :class:`VMobject`\n            ``self``\n        \"\"\"\n        assert mode in [\"jagged\", \"smooth\"], 'mode must be either \"jagged\" or \"smooth\"'\n        nppcc = self.n_points_per_cubic_curve\n        for submob in self.family_members_with_points():\n            subpaths = submob.get_subpaths()\n            submob.clear_points()\n            # A subpath can be composed of several bezier curves.\n            for subpath in subpaths:\n                # This will retrieve the anchors of the subpath, by selecting every n element in the array subpath\n                # The append is needed as the last element is not reached when slicing with numpy.\n                anchors = np.append(subpath[::nppcc], subpath[-1:], 0)\n                if mode == \"smooth\":\n                    h1, h2 = get_smooth_cubic_bezier_handle_points(anchors)\n                else:  # mode == \"jagged\"\n                    # The following will make the handles aligned with the anchors, thus making the bezier curve a segment\n                    a1 = anchors[:-1]\n                    a2 = anchors[1:]\n                    h1 = interpolate(a1, a2, 1.0 / 3)\n                    h2 = interpolate(a1, a2, 2.0 / 3)\n                new_subpath = np.array(subpath)\n                new_subpath[1::nppcc] = h1\n                new_subpath[2::nppcc] = h2\n                submob.append_points(new_subpath)\n        return self\n\n    def make_smooth(self) -> Self:\n        return self.change_anchor_mode(\"smooth\")\n\n    def make_jagged(self) -> Self:\n        return self.change_anchor_mode(\"jagged\")\n\n    def add_subpath(self, points: CubicBezierPathLike) -> Self:\n        assert len(points) % 4 == 0\n        self.append_points(points)\n        return self\n\n    def append_vectorized_mobject(self, vectorized_mobject: VMobject) -> None:\n        if self.has_new_path_started():\n            # Remove last point, which is starting\n            # a new path\n            self.points = self.points[:-1]\n        self.append_points(vectorized_mobject.points)\n\n    def apply_function(self, function: MappingFunction) -> Self:\n        factor = self.pre_function_handle_to_anchor_scale_factor\n        self.scale_handle_to_anchor_distances(factor)\n        super().apply_function(function)\n        self.scale_handle_to_anchor_distances(1.0 / factor)\n        if self.make_smooth_after_applying_functions:\n            self.make_smooth()\n        return self\n\n    def rotate(\n        self,\n        angle: float,\n        axis: Vector3D = OUT,\n        about_point: Point3DLike | None = None,\n        **kwargs,\n    ) -> Self:\n        self.rotate_sheen_direction(angle, axis)\n        super().rotate(angle, axis, about_point, **kwargs)\n        return self\n\n    def scale_handle_to_anchor_distances(self, factor: float) -> Self:\n        \"\"\"If the distance between a given handle point H and its associated\n        anchor point A is d, then it changes H to be a distances factor*d\n        away from A, but so that the line from A to H doesn't change.\n        This is mostly useful in the context of applying a (differentiable)\n        function, to preserve tangency properties.  One would pull all the\n        handles closer to their anchors, apply the function then push them out\n        again.\n\n        Parameters\n        ----------\n        factor\n            The factor used for scaling.\n\n        Returns\n        -------\n        :class:`VMobject`\n            ``self``\n        \"\"\"\n        for submob in self.family_members_with_points():\n            if len(submob.points) < self.n_points_per_cubic_curve:\n                # The case that a bezier quad is not complete (there is no bezier curve as there is not enough control points.)\n                continue\n            a1, h1, h2, a2 = submob.get_anchors_and_handles()\n            a1_to_h1 = h1 - a1\n            a2_to_h2 = h2 - a2\n            new_h1 = a1 + factor * a1_to_h1\n            new_h2 = a2 + factor * a2_to_h2\n            submob.set_anchors_and_handles(a1, new_h1, new_h2, a2)\n        return self\n\n    #\n    def consider_points_equals(self, p0: Point3DLike, p1: Point3DLike) -> bool:\n        return np.allclose(p0, p1, atol=self.tolerance_for_point_equality)\n\n    def consider_points_equals_2d(self, p0: Point2DLike, p1: Point2DLike) -> bool:\n        \"\"\"Determine if two points are close enough to be considered equal.\n\n        This uses the algorithm from np.isclose(), but expanded here for the\n        2D point case. NumPy is overkill for such a small question.\n        Parameters\n        ----------\n        p0\n            first point\n        p1\n            second point\n\n        Returns\n        -------\n        bool\n            whether two points considered close.\n        \"\"\"\n        rtol = 1.0e-5  # default from np.isclose()\n        atol = self.tolerance_for_point_equality\n        if abs(p0[0] - p1[0]) > atol + rtol * abs(p1[0]):\n            return False\n        return abs(p0[1] - p1[1]) <= atol + rtol * abs(p1[1])\n\n    # Information about line\n    def get_cubic_bezier_tuples_from_points(\n        self, points: CubicBezierPathLike\n    ) -> CubicBezierPoints_Array:\n        return np.array(self.gen_cubic_bezier_tuples_from_points(points))\n\n    def gen_cubic_bezier_tuples_from_points(\n        self, points: CubicBezierPathLike\n    ) -> tuple[CubicBezierPointsLike, ...]:\n        \"\"\"Returns the bezier tuples from an array of points.\n\n        self.points is a list of the anchors and handles of the bezier curves of the mobject (ie [anchor1, handle1, handle2, anchor2, anchor3 ..])\n        This algorithm basically retrieve them by taking an element every n, where n is the number of control points\n        of the bezier curve.\n\n\n        Parameters\n        ----------\n        points\n            Points from which control points will be extracted.\n\n        Returns\n        -------\n        tuple\n            Bezier control points.\n        \"\"\"\n        nppcc = self.n_points_per_cubic_curve\n        remainder = len(points) % nppcc\n        points = points[: len(points) - remainder]\n        # Basically take every nppcc element.\n        return tuple(points[i : i + nppcc] for i in range(0, len(points), nppcc))\n\n    def get_cubic_bezier_tuples(self) -> CubicBezierPoints_Array:\n        return self.get_cubic_bezier_tuples_from_points(self.points)\n\n    def _gen_subpaths_from_points(\n        self,\n        points: CubicBezierPath,\n        filter_func: Callable[[int], bool],\n    ) -> Iterable[CubicSpline]:\n        \"\"\"Given an array of points defining the bezier curves of the vmobject, return subpaths formed by these points.\n        Here, Two bezier curves form a path if at least two of their anchors are evaluated True by the relation defined by filter_func.\n\n        The algorithm every bezier tuple (anchors and handles) in ``self.points`` (by regrouping each n elements, where\n        n is the number of points per cubic curve)), and evaluate the relation between two anchors with filter_func.\n        NOTE : The filter_func takes an int n as parameter, and will evaluate the relation between points[n] and points[n - 1]. This should probably be changed so\n        the function takes two points as parameters.\n\n        Parameters\n        ----------\n        points\n            points defining the bezier curve.\n        filter_func\n            Filter-func defining the relation.\n\n        Returns\n        -------\n        Iterable[CubicSpline]\n            subpaths formed by the points.\n        \"\"\"\n        nppcc = self.n_points_per_cubic_curve\n        filtered = filter(filter_func, range(nppcc, len(points), nppcc))\n        split_indices = [0] + list(filtered) + [len(points)]\n        return (\n            points[i1:i2]\n            for i1, i2 in zip(split_indices, split_indices[1:])\n            if (i2 - i1) >= nppcc\n        )\n\n    def get_subpaths_from_points(self, points: CubicBezierPath) -> list[CubicSpline]:\n        return list(\n            self._gen_subpaths_from_points(\n                points,\n                lambda n: not self.consider_points_equals(points[n - 1], points[n]),\n            ),\n        )\n\n    def gen_subpaths_from_points_2d(\n        self, points: CubicBezierPath\n    ) -> Iterable[CubicSpline]:\n        return self._gen_subpaths_from_points(\n            points,\n            lambda n: not self.consider_points_equals_2d(points[n - 1], points[n]),\n        )\n\n    def get_subpaths(self) -> list[CubicSpline]:\n        \"\"\"Returns subpaths formed by the curves of the VMobject.\n\n        Subpaths are ranges of curves with each pair of consecutive curves having their end/start points coincident.\n\n        Returns\n        -------\n        list[CubicSpline]\n            subpaths.\n        \"\"\"\n        return self.get_subpaths_from_points(self.points)\n\n    def get_nth_curve_points(self, n: int) -> CubicBezierPoints:\n        \"\"\"Returns the points defining the nth curve of the vmobject.\n\n        Parameters\n        ----------\n        n\n            index of the desired bezier curve.\n\n        Returns\n        -------\n        CubicBezierPoints\n            points defining the nth bezier curve (anchors, handles)\n        \"\"\"\n        assert n < self.get_num_curves()\n        nppcc = self.n_points_per_cubic_curve\n        return self.points[nppcc * n : nppcc * (n + 1)]\n\n    def get_nth_curve_function(self, n: int) -> Callable[[float], Point3D]:\n        \"\"\"Returns the expression of the nth curve.\n\n        Parameters\n        ----------\n        n\n            index of the desired curve.\n\n        Returns\n        -------\n        Callable[float, Point3D]\n            expression of the nth bezier curve.\n        \"\"\"\n        return bezier(self.get_nth_curve_points(n))\n\n    def get_nth_curve_length_pieces(\n        self,\n        n: int,\n        sample_points: int | None = None,\n    ) -> npt.NDArray[ManimFloat]:\n        \"\"\"Returns the array of short line lengths used for length approximation.\n\n        Parameters\n        ----------\n        n\n            The index of the desired curve.\n        sample_points\n            The number of points to sample to find the length.\n\n        Returns\n        -------\n            The short length-pieces of the nth curve.\n        \"\"\"\n        if sample_points is None:\n            sample_points = 10\n\n        curve = self.get_nth_curve_function(n)\n        points = np.array([curve(a) for a in np.linspace(0, 1, sample_points)])\n        diffs = points[1:] - points[:-1]\n        norms = np.linalg.norm(diffs, axis=1)\n\n        return norms\n\n    def get_nth_curve_length(\n        self,\n        n: int,\n        sample_points: int | None = None,\n    ) -> float:\n        \"\"\"Returns the (approximate) length of the nth curve.\n\n        Parameters\n        ----------\n        n\n            The index of the desired curve.\n        sample_points\n            The number of points to sample to find the length.\n\n        Returns\n        -------\n        length : :class:`float`\n            The length of the nth curve.\n        \"\"\"\n        _, length = self.get_nth_curve_function_with_length(n, sample_points)\n\n        return length\n\n    def get_nth_curve_function_with_length(\n        self,\n        n: int,\n        sample_points: int | None = None,\n    ) -> tuple[Callable[[float], Point3D], float]:\n        \"\"\"Returns the expression of the nth curve along with its (approximate) length.\n\n        Parameters\n        ----------\n        n\n            The index of the desired curve.\n        sample_points\n            The number of points to sample to find the length.\n\n        Returns\n        -------\n        curve : Callable[[float], Point3D]\n            The function for the nth curve.\n        length : :class:`float`\n            The length of the nth curve.\n        \"\"\"\n        curve = self.get_nth_curve_function(n)\n        norms = self.get_nth_curve_length_pieces(n, sample_points=sample_points)\n        length = np.sum(norms)\n\n        return curve, length\n\n    def get_num_curves(self) -> int:\n        \"\"\"Returns the number of curves of the vmobject.\n\n        Returns\n        -------\n        int\n            number of curves of the vmobject.\n        \"\"\"\n        nppcc = self.n_points_per_cubic_curve\n        return len(self.points) // nppcc\n\n    def get_curve_functions(\n        self,\n    ) -> Iterable[Callable[[float], Point3D]]:\n        \"\"\"Gets the functions for the curves of the mobject.\n\n        Returns\n        -------\n        Iterable[Callable[[float], Point3D]]\n            The functions for the curves.\n        \"\"\"\n        num_curves = self.get_num_curves()\n\n        for n in range(num_curves):\n            yield self.get_nth_curve_function(n)\n\n    def get_curve_functions_with_lengths(\n        self, **kwargs\n    ) -> Iterable[tuple[Callable[[float], Point3D], float]]:\n        \"\"\"Gets the functions and lengths of the curves for the mobject.\n\n        Parameters\n        ----------\n        **kwargs\n            The keyword arguments passed to :meth:`get_nth_curve_function_with_length`\n\n        Returns\n        -------\n        Iterable[tuple[Callable[[float], Point3D], float]]\n            The functions and lengths of the curves.\n        \"\"\"\n        num_curves = self.get_num_curves()\n\n        for n in range(num_curves):\n            yield self.get_nth_curve_function_with_length(n, **kwargs)\n\n    def point_from_proportion(self, alpha: float) -> Point3D:\n        \"\"\"Gets the point at a proportion along the path of the :class:`VMobject`.\n\n        Parameters\n        ----------\n        alpha\n            The proportion along the the path of the :class:`VMobject`.\n\n        Returns\n        -------\n        :class:`numpy.ndarray`\n            The point on the :class:`VMobject`.\n\n        Raises\n        ------\n        :exc:`ValueError`\n            If ``alpha`` is not between 0 and 1.\n        :exc:`Exception`\n            If the :class:`VMobject` has no points.\n\n        Example\n        -------\n        .. manim:: PointFromProportion\n            :save_last_frame:\n\n            class PointFromProportion(Scene):\n                def construct(self):\n                    line = Line(2*DL, 2*UR)\n                    self.add(line)\n                    colors = (RED, BLUE, YELLOW)\n                    proportions = (1/4, 1/2, 3/4)\n                    for color, proportion in zip(colors, proportions):\n                        self.add(Dot(color=color).move_to(\n                                line.point_from_proportion(proportion)\n                        ))\n        \"\"\"\n        if alpha < 0 or alpha > 1:\n            raise ValueError(f\"Alpha {alpha} not between 0 and 1.\")\n\n        self.throw_error_if_no_points()\n        if alpha == 1:\n            return self.points[-1]\n\n        curves_and_lengths = tuple(self.get_curve_functions_with_lengths())\n\n        target_length = alpha * sum(length for _, length in curves_and_lengths)\n        current_length = 0\n\n        for curve, length in curves_and_lengths:\n            if current_length + length >= target_length:\n                if length != 0:\n                    residue = (target_length - current_length) / length\n                else:\n                    residue = 0\n\n                return curve(residue)\n\n            current_length += length\n        raise Exception(\n            \"Not sure how you reached here, please file a bug report at https://github.com/ManimCommunity/manim/issues/new/choose\"\n        )\n\n    def proportion_from_point(\n        self,\n        point: Point3DLike,\n    ) -> float:\n        \"\"\"Returns the proportion along the path of the :class:`VMobject`\n        a particular given point is at.\n\n        Parameters\n        ----------\n        point\n            The Cartesian coordinates of the point which may or may not lie on the :class:`VMobject`\n\n        Returns\n        -------\n        float\n            The proportion along the path of the :class:`VMobject`.\n\n        Raises\n        ------\n        :exc:`ValueError`\n            If ``point`` does not lie on the curve.\n        :exc:`Exception`\n            If the :class:`VMobject` has no points.\n        \"\"\"\n        self.throw_error_if_no_points()\n\n        # Iterate over each bezier curve that the ``VMobject`` is composed of, checking\n        # if the point lies on that curve. If it does not lie on that curve, add\n        # the whole length of the curve to ``target_length`` and move onto the next\n        # curve. If the point does lie on the curve, add how far along the curve\n        # the point is to ``target_length``.\n        # Then, divide ``target_length`` by the total arc length of the shape to get\n        # the proportion along the ``VMobject`` the point is at.\n\n        num_curves = self.get_num_curves()\n        total_length = self.get_arc_length()\n        target_length = 0\n        for n in range(num_curves):\n            control_points = self.get_nth_curve_points(n)\n            length = self.get_nth_curve_length(n)\n            proportions_along_bezier = proportions_along_bezier_curve_for_point(\n                point,\n                control_points,\n            )\n            if len(proportions_along_bezier) > 0:\n                proportion_along_nth_curve = max(proportions_along_bezier)\n                target_length += length * proportion_along_nth_curve\n                break\n            target_length += length\n        else:\n            raise ValueError(f\"Point {point} does not lie on this curve.\")\n\n        alpha = target_length / total_length\n\n        return alpha\n\n    def get_anchors_and_handles(self) -> list[Point3D_Array]:\n        \"\"\"Returns anchors1, handles1, handles2, anchors2,\n        where (anchors1[i], handles1[i], handles2[i], anchors2[i])\n        will be four points defining a cubic bezier curve\n        for any i in range(0, len(anchors1))\n\n        Returns\n        -------\n        `list[Point3D_Array]`\n            Iterable of the anchors and handles.\n        \"\"\"\n        nppcc = self.n_points_per_cubic_curve\n        return [self.points[i::nppcc] for i in range(nppcc)]\n\n    def get_start_anchors(self) -> Point3D_Array:\n        \"\"\"Returns the start anchors of the bezier curves.\n\n        Returns\n        -------\n        Point3D_Array\n            Starting anchors\n        \"\"\"\n        return self.points[:: self.n_points_per_cubic_curve]\n\n    def get_end_anchors(self) -> Point3D_Array:\n        \"\"\"Return the end anchors of the bezier curves.\n\n        Returns\n        -------\n        Point3D_Array\n            Starting anchors\n        \"\"\"\n        nppcc = self.n_points_per_cubic_curve\n        return self.points[nppcc - 1 :: nppcc]\n\n    def get_anchors(self) -> list[Point3D]:\n        \"\"\"Returns the anchors of the curves forming the VMobject.\n\n        Returns\n        -------\n        Point3D_Array\n            The anchors.\n        \"\"\"\n        if self.points.shape[0] == 1:\n            return self.points\n\n        s = self.get_start_anchors()\n        e = self.get_end_anchors()\n        return list(it.chain.from_iterable(zip(s, e)))\n\n    def get_points_defining_boundary(self) -> Point3D_Array:\n        # Probably returns all anchors, but this is weird regarding  the name of the method.\n        return np.array(\n            tuple(it.chain(*(sm.get_anchors() for sm in self.get_family())))\n        )\n\n    def get_arc_length(self, sample_points_per_curve: int | None = None) -> float:\n        \"\"\"Return the approximated length of the whole curve.\n\n        Parameters\n        ----------\n        sample_points_per_curve\n            Number of sample points per curve used to approximate the length. More points result in a better approximation.\n\n        Returns\n        -------\n        float\n            The length of the :class:`VMobject`.\n        \"\"\"\n        return sum(\n            length\n            for _, length in self.get_curve_functions_with_lengths(\n                sample_points=sample_points_per_curve,\n            )\n        )\n\n    # Alignment\n    def align_points(self, vmobject: VMobject) -> Self:\n        \"\"\"Adds points to self and vmobject so that they both have the same number of subpaths, with\n        corresponding subpaths each containing the same number of points.\n\n        Points are added either by subdividing curves evenly along the subpath, or by creating new subpaths consisting\n        of a single point repeated.\n\n        Parameters\n        ----------\n        vmobject\n            The object to align points with.\n\n        Returns\n        -------\n        :class:`VMobject`\n           ``self``\n\n        See also\n        --------\n        :meth:`~.Mobject.interpolate`, :meth:`~.Mobject.align_data`\n        \"\"\"\n        self.align_rgbas(vmobject)\n        # TODO: This shortcut can be a bit over eager. What if they have the same length, but different subpath lengths?\n        if self.get_num_points() == vmobject.get_num_points():\n            return\n\n        for mob in self, vmobject:\n            # If there are no points, add one to\n            # wherever the \"center\" is\n            if mob.has_no_points():\n                mob.start_new_path(mob.get_center())\n            # If there's only one point, turn it into\n            # a null curve\n            if mob.has_new_path_started():\n                mob.add_line_to(mob.get_last_point())\n\n        # Figure out what the subpaths are\n        subpaths1 = self.get_subpaths()\n        subpaths2 = vmobject.get_subpaths()\n        n_subpaths = max(len(subpaths1), len(subpaths2))\n        # Start building new ones\n        new_path1 = np.zeros((0, self.dim))\n        new_path2 = np.zeros((0, self.dim))\n\n        nppcc = self.n_points_per_cubic_curve\n\n        def get_nth_subpath(path_list, n):\n            if n >= len(path_list):\n                # Create a null path at the very end\n                return [path_list[-1][-1]] * nppcc\n            path = path_list[n]\n            # Check for useless points at the end of the path and remove them\n            # https://github.com/ManimCommunity/manim/issues/1959\n            while len(path) > nppcc:\n                # If the last nppc points are all equal to the preceding point\n                if self.consider_points_equals(path[-nppcc:], path[-nppcc - 1]):\n                    path = path[:-nppcc]\n                else:\n                    break\n            return path\n\n        for n in range(n_subpaths):\n            # For each pair of subpaths, add points until they are the same length\n            sp1 = get_nth_subpath(subpaths1, n)\n            sp2 = get_nth_subpath(subpaths2, n)\n            diff1 = max(0, (len(sp2) - len(sp1)) // nppcc)\n            diff2 = max(0, (len(sp1) - len(sp2)) // nppcc)\n            sp1 = self.insert_n_curves_to_point_list(diff1, sp1)\n            sp2 = self.insert_n_curves_to_point_list(diff2, sp2)\n            new_path1 = np.append(new_path1, sp1, axis=0)\n            new_path2 = np.append(new_path2, sp2, axis=0)\n        self.set_points(new_path1)\n        vmobject.set_points(new_path2)\n        return self\n\n    def insert_n_curves(self, n: int) -> Self:\n        \"\"\"Inserts n curves to the bezier curves of the vmobject.\n\n        Parameters\n        ----------\n        n\n            Number of curves to insert.\n\n        Returns\n        -------\n        :class:`VMobject`\n            ``self``\n        \"\"\"\n        new_path_point = None\n        if self.has_new_path_started():\n            new_path_point = self.get_last_point()\n\n        new_points = self.insert_n_curves_to_point_list(n, self.points)\n        self.set_points(new_points)\n\n        if new_path_point is not None:\n            self.append_points([new_path_point])\n        return self\n\n    def insert_n_curves_to_point_list(\n        self, n: int, points: BezierPathLike\n    ) -> BezierPath:\n        \"\"\"Given an array of k points defining a bezier curves (anchors and handles), returns points defining exactly k + n bezier curves.\n\n        Parameters\n        ----------\n        n\n            Number of desired curves.\n        points\n            Starting points.\n\n        Returns\n        -------\n            Points generated.\n        \"\"\"\n        if len(points) == 1:\n            nppcc = self.n_points_per_cubic_curve\n            return np.repeat(points, nppcc * n, 0)\n        bezier_tuples = self.get_cubic_bezier_tuples_from_points(points)\n        current_number_of_curves = len(bezier_tuples)\n        new_number_of_curves = current_number_of_curves + n\n        new_bezier_tuples = bezier_remap(bezier_tuples, new_number_of_curves)\n        new_points = new_bezier_tuples.reshape(-1, 3)\n        return new_points\n\n    def align_rgbas(self, vmobject: VMobject) -> Self:\n        attrs = [\"fill_rgbas\", \"stroke_rgbas\", \"background_stroke_rgbas\"]\n        for attr in attrs:\n            a1 = getattr(self, attr)\n            a2 = getattr(vmobject, attr)\n            if len(a1) > len(a2):\n                new_a2 = stretch_array_to_length(a2, len(a1))\n                setattr(vmobject, attr, new_a2)\n            elif len(a2) > len(a1):\n                new_a1 = stretch_array_to_length(a1, len(a2))\n                setattr(self, attr, new_a1)\n        return self\n\n    def get_point_mobject(self, center: Point3DLike | None = None) -> VectorizedPoint:\n        if center is None:\n            center = self.get_center()\n        point = VectorizedPoint(center)\n        point.match_style(self)\n        return point\n\n    def interpolate_color(\n        self, mobject1: VMobject, mobject2: VMobject, alpha: float\n    ) -> None:\n        attrs = [\n            \"fill_rgbas\",\n            \"stroke_rgbas\",\n            \"background_stroke_rgbas\",\n            \"stroke_width\",\n            \"background_stroke_width\",\n            \"sheen_direction\",\n            \"sheen_factor\",\n        ]\n        for attr in attrs:\n            setattr(\n                self,\n                attr,\n                interpolate(getattr(mobject1, attr), getattr(mobject2, attr), alpha),\n            )\n            if alpha == 1.0:\n                val = getattr(mobject2, attr)\n                if isinstance(val, np.ndarray):\n                    val = val.copy()\n                setattr(self, attr, val)\n\n    def pointwise_become_partial(\n        self,\n        vmobject: VMobject,\n        a: float,\n        b: float,\n    ) -> Self:\n        \"\"\"Given a 2nd :class:`.VMobject` ``vmobject``, a lower bound ``a`` and\n        an upper bound ``b``, modify this :class:`.VMobject`'s points to\n        match the portion of the B\u00e9zier spline described by ``vmobject.points``\n        with the parameter ``t`` between ``a`` and ``b``.\n\n        Parameters\n        ----------\n        vmobject\n            The :class:`.VMobject` that will serve as a model.\n        a\n            The lower bound for ``t``.\n        b\n            The upper bound for ``t``\n\n        Returns\n        -------\n        :class:`.VMobject`\n            The :class:`.VMobject` itself, after the transformation.\n\n        Raises\n        ------\n        TypeError\n            If ``vmobject`` is not an instance of :class:`VMobject`.\n        \"\"\"\n        if not isinstance(vmobject, VMobject):\n            raise TypeError(\n                f\"Expected a VMobject, got value {vmobject} of type \"\n                f\"{type(vmobject).__name__}.\"\n            )\n        # Partial curve includes three portions:\n        # - A middle section, which matches the curve exactly.\n        # - A start, which is some ending portion of an inner cubic.\n        # - An end, which is the starting portion of a later inner cubic.\n        if a <= 0 and b >= 1:\n            self.set_points(vmobject.points)\n            return self\n        num_curves = vmobject.get_num_curves()\n        if num_curves == 0:\n            self.clear_points()\n            return self\n\n        # The following two lines will compute which B\u00e9zier curves of the given Mobject must be processed.\n        # The residue indicates the proportion of the selected B\u00e9zier curve which must be selected.\n        #\n        # Example: if num_curves is 10, a is 0.34 and b is 0.78, then:\n        # - lower_index is 3 and lower_residue is 0.4, which means the algorithm will look at the 3rd B\u00e9zier\n        #   and select its part which ranges from t=0.4 to t=1.\n        # - upper_index is 7 and upper_residue is 0.8, which means the algorithm will look at the 7th B\u00e9zier\n        #   and select its part which ranges from t=0 to t=0.8.\n        lower_index, lower_residue = integer_interpolate(0, num_curves, a)\n        upper_index, upper_residue = integer_interpolate(0, num_curves, b)\n\n        nppc = self.n_points_per_curve\n\n        # Copy vmobject.points if vmobject is self to prevent unintended in-place modification\n        vmobject_points = (\n            vmobject.points.copy() if self is vmobject else vmobject.points\n        )\n\n        # If both indices coincide, get a part of a single B\u00e9zier curve.\n        if lower_index == upper_index:\n            # Look at the \"lower_index\"-th B\u00e9zier curve and select its part from\n            # t=lower_residue to t=upper_residue.\n            self.points = partial_bezier_points(\n                vmobject_points[nppc * lower_index : nppc * (lower_index + 1)],\n                lower_residue,\n                upper_residue,\n            )\n        else:\n            # Allocate space for (upper_index-lower_index+1) B\u00e9zier curves.\n            self.points = np.empty((nppc * (upper_index - lower_index + 1), self.dim))\n            # Look at the \"lower_index\"-th Bezier curve and select its part from\n            # t=lower_residue to t=1. This is the first curve in self.points.\n            self.points[:nppc] = partial_bezier_points(\n                vmobject_points[nppc * lower_index : nppc * (lower_index + 1)],\n                lower_residue,\n                1,\n            )\n            # If there are more curves between the \"lower_index\"-th and the\n            # \"upper_index\"-th B\u00e9ziers, add them all to self.points.\n            self.points[nppc:-nppc] = vmobject_points[\n                nppc * (lower_index + 1) : nppc * upper_index\n            ]\n            # Look at the \"upper_index\"-th B\u00e9zier curve and select its part from\n            # t=0 to t=upper_residue. This is the last curve in self.points.\n            self.points[-nppc:] = partial_bezier_points(\n                vmobject_points[nppc * upper_index : nppc * (upper_index + 1)],\n                0,\n                upper_residue,\n            )\n\n        return self\n\n    def get_subcurve(self, a: float, b: float) -> Self:\n        \"\"\"Returns the subcurve of the VMobject between the interval [a, b].\n        The curve is a VMobject itself.\n\n        Parameters\n        ----------\n\n        a\n            The lower bound.\n        b\n            The upper bound.\n\n        Returns\n        -------\n        VMobject\n            The subcurve between of [a, b]\n        \"\"\"\n        if self.is_closed() and a > b:\n            vmob = self.copy()\n            vmob.pointwise_become_partial(self, a, 1)\n            vmob2 = self.copy()\n            vmob2.pointwise_become_partial(self, 0, b)\n            vmob.append_vectorized_mobject(vmob2)\n        else:\n            vmob = self.copy()\n            vmob.pointwise_become_partial(self, a, b)\n        return vmob\n\n    def get_direction(self) -> Literal[\"CW\", \"CCW\"]:\n        \"\"\"Uses :func:`~.space_ops.shoelace_direction` to calculate the direction.\n        The direction of points determines in which direction the\n        object is drawn, clockwise or counterclockwise.\n\n        Examples\n        --------\n        The default direction of a :class:`~.Circle` is counterclockwise::\n\n            >>> from manim import Circle\n            >>> Circle().get_direction()\n            'CCW'\n\n        Returns\n        -------\n        :class:`str`\n            Either ``\"CW\"`` or ``\"CCW\"``.\n        \"\"\"\n        return shoelace_direction(self.get_start_anchors())\n\n    def reverse_direction(self) -> Self:\n        \"\"\"Reverts the point direction by inverting the point order.\n\n        Returns\n        -------\n        :class:`VMobject`\n            Returns self.\n\n        Examples\n        --------\n        .. manim:: ChangeOfDirection\n\n            class ChangeOfDirection(Scene):\n                def construct(self):\n                    ccw = RegularPolygon(5)\n                    ccw.shift(LEFT)\n                    cw = RegularPolygon(5)\n                    cw.shift(RIGHT).reverse_direction()\n\n                    self.play(Create(ccw), Create(cw),\n                    run_time=4)\n        \"\"\"\n        self.points = self.points[::-1]\n        return self\n\n    def force_direction(self, target_direction: Literal[\"CW\", \"CCW\"]) -> Self:\n        \"\"\"Makes sure that points are either directed clockwise or\n        counterclockwise.\n\n        Parameters\n        ----------\n        target_direction\n            Either ``\"CW\"`` or ``\"CCW\"``.\n        \"\"\"\n        if target_direction not in (\"CW\", \"CCW\"):\n            raise ValueError('Invalid input for force_direction. Use \"CW\" or \"CCW\"')\n        if self.get_direction() != target_direction:\n            # Since we already assured the input is CW or CCW,\n            # and the directions don't match, we just reverse\n            self.reverse_direction()\n        return self"}, {"name": "VMobjectFromSVGPath", "code": "class VMobjectFromSVGPath(VMobject, metaclass=ConvertToOpenGL):\n    \"\"\"A vectorized mobject representing an SVG path.\n\n    .. note::\n\n        The ``long_lines``, ``should_subdivide_sharp_curves``,\n        and ``should_remove_null_curves`` keyword arguments are\n        only respected with the OpenGL renderer.\n\n    Parameters\n    ----------\n    path_obj\n        A parsed SVG path object.\n    long_lines\n        Whether or not straight lines in the vectorized mobject\n        are drawn in one or two segments.\n    should_subdivide_sharp_curves\n        Whether or not to subdivide subcurves further in case\n        two segments meet at an angle that is sharper than a\n        given threshold.\n    should_remove_null_curves\n        Whether or not to remove subcurves of length 0.\n    kwargs\n        Further keyword arguments are passed to the parent\n        class.\n    \"\"\"\n\n    def __init__(\n        self,\n        path_obj: se.Path,\n        long_lines: bool = False,\n        should_subdivide_sharp_curves: bool = False,\n        should_remove_null_curves: bool = False,\n        **kwargs,\n    ):\n        # Get rid of arcs\n        path_obj.approximate_arcs_with_quads()\n        self.path_obj = path_obj\n\n        self.long_lines = long_lines\n        self.should_subdivide_sharp_curves = should_subdivide_sharp_curves\n        self.should_remove_null_curves = should_remove_null_curves\n\n        super().__init__(**kwargs)\n\n    def init_points(self) -> None:\n        # TODO: cache mobject in a re-importable way\n\n        self.handle_commands()\n\n        if config.renderer == \"opengl\":\n            if self.should_subdivide_sharp_curves:\n                # For a healthy triangulation later\n                self.subdivide_sharp_curves()\n            if self.should_remove_null_curves:\n                # Get rid of any null curves\n                self.set_points(self.get_points_without_null_curves())\n\n    generate_points = init_points\n\n    def handle_commands(self) -> None:\n        all_points: list[np.ndarray] = []\n        last_move = None\n        curve_start = None\n        last_true_move = None\n\n        def move_pen(pt, *, true_move: bool = False):\n            nonlocal last_move, curve_start, last_true_move\n            last_move = pt\n            if curve_start is None:\n                curve_start = last_move\n            if true_move:\n                last_true_move = last_move\n\n        if self.n_points_per_curve == 4:\n\n            def add_cubic(start, cp1, cp2, end):\n                nonlocal all_points\n                assert len(all_points) % 4 == 0, len(all_points)\n                all_points += [start, cp1, cp2, end]\n                move_pen(end)\n\n            def add_quad(start, cp, end):\n                add_cubic(start, (start + cp + cp) / 3, (cp + cp + end) / 3, end)\n                move_pen(end)\n\n            def add_line(start, end):\n                add_cubic(\n                    start, (start + start + end) / 3, (start + end + end) / 3, end\n                )\n                move_pen(end)\n\n        else:\n\n            def add_cubic(start, cp1, cp2, end):\n                nonlocal all_points\n                assert len(all_points) % 3 == 0, len(all_points)\n                two_quads = get_quadratic_approximation_of_cubic(\n                    start,\n                    cp1,\n                    cp2,\n                    end,\n                )\n                all_points += two_quads[:3].tolist()\n                all_points += two_quads[3:].tolist()\n                move_pen(end)\n\n            def add_quad(start, cp, end):\n                nonlocal all_points\n                assert len(all_points) % 3 == 0, len(all_points)\n                all_points += [start, cp, end]\n                move_pen(end)\n\n            def add_line(start, end):\n                add_quad(start, (start + end) / 2, end)\n                move_pen(end)\n\n        for segment in self.path_obj:\n            segment_class = segment.__class__\n            if segment_class == se.Move:\n                move_pen(_convert_point_to_3d(*segment.end), true_move=True)\n            elif segment_class == se.Line:\n                add_line(last_move, _convert_point_to_3d(*segment.end))\n            elif segment_class == se.QuadraticBezier:\n                add_quad(\n                    last_move,\n                    _convert_point_to_3d(*segment.control),\n                    _convert_point_to_3d(*segment.end),\n                )\n            elif segment_class == se.CubicBezier:\n                add_cubic(\n                    last_move,\n                    _convert_point_to_3d(*segment.control1),\n                    _convert_point_to_3d(*segment.control2),\n                    _convert_point_to_3d(*segment.end),\n                )\n            elif segment_class == se.Close:\n                # If the SVG path naturally ends at the beginning of the curve,\n                # we do *not* need to draw a closing line. To account for floating\n                # point precision, we use a small value to compare the two points.\n                if abs(np.linalg.norm(last_move - last_true_move)) > 0.0001:\n                    add_line(last_move, last_true_move)\n                curve_start = None\n            else:\n                raise AssertionError(f\"Not implemented: {segment_class}\")\n\n        self.points = np.array(all_points, ndmin=2, dtype=\"float64\")\n        # If we have no points, make sure the array is shaped properly\n        # (0 rows tall by 3 columns wide) so future operations can\n        # add or remove points correctly.\n        if len(all_points) == 0:\n            self.points = np.reshape(self.points, (0, 3))"}, {"name": "Wait", "code": "class Wait(Animation):\n    \"\"\"A \"no operation\" animation.\n\n    Parameters\n    ----------\n    run_time\n        The amount of time that should pass.\n    stop_condition\n        A function without positional arguments that evaluates to a boolean.\n        The function is evaluated after every new frame has been rendered.\n        Playing the animation stops after the return value is truthy, or\n        after the specified ``run_time`` has passed.\n    frozen_frame\n        Controls whether or not the wait animation is static, i.e., corresponds\n        to a frozen frame. If ``False`` is passed, the render loop still\n        progresses through the animation as usual and (among other things)\n        continues to call updater functions. If ``None`` (the default value),\n        the :meth:`.Scene.play` call tries to determine whether the Wait call\n        can be static or not itself via :meth:`.Scene.should_mobjects_update`.\n    kwargs\n        Keyword arguments to be passed to the parent class, :class:`.Animation`.\n    \"\"\"\n\n    def __init__(\n        self,\n        run_time: float = 1,\n        stop_condition: Callable[[], bool] | None = None,\n        frozen_frame: bool | None = None,\n        rate_func: Callable[[float], float] = linear,\n        **kwargs,\n    ):\n        if stop_condition and frozen_frame:\n            raise ValueError(\"A static Wait animation cannot have a stop condition.\")\n\n        self.duration: float = run_time\n        self.stop_condition = stop_condition\n        self.is_static_wait: bool = frozen_frame\n        super().__init__(None, run_time=run_time, rate_func=rate_func, **kwargs)\n        # quick fix to work in opengl setting:\n        self.mobject.shader_wrapper_list = []\n\n    def begin(self) -> None:\n        pass\n\n    def finish(self) -> None:\n        pass\n\n    def clean_up_from_scene(self, scene: Scene) -> None:\n        pass\n\n    def update_mobjects(self, dt: float) -> None:\n        pass\n\n    def interpolate(self, alpha: float) -> None:\n        pass"}, {"name": "Wiggle", "code": "class Wiggle(Animation):\n    \"\"\"Wiggle a Mobject.\n\n    Parameters\n    ----------\n    mobject\n        The mobject to wiggle.\n    scale_value\n        The factor by which the mobject will be temporarily scaled.\n    rotation_angle\n        The wiggle angle.\n    n_wiggles\n        The number of wiggles.\n    scale_about_point\n        The point about which the mobject gets scaled.\n    rotate_about_point\n        The point around which the mobject gets rotated.\n    run_time\n        The duration of the animation\n\n    Examples\n    --------\n\n    .. manim:: ApplyingWaves\n\n        class ApplyingWaves(Scene):\n            def construct(self):\n                tex = Tex(\"Wiggle\").scale(3)\n                self.play(Wiggle(tex))\n                self.wait()\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mobject: Mobject,\n        scale_value: float = 1.1,\n        rotation_angle: float = 0.01 * TAU,\n        n_wiggles: int = 6,\n        scale_about_point: np.ndarray | None = None,\n        rotate_about_point: np.ndarray | None = None,\n        run_time: float = 2,\n        **kwargs,\n    ) -> None:\n        self.scale_value = scale_value\n        self.rotation_angle = rotation_angle\n        self.n_wiggles = n_wiggles\n        self.scale_about_point = scale_about_point\n        self.rotate_about_point = rotate_about_point\n        super().__init__(mobject, run_time=run_time, **kwargs)\n\n    def get_scale_about_point(self) -> np.ndarray:\n        if self.scale_about_point is None:\n            return self.mobject.get_center()\n        return self.scale_about_point\n\n    def get_rotate_about_point(self) -> np.ndarray:\n        if self.rotate_about_point is None:\n            return self.mobject.get_center()\n        return self.rotate_about_point\n\n    def interpolate_submobject(\n        self,\n        submobject: Mobject,\n        starting_submobject: Mobject,\n        alpha: float,\n    ) -> None:\n        submobject.points[:, :] = starting_submobject.points\n        submobject.scale(\n            interpolate(1, self.scale_value, there_and_back(alpha)),\n            about_point=self.get_scale_about_point(),\n        )\n        submobject.rotate(\n            wiggle(alpha, self.n_wiggles) * self.rotation_angle,\n            about_point=self.get_rotate_about_point(),\n        )"}, {"name": "wiggle", "code": "def wiggle(t: float, wiggles: float = 2) -> float:\n    val: float = np.sin(wiggles * np.pi * t)\n    return there_and_back(t) * val"}, {"name": "Window", "code": "class Window(PygletWindow):\n    fullscreen = False\n    resizable = True\n    gl_version = (3, 3)\n    vsync = True\n    cursor = True\n\n    def __init__(self, renderer, size=config.window_size, **kwargs):\n        monitors = get_monitors()\n        mon_index = config.window_monitor\n        monitor = monitors[min(mon_index, len(monitors) - 1)]\n\n        if size == \"default\":\n            # make window_width half the width of the monitor\n            # but make it full screen if --fullscreen\n\n            window_width = monitor.width\n            if not config.fullscreen:\n                window_width //= 2\n\n            #  by default window_height = 9/16 * window_width\n            window_height = int(\n                window_width * config.frame_height // config.frame_width,\n            )\n            size = (window_width, window_height)\n        else:\n            size = tuple(size)\n\n        super().__init__(size=size)\n\n        self.title = f\"Manim Community {__version__}\"\n        self.size = size\n        self.renderer = renderer\n\n        mglw.activate_context(window=self)\n        self.timer = Timer()\n        self.config = mglw.WindowConfig(ctx=self.ctx, wnd=self, timer=self.timer)\n        self.timer.start()\n\n        self.swap_buffers()\n\n        initial_position = self.find_initial_position(size, monitor)\n        self.position = initial_position\n\n    # Delegate event handling to scene.\n    def on_mouse_motion(self, x, y, dx, dy):\n        super().on_mouse_motion(x, y, dx, dy)\n        point = self.renderer.pixel_coords_to_space_coords(x, y)\n        d_point = self.renderer.pixel_coords_to_space_coords(dx, dy, relative=True)\n        self.renderer.scene.on_mouse_motion(point, d_point)\n\n    def on_mouse_scroll(self, x, y, x_offset: float, y_offset: float):\n        super().on_mouse_scroll(x, y, x_offset, y_offset)\n        point = self.renderer.pixel_coords_to_space_coords(x, y)\n        offset = self.renderer.pixel_coords_to_space_coords(\n            x_offset,\n            y_offset,\n            relative=True,\n        )\n        self.renderer.scene.on_mouse_scroll(point, offset)\n\n    def on_key_press(self, symbol, modifiers):\n        self.renderer.pressed_keys.add(symbol)\n        super().on_key_press(symbol, modifiers)\n        self.renderer.scene.on_key_press(symbol, modifiers)\n\n    def on_key_release(self, symbol, modifiers):\n        if symbol in self.renderer.pressed_keys:\n            self.renderer.pressed_keys.remove(symbol)\n        super().on_key_release(symbol, modifiers)\n        self.renderer.scene.on_key_release(symbol, modifiers)\n\n    def on_mouse_drag(self, x, y, dx, dy, buttons, modifiers):\n        super().on_mouse_drag(x, y, dx, dy, buttons, modifiers)\n        point = self.renderer.pixel_coords_to_space_coords(x, y)\n        d_point = self.renderer.pixel_coords_to_space_coords(dx, dy, relative=True)\n        self.renderer.scene.on_mouse_drag(point, d_point, buttons, modifiers)\n\n    def find_initial_position(self, size, monitor):\n        custom_position = config.window_position\n        window_width, window_height = size\n        # Position might be specified with a string of the form\n        # x,y for integers x and y\n        if len(custom_position) == 1:\n            raise ValueError(\n                \"window_position must specify both Y and X positions (Y/X -> UR). Also accepts LEFT/RIGHT/ORIGIN/UP/DOWN.\",\n            )\n        # in the form Y/X (UR)\n        if custom_position in [\"LEFT\", \"RIGHT\"]:\n            custom_position = \"O\" + custom_position[0]\n        elif custom_position in [\"UP\", \"DOWN\"]:\n            custom_position = custom_position[0] + \"O\"\n        elif custom_position == \"ORIGIN\":\n            custom_position = \"O\" * 2\n        elif \",\" in custom_position:\n            return tuple(map(int, custom_position.split(\",\")))\n\n        # Alternatively, it might be specified with a string like\n        # UR, OO, DL, etc. specifying what corner it should go to\n        char_to_n = {\"L\": 0, \"U\": 0, \"O\": 1, \"R\": 2, \"D\": 2}\n        width_diff = monitor.width - window_width\n        height_diff = monitor.height - window_height\n\n        return (\n            monitor.x + char_to_n[custom_position[1]] * width_diff // 2,\n            -monitor.y + char_to_n[custom_position[0]] * height_diff // 2,\n        )\n\n    def on_mouse_press(self, x, y, button, modifiers):\n        super().on_mouse_press(x, y, button, modifiers)\n        point = self.renderer.pixel_coords_to_space_coords(x, y)\n        mouse_button_map = {\n            1: \"LEFT\",\n            2: \"MOUSE\",\n            4: \"RIGHT\",\n        }\n        self.renderer.scene.on_mouse_press(point, mouse_button_map[button], modifiers)"}, {"name": "Write", "code": "class Write(DrawBorderThenFill):\n    \"\"\"Simulate hand-writing a :class:`~.Text` or hand-drawing a :class:`~.VMobject`.\n\n    Examples\n    --------\n    .. manim:: ShowWrite\n\n        class ShowWrite(Scene):\n            def construct(self):\n                self.play(Write(Text(\"Hello\", font_size=144)))\n\n    .. manim:: ShowWriteReversed\n\n        class ShowWriteReversed(Scene):\n            def construct(self):\n                self.play(Write(Text(\"Hello\", font_size=144), reverse=True, remover=False))\n\n    Tests\n    -----\n\n    Check that creating empty :class:`.Write` animations works::\n\n        >>> from manim import Write, Text\n        >>> Write(Text(''))\n        Write(Text(''))\n    \"\"\"\n\n    def __init__(\n        self,\n        vmobject: VMobject | OpenGLVMobject,\n        rate_func: Callable[[float], float] = linear,\n        reverse: bool = False,\n        **kwargs,\n    ) -> None:\n        run_time: float | None = kwargs.pop(\"run_time\", None)\n        lag_ratio: float | None = kwargs.pop(\"lag_ratio\", None)\n        run_time, lag_ratio = self._set_default_config_from_length(\n            vmobject,\n            run_time,\n            lag_ratio,\n        )\n        self.reverse = reverse\n        if \"remover\" not in kwargs:\n            kwargs[\"remover\"] = reverse\n        super().__init__(\n            vmobject,\n            rate_func=rate_func,\n            run_time=run_time,\n            lag_ratio=lag_ratio,\n            introducer=not reverse,\n            **kwargs,\n        )\n\n    def _set_default_config_from_length(\n        self,\n        vmobject: VMobject | OpenGLVMobject,\n        run_time: float | None,\n        lag_ratio: float | None,\n    ) -> tuple[float, float]:\n        length = len(vmobject.family_members_with_points())\n        if run_time is None:\n            run_time = 1 if length < 15 else 2\n        if lag_ratio is None:\n            lag_ratio = min(4.0 / max(1.0, length), 0.2)\n        return run_time, lag_ratio\n\n    def reverse_submobjects(self) -> None:\n        self.mobject.invert(recursive=True)\n\n    def begin(self) -> None:\n        if self.reverse:\n            self.reverse_submobjects()\n        super().begin()\n\n    def finish(self) -> None:\n        super().finish()\n        if self.reverse:\n            self.reverse_submobjects()"}, {"name": "write", "code": "def write(level: str | None = None, openfile: bool = False) -> None:\n    config_paths = config_file_paths()\n    console.print(\n        \"[yellow bold]Manim Configuration File Writer[/yellow bold]\",\n        justify=\"center\",\n    )\n\n    USER_CONFIG_MSG = f\"\"\"A configuration file at [yellow]{config_paths[1]}[/yellow] has been created with your required changes.\nThis will be used when running the manim command. If you want to override this config,\nyou will have to create a manim.cfg in the local directory, where you want those changes to be overridden.\"\"\"\n\n    CWD_CONFIG_MSG = f\"\"\"A configuration file at [yellow]{config_paths[2]}[/yellow] has been created.\nTo save your config please save that file and place it in your current working directory, from where you run the manim command.\"\"\"\n\n    parser = make_config_parser()\n    if not openfile:\n        action = \"save this as\"\n        for category in parser:\n            console.print(f\"{category}\", style=\"bold green underline\")\n            default = cast(dict[str, Any], parser[category])\n            if category == \"logger\":\n                console.print(RICH_COLOUR_INSTRUCTIONS)\n                default = replace_keys(default)\n\n            for key in default:\n                # All the cfg entries for logger need to be validated as styles,\n                # as long as they aren't setting the log width or height etc\n                if category == \"logger\" and key not in RICH_NON_STYLE_ENTRIES:\n                    desc = \"style\"\n                    style = default[key]\n                else:\n                    desc = \"value\"\n                    style = None\n\n                console.print(f\"Enter the {desc} for {key} \", style=style, end=\"\")\n                if category != \"logger\" or key in RICH_NON_STYLE_ENTRIES:\n                    defaultval = (\n                        repr(default[key])\n                        if isinstance(value_from_string(default[key]), str)\n                        else default[key]\n                    )\n                    console.print(f\"(defaults to {defaultval}) :\", end=\"\")\n                try:\n                    temp = input()\n                except EOFError:\n                    raise Exception(\n                        \"\"\"Not enough values in input.\nYou may have added a new entry to default.cfg, in which case you will have to\nmodify write_cfg_subcmd_input to account for it.\"\"\",\n                    ) from None\n                if temp:\n                    while temp and not _is_expected_datatype(\n                        temp,\n                        default[key],\n                        bool(style),\n                    ):\n                        console.print(\n                            f\"[red bold]Invalid {desc}. Try again.[/red bold]\",\n                        )\n                        console.print(\n                            f\"Enter the {desc} for {key}:\",\n                            style=style,\n                            end=\"\",\n                        )\n                        temp = input()\n\n                    default[key] = temp.replace(\"%\", \"%%\")\n\n            default = replace_keys(default) if category == \"logger\" else default\n\n            parser[category] = {\n                i: v.replace(\"%\", \"%%\") for i, v in dict(default).items()\n            }\n\n    else:\n        action = \"open\"\n\n    if level is None:\n        console.print(\n            f\"Do you want to {action} the default config for this User?(y/n)[[n]]\",\n            style=\"dim purple\",\n            end=\"\",\n        )\n        action_to_userpath = input()\n    else:\n        action_to_userpath = \"\"\n\n    if action_to_userpath.lower() == \"y\" or level == \"user\":\n        cfg_file_path = config_paths[1]\n        guarantee_existence(config_paths[1].parents[0])\n        console.print(USER_CONFIG_MSG)\n    else:\n        cfg_file_path = config_paths[2]\n        guarantee_existence(config_paths[2].parents[0])\n        console.print(CWD_CONFIG_MSG)\n    with cfg_file_path.open(\"w\") as fp:\n        parser.write(fp)\n    if openfile:\n        open_file(cfg_file_path)"}, {"name": "write_to_movie", "code": "def write_to_movie() -> bool:\n    \"\"\"\n    Determines from config if the output is a video format such as mp4 or gif, if the --format is set as 'png'\n    then it will take precedence event if the write_to_movie flag is set\n\n    Returns\n    -------\n    class:`bool`\n        ``True`` if the output should be written in a movie format\n\n    \"\"\"\n    if is_png_format():\n        return False\n    return (\n        config[\"write_to_movie\"]\n        or is_mp4_format()\n        or is_gif_format()\n        or is_webm_format()\n        or is_mov_format()\n    )"}, {"name": "x_rotation_matrix", "code": "def x_rotation_matrix(x: float = 0) -> MatrixMN:\n    return np.array(\n        [\n            [1, 0, 0, 0],\n            [0, np.cos(x), -np.sin(x), 0],\n            [0, np.sin(x), np.cos(x), 0],\n            [0, 0, 0, 1],\n        ],\n    )"}, {"name": "y_rotation_matrix", "code": "def y_rotation_matrix(y: float = 0) -> MatrixMN:\n    return np.array(\n        [\n            [np.cos(y), 0, np.sin(y), 0],\n            [0, 1, 0, 0],\n            [-np.sin(y), 0, np.cos(y), 0],\n            [0, 0, 0, 1],\n        ],\n    )"}, {"name": "z_rotation_matrix", "code": "def z_rotation_matrix(z: float = 0) -> MatrixMN:\n    return np.array(\n        [\n            [np.cos(z), -np.sin(z), 0, 0],\n            [np.sin(z), np.cos(z), 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n        ],\n    )"}, {"name": "z_to_vector", "code": "def z_to_vector(vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns some matrix in SO(3) which takes the z-axis to the\n    (normalized) vector provided as an argument\n    \"\"\"\n    axis_z = normalize(vector)\n    axis_y = normalize(cross(axis_z, RIGHT))\n    axis_x = cross(axis_y, axis_z)\n    if np.linalg.norm(axis_y) == 0:\n        # the vector passed just so happened to be in the x direction.\n        axis_x = normalize(cross(UP, axis_z))\n        axis_y = -cross(axis_x, axis_z)\n\n    return np.array([axis_x, axis_y, axis_z]).T"}, {"name": "zero", "code": "def zero(function: RateFunction) -> RateFunction:\n    @wraps(function)\n    def wrapper(t: float, *args: Any, **kwargs: Any) -> float:\n        if 0 <= t <= 1:\n            return function(t, *args, **kwargs)\n        else:\n            return 0\n\n    return wrapper"}, {"name": "ZoomedScene", "code": "class ZoomedScene(MovingCameraScene):\n    \"\"\"\n    This is a Scene with special configurations made for when\n    a particular part of the scene must be zoomed in on and displayed\n    separately.\n    \"\"\"\n\n    def __init__(\n        self,\n        camera_class=MultiCamera,\n        zoomed_display_height=3,\n        zoomed_display_width=3,\n        zoomed_display_center=None,\n        zoomed_display_corner=UP + RIGHT,\n        zoomed_display_corner_buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER,\n        zoomed_camera_config={\n            \"default_frame_stroke_width\": 2,\n            \"background_opacity\": 1,\n        },\n        zoomed_camera_image_mobject_config={},\n        zoomed_camera_frame_starting_position=ORIGIN,\n        zoom_factor=0.15,\n        image_frame_stroke_width=3,\n        zoom_activated=False,\n        **kwargs,\n    ):\n        self.zoomed_display_height = zoomed_display_height\n        self.zoomed_display_width = zoomed_display_width\n        self.zoomed_display_center = zoomed_display_center\n        self.zoomed_display_corner = zoomed_display_corner\n        self.zoomed_display_corner_buff = zoomed_display_corner_buff\n        self.zoomed_camera_config = zoomed_camera_config\n        self.zoomed_camera_image_mobject_config = zoomed_camera_image_mobject_config\n        self.zoomed_camera_frame_starting_position = (\n            zoomed_camera_frame_starting_position\n        )\n        self.zoom_factor = zoom_factor\n        self.image_frame_stroke_width = image_frame_stroke_width\n        self.zoom_activated = zoom_activated\n        super().__init__(camera_class=camera_class, **kwargs)\n\n    def setup(self):\n        \"\"\"\n        This method is used internally by Manim to\n        setup the scene for proper use.\n        \"\"\"\n        super().setup()\n        # Initialize camera and display\n        zoomed_camera = MovingCamera(**self.zoomed_camera_config)\n        zoomed_display = ImageMobjectFromCamera(\n            zoomed_camera, **self.zoomed_camera_image_mobject_config\n        )\n        zoomed_display.add_display_frame()\n        for mob in zoomed_camera.frame, zoomed_display:\n            mob.stretch_to_fit_height(self.zoomed_display_height)\n            mob.stretch_to_fit_width(self.zoomed_display_width)\n        zoomed_camera.frame.scale(self.zoom_factor)\n\n        # Position camera and display\n        zoomed_camera.frame.move_to(self.zoomed_camera_frame_starting_position)\n        if self.zoomed_display_center is not None:\n            zoomed_display.move_to(self.zoomed_display_center)\n        else:\n            zoomed_display.to_corner(\n                self.zoomed_display_corner,\n                buff=self.zoomed_display_corner_buff,\n            )\n\n        self.zoomed_camera = zoomed_camera\n        self.zoomed_display = zoomed_display\n\n    def activate_zooming(self, animate: bool = False):\n        \"\"\"\n        This method is used to activate the zooming for\n        the zoomed_camera.\n\n        Parameters\n        ----------\n        animate\n            Whether or not to animate the activation\n            of the zoomed camera.\n        \"\"\"\n        self.zoom_activated = True\n        self.renderer.camera.add_image_mobject_from_camera(self.zoomed_display)\n        if animate:\n            self.play(self.get_zoom_in_animation())\n            self.play(self.get_zoomed_display_pop_out_animation())\n        self.add_foreground_mobjects(\n            self.zoomed_camera.frame,\n            self.zoomed_display,\n        )\n\n    def get_zoom_in_animation(self, run_time: float = 2, **kwargs):\n        \"\"\"\n        Returns the animation of camera zooming in.\n\n        Parameters\n        ----------\n        run_time\n            The run_time of the animation of the camera zooming in.\n        **kwargs\n            Any valid keyword arguments of ApplyMethod()\n\n        Returns\n        -------\n        ApplyMethod\n            The animation of the camera zooming in.\n        \"\"\"\n        frame = self.zoomed_camera.frame\n        full_frame_height = self.camera.frame_height\n        full_frame_width = self.camera.frame_width\n        frame.save_state()\n        frame.stretch_to_fit_width(full_frame_width)\n        frame.stretch_to_fit_height(full_frame_height)\n        frame.center()\n        frame.set_stroke(width=0)\n        return ApplyMethod(frame.restore, run_time=run_time, **kwargs)\n\n    def get_zoomed_display_pop_out_animation(self, **kwargs):\n        \"\"\"\n        This is the animation of the popping out of the\n        mini-display that shows the content of the zoomed\n        camera.\n\n        Returns\n        -------\n        ApplyMethod\n            The Animation of the Zoomed Display popping out.\n        \"\"\"\n        display = self.zoomed_display\n        display.save_state()\n        display.replace(self.zoomed_camera.frame, stretch=True)\n        return ApplyMethod(display.restore)\n\n    def get_zoom_factor(self):\n        \"\"\"\n        Returns the Zoom factor of the Zoomed camera.\n        Defined as the ratio between the height of the\n        zoomed camera and the height of the zoomed mini\n        display.\n        Returns\n        -------\n        float\n            The zoom factor.\n        \"\"\"\n        return self.zoomed_camera.frame.height / self.zoomed_display.height"}]